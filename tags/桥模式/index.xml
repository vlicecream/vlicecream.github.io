<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>桥模式 - 标签 - Ame</title>
        <link>https://example.com/tags/%E6%A1%A5%E6%A8%A1%E5%BC%8F/</link>
        <description>桥模式 - 标签 - Ame</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ame)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ame)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/tags/%E6%A1%A5%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml" /><item>
    <title>桥模式</title>
    <link>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[<h1 id="桥模式">桥模式</h1>
<h2 id="单一职责模式">单一职责模式</h2>
<ol>
<li><em><strong>什么是单一职责</strong></em>
<ul>
<li><em>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充满着重复代码</em></li>
<li><em>这时候最关键是划清责任，每个类引起他变化的原因只有一个</em></li>
</ul>
</li>
<li><em><strong>典型模式</strong></em>
<ul>
<li><em>Decorator</em></li>
<li><em>Bridge</em></li>
</ul>
</li>
</ol>
<h2 id="使用桥模式动机">使用桥模式动机</h2>
<ol>
<li><em>由于某些类型的固有的实现逻辑 使得它们具有两个变化的维度 乃至多个维度的变化</em></li>
<li><em>如何应对这种&quot;多维度的变化&quot; 如何利用面向对象技术来使得类型可以轻松的沿着两个乃至多个方向变化 而不引入额外的复杂度</em></li>
</ol>
<h2 id="初始代码">初始代码</h2>
<ol>
<li>
<p><em><strong>代码演示</strong></em></p>]]></description>
</item>
</channel>
</rss>
