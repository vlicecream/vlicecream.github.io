<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>职责链 - 标签 - Ame</title>
        <link>https://example.com/tags/%E8%81%8C%E8%B4%A3%E9%93%BE/</link>
        <description>职责链 - 标签 - Ame</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ame)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ame)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/tags/%E8%81%8C%E8%B4%A3%E9%93%BE/" rel="self" type="application/rss+xml" /><item>
    <title>职责链</title>
    <link>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/</link>
    <pubDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/</guid>
    <description><![CDATA[<h1 id="职责链">职责链</h1>
<h2 id="数据结构模式">数据结构模式</h2>
<ol>
<li><em><strong>什么是数据结构模式</strong></em>
<ul>
<li><em>常常有一些组件在内部具有特定的数据结构, 如果让客户程序依赖这些特定的数据结构, 将极大的破坏组件的复用</em></li>
</ul>
</li>
<li><em><strong>典型模式</strong></em>
<ul>
<li><em>Composite</em></li>
<li><em>Iterator</em></li>
<li><em>Chain of Resposibility</em></li>
</ul>
</li>
</ol>
<h2 id="职责链前言">职责链前言</h2>
<ol>
<li><em>这个模式 其实随着现在数据结构的发展 也过时了</em></li>
<li><em>但是还是老话 模式过时 思想不会过时</em></li>
</ol>
<h2 id="动机">动机</h2>
<ol>
<li><em>在软件构建过程中, 一个请求可能被多个对象处理, 但是每个请求在运行时只能有一个接受者，如果显式指定, 将必不可少的带来发送者和接受者的紧耦合</em></li>
<li><em>如何使请求的发送者不需要指定具体的接受者?</em></li>
<li><em>让请求的接受者自己在运行时决定来处理请求, 从而使两者解藕</em></li>
</ol>
<h2 id="模式定义">模式定义</h2>
<ol>
<li><em>使多个对象都有机会处理请求, 从而避免请求的发送者和接受者之间的耦合关系，将这些对象形成一条链表, 并沿着这条链传递请求, 直到有一个对象处理它为止</em></li>
</ol>
<h2 id="要点总结">要点总结</h2>
<ol>
<li><em>职责链模式的应用场合在于 &ldquo;一个请求可能有多个接受者, 但是最后真正的接受者只有一个&rdquo;，这时候请求发送者与接受者的耦合有可能出现&quot;变化脆弱&quot;的症状, 职责链的目的就是将二者解藕, 从而更好的应对变化</em></li>
<li><em>应用了职责链模式后, 对象的职责分派将更具有灵活性，我们可以在运行时动态添加/修改请求的处理职责</em></li>
<li><em>如果请求传递到职责链的末尾仍得不到处理, 应该有一个合理的缺省机制，这也是每一个接受对象的责任, 而不是发出</em></li>
</ol>]]></description>
</item>
</channel>
</rss>
