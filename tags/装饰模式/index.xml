<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>装饰模式 - 标签 - Ame</title>
        <link>https://example.com/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link>
        <description>装饰模式 - 标签 - Ame</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ame)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ame)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml" /><item>
    <title>装饰模式</title>
    <link>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[<h1 id="装饰模式">装饰模式</h1>
<h2 id="单一职责模式">单一职责模式</h2>
<ol>
<li><em><strong>什么是单一职责</strong></em>
<ul>
<li><em>在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充满着重复代码</em></li>
<li><em>这时候最关键是划清责任，每个类引起他变化的原因只有一个</em></li>
</ul>
</li>
<li><em><strong>典型模式</strong></em>
<ul>
<li><em>Decorator</em></li>
<li><em>Bridge</em></li>
</ul>
</li>
</ol>
<h2 id="使用装饰模式动机">使用装饰模式动机</h2>
<ol>
<li><em>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀</em></li>
<li><em>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？</em></li>
</ol>
<h2 id="初始代码">初始代码</h2>
<ol>
<li>
<p><em><strong>类图</strong></em></p>]]></description>
</item>
</channel>
</rss>
