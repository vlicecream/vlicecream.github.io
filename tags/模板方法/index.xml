<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>模板方法 - 标签 - Ame</title>
        <link>https://example.com/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</link>
        <description>模板方法 - 标签 - Ame</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ame)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ame)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/" rel="self" type="application/rss+xml" /><item>
    <title>模板方法</title>
    <link>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</link>
    <pubDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</guid>
    <description><![CDATA[<h1 id="模板方法">模板方法</h1>
<h2 id="组件协作模式"><em><strong>组件协作模式</strong></em></h2>
<ol>
<li><em><strong>什么是组件协作模式</strong></em>
<ul>
<li><em>现代软件专业分工之后的第一个结果就是 <strong>框架与应用程序的划分</strong></em></li>
<li><em><strong>组件协作</strong></em> <em>模式通过晚绑定，来实现框架和应用之间的松耦合，是二者之间协作时常用的模式</em></li>
</ul>
</li>
<li><strong>典型模式</strong>
<ul>
<li><em>Template Method</em></li>
<li><em>Observer / Event</em></li>
<li><em>Strategy</em></li>
</ul>
</li>
</ol>
<h2 id="使用模板方法的动机"><em><strong>使用模板方法的动机</strong></em></h2>
<ol>
<li><em>在软件构建的过程中，对于某一项任务，他尝尝有<strong>稳定</strong>的整体操作结构，但是各个子步骤却有很多<strong>改变</strong>的需求，或者由于固有原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现</em></li>
<li><em>那么如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求</em></li>
</ol>
<h2 id="早绑定代码"><em><strong>早绑定代码</strong></em></h2>
<ol>
<li>
<p><em><strong>什么是早绑定</strong></em></p>]]></description>
</item>
</channel>
</rss>
