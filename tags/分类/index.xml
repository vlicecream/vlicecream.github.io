<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>分类 - 标签 - Ame</title>
        <link>https://example.com/tags/%E5%88%86%E7%B1%BB/</link>
        <description>分类 - 标签 - Ame</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ame)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ame)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/tags/%E5%88%86%E7%B1%BB/" rel="self" type="application/rss+xml" /><item>
    <title>分类</title>
    <link>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/</link>
    <pubDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/</guid>
    <description><![CDATA[<h1 id="分类">分类</h1>
<h1 id="模式分类">模式分类</h1>
<h2 id="从目的来看">从目的来看</h2>
<ol>
<li><em><strong>创建型模式</strong></em>
<ul>
<li><em>将对象的部分创建工作延后到子类或者其他对象，从而应对需求变化为对象创建时带来的冲击</em></li>
</ul>
</li>
<li><em><strong>结构型模式</strong></em>
<ul>
<li><em>通过类继承或者对象组合获得灵活的结构，从而应对需求变化为对象的结构带来冲击</em></li>
</ul>
</li>
<li><em><strong>行为型模式</strong></em>
<ul>
<li><em>通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击</em></li>
</ul>
</li>
</ol>
<h2 id="从范围来看">从范围来看</h2>
<ol>
<li><em><strong>类模式处理类与子类的静态关系</strong></em></li>
<li><em><strong>对象模式处理对象间的动态关系</strong></em></li>
</ol>
<h2 id="从封装变化角度来看">从封装变化角度来看</h2>
<ol>
<li><em><strong>组件协作</strong></em>
<ul>
<li><em>Template Method</em></li>
<li><em>Observer / Event</em></li>
<li><em>Strategy</em></li>
</ul>
</li>
<li><em><strong>单一职责</strong></em>
<ul>
<li><em>Decorator</em></li>
<li><em>Bridge</em></li>
</ul>
</li>
<li><em><strong>对象创建</strong></em>
<ul>
<li><em>Factory Method</em></li>
<li><em>Abstract Factory</em></li>
<li><em>Prototype</em></li>
<li><em>Builder</em></li>
</ul>
</li>
<li><em><strong>对象性能</strong></em>
<ul>
<li><em>Singleton</em></li>
<li><em>Flyweight</em></li>
</ul>
</li>
<li><em><strong>接口隔离</strong></em>
<ul>
<li><em>Façade</em></li>
<li><em>Proxy</em></li>
<li><em>Mediator</em></li>
<li><em>Adapter</em></li>
</ul>
</li>
<li><em><strong>状态变化</strong></em>
<ul>
<li><em>Memento</em></li>
<li><em>State</em></li>
</ul>
</li>
<li><em><strong>数据结构</strong></em>
<ul>
<li><em>Composite</em></li>
<li><em>Iterator</em></li>
<li><em>Chain of Resposibility</em></li>
</ul>
</li>
<li><em><strong>行为变化</strong></em>
<ul>
<li><em>Command</em></li>
<li><em>Visitor</em></li>
</ul>
</li>
<li><em><strong>领域问题</strong></em>
<ul>
<li><em>Interpreter</em></li>
</ul>
</li>
</ol>
<h1 id="重构获得模式">重构获得模式</h1>
<h2 id="重构获得模式-1">重构获得模式</h2>
<ol>
<li><em><strong>怎么去看待设计模式</strong></em>
<ul>
<li><em>面向对象模式是 &ldquo;好的面向对象设计&rdquo;，所谓好的面向对象设计就是指那些可以满足 <strong>应对变化</strong>，提高复用性</em></li>
<li><em>现代软件设计的特征就是 <strong>需求的频繁变化</strong>，所以设计模式重点在于 <strong>寻求变化点</strong>，然后在变化点应用设计模式，从而来更好的应对需求的变化</em></li>
<li><em><strong>所以说，什么时候，什么地点应用设计模式比理解设计模式结构本身更为重要!!!</strong></em></li>
<li><em>同时，设计模式的应用不宜先入为主，一上来就是用设计模式，这是最大的错误，而且也没有一步到位的设计模式让你去使用</em></li>
<li><em><strong>重构与模式 很重要!!! 还有脚踏实地!!!</strong></em></li>
</ul>
</li>
</ol>
<h2 id="重构关键方法">重构关键方法</h2>
<ol>
<li><em>静态 -&gt; 动态</em></li>
<li><em>早绑定 -&gt; 晚绑定</em></li>
<li><em>继承 -&gt; 组合</em></li>
<li><em>编译时依赖 -&gt; 运行时依赖</em></li>
<li><em>紧耦合 -&gt; 松耦合</em></li>
</ol>]]></description>
</item>
</channel>
</rss>
