[{"categories":["微积分"],"content":"微积分的预备知识-习题答案","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/","tags":["微积分"],"title":"微积分 - 预备知识 - 习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"直线 - 习题 题 1 和题 2中，求从A到 B 的增量坐标 A(1,2), B(-1,-1) $$ \\Delta{x} = -1 - 1 = -2 \\\\ \\\\ \\Delta{y} = -1 - 2 = -3 $$ A(-3,2),B(-1,-2) $$ \\Delta{x} = -1 - (-3) = 2 \\\\ \\\\ \\Delta{y} = -2 - 2 = -4 $$ A(-3,1),B(-8,1) $$ \\Delta{x} = -8 - (-3) = -5 \\\\ \\\\ \\Delta{y} = 1 - 1 = 0 $$ A(0,4),B(0, -2) $$ \\Delta{x} = 0 - 0 = 0 \\\\ \\\\ \\Delta{y} = -2 - 4 = -6 $$ 题 3 和 题 4中，令L是点A和B决定的直线 图示A 和 B 求L的斜率 画出L的图形 A(1, -2), B(2, 1) $$ m = \\frac{\\Delta{y}}{\\Delta{x}} = \\frac{B_y - A_y}{B_x - A_x} = \\frac{1 - (-2)}{2 - 1} = \\frac{3}{1} = 3 $$ A (-2, -1), B(-1, -2) $$ m = \\frac{\\Delta{y}}{\\Delta{x}} = \\frac{B_y - A_y}{B_x - A_x} = \\frac{-2 - (-1)}{-1 - (-2)} = \\frac{-1}{1} = -1 $$ A(2, 3), B(-1, 3) 光看y轴就是一条水平线，故斜率为0 A(1, 2), B(1, -3) x轴相等，所以这是一条垂直线，斜率无意义 在题 5 和 题 6 中，对过点 P 的 垂直线 以及 水平线写出方程 在题 7 和 题 8中，对过点P的斜率为 m 的直线写出 点斜式方程 P(1, 1)， m = 1 $$ y = m(x - x_1) + y_1 \\\\ \\\\ y = 1(x - 1) + 1 \\\\ \\\\ y = x $$ P(-1, 1)，m = -1 $$ y = m(x - x_1) + y_1 \\\\ \\\\ y = -1(x - (-1)) + 1 \\\\ \\\\ y = -x $$ P(0, 3)，m = 2 $$ y = m(x - x_1) + y_1 \\\\ \\\\ y = 2(x - 0) + 3 \\\\ \\ y = 2x + 3 $$ P(-4, 0)，m = -2 $$ y = m(x - x_1) - y_1 \\\\ \\ y = -2(x - (-4)) - 0 \\\\ \\ y = -2x - 8 $$ 在题 9 和 题 10 中，写出过两点的一般线性方程 （0，0），（2，3） $$ \\begin{align*} m \u0026= \\frac{3 - 0}{2 - 0} = \\frac{3}{2} \\\\ \\\\ y \u0026= m(x - x_1) + y_1 \\quad (用(0，0)) \\\\ \\\\ y \u0026= \\frac{3}{2}(x - 0) + 0 \\\\ \\\\ y \u0026= \\frac{3}{2}x \\\\ \\\\ 2y \u0026= 3x \\\\ \\\\ 3x - 2y \u0026= 0 \\end{align*} $$ （1，1），（2，1） $$ \\begin{align*} m \u0026= \\frac{1 - 1}{2 - 1} = 0 \\\\ \\\\ y \u0026= m(x - x_1) + y_1 \\quad (用(1，1)) \\\\ \\\\ y \u0026= 0(x - 1) + 1 \\\\ \\\\ y \u0026= 1 \\\\ \\\\ y - 1 \u0026= 0 \\\\ \\\\ 0x + y - 1 \u0026= 0 \\end{align*} $$ （-2，0），（-2，-2） 通过计算斜率 $ m \u0026= \\frac{-2 - 0}{-2 - (-2)} = \\frac{-2}{0} $ 发现分母为 0 ，斜率无意义，所以这是一条垂直线 对于垂直线，线上所有点的 x 坐标都相同。观察两个点，它们的 x 坐标都是 -2。所以方程就是 x = -2 （-2，1），（2，-2） $$ \\begin{align*} m \u0026= \\frac{-2 - 1}{2 - (-2)} = \\frac{-3}{4} \\\\ \\\\ y \u0026= m(x - x_1) + y_1 \\quad (用(-2，1)) \\\\ \\\\ y \u0026= -\\frac{3}{4}(x - (-2)) + 1 \\\\ \\\\ 4y \u0026= -3(x + 2) + 4 \\\\ \\\\ 4y \u0026= -3x - 6 + 4 \\\\ \\\\ 3x + 4y \u0026= -2 \\end{align*} $$ 在题 11 和 题 12 中，对斜率为 m，y - 截距 为 b 的直线 写出 斜率截距方程 m = 3，b = -2 $$ y = mx + b \\\\ \\\\ y = 3x - 2 $$ m = -1，b = 2 $$ y = mx + b \\\\ \\\\ y = -x + 2 $$ $ m = \\frac{-1}{2}，b = -3 $ $$ y = mx + b \\\\ \\ y = -\\frac{1}{2}x - 3 $$ $ m = \\frac{1}{3}，b = -1 $ $$ y = mx + b \\\\ \\\\ y = \\frac{1}{3}x - 1 $$ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:1:0","tags":["微积分"],"title":"微积分 - 预备知识 - 习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"求函数的公式 - 习题 把等边三角形的面积和周长表为该三角形边长 x 的函数 $$ \\text{周长:} \\quad y = f(x) = x + x + x = 3x \\\\ \\\\ \\text{面积:} \\quad y = f(x) = \\frac{1}{2}ab \\sin(C) = \\frac{1}{2} \\cdot x \\cdot x \\cdot \\sin{60} = \\frac{\\sqrt{3}}{4}x^2 $$ 把正方形的边长表为该正方形对角线长度 d 的函数，然后把该正方形的面积表为对角线长度的函数 把立方体的棱边长表为该立方体对角线长度 d 的函数，然后把该立方体的表面积和提及表为对角线长度的函数 第一象限中的点 P 位于函数 $ f(x) = \\sqrt{x} $ 的图形上，把点 P 的坐标表为连接点 P 和原点的直线的斜率的函数 在题五 题六中，哪些图是 x 的函数，哪些不是，给出回答和理由 ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:2:0","tags":["微积分"],"title":"微积分 - 预备知识 - 习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"微积分的预备知识","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"直线 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"增量 定义： 当平面上一个质点从一点移动到另外一个点，其坐标的纯改变就是增量 公式： 如果一个质点从 $ (x_1, y_1) $ 移动到 $ (x_2, y_2) $，则其坐标的增量为： $$ \\Delta{x} = x_2 - x_1 ~~~~~~~~~~~~~~~ \\Delta{y} = y_2 - y_1 $$ 解释说明： 质点就是物理学一个有质量但没有体积和形状的理想化模型 $ \\Delta $ 这个叫 Delta，他是差的意思，并不是相乘的意思 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"直线的斜率 定义： 每条非垂直的直线都会有一个斜率，每行进单位距离时高度的变化为直线的斜率 公式： 设 点$ P_1 (x_1, y_1) $ 和 点$ P_2 (x_2, y_2) $ 是非垂直直线L上的两个点，那么L的斜率为： $$ m = \\frac{升高}{前进的距离} = \\frac{\\Delta{y}}{\\Delta{x}} = \\frac{(y_2 - y_1)}{(x_2 - x_1)} $$ 解释说明： 习惯上用 m 表示斜率 从这个公式我们也能看出，为什么垂直直线不会有斜率这个说法，因为当 $ \\Delta{y} ~~ \\Delta{x} $ 为 0 时，这个公式没有了意义 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"平行线与垂直线 定义： 当两个平行线与x轴夹角相等，因此，非垂直的平行线具有相同的斜率，反之，具有相同斜率的直线与x轴的夹角相等，所以是平行线。 当两条非垂直直线 L1 和 L2 是互相垂直的，他的斜率 m1 和 m2 满足 m1m2 = -1，所以 每个斜率是另一个斜率的负倒数： $$ m_1m_2 = -1 ~~~~~ m_1 = - \\frac{1}{m_2} ~~~~~~ m_2 = - \\frac{1}{m_1} $$ 我们还可以反过来，从斜率确定垂直性：若 L 是斜率为 $ \\frac{3}{4} $ 的直线,，任何斜率为 $ - \\frac{4}{3} $ 的直线垂直于 L 公式： $$ m_1m_2 = -1 $$ 推导： 论证大致如下：用图 3 的记号就是：$ m_1=\\tan\\phi_1=\\frac{a}{h} $ ，而 $ m_2=\\tan\\phi_2=-\\frac{h}{a} $，那么：$ m_1m_2 = (\\frac{a}{h}) (-\\frac{h}{a}) = -1 $ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"直线的方程 点斜式方程 定义： 如果我们知道直线的斜率 m，和直线上任意一个点 $ P_1(x_1, y_1) $，那么我们可以写出任意非垂直线的方程，因为如果 P(x, y) 是直线上任意一点，那么他的斜率就是： $$ \\begin{align*} \u0026 \\frac{(y - y_1)}{(x - x_1)} = m \\\\ \\\\ \u0026 (y - y_1) = m(x - x_1) \\\\ \\\\ \u0026 y = m(x - x_1) + y_1 \\end{align*} $$ 所以：$ y = m(x - x_1) + y_1 $ 是过点 $ (x_1, y_1) $，且斜率为 m 的直线的 点斜方程 公式： $$ y = m(x - x_1) + y_1 $$ 斜率 - 截距方程 定义： 非垂直直线和 y 轴的交点的 y轴坐标就是直线的 y截距 非垂直直线和 x 轴的交点的 x轴坐标就是直线的 x截距 斜率为 m 而 y截距为b的直线过 (0, b) ，所以： $$ y = m(x - 0) + b $$ 公式： $$ y = mx + b $$ 解释说明： 此公式是 斜率为 m 而 y截距为b的直线的斜率 - 截距方程，也叫做斜截方程 y截距一般用 b 表示，x截距一般用 a 表示 一般线性方程 定义： 如果 A和B 不全为0，则方程 Ax + By = C 的图形是一条直线，每条直线都有这种形式的方程，即使是一条具有不确定的斜率的直线 公式： $$ Ax+By=C \\quad(A\\text{ 和}B\\text{ 不全为 }0) $$ 解释说明： 虽然一般线性方程的形式有助于快速识别直线，但斜率 - 截距形式使用计算器来画直线图形的输入形式 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:4","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"什么是函数 定义： 从集合 D 到集合 R 的一个函数是对 D 中每个元素指定 R 中唯一确定的元素的一种规则 解释说明： 一个变量的值常常取决于另一个变量的值 水达到沸点的温度取决于海拔高度（当你越往上走沸点降低） 水的沸点 b 取决于 海拔高度 e； 我们称 b 为因变量，变量 e 为 自变量 故对一个集合中的每个元素指定另一个集合中唯一确定的一个元素的规则成为函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"定义域和值域 定义： 函数的输入构成了函数的定义域，输出构成了函数的值域 解释说明： 我们要以某种方式限制定义域，我们要说出来，比如 $ y^2=2x^2,x^2\u003e0 $ 自变量的许多实值函数的定义域和值域是区间或区间的组合，区间可以是开，闭，或半开以及有限无限的 图片 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"增函数与减函数 定义： 如果当你从左往右走，函数的图形是上升的，那么该函数就是增函数 如果当你从左往右走，函数的图形是下降的，那么该函数就是减函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"奇函数与偶函数 定义： 函数 y = f(x) 是 x 的偶函数，如果 $ f(-x)=f(x) $ 函数 y = f(x) 是 x 的偶函数，如果 $ f(-x)= - f(x) $ 性质：对称性 偶函数的图形是关于 y 轴对称的，因为 $ f(-x)=f(x) $，点（x, y）位于该图形上当且仅当 （-x, y）也在该图形上 奇函数的图形是关于 原点 对称的，因为 $ f(-x)= - f(x) $，点（x, y）位于该图形上当且仅当 （-x, -y）也在该图形上 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:4","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"分段定义的函数 定义： 可以通过在定义域的不同部分用不同的公式来定义函数 例子： $$ y = f(x) = \\begin{cases} -x,\\quad x \u003c 0 \\\\ \\\\ x^{2}, \\quad 0 \\leqslant x \\leqslant 1 \\\\ \\\\ 1, \\quad x\u003e1 \u0026 \\end{cases} $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:5","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"绝对值函数 定义： 绝对值函数 $ y = |x| $ 是由下述公式来定义的： $$ \\mid x \\mid = \\begin{cases} -x, \\quad x \u003c 0 \\\\ \\\\ x, \\quad x \\geq 0\u0026 \\end{cases} $$ 性质： $$ \\mid -a \\mid \\quad = \\quad \\mid a \\mid $$ $$ \\mid ab \\mid \\quad = \\quad \\mid a \\mid \\mid b \\mid $$ $$ \\mid \\frac{a}{b} \\mid \\quad = \\quad \\frac{\\mid a \\mid}{\\mid b \\mid} $$ $$ \\begin{array} {c}{a} \u0026 {+} \u0026 {b} \\end{array} \\quad \\leqslant \\quad \\begin{array} {c}{a}\u0026{+}\u0026{b} \\end{array}. $$ $$ \\mid x\\mid=\\sqrt{x^2}. $$ 解释说明： 绝对值函数就是偶函数，所以他是 y 轴对称的，因为符号 $ \\sqrt{a} $ 表示 a 的非负数平方根，所以 $ \\mid a \\mid $ 另一种定义就是： $$ \\mid x\\mid=\\sqrt{x^2}. $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:6","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"位移图形 定义： 为往上位移函数 $ y = f(x) $ 的图形，加一正常数到公式的右边，比如 $ y = x^2 + 1 $，就可以把图形往上移位1个单位 为往下位移函数 $ y = f(x) $ 的图形，加一负常数到公式的右边，比如 $ y = x^2 - 1 $，就可以把图形往下移位1个单位 往左位移函数 $ y = f(x) $ 的图形，将 x 加上常数，比如 $ y = (x + 1)^2 $，就可以把图形往左移位1个单位 往右位移函数 $ y = f(x) $ 的图形，将 x 减上常数，比如 $ y = (x - 1)^2 $，就可以把图形往移位1个单位 移位公式： 垂直移位：$y$ = $f($ $x$ ) + $k$ 若 $k$ \u003e 0,则向上移位 $k$ 个单位 若 $k\u003c0$,则向下移位 $\\mid k\\mid$ 个单位 水平移位：$y$ = $f($ $x$ + $h$ ) 若 $h$ \u003e 0,则向左移位 $h$ 个单位 若 $h\u003c0$,则向右移位 $\\mid h\\mid$ 个单位 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:7","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"复合函数 定义： 假定函数 g 的某些输出可以作为函数 f 的输入，那么函数 $ f(g(x)) $是 g 和 f 的复合函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:8","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"指数函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"指数函数 定义： 设 a 是不等于 1 的正实数，函数 $ f(x) = a^x $ 是底为 a 的指数函数。这个函数的定义域是 $(-\\infty,\\infty) $，值域为 $ (0,\\infty) $ 定律： 若 a \u003e 0，b \u003e 0，对所有实数 x, y，以下结果成立 $$ a^x \\cdot a^y = a^{x+y} $$ $$ \\frac{a^x}{a^y}=a^{x-y} $$ $$ (a^x)^y = (a^y)^x = a^{xy} $$ $$ a^x \\cdot a^y = (ab)^x $$ $$ \\frac{a^x}{b^x} = (\\frac{a}{b})^x $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"自然指数函数 定义： 自然指数函数就是以这个特殊的数字 e 为底的指数函数 标准公式： k 是 非零常数 $$ y = e^{kx} $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"指数增长与指数衰减 函数 $ y = y_0 e^{kx} $ 是指数增长的模式，前提是 k \u003e 0；如果 k \u003c 0 ，那么这个函数就是指数衰减的模型 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"反函数和对数函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"一对一函数 定义： 函数 $ f(x) $ 在定义域 D 上是一对一的，若每当 $ a\\neq b $ 时 $ f(a) \\neq f(b) $ 图形性质： 一对一函数 $ y = f(x) $ 的图形与任何水平直线相交至多一次（水平直线法则），如果他与水平直线相交多余两次，即他取同一y值多于一次的话，那么该函数就不是一对一的 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"反函数 定义： 由逆转一对一函数的定义域和值域定义的函数就是 $f$ 的反函数 反函数 $ f $ 的记号是 $ f^{-1} $，念作 $f$ 逆。记住他的左上角的-1不是指数的意思 反函数的测试： 函数 $f$ 和 $g$ 是反函数对，当且仅当： $$ f(g(x)) = x \\quad \\text{并且} \\quad g(f(x)) = x. $$ 这时，$ g = f^{-1} $ 而且 $ f = g^{-1} $ 怎么求反函数： 第一步：借助 y 对 x解方程 $ y = f(x) $ 第二步：交换 x, y，得到公式将是 $ y = f^{-1}(x) $ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"对数函数 定义： 底为 a 的对数函数 $ y = \\log_a x $ 是底为 a 的指数函数 $ y=a^{x}(a\u003e0,a\\neq1) $ 的反函数 以 e 为底和以 10 为底 的对数的应用是很重要以至于计算器有专门计算他们的键，他们也有其专门的记号和名称 $ \\log_{e}x\\quad $写作 $ \\quad\\ln x. $ $ \\log_{10}x \\quad$ 写作 $ \\quad \\log x$ 函数 $ \\ln x $ 称为自然对数函数，而 $ \\log x $ 称为普通对数函数 $a^{x}$ 和 $\\log_ax$ 的互为反函数性质： 底为 $ a: $ $ a^{\\log_ax},\\quad\\log_aa^x=2x,\\quad a\u003e0,a\\neq1,x\u003e0 $ 底为 $ e: $ $ \\mathrm{e}^{\\ln x}=-x,\\quad\\ln\\mathrm{e}^x=-x,\\quad x\u003e0 $ 对数的算术性质（对任何的实数 x \u003e 0 和 y \u003e 0）： 乘积法则：$ \\log_axy=\\log_ax+\\log_ay $ 商法则：$ \\log_{a}\\frac{x}{y}=\\log_{a}x-\\log_{a}y $ 幂法则：$ \\log_ax^y=y\\log_ax $ 每个指数函数是自然指数函数的幂函数 $$ a^{x}=\\mathrm{e}^{x\\ln a} $$ 即：$ a^x $ 和 $ e^x $ 的 $ \\ln{a} 次幂是同样的 $ 底变换公式： 每个对数函数是自然对数函数的常数倍： $$ \\log_ax=\\frac{\\ln x}{\\ln a}\\quad(a\u003e0,a\\neq1) $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 行为树","date":"2025-08-05","objectID":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/","tags":["Unreal","行为树","Lyra"],"title":"Lyra - 行为树","uri":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/"},{"categories":["Unreal-Lyra"],"content":"Lyra行为树 Lyra是在生成Bot的时候会传入数据 生成AIController，随后在AIController里面绑定行为树 ","date":"2025-08-05","objectID":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/:1:0","tags":["Unreal","行为树","Lyra"],"title":"Lyra - 行为树","uri":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/"},{"categories":["Unreal-Lyra"],"content":"注意事项 我们使用 EQS 中的 Generator: Perceived Actors的时候，必须再AIController或者AI的Pawn中加入 AIPerceptionComponent，还有对感知对方物体中加入 AIPerceptionStimuliSource，并且进行这两个感知组件的 Senses Config 还有一个，这两个组件之间必须阵营不一样, 它依赖于一个接口：IGenericTeamAgentInterface。你需要让AI和玩家都实现这个接口，并告诉系统“我们是不同队伍的”, 或者直接将 Detection by Affiliation: 把 Detect Enemies, Detect Neutrals, Detect Friendlies 全部勾选上！ 这一步是为了暂时绕开复杂的阵营系统，看看AI到底能不能“感知”到任何东西。 还有 AI 自动导航，比如 MoveTo 需要 NavMeshBoundsVolume网格铺满地形，在这网格内AI才会自动导航 ","date":"2025-08-05","objectID":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/:2:0","tags":["Unreal","行为树","Lyra"],"title":"Lyra - 行为树","uri":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 库存与装备系统","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"Equipment Equipment 是 Lyra 的装备系统，也就是执行装备这个过程逻辑的一个系统 它通过 ULyraEquipmentDefinition 这个类，来获得装备的Actor真正的实例，以及装备上会获得什么技能，还有装备到哪里，比如枪装备到人的一个左手骨骼点上 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:1:0","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraEquipmentDefinition 此类就是装备的一个数据结构，你需要提供一个Instance，还有一个装备上会有什么技能，比如装备一个剑，装备上了就会有一把剑的剑光技能，以及还有装备到人身上那个部位，比如剑装备到骨骼体上 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:1:1","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraEquipmentInstance 此类就是装备的一个实例，比如武器就有枪和剑两种，枪是有根据距离，散射程度来进行伤害衰减的，所以就可以继承此基类，去实现，Lyra也就是这么做的，装备以后就可以从各种各样的枪上面拿到伤害数据 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:1:2","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraEquipmentManagerComponent 此Component就是所有的装备到身上的一个管理者了，也是向外部提供各种CURD的接口 Lyra里会在Gamefeature里将这个绑定在Character上 ULyraQuickBarComponent 此Component就是游戏中的装备栏，可以通过此Component的方法快捷装备到人物身上 Lyra里会在Gamefeature里将这个绑定在PlayerState上 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:1:3","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"Inventory Inventory 是Lyra的库存系统，也可以理解为背包系统，然后管理着一个Actor身上所有的物品 它通过 ULyraInventoryItemFragment 的各种子类，来获得相对应的数据，比如 ULyraEquipmentDefinition ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:2:0","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraInventoryItemDefinition 这个就是库存系统中库存的数据了，他的成员就是一个显示名称，以及还有基类，比如UInventoryFragment_EquippableItem就是继承于这个基类，随后UInventoryFragment_EquippableItem只需要绑定一个装备系统的数据结构体-ULyraEquipmentDefinition, 这样就可以将库存系统与装备系统串起来了 核心职责: 定义物品的显示信息，如名称、图标。 通过一个Fragment（碎片）列表来组合物品的功能。一个物品可以由多个Fragment构成，例如： UInventoryFragment_EquippableItem: 表明这是一个可装备的物品。这个Fragment内部持有一个对 ULyraEquipmentDefinition 的引用，这正是将库存系统与装备系统串联起来的关键桥梁 UInventoryFragment_SetStats: 表明这个物品会提供一些基础属性（比如作为合成材料）。 与ULyraEquipmentDefinition的区别: ULyraInventoryItemDefinition 描述的是“背包里的物品是什么”，而 ULyraEquipmentDefinition 描述的是“这个物品装备后会发生什么”。 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:2:1","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraInventoryItemInstance 这个类就是库存的实例，他的主要职责就是存储这个实例相对应的数据-ULyraInventoryItemDefinition，以及还有一个自定义的 GameplayTagStackContainer，这个Tag的作用就是，Unreal原生提供的只能表示一个Tag，自定义的多了一个等级，比如这个库存的1级和2级效果不一致，这个时候加入一个等级概念就很好区分 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:2:2","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraInventoryManagerComponent 这个Component就是库存的管理者了，它的作用就是管理全部的库存，并且对外提供各种CURD的方法 Lyra里会在Gamefeature里将这个绑定在PlayerState上 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:2:3","tags":["Unreal","Lyra"],"title":"Lyra 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 HealthComponent","date":"2025-07-23","objectID":"/lyra-healthcomponent/","tags":["Unreal","Lyra"],"title":"Lyra-HealthComponent","uri":"/lyra-healthcomponent/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 动画蓝图","date":"2025-07-23","objectID":"/lyra-animation/","tags":["Unreal","Lyra"],"title":"Lyra动画层（Anim Layers）与重写机制全解析","uri":"/lyra-animation/"},{"categories":["Unreal-Lyra"],"content":"参考资料 https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animation-in-lyra-sample-game-in-unreal-engine?application_version=5.3 https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-animation-blueprint-linking-in-unreal-engine?application_version=5.3 ","date":"2025-07-23","objectID":"/lyra-animation/:1:0","tags":["Unreal","Lyra"],"title":"Lyra动画层（Anim Layers）与重写机制全解析","uri":"/lyra-animation/"},{"categories":["Unreal-Lyra"],"content":"简介 Lyra 的 动画蓝图，首先是采用 蓝图线程安全更新动画，此开启方法在文档中就写了。再次提一句，这实现了使用属性访问（Property Access）来访问其所有数据，并避免了重新计算链接的图层可能使用的值，如 加速度（Acceleration） 或 速度（Velocity） 。 Lyra 还采用了 LinkLayersInterface，此动画层接口的作用是：比如你的角色可以拿枪和拿剑，但是他们的动作不一样，你就可以很好的利用这个来加载不同的动画 ","date":"2025-07-23","objectID":"/lyra-animation/:2:0","tags":["Unreal","Lyra"],"title":"Lyra动画层（Anim Layers）与重写机制全解析","uri":"/lyra-animation/"},{"categories":["Unreal-Lyra"],"content":"LyraLayersInterface 此动画层接口的使用方法可以看文档，我在这只解释比较绕的逻辑 你创建一个 LyraLayersInterface，创建好图层（接口方法），在创建一个Animation Blueprint，实现了具体的图层（接口方法），在lyra里这其实是创建了一个ABP基类，随后将各种动画创建变量，比如 Idle 变量，然后再创建具体的子类，去设置动画变量。这样再不同的场景就可以用各自的ABP子类 然后在我们的Character是不是必须要设置一个ABP，这个ABP不需要设置为 刚才说的那几个ABP，你可以继续创建一个新的，然后再这新的interface设置为 LyraLayersInterface，随后再具体的使用idle动画，咱们可以使用 这个动画层接口图层，此时记得再character上使用 Set Linked Anim Class，这个方法的参数，再传我们刚刚说的那个基类或者子类，这样就可以用你创建好的图层的ABP的方法了 ","date":"2025-07-23","objectID":"/lyra-animation/:3:0","tags":["Unreal","Lyra"],"title":"Lyra动画层（Anim Layers）与重写机制全解析","uri":"/lyra-animation/"},{"categories":["Unreal-Lyra"],"content":"坑 线程安全函数需要在detail里标记线程安全 如果想创建自定义线程安全函数函数，则一定要勾上纯（Pure）函数和线程安全选项 ","date":"2025-07-23","objectID":"/lyra-animation/:4:0","tags":["Unreal","Lyra"],"title":"Lyra动画层（Anim Layers）与重写机制全解析","uri":"/lyra-animation/"},{"categories":["杂谈"],"content":"我们在使用Rider开发UE时，Ride会为每一个项目创建一个解决方案缓存，如果开几个新项目写测试demo，我们的C盘会逐渐捉急 不知道官方怎么想的，默认在C盘就算了，还没法改 目前没有找到这个路径相关的设置，只能另辟蹊径 我们既然改不掉这个路径，那就将这个路径映射到其他路径上 windows下，可以使用mklink指令，创建类似linux的软连接 首先把C:\\Users\"用户名\"\\AppData\\Local\\JetBrains这个文件夹移动到你希望他出现的位置 然后用管理员身份打开CMD 使用下面的指令，把里面%引起来的内容替换成你的东西 mklink /j \"C:\\Users\\%你的用户名%\\AppData\\Local\\JetBrains\" \"%你希望这个缓存所在的路径%\" 我的就是 mklink /j C:\\Users\\User\\AppData\\Local\\JetBrains G:\\JetCache\\JetBrains 他已经不占用C盘空间了，也不影响Rider解析，大功告成，告别C盘焦虑 ","date":"2025-07-18","objectID":"/ue%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8rider%E6%97%B6%E7%BC%93%E5%AD%98c%E7%9B%98/:0:0","tags":["Rider"],"title":"UE开发使用Rider时缓存干爆C盘的解决方案","uri":"/ue%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8rider%E6%97%B6%E7%BC%93%E5%AD%98c%E7%9B%98/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 AssetManager ","date":"2025-07-15","objectID":"/lyra-dataassetmanager/","tags":["Unreal","Lyra"],"title":"Lyra 资源管理核心：自定义 AssetManager 实战","uri":"/lyra-dataassetmanager/"},{"categories":["Unreal-Lyra"],"content":"作用 在任何一个 Unreal Engine 项目中，资源（Assets）都是构成游戏世界的基础，包括模型、纹理、蓝图、数据资产等等。随着项目规模的扩大，如何高效、有序地加载和管理这些成千上万的资源，成了一个巨大的挑战。开发者常常会遇到这些问题： 资源加载代码散落在项目的各个角落，难以维护和修改。 软引用（Soft Reference）虽然能避免不必要的内存占用，但加载逻辑写起来很繁琐。 关键的游戏数据（如默认角色配置、全局设置等）没有一个统一的获取入口，导致代码依赖混乱。 需要一个中心化的系统来处理异步加载、内存管理和调试。 为了解决这些问题，虚幻引擎提供了一个强大的解决方案——UAssetManager。而自定义一个继承自 UAssetManager 的类，就是为你的项目量身打造一个终极的“资源大管家”。 这样做的好处： 集中化、统一化的资源加载入口 这是最核心、最直接的作用。你可以封装一个简单的静态函数（如 GetAsset())，让项目中的任何代码都能通过这一行调用来获取资源。 管理重要的全局数据资产 你的游戏很可能会有一些“全局”或“默认”的数据资产，你可以将这些数据资产的软指针作为 AssetManager 的成员变量，并提供简单的获取函数。 可靠的内存管理 对于那些加载后需要常驻内存的资源，我们可以在 AssetManager 内部维护一个 TSet 或 TArray 来持有它们的硬引用，防止它们被GC意外卸载 可以在适当的时候（如切换关卡），调用 AssetManager 的函数来主动释放某些资源的引用，从而触发GC进行内存回收。 增强的调试与分析能力 有了统一的处理，那么就可以很轻松的排查问题了 ","date":"2025-07-15","objectID":"/lyra-dataassetmanager/:1:0","tags":["Unreal","Lyra"],"title":"Lyra 资源管理核心：自定义 AssetManager 实战","uri":"/lyra-dataassetmanager/"},{"categories":["Unreal-Lyra"],"content":"修改默认Manager 首先我们得在项目设置，选择到我们自定义的AssetManager类 ","date":"2025-07-15","objectID":"/lyra-dataassetmanager/:2:0","tags":["Unreal","Lyra"],"title":"Lyra 资源管理核心：自定义 AssetManager 实战","uri":"/lyra-dataassetmanager/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 Game Feature","date":"2025-07-15","objectID":"/lyra-gamefeature/","tags":["Unreal","Lyra"],"title":"Lyra架构：Game Feature 篇","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"作用 Game Feature（游戏特性）是虚幻引擎中一个强大的插件系统，旨在实现高度模块化和可扩展的游戏开发*。* 想象一下，你可以像搭乐高积木一样构建你的游戏：角色的能力、新的游戏模式、季节性活动，甚至UI界面，都可以作为一个独立的“特性”插件来开发。当需要时，只需动态地激活这个插件，所有相关的功能、内容和逻辑就会自动应用到游戏中；不需要时，则可以随时停用，干净利落地移除，而不会影响游戏的核心代码。 这种方式极大地降低了团队协作的耦合度，让大型项目管理变得前所未有的清晰和高效。 可以理解为游戏Mod把 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:1:0","tags":["Unreal","Lyra"],"title":"Lyra架构：Game Feature 篇","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"创建一个GameFeature插件 打开GameFeature插件 在插件页面 点击 Add(添加) 根据是否需要c++ 创建GameFeature 他会帮你默认创建一个 GameFeature的 PrimaryDataAsset，写好你需要的即可 我们一定要打开项目设置查看下，这个是否加入，没有得补上去 这样的话我们就创建好了，记得在插件设置里面启动你刚刚创建好的插件 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:2:0","tags":["Unreal","Lyra"],"title":"Lyra架构：Game Feature 篇","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"GameFeature接口 virtual void OnGameFeatureRegistering() override; 当虚幻引擎启动并发现这个 Game Feature 插件时，会立即调用。 virtual void OnGameFeatureUnregistering() override; 引擎关闭的时候，会立刻调用 virtual void OnGameFeatureActivating(FGameFeatureActivatingContext\u0026 Context) override; 当游戏逻辑通过调用 UGameFeaturesSubsystem::Get().ActivateGameFeaturePlugin() 来主动激活这个插件时触发。这通常是游戏流程的一部分 virtual void OnGameFeatureDeactivating(FGameFeatureDeactivatingContext\u0026 Context) override; 当游戏逻辑通过调用 UGameFeaturesSubsystem::Get().DeactivateGameFeaturePlugin() 来主动停用这个插件时触发 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:3:0","tags":["Unreal","Lyra"],"title":"Lyra架构：Game Feature 篇","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 GAS 流程","date":"2025-07-13","objectID":"/lyra-camera/","tags":["Unreal","GAS","Lyra"],"title":"Lyra相机系统：数据驱动与责任分离的设计哲学","uri":"/lyra-camera/"},{"categories":["Unreal-Lyra"],"content":"Lyra的相机系统 简介 Lyra其实没有用最基本的UCameraComponent，也没有用 USpringComponent 他是自己实现了继承于 UCameraComponent的类，他的功能为： 它挂载在玩家角色上，并重写了引擎的 GetCameraView 函数。在每一帧，它负责启动整个更新和混合流程，并将最终计算出的视图结果提交给渲染器。 它拥有一个 CameraModeStack，这是一个“后进先出”的栈结构，用于存放所有当前激活的相机模式。它负责： 管理模式：处理相机模式的推入（Push）和移除 更新模式：在每帧调用每个模式自身的更新逻辑 混合视图：将栈中所有模式的视图根据权重混合成一个最终视图。 当我们需要一种特定的相机行为的时候，就可以自定义一个CameraMode，比如： CameraMode_ThirdPerson：定义了基础的第三人称跟随视角。 CameraMode_Aiming：定义了瞄准时，相机移动到角色肩膀的贴近视角。 其他可能的模式：冲刺模式（增加FOV和抖动）、蹲伏模式（降低相机高度）等。 我们可以把相机一些简单的数据存放到一个结构体 - FLyraCameraModeView (相机视图数据)，用于存放相机的位置（Location）、旋转（Rotation）、视场角（FieldOfView）等关键信息 ","date":"2025-07-13","objectID":"/lyra-camera/:1:0","tags":["Unreal","GAS","Lyra"],"title":"Lyra相机系统：数据驱动与责任分离的设计哲学","uri":"/lyra-camera/"},{"categories":["Unreal-Lyra"],"content":"工作流程 void ULyraCameraComponent::GetCameraView(float DeltaTime, FMinimalViewInfo\u0026 DesiredView) 每帧都会调用一次，或者其他情况，在此函数会进行照相机的一系列数值计算 void ULyraCameraComponent::UpdateCameraModes() 发出委托，获得ULyraPawnData 里面的配置的 CameraMode void ULyraCameraModeStack::PushCameraMode(TSubclassOf\u003cULyraCameraMode\u003e CameraModeClass) 它的作用是将一个新的 摄像机模式（Camera Mode）压入堆栈，并处理 混合（Blending） 和 权重（Blend Weight）逻辑。 void ULyraCameraModeStack::UpdateStack(float DeltaTime) Lyra 摄像机模式堆栈（Camera Mode Stack）的更新逻辑，负责每帧更新堆栈中的摄像机模式，并清理不再需要的模式 void ULyraCameraModeStack::BlendStack(FLyraCameraModeView\u0026 OutCameraModeView) const 负责将堆栈中的所有摄像机模式按权重混合，生成最终的摄像机视图 ","date":"2025-07-13","objectID":"/lyra-camera/:2:0","tags":["Unreal","GAS","Lyra"],"title":"Lyra相机系统：数据驱动与责任分离的设计哲学","uri":"/lyra-camera/"},{"categories":["P4"],"content":"如何在ubuntu上搭建p4","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["P4"],"content":"Rider ","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/:1:0","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["P4"],"content":"配置P4V信息 打开 Rider 设置: File -\u003e Settings (或者按 Ctrl+Alt+S)。 导航到 Version Control -\u003e Perforce。 配置连接参数: Port: 输入你的服务器地址和端口，格式为 host:port (例如 p4.mycompany.com:1666) User: 输入你的 Perforce 用户名。 Workspace: 输入你为这个项目创建的 工作区名称。这是 Rider 用来确定哪些文件在你的控制之下的关键。 Path to P4 executable: 通常你可以留空，Rider 会自动从系统 PATH 中找到 p4.exe。如果找不到，你可以点击 … 按钮手动指定 p4.exe 文件的完整路径。 Path to P4VC executable: 通常你可以留空，Rider 会自动从系统 PATH 中找到 p4v.exe。如果找不到，你可以点击 … 按钮手动指定 p4v.exe 文件的完整路径。 测试连接: 点击 Test Connection 按钮。 如果一切配置正确，你会看到一个 “Connection successful” 的提示。 如果提示需要输入密码，它会弹出一个对话框让你输入。输入后可以选择“记住密码”。 如果连接失败，请仔细检查你的服务器地址、用户名和工作区名称是否拼写正确。 ","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/:1:1","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["P4"],"content":"将项目与 Perforce 关联 即使配置好了连接，你还需要告诉 Rider 这个特定的项目要使用 Perforce 进行版本控制。 打开 Rider 设置: File -\u003e Settings (或者按 Ctrl+Alt+S)。 导航到 Version Control。 在右侧的 Directory Mappings 区域，你会看到你的项目根目录。（没有就新加一个） 在 VCS 这一列，点击下拉菜单，选择 Perforce。 点击 Apply 和 OK。 ","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/:1:2","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["P4"],"content":"Unreal 按照红框点击，并输入其配置即可 ","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/:2:0","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["Unreal-Lyra"],"content":"Lyra 是怎么动态加载游戏体验的","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"举的例子为 大厅 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:0:0","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"什么是 Experience DataAsset 的动态加载机制 Lyra中是分很多游戏玩法的，他在进入一个新的玩法的时候，就会找到玩法对应的 ULyraExperienceDefinition 的数据，系统根据 ULyraExperienceDefinition 里的内容去激活Game Features、Abilities 和 UI 等。 这样的好处是啥，举个例子： 传统方式（硬编码/硬引用）： 想象一下你走进一家自助餐厅。为了能让你随时吃到任何菜，厨房必须提前把所有菜品都做好并摆出来*。这会导致：* 启动慢： 厨房开工时间长。 资源浪费： 很多菜你根本不吃，但它们依然占着空间和保温的能源（内存）。 Lyra 的动态加载方式： 现在想象你走进一家点餐的餐厅。你拿到一本菜单 (Experience DataAsset)*。菜单上写着各种套餐的描述（比如“西部对决”套餐包含：牛仔Pawn、左轮手枪、沙漠地图UI）。* 启动快： 餐厅开门很快，因为厨房什么都还没做，只是准备好了菜单。 按需加载： 当你点单时（选择了一个 Experience），服务员（ExperienceManagerComponent）才把订单（PrimaryAssetId）交给厨房（AssetManager）。厨房只根据你点的菜去准备，然后上菜。 高效节约： 你没点的菜，就完全不占用厨房的任何资源。 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:1:0","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"动态加载代码流程 void ALyraGameMode::InitGame(const FString\u0026 MapName, const FString\u0026 Options, FString\u0026 ErrorMessage) void ALyraGameMode::HandleMatchAssignmentIfNotExpectingOne() 通过一系列的渠道，获取 ULyraExperienceDefinition， 此 ULyraExperienceDefinition 后面会讲解 void ALyraGameMode::OnMatchAssignmentGiven(FPrimaryAssetId ExperienceId, const FString\u0026 ExperienceIdSource) 获取到 GameState 里的 ULyraExperienceManagerComponent，此Component后面会讲解 void ULyraExperienceManagerComponent::SetCurrentExperience(FPrimaryAssetId ExperienceId) 通过 FPrimaryAssetId 进行加载 获取到里面的各种数据，并且保存 void ULyraExperienceManagerComponent::StartExperienceLoad() 将 ULyraExperienceDefinition 其里面的 DataAsset 包括自己本身 都异步加载出来，加载成功了就调用回调事件 OnExperienceLoadComplete void ULyraExperienceManagerComponent::OnExperienceLoadComplete() 加载需要 ULyraExperienceDefinition 里面 GameFeature 的插件，如果加载完成则调用 OnExperienceFullLoadCompleted void ULyraExperienceManagerComponent::OnExperienceFullLoadCompleted() 需要的数据都已经加载完成，获得所有的GameFeatureAction, 调用其生命周期函数，开始进入GameFeatureAction的表演 并发出 OnExperienceLoaded_HighPriority 等 3个优先级事件，通知接收事件的对象 void ALyraGameMode::OnExperienceLoaded(const ULyraExperienceDefinition* CurrentExperience) 将世界的所有 Playcontroller 遍历一遍，如果满足 Restart条件，则 RestartPlayer(PC) APawn* ALyraGameMode::SpawnDefaultPawnAtTransform_Implementation(AController* NewPlayer, const FTransform\u0026 SpawnTransform) 如果这时候经过 上述函数都是正常的，RestartPlayer(PC) 之后会到这个函数，随后根据我们 ULyraExperienceDefinition 里面的Pawn类生成我们的玩家 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:2:0","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"加载流程牵扯到的类 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:0","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"ALyraGameMode 设计理念 标准AGameModeBase： 通常是游戏规则的中心。 硬编码了许多核心逻辑，比如玩家的 Pawn 类型 (DefaultPawnClass)、玩家控制器类型 (PlayerControllerClass)、游戏状态 (GameStateClass) 等。 如果想换一个游戏模式（比如从“死亡竞赛”换到“夺旗”），你通常需要创建一个全新的 GameMode 子类，并在里面写新的逻辑。 ALyraGameMode： 它本身不包含具体游戏模式的逻辑。它不知道什么是“死亡竞赛”或“据点控制”。 它的设计目标是保持通用性，能够适应任何通过 Experience 定义的游戏玩法。 它将具体的游戏规则和玩家配置“外包”给了 LyraExperienceDefinition。 核心职责 ALyraGameMode 依然承担着 AGameMode 的传统职责，即管理玩家的连接、生成和重生。 他只会读取 ULyraExperienceDefinition 并且通过GameState的 ULyraExperienceManagerComponent 去加载他，随后加载完了，再去生成玩家Pawn。 所以他的核心职责就是推迟玩家Pawn的生成，读取 ULyraExperienceDefinition ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:1","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"ALyraGameState 设计理念 标准 GameStateBase 主要职责是同步那些需要被所有客户端知晓的游戏状态信息，例如比赛时间、分数、队伍信息等。 它的数据通常是被动的，由 GameMode 在服务器上修改，然后自动复制（Replicate）到所有客户端。 它本身很少主动执行复杂的逻辑。 ALyraGameState 继承了所有标准职责：它依然负责同步分数、比赛时间等传统状态。 新增了核心职责：它成为了体验（Experience）和游戏功能插件（Game Features）的管理中心。这是通过它所持有的组件实现的。 它的行为是主动的。它主动管理体验的加载、激活和状态切换，并向全场“广播”当前的状态。 核心职责 将 ExperienceManagerComponent 放在GameState身上，当游戏需要切换到一个新的体验时，负责接收 Experience 的 PrimaryAssetId，通过 AssetManager 异步加载它，并在加载完成后激活它。并激活后，发出事件通知 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:2","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"ULyraExperienceDefinition 结构成员 TArray\u003cFString\u003e GameFeaturesToEnable; 定义了这个体验依赖哪些游戏功能插件 (Game Feature Plugins)。 TObjectPtr\u003cconst ULyraPawnData\u003e DefaultPawnData; 指定了在这个体验中，玩家默认应该被生成为什么样子的Pawn TArray\u003cTObjectPtr\u003cUGameFeatureAction\u003e\u003e Actions; 定义了一系列直接嵌入到这个Experience中的Game Feature Actions。 TArray\u003cTObjectPtr\u003cULyraExperienceActionSet\u003e\u003e ActionSets; 允许你引用一个或多个可复用的功能集合。 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:3","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"ULyraExperienceManagerComponent 核心职责 ULyraExperienceDefinition 结构体 的 管理者 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:4","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"一些坑 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:4:0","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"GameModeBase /GameState混用 GameModeBase 与 GameState 不能混用，相反也是一样的道理 这是因为： 网络多人游戏设计：AGameModeBase是游戏模式的基类，它只在服务器上实例化，不会存在于客户端。这意味着AGameModeBase负责定义游戏的核心逻辑和规则，但它并不需要在客户端被复制或同步。 GameState的复制：AGameState（或AGameStateBase）用于存储和同步游戏中的全局状态信息，比如玩家的得分和游戏的当前状态。在网络多人游戏中，AGameState需要被复制到所有客户端以确保所有玩家都有相同的游戏信息。 兼容性问题：当你尝试将AGameState与AGameModeBase一起使用时，会出现兼容性问题，因为AGameModeBase不设计为与需要在客户端复制的AGameState一起工作。这种混合使用会导致运行时错误，因为AGameModeBase不会在客户端存在，而AGameState需要在客户端存在以同步状态。 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:4:1","tags":["Unreal","Lyra\""],"title":"Lyra 架构解析：Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"IGameFrameworkInitStateInterface 怎么玩的","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/","tags":["Unreal","Lyra\""],"title":"解密Lyra初始化流程：IGameFrameworkInitStateInterface的核心回调","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"作用 IGameFrameworkInitStateInterface 的作用，就是将一个组件原本混乱、单体的初始化过程（主要挤在BeginPlay里），拆分成一个清晰、有序、分阶段的“生命周期”。 它允许不同组件之间优雅地声明和等待依赖关系，从而构建出可预测、可扩展、无惧异步加载的复杂系统。 ","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:1:0","tags":["Unreal","Lyra\""],"title":"解密Lyra初始化流程：IGameFrameworkInitStateInterface的核心回调","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"核心接口 virtual FName GetFeatureName() const override { return NAME_ActorFeatureName; } 返回这个组件在 GameFrameworkComponentManager 系统中的唯一标识名称（身份证号） 其他组件如果想查询或依赖这个组件的初始化状态，就必须使用这个函数返回的 FName virtual bool CanChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) const override; 这是一个条件检查函数。当 Manager 尝试将组件的状态从 CurrentState 推进到 DesiredState 时，会调用这个函数来询问：“现在可以进行这个状态转换吗？” virtual void HandleChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) override; 这是一个状态改变回调函数。在 CanChangeInitState 返回 true 并且 Manager 成功地将组件的状态更新后，这个函数会被立即调用。 virtual void OnActorInitStateChanged(const FActorInitStateChangedParams\u0026 Params) override; 这是一个事件监听器。前提是你必须在 BeginPlay 中调用 BindOnActorInitStateChanged() 来注册这个监听。 注册后，当同一个Actor上其他被Manager管理的组件的初始化状态发生变化时，这个函数就会被调用。 virtual void CheckDefaultInitialization() override; 在这个函数内部，你会调用 UGameFrameworkComponentManager 提供的一些工具函数（如 ContinueInitStateChain），来触发一次从当前状态到最终状态的连续转换尝试 ","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:2:0","tags":["Unreal","Lyra\""],"title":"解密Lyra初始化流程：IGameFrameworkInitStateInterface的核心回调","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"正常工作流程 假设我们有4个 FGAmeplayTag： LyraGameplayTags::InitState_Spawned, LyraGameplayTags::InitState_DataAvailable, LyraGameplayTags::InitState_DataInitialized, LyraGameplayTags::InitState_GameplayReady 我们还有两个Component： class LYRAGAME_API ULyraHeroComponent : public UPawnComponent, public IGameFrameworkInitStateInterface class LYRAGAME_API ULyraPawnExtensionComponent : public UPawnComponent, public IGameFrameworkInitStateInterface 所以流程为： 先把这四个注册进去，比如在GameInstance注册： void ULyraGameInstance::Init() { Super::Init(); UGameFrameworkComponentManager* ComponentManager = GetSubsystem\u003cUGameFrameworkComponentManager\u003e(this); if (ensure(ComponentManager)) { ComponentManager-\u003eRegisterInitState(LyraGameplayTags::InitState_Spawned, false, FGameplayTag()); ComponentManager-\u003eRegisterInitState(LyraGameplayTags::InitState_DataAvailable, false, LyraGameplayTags::InitState_Spawned); ComponentManager-\u003eRegisterInitState(LyraGameplayTags::InitState_DataInitialized, false, LyraGameplayTags::InitState_DataAvailable); ComponentManager-\u003eRegisterInitState(LyraGameplayTags::InitState_GameplayReady, false, LyraGameplayTags::InitState_DataInitialized); } } 随后在两个Component初始化，并记得销毁状态（两个Component都一样） void ULyraPawnExtensionComponent::OnRegister() { Super::OnRegister(); // Register with the init state system early, this will only work if this is a game world RegisterInitStateFeature(); } void ULyraPawnExtensionComponent::BeginPlay() { Super::BeginPlay(); // Listen for changes to all features BindOnActorInitStateChanged(NAME_None, FGameplayTag(), false); // Notifies state manager that we have spawned, then try rest of default initialization ensure(TryToChangeInitState(LyraGameplayTags::InitState_Spawned)); CheckDefaultInitialization(); } void ULyraPawnExtensionComponent::EndPlay(const EEndPlayReason::Type EndPlayReason) { UnregisterInitStateFeature(); Super::EndPlay(EndPlayReason); } 只要BeginPlay触发了，CheckDefaultInitialization() 这个就会执行，当然你在其他地方也可以执行，只要满足你的需要 void ULyraPawnExtensionComponent::CheckDefaultInitialization() { // Before checking our progress, try progressing any other features we might depend on CheckDefaultInitializationForImplementers(); static const TArray\u003cFGameplayTag\u003e StateChain = { LyraGameplayTags::InitState_Spawned, LyraGameplayTags::InitState_DataAvailable, LyraGameplayTags::InitState_DataInitialized, LyraGameplayTags::InitState_GameplayReady }; // This will try to progress from spawned (which is only set in BeginPlay) through the data initialization stages until it gets to gameplay ready ContinueInitStateChain(StateChain); } 随后就会执行 CanChangeInitState，每当当前状态通过，返回 true 后，就会调用一次 HandleChangeInitState bool ULyraPawnExtensionComponent::CanChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) const { check(Manager); APawn* Pawn = GetPawn\u003cAPawn\u003e(); if (!CurrentState.IsValid() \u0026\u0026 DesiredState == LyraGameplayTags::InitState_Spawned) { return true; } if (CurrentState == LyraGameplayTags::InitState_Spawned \u0026\u0026 DesiredState == LyraGameplayTags::InitState_DataAvailable) { if (!PawnData) { return false; } return true; } else if (CurrentState == LyraGameplayTags::InitState_DataAvailable \u0026\u0026 DesiredState == LyraGameplayTags::InitState_DataInitialized) { return Manager-\u003eHaveAllFeaturesReachedInitState(Pawn, LyraGameplayTags::InitState_DataAvailable); } else if (CurrentState == LyraGameplayTags::InitState_DataInitialized \u0026\u0026 DesiredState == LyraGameplayTags::InitState_GameplayReady) { return true; } return false; } void ULyraPawnExtensionComponent::HandleChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) { if (DesiredState == LyraGameplayTags::InitState_DataInitialized) { // This is currently all handled by other components listening to this state change } } 当同一个Actor上其他被Manager管理的组件的初始化状态发生变化时，就会调用： void ULyraPawnExtensionComponent::OnActorInitStateChanged(const FActorInitStateChangedParams\u0026 Params) { // If another feature is now in DataAvailable, see if ","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:3:0","tags":["Unreal","Lyra\""],"title":"解密Lyra初始化流程：IGameFrameworkInitStateInterface的核心回调","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"协作方法 bool UGameFrameworkComponentManager::HaveAllFeaturesReachedInitState(AActor* Actor, FGameplayTag RequiredState, FName ExcludingFeature) const 询问 “对于指定的这个 Actor（Pawn），所有在 Manager 中注册过的、并且与这个 Actor 相关的功能（Features），是否都已经达到或超过了给定的状态（InitState_DataAvailable）？” bool UGameFrameworkComponentManager::HasFeatureReachedInitState(AActor* Actor, FName FeatureName, FGameplayTag FeatureState) const 它在问 GameFrameworkComponentManager：“嘿，我的同事 PawnExtensionComponent，它是不是已经到达过 DataInitialized 状态？” 注意是：到达过 xxx 状态，也就是说如果目标已经经过这个状态也会返回 true ","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:4:0","tags":["Unreal","Lyra\""],"title":"解密Lyra初始化流程：IGameFrameworkInitStateInterface的核心回调","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["P4"],"content":"下载P4V","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"下载P4V URL: https://portal.perforce.com/s/downloads?product=Helix%20Visual%20Client%20%28P4V%29 ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"安装后 打开P4V，输入服务器地址和用户名（这些信息在安装服务器或配置 P4 Cloud 时已创建） ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"创建 Depot（仓库） 安装好 Unreal Engine 和 Perforce P4后，需要为项目创建一个 Depot——即你在 Perforce 服务器上用于存储项目的主目录。 操作步骤如下： 打开 P4V，点击菜单栏 Tools \u003e Administration ，进入 P4 Admin 在 P4 Admin 中切换到 Depots 选项卡 点击菜单 File \u003e New \u003e Depot… 给 depot 命名（例如 “ProjectName”）注意：名称不能包含空格，且一旦设定无法更改 将 Depot 类型设置为默认值 “stream”，然后点击 OK 创建 depot ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:3:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"设置 typemap（类型映射） 在向服务器添加文件之前，你需要设置 typemap，这样 P4 服务器才能正确处理不同类型的文件。例如，当你编辑 .uasset 或 .umap 这类二进制文件时，typemap 可以指示服务器对这些文件进行独占锁定，从而避免多人同时编辑造成的冲突。 此步骤只需在首次设置服务器时执行一次： 在 P4V 的左侧 Depot 面板中右键任意 depot，选择 Open Command Window Here 这将打开一个终端窗口，在终端中输入命令：p4 typemap 此操作将在你的默认文本编辑器（通常是记事本）中打开 typemap 文件 大多数用户可以直接复制粘贴 Game Engine Universal Typemap 保存并关闭文件。如果终端显示 “Typemap saved”，则表示操作成功 ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:4:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"创建 Mainline Stream（主线流） Perforce Streams 可以简化分支和合并操作，自动化开发与发布流程。虽然 Streams 功能非常强大，但建议先从一个 mainline stream 开始，后续再随着项目的发展逐步扩展。 操作步骤如下： 返回 P4V（不是 P4 Admin），点击 File \u003e New \u003e Stream… 为 stream 命名（常见的命名方式是使用简短的项目代码 + “_main”，例如 “ABC_main”） 在 Depot 字段中，选择你刚刚为该项目创建的 streams depot 确保 Stream type（流类型）设置为 mainline 取消勾选 Create a workspace to use with this stream （稍后再做这一步） 取消勾选 Populate the mainline stream after it is created （稍后再做这一步） 稍后会设置 p4ignore 文件，但为了更加安全，可以先确保一些文件夹始终被忽略。切换到“高级”选项卡，在 Ignored 字段中添加以下内容，然后点击“确定”： /Saved/... /Intermediate/... /DerivedDataCache/... /FileOpenOrder/... ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:5:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"如何在ubuntu上搭建p4","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"下载并安装 p4d cd /tmp wget https://www.perforce.com/downloads/perforce/r24.1/bin.linux26x86_64/p4d chmod +x p4d sudo mv p4d /usr/local/bin/ ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"创建服务用户和数据目录 sudo useradd -m perforce sudo mkdir -p /opt/perforce/depots sudo chown -R perforce:perforce /opt/perforce ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"设置环境变量（为 perforce 用户） sudo -i -u perforce bash 会进入到 perforce 命令行 sudo -i -u perforce bash vi ~/.bashrc ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:0","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"添加以下内容 export P4PORT=1666 export P4ROOT=/opt/perforce/depots ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:1","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"生效 source ~/.bashrc ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:2","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"初始化 Perforce 服务端 p4d -r $P4ROOT -p $P4PORT -xi ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:3","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"启动服务 p4d -r $P4ROOT -p $P4PORT ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:4","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"配置 systemd 服务 创建服务文件 sudo vi /etc/systemd/system/p4d.service 写入以下内容： [Unit] Description=Perforce Helix Core Server After=network.target [Service] Type=simple User=perforce ExecStart=/usr/local/bin/p4d -r /opt/perforce/depots -p 1666 Restart=on-failure [Install] WantedBy=multi-user.target 启用并启动服务： sudo systemctl daemon-reexec sudo systemctl daemon-reload sudo systemctl enable p4d sudo systemctl start p4d 检查状态 sudo systemctl status p4d 开放防火墙端口（如有需要） sudo ufw allow 1666 ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:0","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 Plugins 介绍","date":"2025-06-16","objectID":"/lyra-plugins/","tags":["Unreal","Lyra"],"title":"Lyra-Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"ModularGameplayActors ","date":"2025-06-16","objectID":"/lyra-plugins/:1:0","tags":["Unreal","Lyra"],"title":"Lyra-Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"作用 Lyra 里的插件 ModularGameplayActors 是整个架构的一个核心部分，用来实现 角色、控制器、HUD 等 Gameplay 类的模块化（Modular）构建机制。它是 Lyra “模块化组件系统” 的基础，支持你以“插件化方式”给 Actor 添加功能，而不是通过硬继承和写死逻辑。 ","date":"2025-06-16","objectID":"/lyra-plugins/:1:1","tags":["Unreal","Lyra"],"title":"Lyra-Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"模块化系统的核心目标 传统方式的问题： 你通常会在 MyCharacter、MyPlayerController、MyHUD 里硬编码各种行为，比如：初始化输入/初始化技能系统组件/初始化 UI 控制逻辑 但这样：很难复用/不利于热更、插件式内容扩展/玩家控制器和角色之间的耦合度太高 ModularGameplayActors 将这些逻辑解耦成一个个“模块化组件”，通过注册自动注入到对应 Actor（如 Pawn, Controller, HUD）中。 ","date":"2025-06-16","objectID":"/lyra-plugins/:1:2","tags":["Unreal","Lyra"],"title":"Lyra-Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"此插件的主要功能 模块化 Actor 生命周期管理：支持在特定时机（如 Controller 初始化、Pawn Possess 等）注册模块组件 动态挂载组件：可以在运行时给 Pawn/Controller 添加组件（如 ULyraHeroComponent） 支持 GameFeature 插件动态注册组件：GameFeature 激活时可以给现有 Actor 动态添加模块逻辑 按类型分组扩展点：拥有像 ExtensionEvent-BindInputsNow、OnPawnExtensionAdded 等事件点 ","date":"2025-06-16","objectID":"/lyra-plugins/:1:3","tags":["Unreal","Lyra"],"title":"Lyra-Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"核心类说明 UGameFrameworkComponentManager 它负责监听 Pawn、Controller、HUD 等的创建事件，并调用注册的扩展。 这个语句会触发所有注册到该事件的组件（如 ULyraHeroComponent）执行绑定。 UGameFrameworkComponentManager::SendGameFrameworkComponentExtensionEvent(Pawn, NAME_BindInputsNow); UModularPawn / UModularPlayerController 等 这些是 Lyra 扩展出来的基类，继承自引擎默认的 APawn / APlayerController 等。 它们的特点： 自动调用 UGameFrameworkComponentManager 的初始化逻辑 支持组件注册、事件派发等 ","date":"2025-06-16","objectID":"/lyra-plugins/:1:4","tags":["Unreal","Lyra"],"title":"Lyra-Plugins","uri":"/lyra-plugins/"},{"categories":["DirectX3D"],"content":"DirectX3D 纹理","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"纹理简介 2D 纹理是一种由特定数据元素所构成的矩阵，它的用处之一即是存储 2D 图像数据，纹理中的每个元素都存储着对应像素的颜色。但是，这并不是它唯一的用途，比如说，在一种称为法线贴图的高级技术中，每个纹理元素都存储的是一个 3D 向量而非颜色数据。 一个纹理可以绑定到渲染流水线的不同阶段，一个常见的例子是既可将一纹理用作渲染目标（即 Direct3D 中的渲染到纹理技术），又能把它作为着色器资源（即在着色器中对该纹理进行采样）。一个纹理可以当作渲染目标，也可以充当着色器资源，但是不能同时“身兼数职”。将数据渲染到一个纹理后，再用它作为着色器资源，这种方法称为渲染到纹理（render-to-texture） ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:1:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"纹理坐标 Direct3D 所采用的纹理坐标系，是由指向图像水平正方向的 u 轴与指向图像垂直正方向的 v 轴所组成的。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:2:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"纹素 取值范围为 0 ≤ u, v ≤ 1 的坐标(u, v)标定的是一 种称为纹素（texel）的纹理元素 无论纹理实际的大小是 256 × 256 像素、512 × 1024 像素还是 2048 × 2048 像素，纹理坐标(0.5, 0.5)总是表示 纹理正中间的纹素；坐标(0.25, 0.75)总是表示在纹理中， 位于水平方向总宽度 1/4、垂直方向总高度3/4处的纹素。这就是纹理坐标采用的归一化坐标区间[0, 1]，通过这种方式便可令 Direct3D 的工作摆脱具体纹理尺寸的干扰 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:2:1","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"纹理图集 我们可以只向几何体映射部分纹理。事实上，我们也能够将几个并无关联的图像合为一个大的纹 理图（这被称为纹理图集），再将它应用于若干不同的物体。此时，纹理坐标将用于确定纹理的哪一部分将被映射到目标三角形上。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:2:2","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"纹理数据源 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:3:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"DDS 图像文件格式 贴图师通常会借助 Photoshop 或一些其他的图像编辑器为游戏制作纹理，最后再将它们保存为某种格式的图像文件，如 BMP、DDS、TGA 或 PNG 等。随后，游戏应用程序会在加载期间将图像文件载入 ID3D12Resource 对象。 对于实时图形应用程序来说，DDS 图像文件格式（DirectDraw 图面格式， DirectDraw Surface format，DDS）是一种尚佳的选择：除了支持 GPU 可原生处理的各种图像格式，它还 支持一些 GPU 自身就可解压的压缩图像格式。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:3:1","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"DDS 格式概述 DDS 对于 3D 图形来说是一种理想的格式，因为它支持一些专用于 3D 图形的特殊格式以及纹理类型。 从本质上来讲，它实为一种针对 GPU 而专门设计的图像格式。例如，DDS 纹理满足用于3D 图形开发的以下特征： mipmap GPU 能自行解压的压缩格式。 纹理数组。 立方体图（cube map，也有译作立方体贴图） 体纹理（volume texture，也有译作体积纹理、立体纹理等） DDS 格式能够支援不同的像素格式。像素格式由枚举类型 DXGI_FORMAT 中的成员来表示，但是并非所有的格式都适用于 DDS 纹理。 随着虚拟场景中纹理数量的大幅增长，对 GPU 端显存的需求也在迅速增加（还记得吗，我们需要将所有的纹理都置于显存当中，以便在程序中快速地运用这些资源）。为了缓解这些内存的需求压力， Direct3D 支持下列几种压缩纹理格式 BC1（DXGI_FORMAT_BC1_UNORM）：如果我们需要将图片压缩为支持 3 个颜色通道和仅有 1 位（开/关）alpha 分量的格式，则使用此格式。 BC2（DXGI_FORMAT_BC2_UNORM）：如果我们需要将图片压缩为支持 3 个颜色通道和仅有 4 位 alpha 分量的格式，则应用此格式。 BC3（DXGI_FORMAT_BC3_UNORM）：如果我们需要将图片压缩为支持 3 个颜色通道和 8 位 alpha 分量的格式，则采用此格式。 BC4（DXGI_FORMAT_BC4_UNORM）：如果我们需要将图片压缩为仅含有 1 个颜色通道的格式 （如灰度图像），则运用此格式。 BC5（DXGI_FORMAT_BC5_UNORM）：如果我们需要将图片压缩为只支持 2 个颜色通道的格式， 则使用此格式。 BC6（DXGI_FORMAT_BC6H_UF16）：如果我们需要将图片压缩为 HDR（高动态范围）图像数 据，则应用此格式。 BC7（DXGI_FORMAT_BC7_UNORM）：此格式用于对 RGBA 数据进行高质量的压缩。特别是， 此格式可极大地减少因压缩法线图而造成的误差。 再次重申，这些格式的优点是可以使图像以压缩的形式存于显存之中，而在需要时，GPU 便能动态 地对它们进行解压。将纹理压缩为 DDS 文件还有另一个好处，即更节省硬盘空间 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:3:2","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"创建 DDS 文件 下面介绍两种可以将传统图像格式转换为 DDS 格式的方法 NVIDIA 公司为 Adobe Photoshop 提供了一款可以将图像导出为 DDS 格式的插件。该插件现存 于 https://developer.nvidia.com/nvidia-texture-tools-adobe-photoshop。此插件还有一些其他选项， 可供用户指定 DDS 文件的 DXGI_FORMAT 格式，或生成 mipmap 等。 微软公司提供了一个名为 texconv 的命令行工具，该工具能将传统的图像格式转换为 DDS 文件。 另外，texconv 程序还有更多的其他功能，如调整图像大小、改变像素格式、生成 mipmap 等。可 以在网站https://directxtex.codeplex.com/wikipage?title=Texconv\u0026referringTitle=ocumentation 找到它 的文档与下载链接。 下面的示例展示了向 texconv 程序输入一个 BMP 文件 bricks.bmp，并通过它来输出格式为 BC3_UNORM 且具有一个 mipmap 链（链中共有 10 个 mipmap）的 DDS 文件 bricks.dds。 texconv -m 10 -f BC3_UNORM bricks.bmp ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:3:3","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"创建以及启用纹理 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:4:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"加载 DDS 文件 微软公司提供了一组用来加载 DDS 文件的轻量级源代码（ps: 此代码仅支持 DirectX 11） HRESULT DirectX::CreateDDSTextureFromFile12( _In_ ID3D12Device* device, _In_ ID3D12GraphicsCommandList* cmdList, _In_z_ const wchar_t* szFileName, _Out_ Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e\u0026 texture, _Out_ Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e\u0026 textureUploadHeap ); device：指向用于创建纹理资源的 D3D 设备的指针 cmdList：提交 GPU 命令（例如，将纹理数据从上传堆复制到默认堆的命令）的命令列表 szFileName：欲加载的图像文件名。 texture：返回载有图像数据的纹理资源。 textureUploadHeap：返回的纹理资源，在此，将它当作一个上传堆，用于将图像数据复制到默认堆中的纹理资源。在 GPU 完成其上述复制命令之前，不能销毁该资源。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:4:1","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"着色器资源视图堆 创建了纹理资源后，我们还需要为它再创建一个 SRV（着色器资源视图）描述符，并将其设置到一 个根签名参数槽（root signature parameter slot），以供着色器程序使用。 为此，首先要用 ID3D12Device:: CreateDescriptorHeap 函数来创建描述符堆，借此存储 SRV 描述符 下面的代码构建了一个可容纳 3 个类型为 CBV、SRV 或 UAV 描述符的描述符堆，并使之在着色器中可见（即可供着色器使用）： D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {}; srvHeapDesc.NumDescriptors = 3; srvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV; srvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE; ThrowIfFailed(md3dDevice-\u003eCreateDescriptorHeap(\u0026srvHeapDesc, IID_PPV_ARGS(\u0026mSrvDescriptorHeap))); ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:4:2","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"创建着色器资源视图描述符 一旦创建了 SRV 堆，便可创建真正的描述符。我们通过填写 D3D12_SHADER_RESOURCE_VIEW_DESC 对象来描述 SRV 描述符，该结构体详述了资源的类型以及其他的信息，如格式、维数、mipmap 数量等。 typedef struct D3D12_SHADER_RESOURCE_VIEW_DESC { DXGI_FORMAT Format; D3D12_SRV_DIMENSION ViewDimension; UINT Shader4ComponentMapping; union { D3D12_BUFFER_SRV Buffer; D3D12_TEX1D_SRV Texture1D; D3D12_TEX1D_ARRAY_SRV Texture1DArray; D3D12_TEX2D_SRV Texture2D; D3D12_TEX2D_ARRAY_SRV Texture2DArray; D3D12_TEX2DMS_SRV Texture2DMS; D3D12_TEX2DMS_ARRAY_SRV Texture2DMSArray; D3D12_TEX3D_SRV Texture3D; D3D12_TEXCUBE_SRV TextureCube; D3D12_TEXCUBE_ARRAY_SRV TextureCubeArray; }; } D3D12_SHADER_RESOURCE_VIEW_DESC; typedef struct D3D12_TEX2D_SRV { UINT MostDetailedMip; UINT MipLevels; UINT PlaneSlice; FLOAT ResourceMinLODClamp; } D3D12_TEX2D_SRV; 对于 2D 纹理来说，我们只关心联合体中的 D3D12_TEX2D_SRV 部分。 Format：视图的格式。如果待创建视图的资源有具体的格式，即并非以无类型（typeless）的格式创建而成），就用此资源的 DXGI_FORMAT 格式来填写此参数。如果是通过无类型的 DXGI_FORMAT 来创建该资源的，则一定要在此为视图填写具体的类型，只有这样 GPU 才能知 道怎样解释并处理这一数据。 ViewDimension：资源的维数。目前我们只使用 2D 纹理，所以将此参数指定为 D3D12_SRV_ DIMENSION_TEXTURE2D 以下是几种常见的纹理维数： D3D12_SRV_DIMENSION_TEXTURE1D：资源为 1D 纹理。 D3D12_SRV_DIMENSION_TEXTURE3D：资源为 3D 纹理。 D3D12_SRV_DIMENSION_TEXTURECUBE：资源为立方体纹理（cube texture）。 Shader4ComponentMapping：在着色器中对纹理进行采样时，它将返回特定纹理坐标处的纹理数据向量。这个字段提供了一种方法，可以将采样时所返回的纹理向量中的分量进行重新排序。例如，可以用此字段将红色分量与绿色分量互换。该方法常用于一些特殊的场合，但目前并不涉及这些情景。因此，只要将它指定为 D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING 即可。这样一来，向量分量的顺序将不会改变，它会以纹理资源中默认的数据顺序直接返回。 MostDetailedMip：指定此视图中图像细节最详尽的 mipmap 层级的索引。此参数的取值范围在 0 与 MipLevels-1 之间。 MipLevels：自 MostDetailedMip 算起，待创建视图的 mipmap 层级数量。通过将这个字段与 MostDetailedMip 配合起来，我们就能够指定此视图 mipmap 层级的连续子范围。可以将此字段设置为-1，用来表示自 MostDetailedMip 始至最后一个 mipmap 层级之间的所有 mipmap 级别。 PlaneSlice：平面切片的索引。 ResourceMinLODClamp：指定可以访问的最小 mipmap 层级。设置为 0.0 表示可以访问所有 的 mipmap 层级。将此参数指定为 3.0，则表示可以访问从 3.0 到 MipCount-1 的 mipmap 层级。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:4:3","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"将纹理绑定到流水线 至此，我们在每次绘制调用时所指定的材质，都是由材质常量缓冲区来进行更新的。这就意味着在 绘制调用的过程中，所有的几何体都将使用同一组材质数据。这对程序而言是一种极大的限制，因为我们 将不能动态地指定每个像素的材质，继而导致场景细节的缺失。 纹理映射技术的想法是用纹理图（texture map）来取代材质常量缓冲区以获取材质数据。这将使每个像素的数据都是灵活可变化的，从而为场景增添更丰富的细节与几分真实感。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:4:4","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"过滤器 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:5:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"纹理放大 我们可以将纹理图中的元素看作是从连续图像中采集的离散颜色样本，但并不应认为它们是有着特定面积大小的矩形。所以，当前的疑问是：如果在纹理坐标(u, v)处没有与之对应的纹素点究竟会发生什么？ 假设玩家慢慢靠近了场景中的一堵墙壁，则墙壁将逐渐放大并占据完整的镜头。为了便于说明问题，这里假设显示器的分辨率为1024 × 1024 ，而且墙壁纹理的分辨率 为 256 × 256 。由此就产生了纹理放大（magnification）的概念——我们试图用少量纹素来覆盖大量的像 素。 还有一点需要注意的是，在以虚拟视角可以自由移动和探索的交互式 3D 程序中，纹理放大是个无法回避的问题。在与目标保持特定距离时，纹理可能看上去还不错，但是随着观察点逐渐接近目标，其效果就开始惨不忍睹了。一些游戏对虚拟视角过于接近物体表面的行为进行了限制，以避免过度的放大处理。通过使用更高分辨率的纹理也可以使此难题得到一定程度的改善。 图形硬件往往会支持常数插值（constant interpolation，也有译作常量插值）与 线性插值（linear interpolation）两种插值方法。在实践中，线性插值的使用更为普遍。 点过滤 1D 情况下的使用过程：假设我们有一个内含 256 个样本的 1D 纹理， 并且某个插值纹理坐标为 u = 0.126484375，所以此归一化纹理坐标就对应于 0.126484375 × 256 = 32.38 处的纹素。显而易见，此值实际位于两个纹素样本之间，所以我们必须通过插值这一手段来求取它的近似值。 线性过滤 2D 线性插值又称为双线性插值（bilinear interpolation），其处理流程：给出四个纹素之间的一个纹理坐标，先在水平方向 u 上进行两次 1D 线性插值（求出 cT与 cB），后在垂直方向 v 上再进行 一次 1D 内插（求取 c）。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:5:1","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"纹理缩小 纹理缩小（minification）是纹理放大的逆运算。在缩小的过程中，大量纹素将被映射到少数纹理之上。 例如，考虑下列情景：假设有一堵被 256 × 256 纹理所映射的墙壁，玩家的观察视角正紧盯着它，并逐渐向后退却。在此过程中，这堵墙会看上去越来越小，直至它在屏幕上只覆盖大小为 64 × 64 像素的区 域。此时，我们就应当将 256 × 256 纹素映射到 64 × 64 屏幕像素。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:5:2","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"各向异性过滤 还有一种名为各向异性过滤（anisotropic filtering）的过滤器类型。该过滤器有助于缓解当多边形法向量与摄像机观察向量之间夹角过大（比如当多边形正交于观察窗口时）所导致的失真现象。 这种过滤器的开销最大，但是其校正失真的效果的确对得起它所消耗的资源。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:5:3","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"寻址模式 可将经过常数插值或线性插值的纹理定义为一个返回向量值的函数 T(u, v) = (r, g, b, a)，即给定纹理坐标 $ (u, v) ∈ [0,1]^2 $ ，则上述纹理函数 T 将返回颜色(r, g, b, a)。 Direct3D 允许我们采用下列 4 种不同方式（即寻址模式）来扩充此函数的定义域（解决输入值超出定义域这一问 题） 重复寻址模式通过在坐标的每个整数点处重复绘制图像来拓充纹理函数 边框颜色寻址模式通过将每个不在范围 $ [0,1]^2 $ 内的坐标(u, v)都映射为程序员指定的颜色而拓充纹理函数 钳位寻址模式通过将范围 $ [0,1]^2 $外的每个坐标(u, v)都映射为颜色 T(u0, v0)来扩充纹理函数，其中， $ (u_0, v_0) $ 为范围 $ [0,1]^2 $ 内距离(u, v)最近的点 镜像寻址模式通过在坐标的每个整数点处绘制图像的镜像来扩充纹理函数 重复寻址也许是最常使用的一种模式，它允许我们将一种纹理反复平铺到某一表面上。也就是说，这种寻址模式使我们在不提供额外数据的情况下，亦可提升纹理的分辨率，虽然很多都是重复的 在执行平铺的时候，纹理是否能无缝衔接往往也是一个重点。例如，若板条箱纹理原本并不是无缝连接的，那么我们就能够明显地看出它是在反复贴同一张图。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:6:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"采样器对象 从前面两个小节中可以看出，在运用纹理的过程中，除了纹理数据本身之外，还有另外两个相关的 重要概念，即纹理过滤以及寻址模式。采集纹理资源时所用的过滤器和寻址模式都是由采样器对象来定义的。一个应用程序通常需要采用若干个采样器对象以不同的方式来采集纹理。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:7:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"创建采样器 为了将采样器绑定到着色器上供其使 用，我们就需要为采样器对象绑定描述符。、 下面的代码展示了这样的一个根签名示例，它的第二个槽位 获取了一个描述符表，此表中存有 1 个与采样器寄存器槽 0 相绑定的采样器描述符。 CD3DX12_DESCRIPTOR_RANGE descRange[3]; descRange[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0); descRange[1].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER, 1, 0); descRange[2].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, 0); CD3DX12_ROOT_PARAMETER rootParameters[3]; rootParameters[0].InitAsDescriptorTable(1, \u0026descRange[0], D3D12_SHADER_VISIBILITY_PIXEL); rootParameters[1].InitAsDescriptorTable(1, \u0026descRange[1], D3D12_SHADER_VISIBILITY_PIXEL); rootParameters[2].InitAsDescriptorTable(1, \u0026descRange[2], D3D12_SHADER_VISIBILITY_ALL); CD3DX12_ROOT_SIGNATURE_DESC descRootSignature; descRootSignature.Init(3, rootParameters, 0, nullptr,D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT); ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:7:1","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"静态采样器 事实证明，图形应用程序通常不会使用过多的采样器。为此，Direct3D 专门提供了一种特殊的方式来定义采样器数组，使用户可以在不创建采样器堆的情况下也能对它们进行配置。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:7:2","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"在着色器中对纹理进行采样 通过下列 HLSL 语法来定义纹理对象，并将其分配给特定的纹理寄存器： Texture2D gDiffuseMap : register(t0); 注意，纹理寄存器由 tn 来标定，其中，整数 n 表示的是纹理寄存器的槽号。此根签名的定义指出了由槽位参数到着色器寄存器的映射关系，这便是应用程序代码能将 SRV 绑定到着色器中特定 Texture2D 对象的原因。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:8:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["DirectX3D"],"content":"小结 纹理坐标用于定义将要映射到 3D 三角形上的纹理三角形 对于游戏而言，创建纹理的常用方法是，请贴图师在 Photoshop 或一些其他的图像编辑器中进行创作，并将结果存为某种图像文件，如 BMP、DDS、TGA 或 PNG。接着，游戏应用程序会在加载资源期间将图像数据载入 ID3D12Resource 对象。 对于实时图形应用程序来说，DDS （DirectDraw 图面格式）图像文件是极好的选择，因为它支持各种 GPU 本身即可处理的图像格 式，以及 GPU 可原生解压的压缩图像格式。 有两种将传统图像格式转换为 DDS 格式的常用方法：使用图像编辑器或借助一种微软公司提供的名为 texconv 的命令行工具导出 DDS 格式。 我们能够通过 CreateDDSTextureFromFile12 函数以存于磁盘中的图像文件来创建纹理 当放大物体表面并试图以少数纹素来覆盖大量屏幕像素时，便会涉及纹理放大的问题。而当缩小物体表面并尝试令大量纹素覆盖少数屏幕像素时，就会进行纹理缩小的相关操作。 mipmap 与纹理过滤器是处理纹理放大与缩小这两种操作的关键技术。GPU 原生支持 3 种纹理过滤器（根据质量由低到高、开销由廉至贵的顺序来排列），即点过滤器、线性过滤器以及各向异性过滤器。 纹理的寻址模式定义了 Direct3D 将如何处理超出范围[0, 1]外的纹理坐标。例如，对于那些超出范围的纹理，究竟是应当采取平铺、镜像，还是钳位或其他处理方式呢？ 我们可以像变换普通点那样，利用纹理坐标对纹理进行缩放、旋转以及平移。通过在每一帧中小幅度渐进地变换纹理坐标，便可以实现纹理的动画效果。 ","date":"2025-06-10","objectID":"/direct3d-%E7%BA%B9%E7%90%86/:9:0","tags":["Unreal","DirectX3D"],"title":"纹理","uri":"/direct3d-%E7%BA%B9%E7%90%86/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 GAS 流程","date":"2025-06-09","objectID":"/lyra-gas/","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"GAS 与 Input 调用 经过游戏体验DataAsset和一系列的组件初始化加载后，在 LyraHeroComponent 绑定按键 /* 此函数是技能函数，比如鼠标左键枪开火 在 ULyraInputConfig 里配置 AbilityInputActions */ LyraIC-\u003eBindAbilityActions(InputConfig, this, \u0026ThisClass::Input_AbilityInputTagPressed, \u0026ThisClass::Input_AbilityInputTagReleased, /*out*/ BindHandles); 在绑定了按键后，会在ASC的 void ULyraAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag\u0026 InputTag) 留下记录 void ULyraAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag\u0026 InputTag) { if (InputTag.IsValid()) { for (const FGameplayAbilitySpec\u0026 AbilitySpec : ActivatableAbilities.Items) { if (AbilitySpec.Ability \u0026\u0026 (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))) { InputPressedSpecHandles.AddUnique(AbilitySpec.Handle); InputHeldSpecHandles.AddUnique(AbilitySpec.Handle); } } } } 自然松开的时候，会调用ASC的void ULyraAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag\u0026 InputTag) 并留下相对应的记录 void ULyraAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag\u0026 InputTag) { if (InputTag.IsValid()) { for (const FGameplayAbilitySpec\u0026 AbilitySpec : ActivatableAbilities.Items) { if (AbilitySpec.Ability \u0026\u0026 (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))) { InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle); InputHeldSpecHandles.Remove(AbilitySpec.Handle); } } } } 在然后，ALyraPlayerController中会Tick调用void ALyraPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused) 随后检索一些TArray记录下来的东西，通过 TryActivateAbility(AbilitySpecHandle); 调用到实际技能 ","date":"2025-06-09","objectID":"/lyra-gas/:1:0","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"从武器到技能 举个例子， 比如是捡到枪，或者默认装备枪，随后鼠标左键开火，这其实就是一个开枪技能 ","date":"2025-06-09","objectID":"/lyra-gas/:2:0","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"装备技能 捡到枪并且装备是通过 Lyra 的 Equipment系统和Inventory系统来实现的，在这里不详细讲，但是此时有一个ULyraEquipmentDefinition 中会记录一个 ULyraAbilitySet，里面有见到这个枪就会装备什么GameAbility技能，以及GameEffect效果，还有AttributeSet属性数值，这时候就会将GameAbility技能给GiveAbility装备上去 ","date":"2025-06-09","objectID":"/lyra-gas/:2:1","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"技能的实现 创建一个GA类，不管是蓝图还是c++，GameplayAbility有以下比较重要的接口 virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const override; 判断是否可以激活此技能，在 TryActivateAbility 后，其实会进行一系列的检查，此接口就在其中 virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override; 在经过一系列技能检查后就会触发，也就是此技能的核心逻辑，比如播放蒙太奇，然后蒙太奇播放完调用 EndAbility virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override; 技能结束的核心逻辑写在这个函数，但是记住这个函数不代表跟技能相关的实例就会销毁 virtual void InputPressed(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) override;* 此函数的作用就在于，如果是通过按键去触发技能，那么在按下键的时候就会触发 virtual void InputReleased(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) override; 抬起键的时候触发 随后不管c++还是蓝图，将其 InstancingPolicy 修改为：InstancedPerActor，此参数有以下几种： NonInstanced：此能力从未实例化。任何执行此能力的操作都是在 CDO 上进行的。 InstancedPerActor：当这个 Ability 被授予给一个 Actor 时，系统会为这个 Actor 创建一个全新的 UGameplayAbility 对象实例。如果 10 个不同的 Actor 都被授予了这个 Ability，内存中就会有 10 个独立的 Ability 对象。 InstancedPerExecution：当这个 Ability 被授予时，系统不会立即创建实例。只有在每次这个 Ability 被激活 (ActivateAbility) 时，系统才会临时创建一个新的 Ability 对象实例。当这个 Ability 执行完毕并结束 (EndAbility) 时，这个临时的实例会被立即销毁（垃圾回收）。 随后还得将一个变量Ability Triggers修改，将你的按键绑定的Tag输入进去，这样就可以将按键跟技能上面关联上啦 ","date":"2025-06-09","objectID":"/lyra-gas/:2:2","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"检测到伤害目标 这里不详细讲如何检测到伤害目标（可能后续会更新？），比如枪发射子弹，就发出射线，进行扫描。如果是近战武器，则利用动画通知去生成碰撞盒子，来进行伤害目标 如果要在这拿到GA实例，只要能拿到ASC，则可以利用 ASC-\u003eGetActivatableAbilities()，拿到所有激活的技能Spec，在通过 AbilitySpec.GetPrimaryInstance() Cast 成你的GA实例就好了 ","date":"2025-06-09","objectID":"/lyra-gas/:2:3","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"应用GE 这时候我们就会有目标Actor了，我们获取到自己的ASC和Target的ASC，可以利用如下代码，创建GameplayEffectSpecHandle，并且应用 FGameplayEffectSpecHandle DamageSpecHandle = MakeOutgoingGameplayEffectSpec(DamageEffect, GetAbilityLevel()); if (DamageSpecHandle.IsValid()) { SourceASC-\u003eApplyGameplayEffectSpecToTarget(*DamageSpecHandle.Data.Get(), TargetASC); } 好，这时候注意力来到 我们创建的GE，GE也有着很多的属性，我们关注点先放在Gameplay Effect Modifiers：这个可以应用比较简单的Attributes。比如直接将Health -\u003e Add -\u003e -10，这样每次攻击，都会对Target扣10点血。但是这样缺点就是不灵活，因为这个伤害值计算确实很复杂，比如lyra的枪，他有距离衰减，物理散射，包括打头伤害更高之类的，所以就需要 Executions Executions：我们可以创建一个 UGameplayEffectExecutionCalculation 的子类，这个类就可以帮助我们去算伤害的具体值，这个类的执行就是在应用AttricuteSet之前，所以我们可以直接操作他的伤害值 ","date":"2025-06-09","objectID":"/lyra-gas/:2:4","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"GameplayEffectContext 再聊到具体的 Executions 之前还得聊一聊这个，这个其实就是 GameplayEffect 的上下文，也就是储存着 GE 通知 AttricuteSet的各种信息，我们继承于这个Struct FGameplayEffectContext，这样就可以塞我们自己自定义的任何信息，比如伤害接口的伤害倍数，在这个struct有如下接口需要注意下，有可能用到： // ~Begin FGameplayEffectContext Interface virtual FGameplayEffectContext* Duplicate() const override; // 进行拷贝结构体的 virtual UScriptStruct* GetScriptStruct() const override; // 获取当前 GameplayEffectContext 实例的实际 UStruct 类型。 virtual bool NetSerialize(FArchive\u0026 Ar, class UPackageMap* Map, bool\u0026 bOutSuccess) override; // 进行网络复制 // ~End FGameplayEffectContext Interface 我们如果想要我们自定义的生效，必须重写AbilitySystemGlobals方法，并且在Project Setting里 设置我们默认的 AbilitySystemGlobals 类 并且要在 我们的GA中 重写 virtual FGameplayEffectContextHandle MakeEffectContext(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo) const override; 在这个函数里面去初始化我们的GEContext哦 ","date":"2025-06-09","objectID":"/lyra-gas/:2:5","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"AbilitySystemGlobals virtual FGameplayEffectContext* AllocGameplayEffectContext() const override; FGameplayEffectContext* USAbilitySystemGlobals::AllocGameplayEffectContext() const { return new FSGameplayEffectContext(); } ","date":"2025-06-09","objectID":"/lyra-gas/:2:6","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"Executions 好了，终于回到了我们的Executions，我们重写 virtual void Execute_Implementation(const FGameplayEffectCustomExecutionParameters\u0026 ExecutionParams, FGameplayEffectCustomExecutionOutput\u0026 OutExecutionOutput) const override;方法 ExecutionParams：这个参数就是带有各种数据，比如SourceASC，TargetASC OutExecutionOutput：这个参数就是我们要给AttricuteSets的数据，所以我们弄好了伤害具体数值后就可以通过这个直接扔过去 我们要注意 比如我们拿一个 BaseDamage，这个基础伤害，我们要通过FGameplayEffectAttributeCaptureDefinition 这个结构体去拿 struct FDamageStatics { FGameplayEffectAttributeCaptureDefinition BaseDamageDef; FDamageStatics() { BaseDamageDef = FGameplayEffectAttributeCaptureDefinition(USCombatSet::GetBaseDamageAttribute(), EGameplayEffectAttributeCaptureSource::Source, true); } }; static FDamageStatics DamageStatics() { static FDamageStatics Statics; return Statics; } USDamageExecution::USDamageExecution() { RelevantAttributesToCapture.Add(DamageStatics().BaseDamageDef); } 如上方代码所示，我们初始化的三个参数的意思分别为： USCombatSet::GetBaseDamageAttribute()：到我们的这个AttricuteSet去拿一个 Attricute EGameplayEffectAttributeCaptureSource::Source：是从Source拿 不是从Target拿 True: 是否拍快照，这个基本都是true，要不然你的数据可能会被污染 然后我们放在RelevantAttributesToCapture里，通过一下方式去拿： FAggregatorEvaluateParameters EvaluateParameters; EvaluateParameters.SourceTags = SourceTags; EvaluateParameters.TargetTags = TargetTags; float BaseDamage = 0.0f; ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(DamageStatics().BaseDamageDef, EvaluateParameters, BaseDamage); 我们最后通过拿到准确数据后就塞到数据里 返回回去： OutExecutionOutput.AddOutputModifier(FGameplayModifierEvaluatedData(USHealthSet::GetDamageAttribute(), EGameplayModOp::Additive, DamageDone)); Lyra是通过WeaponInstance计算好具体的倍数，然后继承了一个接口，送到这里来的 最后别忘记要在GE把这个Executions设置进去哦 ","date":"2025-06-09","objectID":"/lyra-gas/:2:7","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"应用AttributeSet 好了 这下数据都来AttributeSet了，我们就要修改角色身上的Attribute了，这Set也有几个很关键的接口 virtual bool PreGameplayEffectExecute(FGameplayEffectModCallbackData\u0026 Data) override; virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData\u0026 Data) override; virtual void PreAttributeBaseChange(const FGameplayAttribute\u0026 Attribute, float\u0026 NewValue) const override; virtual void PreAttributeChange(const FGameplayAttribute\u0026 Attribute, float\u0026 NewValue) override; virtual void PostAttributeChange(const FGameplayAttribute\u0026 Attribute, float OldValue, float NewValue) override; ","date":"2025-06-09","objectID":"/lyra-gas/:2:8","tags":["Unreal","GAS","Lyra"],"title":"Lyra-GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 Input","date":"2025-06-09","objectID":"/lyra-input/","tags":["Unreal","Lyra"],"title":"深入Lyra输入系统：从按键到能力的完整旅程","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"前言 需要你先了解： Lyra 架构解析：Experience DataAsset 的动态加载机制 ","date":"2025-06-09","objectID":"/lyra-input/:1:0","tags":["Unreal","Lyra"],"title":"深入Lyra输入系统：从按键到能力的完整旅程","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"Lyra 基础 Input 流程 void ULyraHeroComponent::HandleChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) 经历过加载游戏体验的DataAsset后，就来到了这个函数 void ULyraHeroComponent::InitializePlayerInput(UInputComponent* PlayerInputComponent) 这边就是初始化Input的一个重要函数，他会去拿到你的游戏体验中配置的InputConfig的信息，从而拿到 FInputMappingContextAndPriority 具体的信息 要注意，你需要建立一个 GameFeature 然后利用LyraDataAsset 将InputMappingContext 提前加载进内存，否则判断不会进去 你还要注意将项目设置里面的 UEnhancedInputComponent 给替换成自己实现的类，随后就是绑定输入了 蓝图中创建 InputAction 和 InputMappingContext 自己配置好其对应的游戏体验DataAsset 即可 LyraIC-\u003eBindAbilityActions(InputConfig, this, \u0026ThisClass::Input_AbilityInputTagPressed, \u0026ThisClass::Input_AbilityInputTagReleased, /*out*/ BindHandles); /* 此函数是技能函数，比如鼠标左键枪开火 在 ULyraInputConfig 里配置 AbilityInputActions */ /* 此函数则是配置一些角色基本移动输入 在 ULyraInputConfig 里配置 NativeInputActions */ LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_Move, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_Move, /*bLogIfNotFound=*/ false); LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_Look_Mouse, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_LookMouse, /*bLogIfNotFound=*/ false); LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_Look_Stick, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_LookStick, /*bLogIfNotFound=*/ false); LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_Crouch, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_Crouch, /*bLogIfNotFound=*/ false); LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_AutoRun, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_AutoRun, /*bLogIfNotFound=*/ false); ","date":"2025-06-09","objectID":"/lyra-input/:2:0","tags":["Unreal","Lyra"],"title":"深入Lyra输入系统：从按键到能力的完整旅程","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"要记住的点 需要在项目设置手动指定增强输入的setting类 Mouse上下移动的方向 [/Script/LyraGame.LyraPlayerController] InputYawScale=1.0 InputPitchScale=1.0 InputRollScale=1.0 ForceFeedbackScale=1.0 Lyra 是靠这个 来使得我们鼠标向上滑就是人往天看，InputPitchScale默认值是-2.5，如果是默认值，效果则反之 ","date":"2025-06-09","objectID":"/lyra-input/:3:0","tags":["Unreal","Lyra"],"title":"深入Lyra输入系统：从按键到能力的完整旅程","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"相关类与结构体 ","date":"2025-06-09","objectID":"/lyra-input/:4:0","tags":["Unreal","Lyra"],"title":"深入Lyra输入系统：从按键到能力的完整旅程","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"ULyraInputConfig 作用 如何定义 GameplayTag 与 InputAction 的映射 接口与方法 FLyraInputAction 该结构体用于将输入操作映射到游戏玩法的输入标签上。 FindNativeInputActionForTag 根据 GameplayTag来搜索 NativeInputAction FindAbilityInputActionForTag 根据 GameplayTag来搜索 AbilityInputAction 成员变量说明 NativeInputActions：就是WASD这些有关基本操作的 AbilityInputActions: 跟技能相关的，只要跟GAS有关联，都可放这里 ","date":"2025-06-09","objectID":"/lyra-input/:4:1","tags":["Unreal","Lyra"],"title":"深入Lyra输入系统：从按键到能力的完整旅程","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"ULyraInputComponent 作用 用于通过输入配置数据资产来管理输入映射和绑定的组件。说白了就是处理ULyraInputConfig数据CURD的 接口与方法 不多说，基本每个方法直接看就能看出来 都是CURD ","date":"2025-06-09","objectID":"/lyra-input/:4:2","tags":["Unreal","Lyra"],"title":"深入Lyra输入系统：从按键到能力的完整旅程","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"UGameFeatureAction_AddInputContextMapping 作用 给本地玩家添加输入映射: 自动添加 InputMappingContext 到 EnhancedInputSubsystem 中 和 GameInstance / LocalPlayer 生命周期关联：玩家加入时会自动添加；玩家离开时自动移除 支持优先级和是否注册到 Settings 的配置：每个 IMC 可以设置优先级、是否保存到设置中 核心结构体：FInputMappingContextAndPriority InputMapping: 要添加的输入映射资源（IMC） Priority: 优先级（高的优先） bRegisterWithSettings: 是否写入用户设置中（用户可以修改的那种） 生命周期函数 virtual void OnGameFeatureRegistering() override; virtual void OnGameFeatureActivating(FGameFeatureActivatingContext\u0026 Context) override; virtual void OnGameFeatureDeactivating(FGameFeatureDeactivatingContext\u0026 Context) override; virtual void OnGameFeatureUnregistering() override; GameFeature GameFeature 是 UE5 引入的一个 模块化插件系统，主要目标是： Feature 插件 功能 InputMapping 添加新的输入操作映射 Weapon_AR 加入一个步枪的逻辑、资源、蓝图 UI_HUD 添加一个特定的 HUD 或菜单界面 Ability_Fireball 加入一个技能火球术 每个 GameFeature 插件都能控制： 加载哪些资源（IMC、AbilitySet、蓝图、DataAsset…） 在哪个状态执行（只在服务器？只在客户端？） 在哪张地图中生效 ","date":"2025-06-09","objectID":"/lyra-input/:4:3","tags":["Unreal","Lyra"],"title":"深入Lyra输入系统：从按键到能力的完整旅程","uri":"/lyra-input/"},{"categories":["DirectX3D"],"content":"DirectX3D 光照","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"光照与材质的交互 在开启光照的同时，我们不再直接指出顶点的颜色，而是指定材质与光照，再运用光照方程（lighting equation）基于两者的交互来计算顶点颜色。这样做会使物体的颜色更趋于真实 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:1:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"局部光照模型 若使用这种局部模型，则每个物体的光照皆独立于其他物体，我们也就可以在处理光照的过 程中仅考虑光源直接发出的光线（即在处理当前的 物体光照时，忽略来自场景中其他物体所反弹来的 说通俗点也就是即使物体被遮挡，但是也会受到光照，每个物体的光照皆独立于其他物体 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:1:1","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"全局光照模型 谈及全局光照模型， 除了要考虑由光源直接发出的光，还要顾及场景中其他物体所反弹来的间接光照。 之所以称为全局光 照模型，是因为在对一个物体进行照明时，还要考虑全局场景中的所有事物。 全局光照模型的开销通常是实时游戏所负担不起的（但是这种模型会生成十分接近于照片级真实感的场景）。 接近于全局光照的实时方 法尚处于研究阶段。例如，立体像素全局光照技术。 另一种流行的方法是预计算静态物体（如墙壁、塑像）的间接光照，再用得到的结果来近似地模拟动态 物体（如可运动游戏角色）的间接光照。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:1:2","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"法向量 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:2:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"平面法线 平面法线是一种描述多边形朝向（即正交于多边形上所有点）的单位向量 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:2:1","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"曲面法线 曲面法线（surface normal）是 一种垂直于曲面上一点处切平面（有文献强调还要满足曲面法线经过该点这一条件）的单位向量 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:2:2","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"顶点法线 为了求出曲面法线，我们仅先指定位于网格顶点处的曲面法线（所以也将之称作顶点法线） ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:2:3","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"计算法向量 为了找到三角形 $p_0,p_1,p_2$ 的平面法线，我们首先计算位于三角形边上的两个向量： $$ \\vec{u} = p_1 - p_0 \\vec{v} = p_2 - p_0 $$ 那么，此三角形的平面法线即为： $$ \\vec{n} = \\frac{\\vec{u} \\times \\vec{v}}{|| \\vec{u} \\times \\vec{v} ||} $$ 下列函数将根据三角形的 3 个顶点来计算该三角形正面的平面法线： MVECTOR ComputeNormal(FXMVECTOR p0, FXMVECTOR p1, FXMVECTOR p2) { XMVECTOR u = p1 - p0; XMVECTOR v = p2 - p0; return XMVector3Normalize(XMVector3Cross(u,v)); } ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:3:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"求顶点法线平均值 对于可微的光滑曲面而言，我们可以利用微积分方面的知识来求出曲面点处的法线。但问题在于，三角形网格运用一种被称为求顶点法线平均值（vertex normal averaging）的计算方法。 此方法通过对网格中共享顶点 v 的多边形的平面法线求取平均值，从而获得网格中任意顶点 v 处的顶点法线 n。 例如网格中的四个多边形共用顶点 v，因此，v 处的顶点法线求法如下： $$ \\vec{n}_{avg} = \\frac{\\vec{n}_0 + \\vec{n}_1 + \\vec{n}_2 + \\vec{n}_3}{|| \\vec{n}_0 + \\vec{n}_1 + \\vec{n}_2 + \\vec{n}_3 ||} $$ 在上面这个例子中，由于我们对求和的结果已进行了规范化处 理，因此便无需像往常求算术平均值那样再除以 4。 注意，为了得到更为精准的结果，我们还可以采用更加复杂的求平均值方法，比如说，根据多边形的面积来确定权重（如面积大的多边形的权重要大于面积小的多边形），以求取加权平均值。 下列伪代码展示了若给定三角形网格的顶点列表和索引列表，该如何来求取相应的法线平均值。 // 输入 // 1. 一个顶点数组（mVertices）。每个顶点都有一个位置分量（pos）和一个法线分量（normal） // 2. 一个索引数组（mIndices） // 对于网格中的每个三角形来说 for(UINT i = 0; i \u003c mNumTriangles; ++i) { // 第 i 个三角形的索引 UINT i0 = mIndices[i*3+0]; UINT i1 = mIndices[i*3+1]; UINT i2 = mIndices[i*3+2]; // 第 i 个三角形的顶点 Vertex v0 = mVertices[i0]; Vertex v1 = mVertices[i1]; Vertex v2 = mVertices[i2]; // 计算平面法线 Vector3 e0 = v1.pos - v0.pos; Vector3 e1 = v2.pos - v0.pos; Vector3 faceNormal = Cross(e0, e1); // 该三角形共享了下面 3 个顶点，所以将此平面法线与这些顶点法线相加以求平均值 mVertices[i0].normal += faceNormal; mVertices[i1].normal += faceNormal; mVertices[i2].normal += faceNormal; } // 对于每个顶点 v 来说，由于我们已经对所有共享顶点 v 的三角形的平面法线进行求和，所以现在仅需进行规范化处理即可 for (UINT i = 0; i \u003c mNumVertices; ++i) { mVertices[i].normal = Normalize(\u0026mVertices[i].normal)); } ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:3:1","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"变换法向量 思考图 8.7a。图中，切向量 u = v1 – v0 正交于法向量 n。如果对此应用一个非等比缩放变换 A，则可从图 8.7b 看到，变换后的切向量 uA = v1A – v0A 没能与变换后的法向量 nA 继续保持正交性。 若给定一个用于变换点与向量（非法线）的变换矩阵 A，如何能够求出这样一个变换矩阵 B：通过它来变换法向量，使经矩阵 A 变换后的切向量与法向量重归正交的关 系（即 uA ⋅ nB = 0 ）。 我们首先从已知的信息着手，如果法向量 n 正交于切向量 u，则有： 切向量正交于法向量 $$ \\vec{u} \\cdot \\vec{n} = 0 $$ 点积改写为矩阵乘法 $$ \\vec{u}\\vec{n}^T = 0 $$ 插入单位矩阵 $ I = AA^{−1} $ $$ \\vec{u}(AA^{-1})\\vec{n}^T $$ 根据矩阵乘法运算的结合律 $$ (\\vec{u}A)(A^{-1}\\vec{n}^T) = 0 $$ 根据转置矩阵的性质 $ (A^T)^T = A $ $$ (\\vec{u}A)((A^{-1}\\vec{n}^T)^T)^T = 0 $$ 根据转置矩阵的性质 $ (AB)^T = B^T A^T $ $$ (\\vec{u}A)(\\vec{n}(A^{-1})^T)^T = 0 $$ 将矩阵乘法改写为点积的形式 $$ \\vec{u}A \\cdot \\vec{n}(A^{-1})^T = 0 $$ 变换后的切向量正交于变换后的法向量 $$ \\vec{u}A \\cdot \\vec{n}B = 0 $$ 因此，通过 $ B = (A^{−1})^T $（矩阵 A 的逆转置矩阵）对法向量进行变换后，即可使它垂直于经矩阵 A 变换后的切向量 uA。 我们可以为计算逆转置矩阵实现一个辅助函数 static XMMATRIX InverseTranspose(CXMMATRIX M) { XMMATRIX A = M; A.r[3] = XMVectorSet(0.0f, 0.0f, 0.0f, 1.0f); XMVECTOR det = XMMatrixDeterminant(A); return XMMatrixTranspose(XMMatrixInverse(\u0026det, A)); } ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:4:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"参与光照计算的一些关键向量 图8.8 E 是观察者的观察位置 这是在观察点 p 处沿着单位向量 v 所定义的视线来进行观察的过程 位于表面的点 p 处有法线 n，光线由入射方向 I 照射到点 p。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:5:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"光向量 光向量（light vector）L 为单位向量，其所指方向与照射到表面 上点 p 处入射光线 I 的方向刚好相反。尽管在工作中使用光的入射方向 I 可能更为直观，但是为了进行光照计算，我们还是采用光向量 L 向量L 用于计算 $ \\vec{L} \\cdot \\vec{n} = \\cos\\theta_i $. 其中的 $\\cos\\theta_i$ 是光向量L与法向量n之间的夹角 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:5:1","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"反射向量 反射向量 r 是入射光向量 L 关于表面法线 n 的镜像。 反射向量的定义为 $ \\vec{r} = \\vec{I} - 2(\\vec{n} \\cdot \\vec{i} ) \\vec{n} $ ，如图 8.9 所示（这里假设 n 为单位向量）。然而，我们在着色器中实际上是利用内置函数 reflect 来计算 r 的。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:5:2","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"观察向量 观察向量 $\\vec{v} = normalize(E − p) $ 是从表面上的点 p 到观察点 E 方向上的 单位向量，它定义了由观察点向表面点观察的视线。我们有时还要用到向量−v，它是我们所要计算的由观察点到表面点这条光线路径上的单位向量。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:5:3","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"朗伯余弦定律 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:6:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"辐射通量与辐(射)照度 我们可以将光看作是光子的集合，在空间中按特定的方向传播。每个光子都载有（光）能量。光源每秒发出的（光）能量称为辐射通量（radiant flux）。而单位面积上的辐射通量密度（irradiance，称为辐（射） 照度）是一种很重要的概念，因为我们将用它来确定表面某8区域所接收到的光量（即眼睛感受到的明亮度）。 一般来讲，我们可以认为辐照度是照射到表面某区域的光量，或者是通过空间中某假想区域的光量。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:6:1","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"公式推导 如图 8.10a，光线垂直照射到表面（即光向量 L 与法向量 n 相等时）的强度要大于以某个角度照射到表面的强度。 如图 8.10a，一小束辐射通量为 P 且横截面面积为 A1的光束，将此光束垂直打向表面，则光束照射到表面上的面积为 $ A_1 $，而 $ A_1 $内的辐照度为 $ E_1 = P/A_1 $ 现假设转动光源，使光束以某个入射角度照射到表面上（如图 8.10b），则光束将覆于表面上的更大面积 $ A_2 $。此时，该面积的辐照度为 $ E_2 = P/A_2 $。 根据三角学可知，$A_1,A_2$ 关系为: $$ \\begin{align} \\cos\\theta = \\frac{A_1}{A_2} \\Rightarrow A_2 \\cos\\theta = A_1 \\Rightarrow \\frac{\\cos\\theta}{A_1} = \\frac{1}{A_2} \\Rightarrow \\frac{1}{A_2} = \\frac{\\cos\\theta}{A_1} \\end{align} $$ 所以: $$ E_2 = \\frac{p}{A_2} = \\frac{p}{A_1}\\cos\\theta = E_1 \\cos\\theta = E_1(\\vec{n} \\cdot \\vec{L}) $$ 换句话说，面积A2内的辐照度就相当于将受垂直方向光照的面积A1内的辐照度按比例 $ \\vec{n} \\cdot \\vec{L} = \\cos\\theta $ 进行缩放，这就是朗伯余弦定律 考虑到光线照射到表面另一侧的情况（此时。点积结果为负值），我们用 max 函数来钳制“缩放因子”的取值范围： $$ f(\\theta) = \\max(\\cos\\theta, 0) = \\max(\\vec{L} \\cdot \\vec{n}, 0) $$ 图 8.11 所示的是函数 f(θ) 的图像。观察可知，随着变量θ 的变化，函数的值域范围为 0.0～1.0（即光照强度的变化范围为 0%～100%）。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:6:2","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"漫反射光照 当光线照射到表面上的某一点时，一部分光会进入物体的内部，并与表面附近的物质相互作用。这些光会在物体内部四处反弹，其中一部分会被吸收，而余下部分则会向各个方向散射并返回表面，这即是所谓的漫反射（diffuse reflection）。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:7:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"漫反射光照的计算 我们将漫反射光照的计算分为两个部分。在第一部分中，我们要指定光照颜色以及漫反射反照率（diffuse albedo）颜色。漫反射反照率表示的是根据表面的漫反射率（diffuse reflectance，也译作漫反射比）而被反射的入射光量（根据能量守恒定律，入射光不是被反射回表面就是被材 质吸收了）。 要对它们进行处理就需用分量式颜色乘法（因为光是具有颜色的）。例如，假设表面上一点会 反射 50%的入射红光、100%的绿光以及 75%的蓝光，如果这时有一束强度为 80%的白光袭来，那么此入射光的量值就可以表示为 $ B_L = (0.8, 0.8, 0.8) $，又因为漫反射反照率为 $ m_d = (0,5, 1.0, 0.75) $，所以此点的反射光量为： $$ c_d = B_L \\otimes m_d = (0.8, 0.8, 0.8) \\otimes (0.5,1.0, 0.75) = (0.4, 0.8, 0.6) $$ 可以发现，漫反射反照率分量的取值范围必定在 0.0～1.0 之间，因此我们用小数来表示反射光。 然而，上述公式并非十分准确，我们还需将朗伯余弦定律（根据表面法线与光向量之间的夹角来控 制表面接收原始光照的量）考虑在内。 设 $ B_L $表示入射光量，$ m_d $为漫反射反照率，L 为光向量，而 n 为表面法线，则位于表面上某点处的漫反射光量为： $$ c_d = \\max(\\vec{L} \\cdot \\vec{n}, 0) \\cdot B_L \\otimes m_d $$ ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:7:1","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"环境光照 假设我们正坐在一间设有一个光源的屋子里，房内的桌上还放有一个茶壶。虽然茶壶只有一侧被光源直接照射，但它的另一侧却不可能完全被笼罩在漆黑的阴影当中。这是因为一部分光经墙壁或室内的其他物体反射，而最终照射到茶壶的背面。 为了处理这种间接光照，我们给光照方程引进了一个环境光（ambient light）项： $$ c_a = A_L \\otimes m_d $$ 颜色 $ A_L $ 指定了表面收到的间接（环境）光量，它可能与光源发出的光量不同，因为光源发射的光在其他表面反射的时候会被吸收一部分。 漫反射反照率 $ m_d $ 指示了根据表面漫反射率而被表面反射的入射光量。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:8:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"镜面光照 我们此前用漫反射光照来模拟漫反射的过程：光进入介质，发生反射，部分光被吸收，而剩下的光 则向介质外的各个方向散射。 第二种反射的发生是根据一种名为菲涅耳效应（也译作菲涅尔效应）的物理现象。 当光线到达两种不同折射率介质之间的界面时，一部分光将被反射，而剩下的光则发生折射。 折射率是一种介质的物理性质，即光在真空中传播的速度与光在给定介质内的传播速度之比。我们将第二种光的反射过程称为镜面反射，把被反射的光称为镜面（反射）光 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:9:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"菲尼尔效应 我们来考虑一个具有法线 n 的平滑界面，它将两种不同折射率的介质分隔开来。由于在界面处具有折射率不连续性（因不同介质的折射率差异所导致），当光线照射到界面时，一部分会被界面反射，另一部分则折射进界面。 菲涅耳方程（Fresnel equations）以数学方法描述了入射光线被反射的百分比， 即 $ 0 ≤ R_F ≤ 1 $。根据能量守恒定律，如果 $ R_F $是反射光量，则 $ (1 − R_F) $为折射光量。$ R_F $的值是一个 RGB 向量， 因为光的颜色反映了反射光量。 反射的光量既依赖于介质（某些材质的反射率相对更大），也与法向量 n 与光向量 L 之间的夹角 $ θi $ 有 关。由于光照过程的复杂性，我们一般不会将完整的菲涅耳方程用于实时渲染，而是采用石里克近似法来加以代替： $$ R_F(\\theta_i) = R_F(0\\textdegree) + (1 - R_F(0^\\textdegree))(1-\\cos\\theta_i)^5 $$ $ R_F(0\\textdegree) $ 是介质的一种属性，下面所列的即是一些常见材质的对应属性数值 我们来看一个现实世界中的例子，现假设我们正置身 于一个水质相对清澈、深达数英尺的小池塘里。若向下俯视，我们基本可以清楚地看到其底部沉积的沙 。这是由于有从周围环境中照射到池水的光以接近于 0.0° 的小角度 $ θ_i $ 反射进我们的眼睛而造成的；如此一来，反射到我们眼中的光量相对较低，又根据能量守恒定律可知，此时的折射光量却很高。现在来换个观察角度，如果我们向稍远处望去，将会看到池水极强的反射光。这是因为有从周围环境中射向水的光以接近 90.0° 的角度 $ θ_i $反射进我们的眼中，从而增加了反射光量。这种现象通常称为菲涅耳效应 。 可以将菲涅耳效应简洁地概括为：反射光量取决于材质 $ (R_F(0^\\textgress)) $ 以及法线与光向量之间的夹角。 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:9:1","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"表面粗糙度 粗糙度 真实世界中的反射物体往往不是理想镜面（perfect mirror）。尽管一个物体的表面看起来似乎十分平滑，但从微观水平上看，它还是具有一定的粗糙度。 镜面瓣 随着粗糙度的增加，微观表面法线的方向开始纷纷偏离宏观表面法线， 由此反射光逐渐扩展为一个镜面瓣 微平面模型 为了用数学方法对粗糙度进行建模，我们采用了微平面（microfacet，也作微表面）模型。在此模型中，我们将微观表面模拟为由多个既微小又平滑的微平面所构成的集合；而微观表面法线正是这些微平面上的法线 算上菲尼尔效应和表面粗糙度，获得公式: $$ c_s = \\max(\\vec{L} \\cdot \\vec{n}, 0) \\cdot \\vec{B}_L \\otimes \\vec{R}_F(\\alpha_h)\\frac{m + 8}{8}(\\vec{n} \\cdot \\vec{h})^m $$ 可以发现，如果 $ \\vec{L} \\cdot \\vec{n} \\leq 0 $ ，那么所计算的结果是射向表面另一侧的光，因而此时的正表面并不会接收到任何光照 ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:9:2","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"光照模型的概述 现在将之前所述的所有光照内容都结合起来，即表面反射的光量相当于环境反射光、漫反射光以及镜面反射光的光量总和。 环境光 $ c_a $：模拟经表面反射的间接光量。 漫反射光 $ c_d $：对进入介质内部，又经过表面下吸收而最终散射出表面的光进行模拟。由于对表面下的散射光建模比较困难，我们便假设在表面下与介质相互作用后的光从进入表面处返回， 并向各个方向均匀散射。 镜面光 $ c_s $：模拟经菲涅耳效应与表面粗糙度共同作用的表面反射光。 所以，结合这三个的着色方程出来了: $$ \\begin{align} LitColor \u0026= c_a + c_d + c_s \\\\ \\ \u0026= A_L \\otimes m_d + \\max(\\vec{L} \\cdot \\vec{n}, 0) \\cdot B_L \\otimes \\end{align} $$ ","date":"2025-05-14","objectID":"/direct3d-%E5%85%89%E7%85%A7/:10:0","tags":["Unreal","DirectX3D"],"title":"光照","uri":"/direct3d-%E5%85%89%E7%85%A7/"},{"categories":["DirectX3D"],"content":"DirectX3D 绘制3D立方体（下）","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"帧资源 在上篇，我们的演示程序在绘制每一帧时 都会将 CPU 和 GPU 进行一次同步，这样做的原因当然是确保数据安全。这种解决方案虽然奏效却效率低下 解决此问题的一种方案是：以 CPU 每帧都需更新的资源作为基本元素，创建一个环形数组。我们称这些资源为帧资源，而这种循环数组通常是由 3 个帧资源元素所构成的。该方案的思路是：在处理第 n 帧的时候，CPU 将周而复始地从帧资源数组中获取下一个可用的（即没被 GPU 使用中的）帧资源。趁着 GPU 还在处理此前帧之时，CPU 将为第 n 帧更新 资源，并构建和提交对应的命令列表。随后，CPU 会继续针对第 n+1 帧执行同样的工作流程，并不断重复下去。如果帧资源数组共有 3 个元素，则令 CPU 比 GPU 提前处理两帧，以确保 GPU 可持续工作。 不难看出，这种解决方案还是无法完全避免等待情况的发生。但是如果CPU执行的比GPU快，那么就可以保证GPU不会浪费任何性能，并且CPU等GPU的时候可以去执行不依赖GPU，比如AI以及游戏业务逻辑一些的任务 ","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:1:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"渲染项 绘制一个物体需要设置多种参数，例如绑定顶点缓冲区和索引缓冲区、绑定与物体有关的常量数据、 设定图元类型以及指定 DrawIndexedInstanced 方法的参数。随着场景中所绘物体的逐渐增多，如果我们能创建一个轻量级结构来存储绘制物体所需的数据，那真是极好的；由于每个物体的特征不同，绘制过程中所需的数据也会有所变化，因此该结构中的数据也会因具体程序而异。我们把单次绘制调用过程中，需要向渲染流水线提交的数据集称为渲染项。 ","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:2:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"渲染过程中所用到的常量数据 随着演示代码复杂度的不断增加，该缓冲区中存储的数据内容（例如观察位置、观察矩阵与投影矩阵以 及与屏幕（渲染目标）分辨率等相关的信息）会根据特定的渲染过程（rendering pass）而确定下来。其中也包含了与游戏计时有关的信息，它们是着色器程序中要访问的极有用的数据。 就目前的情况而言，为了绘制物体，与之唯一相关的常量就是它的世界矩阵： 我们做出上述调整的思路为：基于资源的更新频率对常量数据进行分组。在每次渲染过程中，只需将本次所用的常量（cbPass）更新一次；而每当某个物体的世界矩阵发生改变时，只需更新该物体的相关常量（cbPerObject）即可。如果场景中有一个静态物体，比如一棵树，则只需对它的物体常量缓冲区设置一次（树的）世界矩阵，而后就再也不必对它进行更新了。 现在，着色器所期望的输入资源已发生了改变，因此我们需要相应地调整根签名来使之获取所需的 两个描述符表（此时，我们的着色器程序需要获取两个描述符表，因为这两个 CBV（常量缓冲区视图） 有着不同的更新频率——渲染过程 CBV 仅需在每个渲染过程中设置一次，而物体 CBV 则要针对每一个 渲染项进行配置） ","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:3:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"不同形状的几何体 我们将展示如何创建不同形状的几何体，如椭球体、球体、柱体（通过调整圆柱体的上下两底即可创建出圆台和圆锥体）。这些几何体对于绘制天空穹顶（sky dome，即描述游戏中玩家头顶的天空部分，也有译作天空穹、天穹等）、图形程序调试、碰撞检测的可视化以及延迟渲染（deferred rendering） 是有极大裨益的。比如说，我们可以先将正在制作中的游戏角色简化渲染成球体，以供调试检测。 ","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:4:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"生成柱形网格 在定义一个柱体时，需要指定其顶、底面半径，高度，切片数量（slice count，即将截面分割的块数）， 以及堆叠层数（stack count，即横向切割的层数） 程序中的柱体呈圆台形状，因而就此展开讨论。我们将圆台的构成分为侧面几何体，顶面几何体以及底面几何体 3 个部分。 柱体的侧面几何体 圆台的所有顶点都列于其各层侧面的“环”上，共有 stackCount + 1 环，而每个环上的顶点数 量都为 sliceCount。相邻环的半径差为 Δ =r (topRadius-bottomRadius)/stackCount 。 如果从底面上的环开始用索引来 0 表示，那么第 i 环的半径就是 $ r_i = + bottomRadius + iΔr $，且第 i 环的高度值为 $ h_i = -\\frac{h}{2} + iΔr $ 其中的 Δh 是每层的高度，h 为圆台的高度。 由此可知， 生成圆台的基本思路是遍历每个环，并生成列于环上的各个顶点 下面给出此算法的实现： GeometryGenerator::MeshData GeometryGenerator::CreateCylinder ( float bottomRadius, float topRadius, float height, uint32 sliceCount, uint32 stackCount ) { MeshData meshData; // 构建堆叠层 float stackHeight = height / stackCount; // 计算从下至上遍历每个相邻分层时所需的半径增量 float radiusStep = (topRadius - bottomRadius) / stackCount; uint32 ringCount = stackCount+1; // 从底面开始，由下至上计算每个堆叠层环上的顶点坐标 for(uint32 i = 0; i \u003c ringCount; ++i) { float y = -0.5f*height + i*stackHeight; float r = bottomRadius + i*radiusStep; // 环上的各个顶点 float dTheta = 2.0f*XM_PI/sliceCount; for(uint32 j = 0; j \u003c= sliceCount; ++j) { Vertex vertex; t c = cosf(j*dTheta); float s = sinf(j*dTheta); vertex.Position = XMFLOAT3(r*c, y, r*s); vertex.TexC.x = (float)j/sliceCount; vertex.TexC.y = 1.0f - (float)i/stackCount; /* 可以像下面那样以参数化（parameterized）的方式来计算圆台顶点， 我们引入与纹理坐标 v 方向相同的参数 v，从而使副切线与纹理坐标 v 的方向相同 设 r0 为底面半径，r1 为顶面半径 y(v) = h - hv 其中 v 位于区间[0,1] r(v) = r1 + (r0-r1)v x(t, v) = r(v)*cos(t) y(t, v) = h - hv z(t, v) = r(v)*sin(t) dx/dt = -r(v)*sin(t) dy/dt = 0 dz/dt = +r(v)*cos(t) dx/dv = (r0-r1)*cos(t) dy/dv = -h dz/dv = (r0-r1)*sin(t) */ // 此为单位长度 vertex.TangentU = XMFLOAT3(-s, 0.0f, c); float dr = bottomRadius-topRadius; XMFLOAT3 bitangent(dr*c, -height, dr*s); XMVECTOR T = XMLoadFloat3(\u0026vertex.TangentU); XMVECTOR B = XMLoadFloat3(\u0026bitangent); XMVECTOR N = XMVector3Normalize(XMVector3Cross(T, B)); XMStoreFloat3(\u0026vertex.Normal, N); meshData.Vertices.push_back(vertex); } } } 观察图 7.2 可知，由每个分层以及切片分割出的侧面块都是一个四边形（由两个三角形构成）。而以第 i 层与第 j 块切片所确定下来的侧面块中的两个三角形的索引分别为： ΔABC = (i · n + j, (i + 1) · n + j, (i + 1) · n + j + 1) ΔABC = (i · n + j, (i + 1) · n + j + 1, i · n + j + 1) 其中，n 是每个环上的顶点数量。因此，求取圆台侧面块上所有三角形索引的主要思路是：遍历每个堆叠层和每个切片，并运用上述公式进行计算。 GeometryGenerator::MeshData GeometryGenerator::CreateCylinder ( float bottomRadius, float topRadius, float height, uint32 sliceCount, uint32 stackCount ) { MeshData meshData; // 构建堆叠层 float stackHeight = height / stackCount; // 计算从下至上遍历每个相邻分层时所需的半径增量 float radiusStep = (topRadius - bottomRadius) / stackCount; uint32 ringCount = stackCount+1; // 从底面开始，由下至上计算每个堆叠层环上的顶点坐标 for(uint32 i = 0; i \u003c ringCount; ++i) { float y = -0.5f*height + i*stackHeight; float r = bottomRadius + i*radiusStep; // 环上的各个顶点 float dTheta = 2.0f*XM_PI/sliceCount; for(uint32 j = 0; j \u003c= sliceCount; ++j) { Vertex vertex; t c = cosf(j*dTheta); float s = sinf(j*dTheta); vertex.Position = XMFLOAT3(r*c, y, r*s); vertex.TexC.x = (float)j/sliceCount; vertex.TexC.y = 1.0f - (float)i/stackCount; /* 可以像下面那样以参数化（parameterized）的方式来计算圆台顶点， 我们引入与纹理坐标 v 方向相同的参数 v，从而使副切线与纹理坐标 v 的方向相同 设 r0 为底面半径，r1 为顶面半径 y(v) = h - hv 其中 v 位于区间[0,1] r(v) = r1 + (r0-r1)v x(t, v) = r(v)*cos(t) y(t, v) = h - hv z(t, v) = r(v)*sin(t) dx/dt = -r(v)*sin(t) dy/dt = 0 dz/dt = +r(v)*cos(t) dx/dv = (r0-r1)*cos(t) dy/dv = -h dz/dv = (r0-r1)*sin(t) */ // 此为单位长度 vertex.TangentU = XMFLOAT3(-s, 0.0f, c); float dr = bottomRadius-topRadius; XMFLOAT3 bitangent(dr*c, -height, dr*s); XMVECTOR T = XMLoadFloat3(\u0026vertex.TangentU); XMVECTOR B = XMLoadFloat3(\u0026bitangent); XMVECTOR N = XMVector3Normalize(XMVector3Cross(T, B)); XMStoreFloat3(\u0026vertex.Normal, N); meshData.Vertices.push_back(vertex); } } // +1 是希望让每环的第一个顶点和最后一个顶点重合，这是因为它们的纹理坐标并不相同 uint32 ringVertexCount = sliceCount+1; // 计算每个侧面块中三角形的索引 for(uint32 i = 0; i \u003c stackCount; ++i) { for(uint32 j = 0; j \u003c sliceCount; ++j) { meshData.Indices32.push_back(i*ringVertexCount + j); meshData.Indices32.push_back((i+1)*ringVertexCount + j); meshData.Indices32.push_back((i+1)*ringVertexCount + j+1); meshData.Indices32.push_back(i*ringVertexCount + j); meshData.Indi","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:4:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"生成球体网格 欲定义一个球体，就要指定其半径、切片数量及其堆叠层数，如图 7.3 所示。除了每个环上的半径是依三角函数非线性变化，生成球体的算法与生成圆台的算法非常相近。我们将把 GeometryGenerator::CreateSphere 方法的代码留给读者自行研究。最后，值得一提的是，若采用不等比缩放世界变换，即可将球体转换为椭球体。 ","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:4:2","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"生成几何球体网格 观察图 7.3 可知，构成球体的三角形面积并不相同，这在某些情景中并非我们所愿。相对而言，几何球体（geosphere）利用面积相同且边长相等的三角形来逼近球体，如图 7.4 所示。 为了生成几何球体，我们以一个正二十面体作为基础，细分其上的三角形，再根据给定的半径向球面投影新生成的顶点。反复重复这个过程，便可以提高该几何球体的曲面细分程度。 图 7.5 展示了如何将一个三角形细分为 4 个大小相等的小三角形。不难发现，新生成的顶点都位于原始三角形边上的中点。先将顶点投影到单位球面上，再利用 r 进行标量乘法： $ v^’ = r \\frac{v}{||v||} $，即可把新顶点都投影到半径为 r 的球体之上。 ","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:4:3","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"细探根签名 根签名定义了：在绘制调用之前，需要绑定到渲染流水线上的资源，以及这些资源应如何映射到着色器的输入寄存器中。选择绑定到流水线上的资源要根据着色器程序的具体需求。从 PSO 被创建之时起，根签名和着色器程序的组合就开始生效。 ","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:5:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"根参数 ","date":"2025-04-23","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/:5:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(下)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8B/"},{"categories":["DirectX3D"],"content":"DirectX3D 绘制3D立方体","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"绘制3D立方体 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:0:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"顶点与输入布局 除了空间位置，Direct3D 中的顶点还可以存储其他属性数据 为了构建自定义的 顶点格式，我们首先要创建一个结构体来容纳选定的顶点数据。例如，下面列出了两种不同类型的顶点 格式：一种由位置和颜色信息组成，另一种则由位置、法向量以及两组 2D 纹理坐标构成。 #include \u003cDirectXMath.h\u003e using namespace DirectX; struct Vertex1 { XMFLOAT3 Pos; XMFLOAT4 Color; }; struct Vertex2 { XMFLOAT3 Pos; XMFLOAT3 Normal; XMFLOAT2 Tex0; XMFLOAT2 Tex1; }; 定义了顶点结构体之后，我们还需要向 Direct3D 提供该顶点结构体的描述，使它了解应怎样来处理 结构体中的每个成员。用户提供给 Direct3D 的这种描述被称为输入布局描述 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:1:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_INPUT_LAYOUT_DESC 用结构体 D3D12_INPUT_LAYOUT_DESC 来表示 typedef struct D3D12_INPUT_LAYOUT_DESC { const D3D12_INPUT_ELEMENT_DESC *pInputElementDescs; UINT NumElements; } D3D12_INPUT_LAYOUT_DESC; // 输入布局描述实由两部分组成：即一个以 D3D12_INPUT_ELEMENT_DESC 元素构成的数组，以及一个表示该数组中的元素数量的整数 D3D12_INPUT_ELEMENT_DESC 数组中的元素依次描述了顶点结构体中所对应的成员。这就是说， 如果某顶点结构体中有两个成员，那么与之对应的 D3D12_INPUT_ELEMENT_DESC 数组也将存有两个 元素。D3D12_INPUT_ELEMENT_DESC 结构体的定义如下： typedef struct D3D12_INPUT_ELEMENT_DESC { LPCSTR SemanticName; UINT SemanticIndex; DXGI_FORMAT Format; UINT InputSlot; // 指定传递元素所用的输入槽（input slot index）索引 UINT AlignedByteOffset; // 在特定输入槽中，从 C++顶点结构体的首地址到其中某点元素起始地址的偏移量（用字节表示） D3D12_INPUT_CLASSIFICATION InputSlotClass; // 我们暂且把此参数指定为 D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA UINT InstanceDataStepRate; // 目前仅将此值指定为 0。若要采用实例化这种高级技术，则将此参数设为 1 } D3D12_INPUT_ELEMENT_DESC; SemanticName: 一个与元素相关联的特定字符串，我们称之为语义（semantic），它传达了元素的预期用途 该参数可以是任意合法的语义名 SemanticIndex: 附加到语义上的索引 例如，顶点结构体中的纹理坐标可能不止一组，而仅在语义名尾部添加一个索引，即可在不引入新语义名的情况下区分出这两组不同的纹理坐标 Format: 在 Direct3D 中，要通过枚举类型 DXGI_FORMAT 中的成员来指定顶点元素的格式（即数据类型） 下面是一些常用的格式。 DXGI_FORMAT_R32_FLOAT // 1D 32 位浮点标量 DXGI_FORMAT_R32G32_FLOAT // 2D 32 位浮点向量 DXGI_FORMAT_R32G32B32_FLOAT // 3D 32 位浮点向量 DXGI_FORMAT_R32G32B32A32_FLOAT // 4D 32 位浮点向量 DXGI_FORMAT_R8_UINT // 1D 8 位无符号整型标量 DXGI_FORMAT_R16G16_SINT // 2D 16 位有符号整型向量 DXGI_FORMAT_R32G32B32_UINT // 3D 32 位无符号整型向量 DXGI_FORMAT_R8G8B8A8_SINT // 4D 8 位有符号整型向量 DXGI_FORMAT_R8G8B8A8_UINT // 4D 8 位无符号整型向量 InputSlot: 指定传递元素所用的输入槽（input slot index）索引。Direct3D 共支持 16 个输入槽 （索引值为 0～15），可以通过它们来向输入装配阶段传递顶点数据。目前我们只会用到输入槽 0（即 所有的顶点元素都来自同一个输入槽），但在本博客的习题 2中将会涉及多输入槽的编程实践。 AlignedByteOffset: 在特定输入槽中，从 C++顶点结构体的首地址到其中某点元素起始地 址的偏移量（用字节表示）。 例如，在下列顶点结构体中，元素 Pos 的偏移量为 0 字节，因为它 的起始地址与顶点结构体的首地址一致；元素 Normal 的偏移量为 12 字节，因为跳过 Pos 所 占用的字节数才能找到 Normal 的起始地址；元素 Tex0 的偏移量为 24 字节，因为跨过 Pos 和 Normal 的总字节数才可获取 Tex0 的起始地址。同理，元素 Tex1 的偏移量为 32 字节， 只有跳过 Pos、Normal 和 Tex0 这 3 个元素的总字节数方可寻得 Tex1 的起始地址。 struct Vertex2 { XMFLOAT3 Pos; // 偏移量为 0 字节 XMFLOAT3 Normal; // 偏移量为 12 字节 XMFLOAT2 Tex0; // 偏移量为 24 字节 XMFLOAT2 Tex1; // 偏移量为 32 字节 }; InputSlotClass: 我们暂且把此参数指定为 D3D12_INPUT_CLASSIFICATION_PER_ VERTEX_DATA。而另一选项（D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA ） 则用于实现实例化（instancing）这种高级技术 InstanceDataStepRate：目前仅将此值指定为 0。若要采用实例化这种高级技术，则将此参数设为 1 就前面 Vertex1 和 Vertex2 这两个顶点结构体的例子来说，其相应的输入布局描述为： D3D12_INPUT_ELEMENT_DESC desc1[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0} }; D3D12_INPUT_ELEMENT_DESC desc2[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"NORMAL\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"TEXCOORD\", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 24, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0} {\"TEXCOORD\", 1, DXGI_FORMAT_R32G32_FLOAT, 0, 32, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0} }; ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:1:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"顶点缓冲区 为了使 GPU 可以访问顶点数组，就需要把它们放置在称为缓冲区（buffer）的 GPU 资源 （ID3D12Resource）里。我们把存储顶点的缓冲区叫作顶点缓冲区（vertex buffer）。缓冲区的结构比纹 理更为简单：既非多维资源，也不支持 mipmap、过滤器以及多重采样等技术。当需要向 GPU 提供如顶 点这类数据元素所构成的数组时，我们便会使用缓冲区 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_RESOURCE_DESC 我们先通过填写 D3D12_RESOURCE_DESC 结构体来描述缓冲区资源 接着再调用 ID3D12Device::CreateCommittedResource 方法去创建 ID3D12Resource 对象。 至于 D3D12_RESOURCE_DESC 结构体中所有成员的介绍，可参考 4.3.8 节。 typedef struct D3D12_RESOURCE_DESC { D3D12_RESOURCE_DIMENSION Dimension; UINT64 Alignment; UINT64 Width; UINT Height; UINT16 DepthOrArraySize; UINT16 MipLevels; DXGI_FORMAT Format; DXGI_SAMPLE_DESC SampleDesc; D3D12_TEXTURE_LAYOUT Layout; D3D12_RESOURCE_MTSC_FLAG Misc Flags; } D3D12_RESOURCE_DESC; Dimension：资源的维度，即为下列枚举类型中的成员之一。 enum D3D12_RESOURCE_DIMENSION { D3D12_RESOURCE_DIMENSION_UNKNOWN = 0, D3D12_RESOURCE_DIMENSION_BUFFER = 1, D3D12_RESOURCE_DIMENSION_TEXTURE1D = 2, D3D12_RESOURCE_DIMENSION_TEXTURE2D = 3, D3D12_RESOURCE_DIMENSION_TEXTURE3D = 4 } D3D12_RESOURCE_DIMENSION; Width：以纹素为单位来表示的纹理宽度。对于缓冲区资源来说，此项是缓冲区占用的字节数。 Height：以纹素为单位来表示的纹理高度。 DepthOrArraySize：以纹素为单位来表示的纹理深度，或者（对于 1D 纹理和 2D 纹理来说） 是纹理数组的大小。注意，Direct3D 中并不存在 3D 纹理数组的概念 MipLevels：mipmap 层级的数量。我们会在讲纹理时介绍 mipmap。对于深度/模板缓冲区而言，只能有一个 mipmap 级别 Format：DXGI_FORMAT 枚举类型中的成员之一，用于指定纹素的格式。对于深度/模板缓冲区 来说，需要从x下述介绍的格式中选择 1. DXGI_FORMAT_D32_FLOAT_S8X24_UINT：该格式共占用 64 位，取其中的 32 位指定一个浮点型深度缓冲区，另有 8 位（无符号整数）分配给模板缓冲区（stencil buffer），并将该元素映射到[0, 255]区间，剩下的 24 位仅用于填充对齐（padding）不作他用。 2. DXGI_FORMAT_D32_FLOAT：指定一个 32 位浮点型深度缓冲区。 3. DXGI_FORMAT_D24_UNORM_S8_UINT：指定一个无符号 24 位深度缓冲区，并将该元素映射到[0, 1]区间。另有 8 位（无符号整型）分配给模板缓冲区，将此元素映射到[0, 255]区间。 4. DXGI_FORMAT_D16_UNORM：指定一个无符号 16 位深度缓冲区，把该元素映射到[0, 1]区间。 SampleDesc：多重采样的质量级别以及对每个像素的采样次数. 先来回顾一下 4X MSAA 技术：为了存储每个子像素的颜色和深度/模板信息，所用后台 缓冲区和深度缓冲区的大小要 4 倍于屏幕的分辨率。因此，深度/模板缓冲区与渲染目标的多 重采样设置一定要相匹配 Layout：D3D12_TEXTURE_LAYOUT 枚举类型的成员之一，用于指定纹理的布局。我们暂 时还不用考虑这个问题，在此将它指定为 D3D12_TEXTURE_LAYOUT_UNKNOWN 即可。 Flags：与资源有关的杂项标志。对于一个深度/模板缓冲区资源来说，要将此项指定为 D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"CD3DX12_RESOURCE_DESC Direct3D 12 提供了 一个 C++包装类 CD3DX12_RESOURCE_DESC，它派生自 D3D12_RESOURCE_DESC 结构体，并附有 多种便于使用的构造函数以及方法。特别是它提供的下列方法，一种简化缓冲区描述过程的 D3D12_ RESOURCE_DESC 的构造函数： static inline CD3DX12_RESOURCE_DESC Buffer(UINT64 width, D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE, UINT64 alignment = 0) { return CD3DX12_RESOURCE_DESC( D3D12_RESOURCE_DIMENSION_BUFFER, alignment, width, 1, 1, 1, DXGI_FORMAT_UNKNOWN, 1, 0, D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags ); } 对于缓冲区而言，函数代码中的 width 即表示缓冲区中所占的字节数。例如，若缓冲区存储了 64 个 float 类型的数据，那么 width 的值即为 64sizeof(float)。* ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:2","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_HEAP_TYPE_DEFAULT 对于静态几何体（static geometry，即每一帧都不会发生改变的几何体）而言，我们会将其顶点缓冲区置于默认堆（D3D12_HEAP_TYPE_DEFAULT）中来优化性能。 一般说来，游戏中的大多数几何体（如 树木、建筑物、地形和动画角色）都是如此处理。在这种情况下，顶点缓冲区初始化完毕后，只有 GPU 需要从其中读取数据来绘制几何体，所以使用默认堆是很明智的做法 然而，如果 CPU 不能向默认堆中 的顶点缓冲区写入数据，那么我们该如何初始化此顶点缓冲区呢？ ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:3","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_HEAP_TYPE_UPLOAD 因此，除了创建顶点缓冲区资源本身之外，我们还需用 D3D12_HEAP_TYPE_UPLOAD 这种堆类型 来创建一个处于中介位置的上传缓冲区（upload buffer）资源 由于我们需要利用作为中介的上传缓冲区来初始化默认缓冲区（即用堆类型 D3D12_HEAP_TYPE_ DEFAULT 创建的缓冲区）中的数据，因此，我们就在 d3dUtil.h/.cpp 文件中构建了下列工具函数，以避 免在每次使用默认缓冲区时再做这些重复的工作 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:4","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_SUBRESOURCE_DATA D3D12_SUBRESOURCE_DATA 结构体的定义为： typedef struct D3D12_SUBRESOURCE_DATA { const void *pData; LONG_PTR RowPitch; LONG_PTR SlicePitch; } D3D12_SUBRESOURCE_DATA; pData：指向某个系统内存块的指针，其中有初始化缓冲区所用的数据。如果欲初始化的缓冲 区能够存储 n 个顶点数据，则该系统内存块必定可容纳至少 n 个顶点数据，以此来初始化整个 缓冲区。 RowPitch：对于缓冲区而言，此参数为欲复制数据的字节数。 SlicePitch：对于缓冲区而言，此参数亦为欲复制数据的字节数。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:5","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"创建存有立方体 8 个顶点的默认缓冲区 下面的代码演示了此类将如何创建存有立方体 8 个顶点的默认缓冲区，并为其中的每个顶点都分别 赋予了不同的颜色 struct Vertex { XMFLOAT3 Pos; XMFLOAT4 Color; }; Vertex vertices[] = { { XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT4(Colors::White) }, { XMFLOAT3(-1.0f, +1.0f, -1.0f), XMFLOAT4(Colors::Black) }, { XMFLOAT3(+1.0f, +1.0f, -1.0f), XMFLOAT4(Colors::Red) }, { XMFLOAT3(+1.0f, -1.0f, -1.0f), XMFLOAT4(Colors::Green) }, { XMFLOAT3(-1.0f, -1.0f, +1.0f), XMFLOAT4(Colors::Blue) }, { XMFLOAT3(-1.0f, +1.0f, +1.0f), XMFLOAT4(Colors::Yellow) }, { XMFLOAT3(+1.0f, +1.0f, +1.0f), XMFLOAT4(Colors::Cyan) }, { XMFLOAT3(+1.0f, -1.0f, +1.0f), XMFLOAT4(Colors::Magenta) } }; const UINT64 vbByteSize = 8 * sizeof(Vertex); ComPtr\u003cID3D12Resource\u003e VertexBufferGPU = nullptr; ComPtr\u003cID3D12Resource\u003e VertexBufferUploader = nullptr; VertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(), mCommandList.Get(), vertices, vbByteSize, VertexBufferUploader); ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:6","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_VERTEX_BUFFER_VIEW 为了将顶点缓冲区绑定到渲染流水线上，我们需要给这种资源创建一个顶点缓冲区视图（vertex buffer view）。 与 RTV（render target view，渲染目标视图）不同的是，我们无须为顶点缓冲区视图创建描 述符堆。 而且，顶点缓冲区视图是由 D3D12_VERTEX_BUFFER_VIEW结构体来表示。 typedef struct D3D12_VERTEX_BUFFER_VIEW { D3D12_GPU_VIRTUAL_ADDRESS BufferLocation; UINT SizeInBytes; UINT StrideInBytes; } D3D12_VERTEX_BUFFER_VIEW; BufferLocation：待创建视图的顶点缓冲区资源虚拟地址。我们可以通过 ID3D12Resource:: GetGPUVirtualAddress 方法来获得此地址 SizeInBytes：待创建视图的顶点缓冲区大小（用字节表示）。 StrideInBytes：每个顶点元素所占用的字节数。 在顶点缓冲区及其对应视图创建完成后，便可以将它与渲染流水线上的一个输入槽（input slot）相绑定。 这样一来，我们就能向流水线中的输入装配器阶段传递顶点数据了。此操作可以通过下列方法来实现 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:7","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"ID3D12GraphicsCommandList::IASetVertexBuffers void ID3D12GraphicsCommandList::IASetVertexBuffers ( UINT StartSlot, UINT NumView, const D3D12_VERTEX_BUFFER_VIEW *pViews ); StartSlot：在绑定多个顶点缓冲区时，所用的起始输入槽（若仅有一个顶点缓冲区，则将其 绑定至此槽）。输入槽共有 16 个，索引为 0～15 NumViews：将要与输入槽绑定的顶点缓冲区数量（即视图数组 pViews 中视图的数量）。如果 起始输入槽 StartSlot 的索引值为 k，且我们要绑定 n 个顶点缓冲区，那么这些缓冲区将依次 与输入槽 $ I_k, I_{k+1},…,I_{k+n-1} $相绑定 pViews：指向顶点缓冲区视图数组中第一个元素的指针。 下面是该函数的一个调用示例。 D3D12_VERTEX_BUFFER_VIEW vbv; vbv.BufferLocation = VertexBufferGPU-\u003eGetGPUVirtualAddress(); vbv.StrideInBytes = sizeof(Vertex); vbv.SizeInBytes = 8 * sizeof(Vertex); D3D12_VERTEX_BUFFER_VIEW vertexBuffers[1] = { vbv }; mCommandList-\u003eIASetVertexBuffers(0, 1, vertexBuffers); 由于 IASetVertexBuffers 方法会将顶点缓冲区数组中的元素设置到不同的输入槽上去，所以使 它看起来似乎有些复杂。但是，在我们的示例中实际只会使用一个输入槽。而在章末的一道习题中，我 们将体验到运用两个输入槽进行绘制的过程 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:8","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"使用多个顶点缓冲区 我们若不对顶点缓冲区进行任何修改，它就将一直被绑定于所在的输入槽上。所以，如果使用多个 顶点缓冲区，那么就可以按以下流程来构建代码。 ID3D12Resource* mVB1; // 存储 Vertex1 类型的顶点 ID3D12Resource* mVB2; // 存储 Vertex2 类型的顶点 D3D12_VERTEX_BUFFER_VIEW mVBView1; // mVB1 的视图 D3D12_VERTEX_BUFFER_VIEW mVBView2; // mVB2 的视图 /*……创建顶点缓冲区及其视图……*/ mCommandList-\u003eIASetVertexBuffers(0, 1, \u0026mVBView1); /* ……使用顶点缓冲区 1 来绘制物体…… */ mCommandList-\u003eIASetVertexBuffers(0, 1, \u0026mVBView2); /* ……使用顶点缓冲区 2 来绘制物体…… */ ID3D12GraphicsCommandList::DrawInstanced 将顶点缓冲区设置到输入槽上并不会对其执行实际的绘制操作，而是仅为顶点数据送至渲染流 水线做好准备而已。这最后一步才是通过 ID3D12GraphicsCommandList::DrawInstanced 方法真正地绘制顶点 void ID3D12GraphicsCommandList::DrawInstanced ( UINT VertexCountPerInstance, UINT InstanceCount, UINT StartVertexLocation, UINT StartInstanceLocation ); VertexCountPerInstance：每个实例要绘制的顶点数量。 InstanceCount：用于实现一种被称作实例化（instancing）的高级技术。就目前来说，我们 只绘制一个实例，因而将此参数设置为 1。 StartVertexLocation：指定顶点缓冲区内第一个被绘制顶点的索引（该索引值以 0 为基准）。 StartInstanceLocation：用于实现一种被称作实例化的高级技术，暂时只需将其设置为 0。 VertexCountPerInstance和StartVertexLocation两个参数定义了顶点缓冲区中将要被绘 制的一组连续顶点 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:9","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"IASetPrimitiveTopology 既然 DrawInstanced 方法没有指定顶点被定义为何种图元，那么，它们应该被绘制为点、线 列表还是三角形列表呢？回顾 图元拓扑 可知，图元拓扑状态实由 ID3D12GraphicsCommandList:: IASetPrimitiveTopology 方法来设置。下面给出一个相关的调用示例： cmdList-\u003eIASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST); ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:2:10","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"索引和索引缓冲区 与顶点相似，为了使 GPU 可以访问索引数组，就需要将它们放置于 GPU 的缓冲区资源（ID3D12Resource）内。 我们称存储索引的缓冲区为索引缓冲区（index buffer）。 如果采用 d3dUtil::CreateDefaultBuffer 函数，他是通过 void类型作为参数引入泛型数据，这就意味着我们 也可以用此函数来创建索引缓冲区（或任意类型的默认缓冲区）。* ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:3:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_INDEX_BUFFER_VIEW 为了使索引缓冲区与渲染流水线绑定，我们需要给索引缓冲区资源创建一个索引缓冲区视图（index buffer view）。如同顶点缓冲区视图一样，我们也无须为索引缓冲区视图创建描述符堆。但索引缓冲区视 图要由结构体 D3D12_INDEX_BUFFER_VIEW 来表示 typedef struct D3D12_INDEX_BUFFER_VIEW { D3D12_GPU_VIRTUAL_ADDRESS BufferLocation; UINT SizeInBytes; DXGI_FORMAT Format; } D3D12_INDEX_BUFFER_VIEW; BufferLocation：待创建视图的索引缓冲区资源虚拟地址。我们可以通过调用ID3D12Resource:: GetGPUVirtualAddress 方法来获取此地址。 SizeInBytes：待创建视图的索引缓冲区大小（以字节表示）。 Format：索引的格式必须为表示 16 位索引的 DXGI_FORMAT_R16_UINT 类型，或表示 32 位 索引的 DXGI_FORMAT_R32_UINT 类型。16 位的索引可以减少内存和带宽的占用，但如果索引 值范围超过了 16 位数据的表达范围，则也只能采用 32 位索引了。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:3:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"ID3D12GraphicsCommandList::IASetIndexBuffer 与顶点缓冲区相似（也包括其他的 Direct3D 资源在内），在使用之前，我们需要先将它们绑定到渲染流水线上。通过 ID3D12GraphicsCommandList::IASetIndexBuffer 方法即可将索引缓冲区绑 定到输入装配器阶段 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:3:2","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"创建一个索引缓冲区来定义构成立方体的三角形 std::uint16_t indices[] = { // 立方体前表面 0, 1, 2, 0, 2, 3, // 立方体后表面 4, 6, 5, 4, 7, 6, // 立方体左表面 4, 5, 1, 4, 1, 0, // 立方体右表面 3, 2, 6, 3, 6, 7, // 立方体上表面 1, 5, 6, 1, 6, 2, // 立方体下表面 4, 0, 3, 4, 3, 7 }; const UINT ibByteSize = 36 * sizeof(std::uint16_t); ComPtr\u003cID3D12Resource\u003e IndexBufferGPU = nullptr; ComPtr\u003cID3D12Resource\u003e IndexBufferUploader = nullptr; IndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(), mCommandList.Get(), indices, ibByteSize, IndexBufferUploader); D3D12_INDEX_BUFFER_VIEW ibv; ibv.BufferLocation = IndexBufferGPU-\u003eGetGPUVirtualAddress(); ibv.Format = DXGI_FORMAT_R16_UINT; ibv.SizeInBytes = ibByteSize; mCommandList-\u003eIASetIndexBuffer(\u0026ibv); ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:3:3","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"ID3D12GraphicsCommandList:: DrawIndexedInstanced 最后需要注意的是，在使用索引的时候，我们一定要用 ID3D12GraphicsCommandList:: DrawIndexedInstanced 方法代替 DrawInstanced 方法进行绘制。 void ID3D12GraphicsCommandList::DrawIndexedInstanced( UINT IndexCountPerInstance, UINT InstanceCount, UINT StartIndexLocation, INT BaseVertexLocation, UINT StartInstanceLocation ); IndexCountPerInstance：每个实例将要绘制的索引数量。 InstanceCount：用于实现一种被称作实例化的高级技术。就目前而言，我们只绘制一个实例，因而将此值设置为 1。 StartIndexLocation：指向索引缓冲区中的某个元素，将其标记为欲读取的起始索引。 BaseVertexLocation：在本次绘制调用读取顶点之前，要为每个索引都加上此整数值。 StartInstanceLocation：用于实现一种被称为实例化的高级技术，暂将其设置为 0。 为了理解这些参数，让我们来思考这样一个情景: 假设有 3 个欲绘制的物体，一个球体、一个立方体以及一个圆柱体。 首先，每个物体都有自己的顶点缓冲区以及索引缓冲区。而每个局部索引缓冲区中的索引，又都引用的是各自的局部顶点缓冲区。 现在，我们把这 3 个物体的顶点和索引分别连接为全局顶点缓冲区和全局索引缓冲区，如图 6.3 所示。（在顶点缓冲区和索引缓冲区合并的过程中，调用 API 时 可能会产生一些开销，但这基本上不会成为程序的瓶颈。出于性能的原因，当应用中有一些可以轻易合 并的零散顶点缓冲区和索引缓冲区时，便值得照这样试一试） 待合并完成后，索引缓冲区里的元素就不能正确地引用对应的顶点数据了，这是因为它们存储的索引值是相对于物体各自的局部顶点缓冲区而言， 而非全局的顶点缓冲区。 所以，还需要对索引值进行重新计算，使之可以正确地引用全局顶点缓冲区中的顶点数据。假设原始的立方体索引是根据下述立方体顶点编号来计算的： 0, 1, ..., numBoxVertices-1 但是在顶点缓冲区与索引缓冲区一一合并之后，该立方体的索引编号将依次变为： firstBoxVertexPos, firstBoxVertexPos+1, ..., firstBoxVertexPos+numBoxVertices-1 因此，为了更新索引，我们需要为每个立方体的原索引加上 firstBoxVertexPos（缓冲区合并后 立方体第一个顶点的索引值）。类似地，我们也需要给每个圆柱体的原索引加上 firstCylVertexPos （缓冲区合并后圆柱体第一个顶点的索引值）。注意，球体的索引是不需要改变的（因为球体第一个顶点 的位置始终为 0，在合并后的全局索引缓冲区中也未曾改变）。我们将每个物体的第一个顶点相对于 全局顶点缓冲区的位置叫作它的基准顶点地址（base vertex location）。 通常来讲，一个物体的新索引是通过原始索引加上它的基准顶点地址来获取的。事实上，我们不必亲自计算新的索引值：通过向 DrawIndexedInstanced 函数的第 4 个参数传递基准顶点地址，即可让 Direct3D 去执行相关计算工作 接下来，我们再通过下列 3 次绘制调用来依次绘制球体、立方体和圆柱体： mCmdList-\u003eDrawIndexedInstanced(numSphereIndices, 1, 0, 0, 0); mCmdList-\u003eDrawIndexedInstanced(numBoxIndices, 1, firstBoxIndex, firstBoxVertexPos, 0); mCmdList-\u003eDrawIndexedInstanced(numCylIndices, 1, firstCylIndex, firstCylVertexPos, 0); ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:3:4","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"顶点着色器示例 以下代码实现的是一个简单的顶点着色器 cbuffer cbPerObject : register(b0) { float4x4 gWorldViewProj; }; void VS(float3 iPosL : POSITION, float4 iColor : COLOR, out float4 oPosH : SV_POSITION, out float4 oColor : COLOR) { // 把顶点变换到齐次裁剪空间 oPosH = mul(float4(iPosL, 1.0f), gWorldViewProj); // 直接将顶点的颜色信息传至像素着色器 oColor = iColor; } 在 Direct3D 中，编写着色器的语言为高级着色语言（High Level Shading Language，HLSL），其语 法与 C++十分相似，这使得它较易于学习 一般情况下，着色器通常在以.hlsl 为扩展名的文本文件中编写。 详细语法介绍，请参考https://cutecocoa.github.io/unreal-hlsl/ 顶点着色器就是上例中名为 VS 的函数，值得注意的是，我们可以给顶点着色器起任意合法的函数 名。 上述顶点着色器共有 4 个参数，前两个为输入参数，后两个为输出参数（通过关键字 out 来表示）。 HLSL 没有引用（reference）和指针（pointer）的概念，所以需要借助结构体或多个输出参数才能够从函 数中返回多个数值。 而且，在 HLSL 中，所有的函数都是内联（inline）函数。 前两个输入参数分别对应于绘制立方体所自定义顶点结构体中的两个数据成员，也构成了顶点着色 器的输入签名（input signature）。 参数语义“ :POSITION”和“ :COLOR”用于将顶点结构体中的元素映射到顶点着色器的相应输入参数 输出参数也附有各自的语义（“:SV_POSITION”和“:COLOR”），并以此作为纽带，将顶点着色器 的输出参数映射到下个处理阶段（几何着色器或像素着色器）中所对应的输入参数 注意，SV_POSITION 语义比较特殊（SV 代表系统值，即 system value），它所修饰的顶点着色器输出元素存有齐次裁剪空间中的顶点位置信息 因此，我们必须为输出位置信息的参数附上 SV_POSITION 语义，使 GPU 可以在进 行例如裁剪、深度测试和光栅化等处理之时，借此实现其他属性所无法介入的有关运算 值得注意的是对于任何不具有系统值的输出参数而言，我们都可以根据需求以合法的语义名修饰它。 上述顶点着色器函数的第一行代码是通过将顶点与 4 x 4 矩阵 gWorldViewProj 相乘，使其坐标由 局部空间变换到齐次裁剪空间 // 将顶点坐标变换到齐次裁剪空间 oPosH = mul(float4(iPosL, 1.0f), gWorldViewProj); 借助构造语法 float4(iPosL, 1.0f)即可构建一个等价于 float4(iPosL.x, iPosL.y, iPosL.z, 1.0f)的 4D 向量 我们知道，顶点的位置是一个点而非向量，所以将向量的第 4 个分量设 置为 1（w = 1）。并以 float2 与 float3 类型分别表示 2D 和 3D 向量。 矩阵变量 gWorldViewProj 存于常量缓冲区（constant buffer）内 内置函数（built-in function, 也译作内建函数、内部函数等）mul 则用于计算向量与矩阵之间的乘法 顺便提一下，mul 函数可以根据 不同规模的矩阵乘法而重载。例如，我们可以用 mul 函数进行两个 4 × 4 矩阵的乘法、两个3 × 3矩阵的乘法或者一个1 × 3向量与 3 x 3矩阵的乘法等。 着色器函数的最后一行代码把输入的颜色直接复制给输出参数，继而将该颜色传递到渲染流水线的下个阶段: oColor = iColor; 我们可以把函数的返回类型和输入签名替换为结构体（从而取代过长的参数列表），即将以上顶点着 色器改写为另一种等价实现： cbuffer cbPerObject : register(b0) { float4x4 gWorldViewProj; }; struct VertexIn { float3 PosL : POSITION; float4 Color : COLOR; }; struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; }; VertexOut VS(VertexIn vin) { VertexOut vout; // 将顶点变换到齐次裁剪空间 vout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj); // 直接将顶点颜色传至像素着色器 vout.Color = vin.Color; return vout; } ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:4:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"连接输入布局描述符与输入签名 根据图 6.4 来看，输送到渲染流水线的顶点属性与输入布局描述的定义相关联。如果我们传入的顶 点数据与顶点着色器所期望的输入不相符，便会导致错误 例如，下列顶点着色器的输入签名与顶点数 据就是不匹配的： //-------------- // C++应用程序代码 //-------------- struct Vertex { XMFLOAT3 Pos; XMFLOAT4 Color; }; D3D12_INPUT_ELEMENT_DESC desc[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0} }; //-------------- // 顶点着色器 //-------------- struct VertexIn { float3 PosL : POSITION; float4 Color : COLOR; float3 Normal : NORMAL; }; struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; }; VertexOut VS(VertexIn vin) { ... } 在创建 ID3D12PipelineState 对象的时候，必须指定输入 布局描述和顶点着色器，而 Direct3D 则会验证两者是否匹配 事实上，顶点数据与输入签名不需要完全匹配，前提是我们一定要向顶点着色器提供其输入签 名所定义的顶点数据。这就是说，顶点数据中也可以附带一些顶点着色器根本用不到的额外数据。 下面的代码就描述了这样一种匹配的情况： //-------------- // C++应用程序代码 //-------------- struct Vertex { XMFLOAT3 Pos; XMFLOAT4 Color; XMFLOAT3 Normal; }; D3D12_INPUT_ELEMENT_DESC desc[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"NORMAL\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 28, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 } }; //-------------- // 顶点着色器 //-------------- struct VertexIn { float3 PosL : POSITION; float4 Color : COLOR; }; struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; }; VertexOut VS(VertexIn vin) { ... } 现在，让我们再来思考这样一种情况：当顶点结构体和输入签名有着匹配的顶点元素，唯独两者的 颜色属性类型却不相同，此时会发生什么呢？ //-------------- // C++应用程序代码 //-------------- struct Vertex { XMFLOAT3 Pos; XMFLOAT4 Color; }; D3D12_INPUT_ELEMENT_DESC desc[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0} }; //-------------- // 顶点着色器 //-------------- struct VertexIn { float3 PosL : POSITION; int4 Color : COLOR; }; struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; }; VertexOut VS(VertexIn vin) { ... } 这其实也是合法的，因为 Direct3D 允许用户对输入寄存器（input register，全称为顶点着色器输入 寄存器）中数据的类型重新加以解释。然而，VC++调试输出窗口还是会给出下面的警告 D3D12 WARNING: ID3D12 Device::CreateInputLayout: The provided input signature expects to read an element with SemanticName/Index: 'COLOR'/0 and component(s) of the type 'int32'. However, the matching entry in the Input Layout declaration, element[1], specifies mismatched format: 'R32G32B32A32_FLOAT'. This is not an error, since behavior is well defined: The element format determines what data conversion algorithm gets applied before it shows up in a shader register. Independently, the shader input signature defines how the shader will interpret the data that has been placed in its input registers, with no change in the bits stored. It is valid for the application to reinterpret data as a different type once it is in the vertex shader, so this warning is issued just in case reinterpretation was not intended by the author. （D3D12 警告：ID3D12Device::CreateInputLayout: 根据代码中提供的输入签名推断，其中 的 SemanticName/Index: 'COLOR'/0 项希望读取'int32'类型的数据分量。但是，此类型却与输 入布局声明中的对应匹配项 element[1]所指定的格式'R32G32B32A32_FLOAT'不匹配。这并不是一个 错误，因为 Direct3D 对该行为有着明确的定义：输入布局中的元素格式确定的是，在数据未进入着色器 寄存器之前，应运用何种数据转换算法来确定各元素的具体格式。而着色器输入签名则定义的是，在不 修改输入寄存器中所存数据的情况下，顶点着色器将如何来解释这些数据的类型。所以，在应用程序里 将顶点着色器中的数据重新解释为与之不同的类型，亦是合法的。因此，该警告只用于提醒在无意间对 数据类型作出不同解释的程序员①。） ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:4:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"像素着色器示例 为了计算出三角形中每个像素的属性，我们会在光栅化处理期间对顶点着色器（或几何着色器）输出的顶点属性进行插值。随后，再将这些插值数据传至像素着色器中作为它的输入 现假设我们的程序未使用几何着色器，图 6.5 展示的即为当前顶点数 据所流经的路径 像素着色器与顶点着色器有些相似：前者是针对每一个像素片段（pixel fragment）而运行的函数， 后者是针对每一个顶点而运行的函数（即在每次执行时处理单个像素（顶点））。 只要为像素着色器指 定了输入数据，它就会为像素片段计算出一个对应的颜色 值得我们注意的是，这些输入像素着色器 的像素片段有可能最终不会传入或留存在后台缓冲区中 例如，像素片段可能会在像素着色器中被裁 剪掉（HLSL 中内置了一个裁剪函数 clip，可以使指定的像素片段在后续的处理流程中被忽略掉）、 被另一个具有较小深度值的像素片段所遮挡或者在类似于模板缓冲区测试的后续渲染流水线测试中被丢弃。 因此，在确定后台缓冲区某一像素的过程中，可能会存在多个候选的像素片段。这就是“像素 片段”和“像素”意义的差别，尽管有时这两个术语可以互用，但是在一些语境下它们的意义也将变得更加分明 下面是一段简单的像素着色器代码，它与顶点着色器相呼应。考虑到代码的完整性， 此处把顶点着色器部分也一并再次给出 cbuffer cbPerObject : register(b0) { float4x4 gWorldViewProj; }; void VS(float3 iPos : POSITION, float4 iColor : COLOR, out float4 oPosH : SV_POSITION, out float4 oColor : COLOR) { // 将顶点变换到齐次裁剪空间 oPosH = mul(float4(iPos, 1.0f), gWorldViewProj); // 直接把顶点颜色传递到像素着色器 oColor = iColor; } float4 PS(float4 posH : SV_POSITION, float4 color : COLOR) : SV_Target { return color; } 在这个示例中，像素着色器只简单地返回了插值颜色数据。 可以发现，像素着色器的输入与顶点着 色器的输出可以准确匹配，这也是必须满足的一点 像素着色器返回一个 4D 颜色值，而位于此函数参 数列表后的 SV_TARGET 语义则表示该返回值的类型应当与渲染目标格式（render target format）相匹配 （该输出值会被存于渲染目标之中）。 我们可以利用输入/输出结构体重写上述顶点着色器和像素着色器的等价实现。这与之前的表示方法 有所不同，我们要将语义附加给输入/输出结构体中的成员，并通过一条用于输出结构体的返回语句代替 之前的多个输出参数。 cbuffer cbPerObject : register(b0) { float4x4 gWorldViewProj; }; struct VertexIn { float3 Pos : POSITION; float4 Color : COLOR; }; struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; }; VertexOut VS(VertexIn vin) { VertexOut vout; // 把顶点变换到齐次裁剪空间 vout.PosH = mul(float4(vin.Pos, 1.0f), gWorldViewProj); // 直接将顶点颜色传至像素着色器 vout.Color = vin.Color; return vout; } float4 PS(VertexOut pin) : SV_Target { return pin.Color; } ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:5:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"常量缓冲区 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:6:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"创建常量缓冲区 常量缓冲区（constant buffer）也是一种 GPU 资源（ID3D12Resource），其数据内容可供着色器程序所引用。就像我们将会学到的纹理等其他类型的缓冲区资源一样，它们都可以被着色器程序所引用 顶点着色器中有如下代码 cbuffer cbPerObject : register(b0) { float4x4 gWorldViewProj; }; 在这段代码中，cbuffer 对象（常量缓冲区）的名称为 cbPerObject，其中存储的是一个 4 x 4 矩阵 gWorldViewProj，表示把一个点从局部空间变换到齐次裁剪空间所用到的由世界、视图和投影 3 种变换组合而成的矩阵。 在 HLSL 中，可将一个 4 × 4 矩阵声明为内置的 float4x4 类型。相应地，要声 明 3 × 4 矩阵或 2 × 4 矩阵，即可分别使用 float3x4 和 float2x4 这两种类型 与顶点缓冲区和索引缓冲区不同的是，常量缓冲区通常由 CPU 每帧更新一次。 举个例子，如果摄像机每帧都在不停地移动，那么常量缓冲区也需要在每一帧都随之以新的视图矩阵而更新。所以，我们会把常量缓冲区创建到一个上传堆而非默认堆中，这样做能使我们从 CPU 端更新常量 常量缓冲区对硬件也有特别的要求，即常量缓冲区的大小必为硬件最小分配空间（256B）的整数倍。 我们经常需要用到多个相同类型的常量缓冲区。例如，假设常量缓冲区 cbPerObject 内存储的是 随不同物体而异的常量数据，因此，如果我们要绘制 n 个物体，则需要 n 个该类型的常量缓冲区 下列 代码展示了我们是如何创建一个缓冲区资源，并利用它来存储 NumElements 个常量缓冲区。 struct ObjectConstants { DirectX::XMFLOAT4X4 WorldViewProj = MathHelper::Identity4x4(); }; UINT mElementByteSize = d3dUtil::CalcConstantBufferByteSize(sizeof(ObjectConstants)); ComPtr\u003cID3D12Resource\u003e mUploadCBuffer; device-\u003eCreateCommittedResource ( \u0026CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD), D3D12_HEAP_FLAG_NONE, \u0026CD3DX12_RESOURCE_DESC::Buffer(mElementByteSize * NumElements), D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(\u0026mUploadCBuffer) ); 我们可以认为 mUploadCBuffer 中存储了一个 ObjectConstants 类型的常量缓冲区数组（同时 按 256 字节的整数倍来为之填充数据）。待到绘制物体的时候，只要将常量缓冲区视图（Constant Buffer View，CBV）绑定到存有物体相应常量数据的缓冲区子区域即可。由于 mUploadCBuffer 缓冲区存储 的是一个常量缓冲区数组，因此，我们把它称之为常量缓冲区。 CalcConstantBufferByteSize 工具函数 d3dUtil::CalcConstantBufferByteSize 会做适当的运算，使缓冲区的大小凑整为 硬件最小分配空间（256B）的整数倍。 UINT d3dUtil::CalcConstantBufferByteSize(UINT byteSize) { // 常量缓冲区的大小必须是硬件最小分配空间（通常是 256B）的整数倍 // 为此，要将其凑整为满足需求的最小的 256 的整数倍。我们现在通过为输入值 byteSize 加上 255， // 再屏蔽求和结果的低 2 字节（即计算结果中小于 256 的数据部分）来实现这一点 // 例如：假设 byteSize = 300 // (300 + 255) \u0026 ~255 // 555 \u0026 ~255 // 0x022B \u0026 ~0x00ff // 0x022B \u0026 0xff00 // 0x0200 // 512 return (byteSize + 255) \u0026 ~255; } 随 Direct3D 12 一同推出的是着色器模型（shader model，SM）5.1。其中新引进了一条可用于定义 常量缓冲区的 HLSL 语法，它的使用方法如 struct ObjectConstants { float4x4 gWorldViewProj; uint matIndex; }; ConstantBuffer\u003cObjectConstants\u003e gObjConstants : register(b0); 在此段代码中，常量缓冲区的数据元素被定义在一个单独的结构体中，随后再用此结构体来创建一 个常量缓冲区。这样一来，我们就可以利用下列获取数据成员的语法，在着色器里访问常量缓冲区中的 各个字段： uint index = gObjConstants.matIndex; ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:6:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"更新常量缓冲区 由于常量缓冲区是用 D3D12_HEAP_TYPE_UPLOAD 这种堆类型来创建的，所以我们就能通过 CPU 为常量缓冲区资源更新数据。为此，我们首先要获得指向欲更新资源数据的指针，可用 Map 方法来做到这一点： ComPtr\u003cID3D12Resource\u003e mUploadBuffer; BYTE* mMappedData = nullptr; mUploadBuffer-\u003eMap(0, nullptr, reinterpret_cast\u003cvoid**\u003e(\u0026mMappedData)); 第一个参数是子资源（subresource）的索引①，指定了欲映射的子资源。对于缓冲区来说，它自身就 是唯一的子资源，所以我们将此参数设置为 0 第二个参数是一个可选项，是个指向 D3D12_RANGE 结构体的指针，此结构体描述了内存的映射范围，若将该参数指定为空指针，则对整个资源进行映射 第三个参数则借助双重指针，返回待映射资源数据的目标内存块。我们利用 memcpy 函数将数据从系统内存（system memory，也就是 CPU 端控制的内存）复制到常量缓冲区 memcpy(mMappedData, \u0026data, dataSizeInBytes); 当常量缓冲区更新完成后，我们应在释放映射内存之前对其进行 Unmap（取消映射）操作 if(mUploadBuffer != nullptr) mUploadBuffer-\u003eUnmap(0, nullptr); mMappedData = nullptr; Unmap 的第一个参数是子资源索引，指定了将被取消映射的子资源。若取消映射的是缓冲区，则将其置为 0。第二个参数是个可选项，是一个指向 D3D12_RANGE 结构体的指针，用于描述取消映射的内存范围，若将它指定为空指针，则取消整个资源的映射 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:6:2","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"上传缓冲区辅助函数 将上传缓冲区的相关操作简单地封装一下，使用起来会更加方便。 我们在 UploadBuffer.h 文件中定义了下面这个类，令上传缓冲区的相关处理工作更加轻松。 它替我们实现了上传缓冲区资源的构造与析构函数、处理资源的映射和取消映射操作，还提供了 CopyData 方法来更新缓冲区内的特定元素。 在需要通过 CPU 修改上传缓冲区中数据的时候（例如，当观察矩阵有了变化），便可以使用 CopyData 注 意，此类可用于各种类型的上传缓冲区，而并非只针对常量缓冲区。当用此类管理常量缓冲区时，我们就需要通过构造函数参数 isConstantBuffer 来对此加以描述。另外，如果此类中存储的是常量缓冲 区，那么其中的构造函数将自动填充内存，使每个常量缓冲区的大小都成为 256B 的整数倍。 template\u003ctypename T\u003e class UploadBuffer { public: UploadBuffer(ID3D12Device* device, UINT elementCount, bool isConstantBuffer) : mIsConstantBuffer(isConstantBuffer) { mElementByteSize = sizeof(T); // 常量缓冲区的大小为 256B 的整数倍。这是因为硬件只能按 m*256B 的偏移量和 n*256B 的数据 // 长度这两种规格来查看常量数据 // typedef struct D3D12_CONSTANT_BUFFER_VIEW_DESC { // D3D12_GPU_VIRTUAL_ADDRESS BufferLocation; // 256 的整数倍 // UINT SizeInBytes; // 256 的整数倍 // } D3D12_CONSTANT_BUFFER_VIEW_DESC; if(isConstantBuffer) mElementByteSize = d3dUtil::CalcConstantBufferByteSize(sizeof(T)); ThrowIfFailed( device-\u003eCreateCommittedResource( \u0026CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD), D3D12_HEAP_FLAG_NONE, \u0026CD3DX12_RESOURCE_DESC::Buffer(mElementByteSize*elementCount), D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(\u0026mUploadBuffer))); ThrowIfFailed(mUploadBuffer-\u003eMap(0, nullptr, reinterpret_cast\u003cvoid**\u003e(\u0026mMappedData)) ); // 只要还会修改当前的资源，我们就无须取消映射 // 但是，在资源被 GPU 使用期间，我们千万不可向该资源进行写操作（所以必须借助于同步技术） } UploadBuffer(const UploadBuffer\u0026 rhs) = delete; UploadBuffer\u0026 operator=(const UploadBuffer\u0026 rhs) = delete; ~UploadBuffer() { if(mUploadBuffer != nullptr) mUploadBuffer-\u003eUnmap(0, nullptr); mMappedData = nullptr; } ID3D12Resource* Resource()const { return mUploadBuffer.Get(); } void CopyData(int elementIndex, const T\u0026 data) { memcpy(\u0026mMappedData[elementIndex*mElementByteSize], \u0026data, sizeof(T)); } private: Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e mUploadBuffer; BYTE* mMappedData = nullptr; UINT mElementByteSize = 0; bool mIsConstantBuffer = false; }; 一般来讲，物体的世界矩阵将随其移动 / 旋转 / 缩放而改变，观察矩阵随虚拟摄像机的移动/旋转而改 变，投影矩阵随窗口大小的调整而改变。 如果用户可以通过鼠标来旋转和移动摄像机， 变换观察角度。我们就要在每一帧都要用 Update 函数，以新的观察矩阵来更新“世界—观察—投影” 3 种矩阵组合而成的复合矩阵 void BoxApp::OnMouseMove(WPARAM btnState, int x, int y) { if((btnState \u0026 MK_LBUTTON) != 0) { // 根据鼠标的移动距离计算旋转角度，令每个像素按此角度的 1/4 进行旋转 float dx = XMConvertToRadians(0.25f*static_cast\u003cfloat\u003e(x - mLastMousePos.x)); float dy = XMConvertToRadians(0.25f*static_cast\u003cfloat\u003e(y - mLastMousePos.y)); // 根据鼠标的输入来更新摄像机绕立方体旋转的角度 mTheta += dx; mPhi += dy; // 限制角度 mPhi 的范围 mPhi = MathHelper::Clamp(mPhi, 0.1f, MathHelper::Pi - 0.1f); } else if((btnState \u0026 MK_RBUTTON) != 0) { // 使场景中的每个像素按鼠标移动距离的 0.005 倍进行缩放 float dx = 0.005f*static_cast\u003cfloat\u003e(x - mLastMousePos.x); float dy = 0.005f*static_cast\u003cfloat\u003e(y - mLastMousePos.y); // 根据鼠标的输入更新摄像机的可视范围半径 mRadius += dx - dy; // 限制可视半径的范围 mRadius = MathHelper::Clamp(mRadius, 3.0f, 15.0f); } mLastMousePos.x = x; mLastMousePos.y = y; } void BoxApp::Update(const GameTimer\u0026 gt) { // 由球坐标（也有译作球面坐标）转换为笛卡儿坐标 float x = mRadius*sinf(mPhi)*cosf(mTheta); float z = mRadius*sinf(mPhi)*sinf(mTheta); float y = mRadius*cosf(mPhi); // 构建观察矩阵 XMVECTOR pos = XMVectorSet(x, y, z, 1.0f); XMVECTOR target = XMVectorZero(); XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f); XMMATRIX view = XMMatrixLookAtLH(pos, target, up); XMStoreFloat4x4(\u0026mView, view); XMMATRIX world = XMLoadFloat4x4(\u0026mWorld); XMMATRIX proj = XMLoadFloat4x4(\u0026mProj); XMMATRIX worldViewProj = world*view*proj; // 用最新的 worldViewProj 矩阵来更新常量缓冲区 ObjectConstants objConstants; XMStoreFloat4x4(\u0026objConstants.WorldViewProj, XMMatrixTranspose(worldViewProj)); mObjectCB-\u003eCopyData(0, objConstants); } ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:6:3","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"常量缓冲区描述符 我们首次通过描述符对象将资源绑定到渲染流水线上。 到目前为止，已经依次介绍 了渲染目标、深度 / 模板缓冲区、顶点缓冲区以及索引缓冲区这几种资源描述符（或称视图）的使用方法， 现在还需利用描述符将常量缓冲区绑定至渲染流水线上。而且常量缓冲区描述符都要存放在以 D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV 类型所建的描述符堆里。这种堆内可以混合存储常 量缓冲区描述符、着色器资源描述符和无序访问（unordered access）描述符 为了存放这些新类型的描 述符，我们需要为之创建以下类型的新式描述符堆： D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc; cbvHeapDesc.NumDescriptors = 1; cbvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV; cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE; cbvHeapDesc.NodeMask = 0; ComPtr\u003cID3D12DescriptorHeap\u003e mCbvHeap md3dDevice-\u003eCreateDescriptorHeap(\u0026cbvHeapDesc, IID_PPV_ARGS(\u0026mCbvHeap)); ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:6:4","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"根签名和描述符表 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:6:5","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"编译着色器 在 Direct3D 中，着色器程序必须先被编译为一种可移植的字节码。接下来，图形驱动程序将获取这 些字节码，并将其重新编译为针对当前系统 GPU 所优化的本地指令[ATI1]。我们可以在运行期间用下列 函数对着色器进行编译。 HRESULT D3DCompileFromFile( LPCWSTR pFileName, const D3D_SHADER_MACRO *pDefines, ID3DInclude *pInclude, LPCSTR pEntrypoint, LPCSTR pTarget, UINT Flags1, UINT Flags2, ID3DBlob **ppCode, ID3DBlob **ppErrorMsgs ); pFileName：我们希望编译的以.hlsl 作为扩展名的 HLSL 源代码文件。 pDefines：在本书中，我们并不使用这个高级选项，因此总是将它指定为空指针。关于此参数的详细信息可参见 SDK 文档。 pInclude：在本书中，我们并不使用这个高级选项，因而总是将它指定为空指针。关于此参 数的详细信息可详见 SDK 文档。 pEntrypoint：着色器的入口点函数名。一个.hlsl 文件可能存有多个着色器程序（例如，一个 顶点着色器和一个像素着色器），所以我们需要为待编译的着色器指定入口点。 pTarget：指定所用着色器类型和版本的字符串。在本博客中，我们采用的着色器模型版本是 5.0 和 5.1。 vs_5_0 与 vs_5_1：表示版本分别为 5.0 和 5.1 的顶点着色器（vertex shader） hs_5_0 与 hs_5_1：表示版本分别为 5.0 和 5.1 的外壳着色器（hull shader） ds_5_0 与 ds_5_1：表示版本分别为 5.0 和 5.1 的域着色器（domain shader） gs_5_0 与 gs_5_1：表示版本分别为 5.0 和 5.1 的几何着色器（geometry shader） ps_5_0 与 ps_5_1：表示版本分别为 5.0 和 5.1 的像素着色器（pixel shader） cs_5_0 与 cs_5_1：表示版本分别为 5.0 和 5.1 的计算着色器（compute shader) Flags1：指示对着色器代码应当如何编译的标志。在 SDK 文档里，这些标志列出得不少，但 是此书中我们仅用两种 D3DCOMPILE_DEBUG：用调试模式来编译着色器 D3DCOMPILE_SKIP_OPTIMIZATION：指示编译器跳过优化阶段（对调试很有用处） Flags2：我们不会用到处理效果文件的高级编译选项，关于它的信息请参见 SDK 文档 ppCode：返回一个指向 ID3DBlob 数据结构的指针，它存储着编译好的着色器对象字节码。 ppErrorMsgs：返回一个指向 ID3DBlob 数据结构的指针。如果在编译过程中发生了错误， 它便会储存报错的字符串 ID3DBlob 类型描述的其实就是一段普通的内存块，这是该接口的两个方法 LPVOID GetBufferPointer：返回指向 ID3DBlob 对象中数据的 void类型的指针。由此 可见，在使用此数据之前务必先要将它转换为适当的类型* SIZE_T GetBufferSize：返回缓冲区的字节大小（即该对象中的数据大小） 为了能够输出错误信息，我们在 d3dUtil.h/.cpp 文件中实现了下列辅助函数在运行时编译着色器： ComPtr\u003cID3DBlob\u003e d3dUtil::CompileShader( const std::wstring\u0026 filename, const D3D_SHADER_MACRO* defines, const std::string\u0026 entrypoint, const std::string\u0026 target) { // 若处于调试模式,则使用调试标志 UINT compileFlags = 0; #if defined(DEBUG) || defined(_DEBUG) compileFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION; #endif HRESULT hr = S_OK; ComPtr\u003cID3DBlob\u003e byteCode = nullptr; ComPtr\u003cID3DBlob\u003e errors; hr = D3DCompileFromFile(filename.c_str(), defines, D3D_COMPILE_STANDARD_FILE_INCLUDE, entrypoint.c_str(), target.c_str(), compileFlags, 0, \u0026byteCode, \u0026errors); // 将错误信息输出到调试窗口 if(errors != nullptr) OutputDebugStringA((char*)errors-\u003eGetBufferPointer()); ThrowIfFailed(hr); return byteCode; } ComPtr\u003cID3DBlob\u003e mvsByteCode = nullptr; ComPtr\u003cID3DBlob\u003e mpsByteCode = nullptr; mvsByteCode = d3dUtil::CompileShader(L\"Shaders\\\\color.hlsl\",nullptr, \"VS\", \"vs_5_0\"); mpsByteCode = d3dUtil::CompileShader(L\"Shaders\\\\color.hlsl\",nullptr, \"PS\", \"ps_5_0\"); HLSL 的错误和警告消息将通过 ppErrorMsgs 参数返回。比方说，如果不小心把 mul 函数拼写错 误，那么我们便会从调试窗口得到类似于下列的错误输出： Shaders\\color.hlsl(29,14-55): error X3004: undeclared identifier 'mu' （Shaders\\color.hlsl(29,14-55): 错误 X3004: 未声明的标识符 'mu'） 仅对着色器进行编译并不会使它与渲染流水线相绑定以供其使用 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:7:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"离线编译 我们不仅可以在运行期间编译着色器，还能够以单独的步骤（例如，将其作为构建整个工程过程中 的一个独立环节，或是将其视为资源内容流水线（asset content pipeline）流程的一部分）离线地（offline） 编译着色器 这样做有原因若干： 对于复杂的着色器来说，其编译过程可能耗时较长。因此，借助离线编译即可缩短应用程序的 加载时间 以便在早于运行时的构建处理期间提前发现编译错误。 对于 Windows 8 应用商店中的应用而言，必须采用离线编译这种方式 我们通常用.cso (即 compiled shader object，已编译的着色器对象)作为已编译着色器的扩展名。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:7:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"生成着色器汇编代码 FXC 程序根据可选参数/Fc 来生成可移植的着色器汇编代码。通过查阅着色器的汇编代码，既可核对着色 器的指令数量，也能了解生成的代码细节——这是为了验证编译器所生成的代码与我们预想的是否一致。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:7:2","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"光栅器状态 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:8:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_RASTERIZER_DESC *当今渲染流水线中的大多阶段都是可编程的，但是有些特定环节却只能接受配置。 例如，用于配置渲 染流水线中光栅化阶段的光栅器状态（rasterizer state）组由结构体 D3D12_RASTERIZER_DESC 来表示: * typedef struct D3D12_RASTERIZER_DESC { D3D12_FILL_MODE FillMode; // 默认值为： D3D12_FILL_MODE_SOLID D3D12_CULL_MODE CullMode; // 默认值为： D3D12_CULL_MODE_BACK BOOL FrontCounterClockwise; // 默认值为： false INT DepthBias; // 默认值为： 0 FLOAT DepthBiasClamp; // 默认值为： 0.0f FLOAT SlopeScaledDepthBias; // 默认值为： 0.0f BOOL DepthClipEnable; // 默认值为： true BOOL MultisampleEnable; // 默认值为： false BOOL AntialiasedLineEnable; // 默认值为： false UINT ForcedSampleCount; // 默认值为： 0 // 默认值为： D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF D3D12_CONSERVATIVE_RASTERIZATION_MODE ConservativeRaster; } D3D12_RASTERIZER_DESC; FillMode：将此参数设置为D3D12_FILL_MODE_WIREFRAME 是采用线框模式进行渲染，而设置 为 D3D12_FILL_MODE_SOLID 则是使用实体模式进行渲染。默认设置为实体渲染模式。 CullMode：指定 D3D12_CULL_MODE_NONE 是禁用剔除操作，D3D12_CULL_MODE_BACK 是 剔除背面朝向的三角形，而 D3D12_CULL_MODE_FRONT 是剔除正面朝向的三角形。默认配置 为剔除背面朝向的三角形 FrontCounterClockwise：如果指定为 false，则根据摄像机的观察视角，将顶点顺序为 顺时针方向的三角形看作正面朝向，而把逆时针绕序的三角形当作背面朝向。相反，如果指定 为 true，则根据摄像机的观察视角，将顶点顺序为逆时针方向的三角形看作正面朝向，而把顺 时针绕序的三角形当作背面朝向。此参数默认值为 false 下列代码展示了如何创建一个开启线框模式，且禁用背面剔除的光栅化状态： CD3DX12_RASTERIZER_DESC rsDesc(D3D12_DEFAULT); rsDesc.FillMode = D3D12_FILL_MODE_WIREFRAME; rsDesc.CullMode = D3D12_CULL_MODE_NONE; CD3DX12_RASTERIZER_DESC 是在扩展自 D3D12_RASTERIZER_DESC 结构体的基础上，又添加 了一些辅助构造函数的工具类。 其中有一个以接收 CD3DX12_DEFAULT 作为参数来创建光栅化状态对象 的构造函数，其实 CD3DX12_DEFAULT 只是一个哑类型（dummy），而此函数的作用是将光栅化状态中 需要被初始化的成员重载为默认值。CD3DX12_DEFAULT① 和 D3D12_DEFAULT 的定义如下： struct CD3DX12_DEFAULT {}; extern const DECLSPEC_SELECTANY CD3DX12_DEFAULT D3D12_DEFAULT; 另外，D3D12_DEFAULT（CD3DX12_DEFAULT）还被广泛地运用于 Direct3D 的其他几种工具类中。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:8:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"流水线状态对象 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:9:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"D3D12_GRAPHICS_PIPELINE_STATE_DESC 到目前为止，我们已经展示过编写输入布局描述、创建顶点着色器和像素着色器，以及配置光栅器状 态组这 3 个步骤，还未曾讲解如何将这些对象绑定到图形流水线上，用以实际绘制图形。大多数控制图形 流水线状态的对象被统称为流水线状态对象（Pipeline State Object，PSO），用 ID3D12PipelineState 接 口来表示。要创建 PSO，我们首先要填写一份描述其细节的 D3D12_GRAPHICS_PIPELINE_STATE_DESC 结构体实例。 typedef struct D3D12_GRAPHICS_PIPELINE_STATE_DESC { ID3D12RootSignature *pRootSignature; D3D12_SHADER_BYTECODE VS; D3D12_SHADER_BYTECODE PS; D3D12_SHADER_BYTECODE DS; D3D12_SHADER_BYTECODE HS; D3D12_SHADER_BYTECODE GS; D3D12_STREAM_OUTPUT_DESC StreamOutput; D3D12_BLEND_DESC BlendState; UINT SampleMask; D3D12_RASTERIZER_DESC RasterizerState; D3D12_DEPTH_STENCIL_DESC DepthStencilState; D3D12_INPUT_LAYOUT_DESC InputLayout; D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyType; UINT NumRenderTargets; DXGI_FORMAT RTVFormats[8]; DXGI_FORMAT DSVFormat; DXGI_SAMPLE_DESC SampleDesc; } D3D12_GRAPHICS_PIPELINE_STATE_DESC; pRootSignature：指向一个与此 PSO 相绑定的根签名的指针。该根签名一定要与此 PSO 指 定的着色器相兼容。 VS：待绑定的顶点着色器。此成员由结构体 D3D12_SHADER_BYTECODE 表示，这个结构体存 有指向已编译好的字节码数据的指针，以及该字节码数据所占的字节大小。 typedef struct D3D12_SHADER_BYTECODE { const void *pShaderBytecode; SIZE_T BytecodeLength; } D3D12_SHADER_BYTECODE; PS：待绑定的像素着色器。 DS：待绑定的域着色器（我们将在后续章节中讲解此类型的着色器）。 HS：待绑定的外壳着色器（我们将在后续章节中讲解此类型的着色器）。 GS：待绑定的几何着色器（我们将在后续章节中讲解此类型的着色器）。 StreamOutput：用于实现一种称作流输出（stream-out）的高级技术。目前我们仅将此字段清零 BlendState：指定混合（blending）操作所用的混合状态。我们将在后续章节中讨论此状态组， 目前仅将此成员指定为默认的 CD3DX12_BLEND_DESC(D3D12_DEFAULT)。 SampleMask：多重采样最多可采集 32 个样本。借此参数的 32 位整数值，即可设置每个采样 点的采集情况（采集或禁止采集）。例如，若禁用了第 5 位（将第 5 位设置为 0），则将不会对 第 5 个样本进行采样。当然，要禁止采集第 5 个样本的前提是，所用的多重采样至少要有 5 个样本。假如一个应用程序仅使用了单采样（single sampling），那么只能针对该参数的第 1 位 进行配置。一般来说，使用的都是默认值 0xffffffff，即表示对所有的采样点都进行采样。 RasterizerState：指定用来配置光栅器的光栅化状态。 DepthStencilState：指定用于配置深度/模板测试的深度/模板状态。我们将在后续章节中对 此状态进行讨论，目前只把它设为默认的 CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT)。 InputLayout：输入布局描述，此结构体中有两个成员：一个由 D3D12_INPUT_ELEMENT_DESC 元素构成的数组，以及一个表示此数组中元素数量的无符号整数。 typedef struct D3D12_INPUT_LAYOUT_DESC { const D3D12_INPUT_ELEMENT_DESC *pInputElementDescs; UINT NumElements; } D3D12_INPUT_LAYOUT_DESC; PrimitiveTopologyType：指定图元的拓扑类型。 typedef enum D3D12_PRIMITIVE_TOPOLOGY_TYPE { D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED = 0, D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT = 1, D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE = 2, D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE = 3, D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH = 4 } D3D12_PRIMITIVE_TOPOLOGY_TYPE; NumRenderTargets：同时所用的渲染目标数量（即 RTVFormats 数组中渲染目标格式的数量）。 RTVFormats：渲染目标的格式。利用该数组实现向多渲染目标同时进行写操作。使用此 PSO 的渲染目标的格式设定应当与此参数相匹配。 DSVFormat：深度/模板缓冲区的格式。使用此 PSO 的深度/模板缓冲区的格式设定应当与 此参数相匹配。 SampleDesc：描述多重采样对每个像素采样的数量及其质量级别。此参数应与渲染目标的对 应设置相匹配。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:9:1","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"ID3D12Device:: CreateGraphicsPipelineState 在 D3D12_GRAPHICS_PIPELINE_STATE_DESC 实例填写完毕后，我们即可用 ID3D12Device:: CreateGraphicsPipelineState 方法来创建 ID3D12PipelineState 对象。 ComPtr\u003cID3D12RootSignature\u003e mRootSignature; std::vector\u003cD3D12_INPUT_ELEMENT_DESC\u003e mInputLayout; ComPtr\u003cID3DBlob\u003e mvsByteCode; ComPtr\u003cID3DBlob\u003e mpsByteCode; ... D3D12_GRAPHICS_PIPELINE_STATE_DESC psoDesc; ZeroMemory(\u0026psoDesc, sizeof(D3D12_GRAPHICS_PIPELINE_STATE_DESC)); psoDesc.InputLayout = { mInputLayout.data(), (UINT)mInputLayout.size() }; psoDesc.pRootSignature = mRootSignature.Get(); psoDesc.VS = { reinterpret_cast\u003cBYTE*\u003e(mvsByteCode-\u003eGetBufferPointer()), mvsByteCode-\u003eGetBufferSize() }; psoDesc.PS = { reinterpret_cast\u003cBYTE*\u003e(mpsByteCode-\u003eGetBufferPointer()), mpsByteCode-\u003eGetBufferSize() }; psoDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT); psoDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT); psoDesc.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC(D3D12_DEFAULT); psoDesc.SampleMask = UINT_MAX; psoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE; psoDesc.NumRenderTargets = 1; psoDesc.RTVFormats[0] = mBackBufferFormat; psoDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1; psoDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - 1) : 0; psoDesc.DSVFormat = mDepthStencilFormat; ComPtr\u003cID3D12PipelineState\u003e mPSO; md3dDevice-\u003eCreateGraphicsPipelineState(\u0026psoDesc, IID_PPV_ARGS(\u0026mPSO))); ID3D12PipelineState 对象集合了大量的流水线状态信息。为了保证性能，我们将所有这些对 象都集总在一起，一并送至渲染流水线。 通过这样的一个集合，Direct3D 便可以确定所有的状态是否彼 此兼容，而驱动程序则能够据此而提前生成硬件本地指令及其状态。 并非所有的渲染状态都封装于 PSO 内，如视口（viewport）和裁剪矩形（scissor rectangle）等 属性就独立于 PSO。由于将这些状态的设置与其他的流水线状态分隔开来会更有效，所以把它们 强行集中在 PSO 内也并不会为之增添任何优势。 *Direct3D 实质上就是一种状态机（state machine），里面的事物会保持它们各自的状态，直到我们将 其改变。如果我们以不同的 PSO 去绘制不同物体，则需要像下面那样来组织代码: * // 重置命令列表并指定初始 PSO mCommandList-\u003eReset(mDirectCmdListAlloc.Get(), mPSO1.Get()); /* ……使用 PSO 1 绘制物体…… */ // 改变 PSO mCommandList-\u003eSetPipelineState(mPSO2.Get()); /* ……使用 PSO 2 绘制物体…… */ // 改变 PSO mCommandList-\u003eSetPipelineState(mPSO3.Get()); /* ……使用 PSO 3 绘制物体…… */ 换句话说，如果把一个 PSO 与命令列表相绑定，那么，在我们设置另一个 PSO 或重置命令列表之 前，会一直沿用当前的 PSO 绘制物体。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:9:2","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"几何图形辅助结构体 我们通过创建一个同时存有顶点缓冲区和索引缓冲区的结构体来方便地定义多个几何体 另外，借此结构体即可将顶点和索引数据置于系统内存之中，以供 CPU 读取 例如，执行拾取（picking）和碰撞检测（collision detection）这样的工作就需要 CPU 来访问几何体数据。 再者，该结构体还缓存了顶点缓冲 区和索引缓冲区的一些重要属性（例如格式和每个顶点项所占用的字节数），并提供了返回缓冲区视图的方法。 当需要定义多个几何体时，我们就使用下面的 MeshGeometry结构体 // 利用 SubmeshGeometry 来定义 MeshGeometry 中存储的单个几何体 // 此结构体适用于将多个几何体数据存于一个顶点缓冲区和一个索引缓冲区的情况 // 它提供了对存于顶点缓冲区和索引缓冲区中的单个几何体进行绘制所需的数据和偏移量，我们可以据此来 // 实现图 6.3 中所描绘的技术 struct SubmeshGeometry { UINT IndexCount = 0; UINT StartIndexLocation = 0; INT BaseVertexLocation = 0; // 通过此子网格来定义当前 SubmeshGeometry 结构体中所存几何体的包围盒（bounding box）。我们 // 将在本书的后续章节中使用此数据 DirectX::BoundingBox Bounds; }; struct MeshGeometry { // 指定此几何体网格集合的名称，这样我们就能根据此名找到它 std::string Name; // 系统内存中的副本。由于顶点/索引可以是泛型格式（具体格式依用户而定），所以用 Blob 类型来表示 // 待用户在使用时再将其转换为适当的类型 Microsoft::WRL::ComPtr\u003cID3DBlob\u003e VertexBufferCPU = nullptr; Microsoft::WRL::ComPtr\u003cID3DBlob\u003e IndexBufferCPU = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e VertexBufferGPU = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e IndexBufferGPU = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e VertexBufferUploader = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e IndexBufferUploader = nullptr; // 与缓冲区相关的数据 UINT VertexByteStride = 0; UINT VertexBufferByteSize = 0; DXGI_FORMAT IndexFormat = DXGI_FORMAT_R16_UINT; UINT IndexBufferByteSize = 0; // 一个 MeshGeometry 结构体能够存储一组顶点/索引缓冲区中的多个几何体 // 若利用下列容器来定义子网格几何体，我们就能单独地绘制出其中的子网格（单个几何体） std::unordered_map\u003cstd::string, SubmeshGeometry\u003e DrawArgs; D3D12_VERTEX_BUFFER_VIEW VertexBufferView()const { D3D12_VERTEX_BUFFER_VIEW vbv; vbv.BufferLocation = VertexBufferGPU-\u003eGetGPUVirtualAddress(); vbv.StrideInBytes = VertexByteStride; vbv.SizeInBytes = VertexBufferByteSize; return vbv; } D3D12_INDEX_BUFFER_VIEW IndexBufferView()const { D3D12_INDEX_BUFFER_VIEW ibv; ibv.BufferLocation = IndexBufferGPU-\u003eGetGPUVirtualAddress(); ibv.Format = IndexFormat; ibv.SizeInBytes = IndexBufferByteSize; return ibv; } // 待数据上传至 GPU 后，我们就能释放这些内存了 void DisposeUploaders() { VertexBufferUploader = nullptr; IndexBufferUploader = nullptr; } }; ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:10:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"小结 除了空间位置信息，Direct3D 中的顶点还可以存储其他类型的属性数据。为了创建自定义的顶 点格式，我们首先要将选定的顶点数据定义为一个结构体。待顶点结构体定义好后，便可用输 入布局描述（D3D12_INPUT_LAYOUT_DESC）向 Direct3D 提供其细节。输入布局描述由两部 分组成：一个 D3D12_INPUT_ELEMENT_DESC 元素构成的数组，一个记录该数组中元素个数 的无符号整数。D3D12_INPUT_ELEMENT_DESC 数组中的元素要与顶点结构体中的成员一一对 应。事实上，输入布局描述为结构体 D3D12_GRAPHICS_PIPELINE_STATE_DESC 中的一个 字段，这就是说，它实为 PSO 的一个组成部分，用于与顶点着色器输入签名进行格式的比对验 证。因此，当 PSO 与渲染流水线绑定时，输入布局也将以 PSO 组成元素的身份随 PSO 与渲染 流水线的 IA 阶段相绑定。 为了使 GPU 可以访问顶点/索引数组，便需要将其置于一种名为缓冲区（buffer）的资源之内。顶 点数据与索引数据的缓冲区分别称为顶点缓冲区（vertex buffer）和索引缓冲区（index buffer）。缓 冲区用接口 ID3D12Resource 表示，要创建缓冲区资源需要填写 D3D12_RESOURCE_DESC 结 构体，再调用 ID3D12Device::CreateCommittedResource 方法。顶点缓冲区的视图与索 引缓冲区的视图分别用 D3D12_VERTEX_BUFFER_VIEW 与 D3D12_INDEX_BUFFER_VIEW 结构 体加以描述。随后，即可通过 ID3D12GraphicsCommandList::IASetVertexBuffers 方法与 ID3D12GraphicsCommandList::IASetIndexBuffer方法分别将顶点缓冲区与索引缓冲区绑定 到渲染流水线的 IA 阶段。最后，要绘制非索引（non-indexed）描述的几何体（即以顶点数据来绘 制的几何体）可借助 ID3D12GraphicsCommandList::DrawInstanced 方法，而以索引描述的 几何体可由 ID3D12GraphicsCommandList::DrawIndexedInstanced 方法进行绘制。 顶点着色器是一种用 HLSL 编写并在 GPU 上运行的程序，它以单个顶点作为输入与输出。每个 待绘制的顶点都要流经顶点着色器阶段。这使得程序员能够在此以顶点为基本单位进行处理， 继而获取多种多样的渲染效果。从顶点着色器输出的数据将传至渲染流水线的下一个阶段。 常量缓冲区是一种 GPU 资源（ID3D12Resource），其数据内容可供着色器程序引用。它们被 创建在上传堆（upload heap）而非默认堆（default heap）中。因此，应用程序可通过将数据从系 统内存复制到显存中来更新常量缓冲区。如此一来，C++应用程序就可与着色器通信，并更新 常量缓冲区内着色器所需的数据。例如，C++程序可以借助这种方式对着色器所用的“世界— 观察—投影”矩阵进行更改。在此，我们建议读者考量数据更新的频繁程度，以此为依据来创 建不同的常量缓冲区。效率乃是划分常量缓冲区的动机。在对一个常量缓冲区进行更新的时 候，其中的所有变量都会随之更新，正所谓牵一发而动全身。因此，应根据更新频率将数据 有效地组织为不同的常量缓冲区，以此来避免无谓的冗余的更新，从而提高效率。 像素着色器是一种用 HLSL 编写且运行在 GPU 上的程序，它以经过插值计算所得到的顶点数据 作为输入，待处理后，再输出与之对应的一种颜色值。由于硬件优化的原因，某些像素片段可能还未到像素着色器就已被渲染流水线剔除了（例如采用了提前深度剔除技术，early-z rejection）。 像素着色器可使程序员以像素为基本单位进行处理，从而获得变化万千的渲染效果。从像素着 色器输出的数据将被移交至渲染流水线的下一个阶段。 大多数控制图形流水线状态的 Direct3D 对象都被指定到了一种称作流水线状态对象（pipeline state object，PSO）的集合之中，并用 ID3D12PipelineState 接口来表示。我们将这些对象 集总起来再统一对渲染流水线进行设置，是出于对性能因素的考虑。这样一来，Direct3D 就能 验证所有的状态是否彼此兼容，而驱动程序也将可以提前生成硬件本地指令及其状态。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:11:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业大纲 写出与下列顶点结构体所对应的 D3D12_INPUT_ELEMENT_DESC 数组： struct Vertex { XMFLOAT3 Pos; XMFLOAT3 Tangent; XMFLOAT3 Normal; XMFLOAT2 Tex0; XMFLOAT2 Tex1; XMCOLOR Color; }; 改写彩色立方体演示程序，这次使用两个顶点缓冲区（以及两个输入槽）来向渲染流水线传送 顶点数据。这两个顶点缓冲区，一个用来存储位置元素，另一个用来储存颜色元素。此时，我们应当利用两个顶点结构体以下列方式分别存放这两种不同的数据： struct VPosData { XMFLOAT3 Pos; }; struct VColorData { XMFLOAT4 Color; }; 我们编写的 D3D12_INPUT_ELEMENT_DESC 数组应当是这样子的： D3D12_INPUT_ELEMENT_DESC vertexDesc[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0} }; 此后，位置元素会被连接到输入槽 0，而颜色元素将被连接到输入槽 1。而且我们还可以发现， 对于这两种元素来说，它们的 D3D12_INPUT_ELEMENT_DESC::AlignedByteOffset 字段皆为 0。这是因为位置和颜色这两种元素不再共用输入槽，而是独享各自的输入槽。 接下来，我们再用 ID3D12GraphicsCommandList::IASetVertexBuffers 方法，将两个顶点缓冲区 分别与寄存器槽 0 和槽 1 相绑定。自此，Direct3D 也将用来自不同输入槽的元素来装配顶点（合成顶点数据）。这种将元素分槽存放的方法也可用于程序优化。 例如，在实现阴影贴图算法 （shadow mapping algorithm，或称阴影映射算法）的过程中，我们需要在每一帧绘制场景两次： 第一次是从光源的视角渲染场景（shadow pass，阴影绘制过程） 第二次是从主摄像机的视角 来渲染场景（main pass，主渲染过程）。阴影绘制过程只需要用到位置数据和纹理坐标（为了对 几何体进行 alpha 测试）。所以，我们可以将顶点数据分到两个槽中：一个槽容纳位置信息和纹理坐标，另一个槽存储顶点的其他属性（如法向量和切向量）。如此一来，阴影绘制过程所需的顶点数据只用一个数据流即可（存有位置信息和纹理坐标的那组数据），从而节省阴影绘制过程 所消耗的数据带宽。而主渲染过程将同时使用这两个顶点输入槽，以获得所需的全部顶点数据。 考虑到程序性能，建议您尽量减少输入槽的使用数量，最好不要多于 3 个。 绘制： （a）图 5.13a 中所示的点列表。 （b）图 5.13b 中所示的线条带。 （c）图 5.13c 中所示的线列表。 （d）图 5.13d 中所示的三角形带。 （e）图 5.14a 中所示的三角形列表。 构造图 6.8 所示的金字塔的顶点列表和索引列表，并将其绘制出来：令塔顶为红色，其他底座顶点为绿色。 查阅本章的“Box”（立方体）演示程序代码可知，我们只对立方体的顶点处指定了颜色。运行此程序后会发现立方体却处处都呈现出了不同的色彩，那么问题就来了：构成立方体表面的三角形内的像素是怎样得到各自像素颜色的呢？ 修改“Box”演示程序，在顶点着色器将诸顶点变换到世界空间之前，先对顶点应用下列变换。 vin.PosL.xy += 0.5f*sin(vin.PosL.x)*sin(3.0f*gTime); vin.PosL.z *= 0.6f + 0.4f*sin(2.0f*gTime); 为此，我们需要在程序中添加一个常量缓冲区变量gTime，此变量为函数GameTimer::TotalTime() 的当前值。这段代码将通过时间函数驱动各顶点，使立方体的形状随正弦函数周期性地发生改变。 将立方体和练习 4 中金字塔的顶点合并到一个大的顶点缓冲区内，再将两者的索引合并至一个大的索引缓冲区中（但是不要更新索引值）。接着，再根据上述改动来依次调整调用 ID3D12GraphicsCommandList::DrawIndexedInstanced 方法的参数，以正确地绘制立方体和金字塔。并通过设置世界变换矩阵，使两者在世界空间中互不相交。 修改“Box”演示程序，以线框模式来渲染立方体。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:12:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业一 写出与下列顶点结构体所对应的 D3D12_INPUT_ELEMENT_DESC 数组： struct Vertex { XMFLOAT3 Pos; XMFLOAT3 Tangent; XMFLOAT3 Normal; XMFLOAT2 Tex0; XMFLOAT2 Tex1; XMCOLOR Color; }; D3D12_INPUT_ELEMENT_DESC desc2[] = { {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"TANGENT\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"NORMAL\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 24, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"TEXCOORD\", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 36, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"TEXCOORD\", 1, DXGI_FORMAT_R32G32_FLOAT, 0, 44, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0}, {\"COLOR\", 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, 52, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0} } ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:13:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业二 改写彩色立方体演示程序，这次使用两个顶点缓冲区（以及两个输入槽）来向渲染流水线传送 顶点数据。这两个顶点缓冲区，一个用来存储位置元素，另一个用来储存颜色元素。（详细题目及解释看题目大纲） // d3dUtil.h struct MeshGeometry { std::string Name; Microsoft::WRL::ComPtr\u003cID3DBlob\u003e VertexBufferCPU = nullptr; Microsoft::WRL::ComPtr\u003cID3DBlob\u003e ColorBufferCPU = nullptr; Microsoft::WRL::ComPtr\u003cID3DBlob\u003e IndexBufferCPU = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e VertexBufferGPU = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e ColorBufferGPU = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e IndexBufferGPU = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e VertexBufferUploader = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e ColorBufferUploader = nullptr; Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e IndexBufferUploader = nullptr; UINT VertexByteStride = 0; UINT VertexBufferByteSize = 0; UINT ColorByteStride = 0; UINT ColorBufferByteSize = 0; DXGI_FORMAT IndexFormat = DXGI_FORMAT_R16_UINT; UINT IndexBufferByteSize = 0; std::unordered_map\u003cstd::string, SubmeshGeometry\u003e DrawArgs; D3D12_VERTEX_BUFFER_VIEW PositionBufferView() const { D3D12_VERTEX_BUFFER_VIEW vbv; vbv.BufferLocation = VertexBufferGPU-\u003eGetGPUVirtualAddress(); vbv.StrideInBytes = VertexByteStride; vbv.SizeInBytes = VertexBufferByteSize; return vbv; } D3D12_VERTEX_BUFFER_VIEW ColorBufferView() const { D3D12_VERTEX_BUFFER_VIEW vbv; vbv.BufferLocation = ColorBufferGPU-\u003eGetGPUVirtualAddress(); vbv.StrideInBytes = ColorByteStride; vbv.SizeInBytes = ColorBufferByteSize; return vbv; } D3D12_INDEX_BUFFER_VIEW IndexBufferView()const { D3D12_INDEX_BUFFER_VIEW ibv; ibv.BufferLocation = IndexBufferGPU-\u003eGetGPUVirtualAddress(); ibv.Format = IndexFormat; ibv.SizeInBytes = IndexBufferByteSize; return ibv; } // We can free this memory after we finish upload to the GPU. void DisposeUploaders() { VertexBufferUploader = nullptr; IndexBufferUploader = nullptr; } }; // BoxApp.cpp struct VPosData { XMFLOAT3 Pos; }; struct VColorData { XMFLOAT4 Color; }; void BoxApp::Draw(const GameTimer\u0026 gt) { // ... 其他代码保持不变 ... // 设置顶点缓冲区（现在有两个） D3D12_VERTEX_BUFFER_VIEW vbViews[2] = { mBoxGeo-\u003ePositionBufferView(), mBoxGeo-\u003eColorBufferView() }; mCommandList-\u003eIASetVertexBuffers(0, 2, vbViews); mCommandList-\u003eIASetIndexBuffer(\u0026mBoxGeo-\u003eIndexBufferView()); mCommandList-\u003eIASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); // ... 其他代码保持不变 ... } void BoxApp::BuildShadersAndInputLayout() { // ... 其他代码保持不变 ... mInputLayout = { { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 }, { \"COLOR\", 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 1, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 } }; } void BoxApp::BuildBoxGeometry() { // 位置数据 std::array\u003cVPosData, 8\u003e posVertices = { VPosData({ XMFLOAT3(-1.0f, -1.0f, -1.0f) }), VPosData({ XMFLOAT3(-1.0f, +1.0f, -1.0f) }), VPosData({ XMFLOAT3(+1.0f, +1.0f, -1.0f) }), VPosData({ XMFLOAT3(+1.0f, -1.0f, -1.0f) }), VPosData({ XMFLOAT3(-1.0f, -1.0f, +1.0f) }), VPosData({ XMFLOAT3(-1.0f, +1.0f, +1.0f) }), VPosData({ XMFLOAT3(+1.0f, +1.0f, +1.0f) }), VPosData({ XMFLOAT3(+1.0f, -1.0f, +1.0f) }) }; // 颜色数据 std::array\u003cVColorData, 8\u003e colorVertices = { VColorData({ XMFLOAT4(Colors::White) }), VColorData({ XMFLOAT4(Colors::Black) }), VColorData({ XMFLOAT4(Colors::Red) }), VColorData({ XMFLOAT4(Colors::Green) }), VColorData({ XMFLOAT4(Colors::Blue) }), VColorData({ XMFLOAT4(Colors::Yellow) }), VColorData({ XMFLOAT4(Colors::Cyan) }), VColorData({ XMFLOAT4(Colors::Magenta) }) }; // ... 其他代码保持不变 ... // 创建位置顶点缓冲区 ThrowIfFailed(D3DCreateBlob(posVBByteSize, \u0026mBoxGeo-\u003eVertexBufferCPU)); CopyMemory(mBoxGeo-\u003eVertexBufferCPU-\u003eGetBufferPointer(), posVertices.data(), posVBByteSize); mBoxGeo-\u003eVertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(), mCommandList.Get(), posVertices.data(), posVBByteSize, mBoxGeo-\u003eVertexBufferUploader); // 创建颜色顶点缓冲区 ThrowIfFailed(D3DCreateBlob(colorVBByteSize, \u0026mBoxGeo-\u003eColorBufferCPU)); CopyMemory(mBoxGeo-\u003eColorBufferCPU-\u003eGetBufferPointer(), colorVertices.data(), colorVBByteSize); mBoxGeo-\u003eColorBufferGPU = d3dUtil::Crea","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:14:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业三 绘制： （a）图 5.13a 中所示的点列表。 struct VPosData { XMFLOAT3 Pos; }; // 顶点缓冲区 std::array\u003cVPosData, 8\u003e posVertices = { VPosData({ XMFLOAT3(0.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.2f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.4f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(2.0f, 0.5f, 0.0f) }) }; // 索引缓冲区 std::array\u003cstd::uint16_t, 8\u003e indices = { 0, 1, 2, 3, 4, 5, 6, 7 }; mCommandList-\u003eIASetPrimitiveTopology( D3D_PRIMITIVE_TOPOLOGY_POINTLIST ); （b）图 5.13b 中所示的线条带。 struct VPosData { XMFLOAT3 Pos; }; // 顶点缓冲区 std::array\u003cVPosData, 8\u003e posVertices = { VPosData({ XMFLOAT3(0.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.2f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.4f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(2.0f, 0.5f, 0.0f) }) }; // 索引缓冲区 std::array\u003cstd::uint16_t, 8\u003e indices = { 0, 1, 2, 3, 4, 5, 6, 7 }; mCommandList-\u003eIASetPrimitiveTopology( D3D_PRIMITIVE_TOPOLOGY_LINESTRIP ); （c）图 5.13c 中所示的线列表。 struct VPosData { XMFLOAT3 Pos; }; // 顶点缓冲区 std::array\u003cVPosData, 8\u003e posVertices = { VPosData({ XMFLOAT3(0.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.2f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.4f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(2.0f, 0.5f, 0.0f) }) }; // 索引缓冲区 std::array\u003cstd::uint16_t, 8\u003e indices = { 0, 1, 2, 3, 4, 5, 6, 7 }; mCommandList-\u003eIASetPrimitiveTopology( D3D_PRIMITIVE_TOPOLOGY_LINELIST ); （d）图 5.13d 中所示的三角形带。 struct VPosData { XMFLOAT3 Pos; }; // 顶点缓冲区 std::array\u003cVPosData, 8\u003e posVertices = { VPosData({ XMFLOAT3(0.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.2f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.4f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(2.0f, 0.5f, 0.0f) }) }; // 索引缓冲区 std::array\u003cstd::uint16_t, 18\u003e indices = { 0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7 }; mCommandList-\u003eIASetPrimitiveTopology( D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP ); void BoxApp::BuildPSO() { // ... 其他设置保持不变 ... // 修改光栅化状态 - 设置为线框模式 CD3DX12_RASTERIZER_DESC rasterDesc(D3D12_DEFAULT); rasterDesc.FillMode = D3D12_FILL_MODE_WIREFRAME; // 线框模式 rasterDesc.CullMode = D3D12_CULL_MODE_NONE; // 禁用背面剔除 psoDesc.RasterizerState = rasterDesc; // ... 其他设置保持不变 ... } （e）图 5.14a 中所示的三角形列表。 struct VPosData { XMFLOAT3 Pos; }; // 顶点缓冲区 std::array\u003cVPosData, 9\u003e posVertices = { VPosData({ XMFLOAT3(0.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(0.5f, 0.2f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.4f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(1.5f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(2.0f, 0.5f, 0.0f) }), VPosData({ XMFLOAT3(2.0f, 1.0f, 0.0f) }) }; // 索引缓冲区 std::array\u003cstd::uint16_t, 18\u003e indices = { 0, 1, 2, 3, 4, 5, 6, 7, 8 }; mCommandList-\u003eIASetPrimitiveTopology( D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST ); void BoxApp::BuildPSO() { // ... 其他设置保持不变 ... // 修改光栅化状态 - 设置为线框模式 CD3DX12_RASTERIZER_DESC rasterDesc(D3D12_DEFAULT); rasterDesc.FillMode = D3D12_FILL_MODE_WIREFRAME; // 线框模式 rasterDesc.CullMode = D3D12_CULL_MODE_NONE; // 禁用背面剔除 psoDesc.RasterizerState = rasterDesc; // ... 其他设置保持不变 ... } ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:15:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业四 构造图 6.8 所示的金字塔的顶点列表和索引列表，并将其绘制出来：令塔顶为红色，其他底座顶点为绿色。 mCommandList-\u003eIASetPrimitiveTopology( D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP ); struct VPosData { XMFLOAT3 Pos; }; struct VColorData { XMFLOAT4 Color; }; // 位置数据 std::array\u003cVPosData, 9\u003e posVertices = { VPosData({ XMFLOAT3(0.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(0.0f, 2.0f, 0.0f) }), VPosData({ XMFLOAT3(2.0f, 0.0f, 0.0f) }), VPosData({ XMFLOAT3(2.0f, 2.0f, 0.0f) }), VPosData({ XMFLOAT3(1.0f, 1.0f, 3.0f) }), }; // 颜色数据 std::array\u003cVColorData, 9\u003e colorVertices = { VColorData({ XMFLOAT4(Colors::Green) }), VColorData({ XMFLOAT4(Colors::Green) }), VColorData({ XMFLOAT4(Colors::Green) }), VColorData({ XMFLOAT4(Colors::Green) }), VColorData({ XMFLOAT4(Colors::Red) }), }; std::array\u003cstd::uint16_t, 18\u003e indices = { // 底部 0, 1, 2, 1, 2, 3, // 四个侧面三角形 0, 1, 4, 0, 2, 4, 1, 2, 4, 1, 3, 4 }; psoDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT); ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:16:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业五 查阅本章的“Box”（立方体）演示程序代码可知，我们只对立方体的顶点处指定了颜色。运行此程序后会发现立方体却处处都呈现出了不同的色彩，那么问题就来了：构成立方体表面的三角形内的像素是怎样得到各自像素颜色的呢？ 颜色属性仅在顶点处定义。 光栅化阶段自动对顶点颜色插值，填充三角形内部像素。 *插值结果是平滑的，因此立方体表面表现出颜色渐变效果。 这种机制是实时渲染的基础，不仅用于颜色，也适用于纹理坐标、法线等其他顶点属性。 ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:17:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业六 修改“Box”演示程序，在顶点着色器将诸顶点变换到世界空间之前，先对顶点应用下列变换。 vin.PosL.xy += 0.5f*sin(vin.PosL.x)*sin(3.0f*gTime); vin.PosL.z *= 0.6f + 0.4f*sin(2.0f*gTime); 为此，我们需要在程序中添加一个常量缓冲区变量gTime，此变量为函数GameTimer::TotalTime() 的当前值。这段代码将通过时间函数驱动各顶点，使立方体的形状随正弦函数周期性地发生改变。 struct ObjectConstants { XMFLOAT4X4 WorldViewProj = MathHelper::Identity4x4(); float gTime = 0.0f; // 新增时间变量 XMFLOAT3 padding; // 用于对齐（常量缓冲区需16字节对齐） }; void BoxApp::Update(const GameTimer\u0026 gt) { // ... 其他设置保持不变 ... ObjectConstants objConstants; XMStoreFloat4x4(\u0026objConstants.WorldViewProj, XMMatrixTranspose(worldViewProj)); objConstants.gTime = gt.TotalTime(); // 传递时间值 mObjectCB-\u003eCopyData(0, objConstants); } // color.hlsl //*************************************************************************************** // color.hlsl by Frank Luna (C) 2015 All Rights Reserved. // // Transforms and colors geometry. //*************************************************************************************** cbuffer cbPerObject : register(b0) { float4x4 gWorldViewProj; float gTime; // 新增时间变量 }; struct VertexIn { float3 PosL : POSITION; float4 Color : COLOR; }; struct VertexOut { float4 PosH : SV_POSITION; float4 Color : COLOR; }; VertexOut VS(VertexIn vin) { VertexOut vout; // 对顶点位置应用动态变形 vin.PosL.xy += 0.5f * sin(vin.PosL.x) * sin(3.0f * gTime); vin.PosL.z *= 0.6f + 0.4f * sin(2.0f * gTime); // Transform to homogeneous clip space. vout.PosH = mul(float4(vin.PosL, 1.0f), gWorldViewProj); // Just pass vertex color into the pixel shader. vout.Color = vin.Color; return vout; } float4 PS(VertexOut pin) : SV_Target { return pin.Color; } ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:18:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业七 将立方体和练习 4 中金字塔的顶点合并到一个大的顶点缓冲区内，再将两者的索引合并至一个大的索引缓冲区中（但是不要更新索引值）。接着，再根据上述改动来依次调整调用 ID3D12GraphicsCommandList::DrawIndexedInstanced 方法的参数，以正确地绘制立方体和金字塔。并通过设置世界变换矩阵，使两者在世界空间中互不相交。 void BoxApp::BuildBoxGeometry() { // 立方体顶点 (8个顶点) std::array\u003cVertex, 8\u003e cubeVertices = { // 前面 Vertex({ XMFLOAT3(-1.0f, -1.0f, -1.0f), XMFLOAT4(Colors::Red) }), Vertex({ XMFLOAT3(-1.0f, +1.0f, -1.0f), XMFLOAT4(Colors::Red) }), Vertex({ XMFLOAT3(+1.0f, +1.0f, -1.0f), XMFLOAT4(Colors::Red) }), Vertex({ XMFLOAT3(+1.0f, -1.0f, -1.0f), XMFLOAT4(Colors::Red) }), // 后面 Vertex({ XMFLOAT3(-1.0f, -1.0f, +1.0f), XMFLOAT4(Colors::Green) }), Vertex({ XMFLOAT3(-1.0f, +1.0f, +1.0f), XMFLOAT4(Colors::Green) }), Vertex({ XMFLOAT3(+1.0f, +1.0f, +1.0f), XMFLOAT4(Colors::Green) }), Vertex({ XMFLOAT3(+1.0f, -1.0f, +1.0f), XMFLOAT4(Colors::Green) }) }; // 金字塔顶点 (5个顶点) std::array\u003cVertex, 5\u003e pyramidVertices = { Vertex({ XMFLOAT3(0.0f, 0.0f, 0.0f), XMFLOAT4(Colors::Blue) }), Vertex({ XMFLOAT3(0.0f, 2.0f, 0.0f), XMFLOAT4(Colors::Blue) }), Vertex({ XMFLOAT3(2.0f, 0.0f, 0.0f), XMFLOAT4(Colors::Blue) }), Vertex({ XMFLOAT3(2.0f, 2.0f, 0.0f), XMFLOAT4(Colors::Blue) }), Vertex({ XMFLOAT3(1.0f, 1.0f, 3.0f), XMFLOAT4(Colors::Yellow) }) }; // 合并顶点 std::vector\u003cVertex\u003e vertices; vertices.insert(vertices.end(), cubeVertices.begin(), cubeVertices.end()); vertices.insert(vertices.end(), pyramidVertices.begin(), pyramidVertices.end()); // 立方体索引 (36个索引) std::array\u003cstd::uint16_t, 36\u003e cubeIndices = { // 前面 0, 1, 2, 0, 2, 3, // 后面 4, 6, 5, 4, 7, 6, // 左面 4, 5, 1, 4, 1, 0, // 右面 3, 2, 6, 3, 6, 7, // 顶面 1, 5, 6, 1, 6, 2, // 底面 4, 0, 3, 4, 3, 7 }; // 金字塔索引 (18个索引) std::array\u003cstd::uint16_t, 18\u003e pyramidIndices = { // 底部 8, 9, 10, 9, 10, 11, // 四个侧面三角形 8, 9, 12, 8, 10, 12, 9, 10, 12, 10, 11, 12 }; // 合并索引 std::vector\u003cstd::uint16_t\u003e indices; indices.insert(indices.end(), cubeIndices.begin(), cubeIndices.end()); indices.insert(indices.end(), pyramidIndices.begin(), pyramidIndices.end()); const UINT vbByteSize = (UINT)vertices.size() * sizeof(Vertex); const UINT ibByteSize = (UINT)indices.size() * sizeof(std::uint16_t); mBoxGeo = std::make_unique\u003cMeshGeometry\u003e(); mBoxGeo-\u003eName = \"shapeGeo\"; // 创建顶点缓冲区 ThrowIfFailed(D3DCreateBlob(vbByteSize, \u0026mBoxGeo-\u003eVertexBufferCPU)); CopyMemory(mBoxGeo-\u003eVertexBufferCPU-\u003eGetBufferPointer(), vertices.data(), vbByteSize); mBoxGeo-\u003eVertexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(), mCommandList.Get(), vertices.data(), vbByteSize, mBoxGeo-\u003eVertexBufferUploader); // 创建索引缓冲区 ThrowIfFailed(D3DCreateBlob(ibByteSize, \u0026mBoxGeo-\u003eIndexBufferCPU)); CopyMemory(mBoxGeo-\u003eIndexBufferCPU-\u003eGetBufferPointer(), indices.data(), ibByteSize); mBoxGeo-\u003eIndexBufferGPU = d3dUtil::CreateDefaultBuffer(md3dDevice.Get(), mCommandList.Get(), indices.data(), ibByteSize, mBoxGeo-\u003eIndexBufferUploader); mBoxGeo-\u003eVertexByteStride = sizeof(Vertex); mBoxGeo-\u003eVertexBufferByteSize = vbByteSize; mBoxGeo-\u003eIndexFormat = DXGI_FORMAT_R16_UINT; mBoxGeo-\u003eIndexBufferByteSize = ibByteSize; // 立方体子网格 SubmeshGeometry cubeSubmesh; cubeSubmesh.IndexCount = (UINT)cubeIndices.size(); cubeSubmesh.StartIndexLocation = 0; cubeSubmesh.BaseVertexLocation = 0; mBoxGeo-\u003eDrawArgs[\"cube\"] = cubeSubmesh; // 金字塔子网格 SubmeshGeometry pyramidSubmesh; pyramidSubmesh.IndexCount = (UINT)pyramidIndices.size(); pyramidSubmesh.StartIndexLocation = (UINT)cubeIndices.size(); // 接在立方体索引后面 pyramidSubmesh.BaseVertexLocation = (UINT)cubeVertices.size(); // 接在立方体顶点后面 mBoxGeo-\u003eDrawArgs[\"pyramid\"] = pyramidSubmesh; } void BoxApp::Draw(const GameTimer\u0026 gt) { // ... (前面的代码保持不变) // 绘制立方体 XMStoreFloat4x4(\u0026mWorld, XMMatrixTranslation(-2.0f, 0.0f, 0.0f)); // 向左移动立方体 UpdateObjectCBs(); mCommandList-\u003eDrawIndexedInstanced( mBoxGeo-\u003eDrawArgs[\"cube\"].IndexCount, 1, mBoxGeo-\u003eDrawArgs[\"cube\"].StartIndexLocation, mBoxGeo-\u003eDrawArgs[\"cube\"].BaseVertexLocation, 0); // 绘制金字塔 XMStoreFloat4x4(\u0026mWorld, XMMatrixTranslation(+2.0f, 0.0f, 0.0f)); // 向右移动金字塔 UpdateObjectCBs(); mCommandList-\u003eDrawIndexedInstanced( mBoxGeo-\u003eDrawArgs[\"pyramid\"].IndexCount, 1, mBoxGeo-\u003e","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:19:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"作业八 修改“Box”演示程序，以线框模式来渲染立方体。 CD3DX12_RASTERIZER_DESC rasterDesc(D3D12_DEFAULT); rasterDesc.FillMode = D3D12_FILL_MODE_WIREFRAME; // 线框模式 rasterDesc.CullMode = D3D12_CULL_MODE_NONE; // 禁用背面剔除 psoDesc.RasterizerState = rasterDesc; ","date":"2025-02-12","objectID":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/:20:0","tags":["Unreal","DirectX3D"],"title":"绘制3D立方体(上)","uri":"/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93%E4%B8%8A/"},{"categories":["DirectX3D"],"content":"DirectX3D的初始化","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"渲染流水线 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:0:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"3D 视觉即错觉？ 我们都知道物体重叠（object overlap）的概念，即不透明物体能够遮挡住其后侧物体的局部（或整 体），如图 5.4 所示。这是一个重要的概念，它传达了不同物体在场景中的深度顺序关系。而我们在第 4 章 中也已经讨论过如何在 Direct3D 中借助深度缓冲区来确定那些应当受到遮蔽而不是绘制出来的像素。 光照和阴影的处理在刻画 3D 物体的实体形状和立体感中扮演着至关重要的角色。 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:1:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"模型的表示 实际上，实体 3D 对象是借助三角形网格（triangle mesh）来近似表示的，因而我们要以三角形作为 3D 物体建模的基石，通常来讲，模拟一个物体所用的三角形越多，那么模型就与目标物体越接近，这是因为模型会随之获得更为丰富的细节。当然，建模所用的三角形越多，也就需要更强大的计算处理能 力，所以要根据应用受众的硬件性能做出权衡。 除了三角形，点和线也有其用武之地，若要手动列出这些三角形来模拟 3D 物体，实在是一件太麻烦的事儿了。除了最简单的模型， 我们可以使用一种叫作 3D 建模工具（3D modeler）的专用软件，来生成和处理复杂的 3D 对象，流行的建模软件有 3D Studio Max、LightWave 3D、 Maya、Softimage|XSI①和 Blender。其中，Blender 是开源和免费爱好者的福音 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:2:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"计算机色彩基础 计算机显示器中的每个像素发出的都是红、绿、蓝三色混合光 每款显示器所能发出的红、绿、蓝三色光的强度都是有限的。为了便于描述光的强度，我们常将它 量化为范围在 0～1 归一化区间中的值。0 代表无强度，1 则表示强度最大，处于两者之间的值就表示对 应的中间强度 例如，强度值（0.25, 0.67, 1.0）就表明此光线由强度为 25%的红色光、强度为 67%的绿色光以及强度为 100%的蓝色光混合而成 由此例可以看出，我们能用 3D 向量（r, g, b）来表示颜色，其中 0 ≤ r, g, b ≤ 1 ，这 3 种颜色分量分别代表红、绿、蓝三色光在混合光中的强度 颜色运算 向量的部分运算规则在颜色向量上同样适用。例如，我们可以使两个颜色向量相加来得到新的颜色： (0.0, 0.5, 0) + (0, 0.0, 0.25) = (0.0, 0.5, 0.25) 这就是说，通过混合中等强度的绿色和低等强度的蓝色，便会得到深绿色。 也可以通过颜色向量之间的减法运算来获得新的颜色 (1, 1, 1) - (1, 1, 0) = (0, 0, 1) 由上式可以看出，从白色中去掉红色和绿色的成分，便可得到蓝色。 标量乘法也是有效的，请考虑下式: 0.5(1, 1, 1) = (0.5, 0.5, 0.5) 此式将白色的各颜色分量取半，继而得到中等强度的灰色。另外，可通过 2(0.25, 0, 0) = (0.5, 0, 0)运算将 红色分量的强度加倍。 显而易见的是，像点积和叉积这样的运算法则就不适用于颜色向量了 颜色向量也有它们自己专属的颜色运算，即分量式（modulation 或 componentwise）乘法 $$ (c_r, c_g, c_b) \\otimes (k_r, k_g, k_b) = (c_rk_r, c_gk_g, c_bk_b) $$ 这种运算主要应用于光照方程 *例如，假设有颜色为（r, g, b）的入射光线，照射到一个反射 50%红色光、 75%绿色光、25%蓝色光且吸收剩余光的表面。那么，我们就可以据此给出反射光线的颜色: * $$ (r, g, b) \\otimes (0.5, 0.75, 0.25) = (0.5r, 0.75g, 0.25b) $$ 通过此式即可看出，由于此表面会吸收一部分入射光，所以当它照射在该平面上时会损失掉部分颜色强度 在进行颜色运算的过程中，颜色分量有可能会超出 [ 0, 1 ] 这个区间。 如，思考 (1, 0.1, 0.6) + (0, 0.3, 0.5) = (1, 0.4, 1.1) 这个等式。 由于 1.0 代表颜色分量的最大强度，所以任何光的强度都不能超过此值。因此， 我们就只得将值为 1.1 的强度与 1.0 这一上限强度视作等同，将 1.1 钳制（clamp）为 1.0。同样地，显示 器也不能发出强度为负值的光，所以亦应把负的颜色分量（由减法运算所得到的结果）钳制为 0.0 128 位颜色 事实上，我们通常还会用到另一种名为 alpha 分量（alpha component）的颜色分量。alpha 分量常用于表示颜色的不透明度 （opacity。值为 0.0 表示完全透明，值为 1.0 表示不透明），它在混合（blending）技术中起到了至关重要的作用。 这就是说， 把 alpha 分量算在内的话，我们就可以用 4D 向量(r, g, b, a)来表示每一种颜色，分量需要满足0 ≤ r, g, b, a≤ 1 。 为了用 128 位（128bit）数据来表示一种颜色，每个分量都要使用浮点值 由于每种颜色刚好能用数学上的 4D 向量来表示，所以我们也就能在代码中用 XMVECTOR 类型来描述它们 32位颜色 为了用32 位（32bit）数据表示一种颜色，每个分量仅能分配到 1 个字节。 因此，每个占用 8 位字节的颜色 分量就可以分别描述256 种不同的颜色强度——0 代表无强度，255 是最大强度，处于两者之间的值也就表示相 应的中间强度。 每种颜色分量占用空间虽然看起来很小，但是它们的全部组合（256 × 256 × 256 = 16 777 216 ） 却能表示出千万种不同的颜色 DirectXMath 库（#include ) 在 DirectX::PackedVector 命名空间中提供了下面的结构用于存储 32 位颜色 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:3:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"渲染流水线概述 若给出某个 3D 场景的几何描述，并在其中架设一台具有确定位置和朝向的虚拟摄像机，那么渲染 流水线（rendering pipeline）是以此摄像机为观察视角而生成 2D 图像的一系列完整步骤。 图5.11 左侧展 示的是组成渲染流水线的所有阶段，而右侧则是显存资源 从资源内存池指向渲染流水线阶段的箭头， 表示该阶段可以访问资源并以此作为输入 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:4:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"输入装配器阶段 输入装配器（Input Assembler，IA）阶段会从显存中读取几何数据（顶点和索引，vertex and index），再将它们装配为几何图元（geometric primitive，亦译作几何基元，如三角形和线条这种构成图形的基本元素）。 简单来说，我们是通过索引来定义如何将顶点装配在一起，从而构成图元的方法 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:5:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"顶点 在数学中，三角形的顶点是两条边的交点；线段的顶点是它的两个端点；而对于单个的点来说，它本身就是一个顶点 顶点除了空间位置以外, Direct3D 中的顶点还可以包含其他 信息，这使我们能够利用它来表现出更为复杂的渲染效果 例如，我们可以为顶点添加法向量，以实现光照效果。也可以为顶点添加纹理坐标，从而实现纹理贴图。 Direct3D 为用户自定义顶点格式提供了很高的灵活性（即它允许我们定义顶点结构体中的分量） ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:5:1","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"图元拓扑 Direct3D 中，我们要通过一种名为顶点缓冲区（vertex buffer）的特殊数据结构，将顶点与渲染流水线相绑定 顶点缓冲区利用连续的内存来存储一系列顶点。可是，仅凭这一点并不能说明这些顶点究竟如何组成几何图元 例如，我们应将顶点缓冲区内的顶点两两一组解释成线段，还是每 3 个一组解释 为三角形呢？ 对此，我们要通过指定图元拓扑（primitive topology，或称基元拓扑）来告知 Direct3D 如 何用顶点数据来表示几何图元 点列表 通过枚举项 D3D_PRIMITIVE_TOPOLOGY_POINTLIST 来指定点列表（point list）。当使用点列表 拓扑时，所有的顶点都将在绘制调用的过程中被绘制为一个单独的点 线条带 通过枚举项 D3D_PRIMITIVE_TOPOLOGY_LINESTRIP 来指定线条带（line strip）。在使用线条带 拓扑时，顶点将在绘制调用的过程中被连接为一系列的连续线段（如图 5.13b 所示）。所以，在这种拓扑 模式下，若有 n+1 个顶点就会生成 n 条线段 线列表 通过枚举项 D3D_PRIMITIVE_TOPOLOGY_LINELIST 来指定线列表（line list）。当使用线列表拓扑 时，每对顶点在绘制调用的过程中都会组成单独的线段（如图 5.13c 所示）。所以 2n 个顶点就会生成 n 条线段。线列表与线条带的区别是：线列表中的线段可以彼此分开，而线条带中的线段则是相连的。如 果线段相连的话，绘制同样数量的线段便会占用更少的顶点，因为每个处于线条带中间位置的顶点都可以同时被两条线段所共用 三角形带 通过枚举项 D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP 来指定三角形带（triangle strip）。当使用 三角形带拓扑时，所绘制的三角形将像图 5.13d 所示的那样被连接成带状。可以看到，在这种三角形连接的 结构中，处于中间位置的顶点将被相邻的三角形所共同使用。因此，利用 n 个顶点即可生成 n−2 个三角形 三角形列表 通过枚举项 D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST 来指定三角形列表（triangle list）。当使用三角 形列表拓扑时，在绘制调用的过程中会将每 3 个顶点装配成独立的三角形（如图 5.14a 所示）；所以每 3n 个顶点会生成 n 个三角形。三角形列表与三角形带的区别是：三角形列表中的三角形可以彼此分离，而 三角形带中的三角形则是相连的 具有邻接数据的图元拓扑 对于存有邻接数据的三角形列表而言，每个三角形都有 3 个与之相邻的邻接三角形（adjacent triangle）。图 5.14b 中展示的就是这种图元拓扑。在几何着色器中，往往需要访问这些邻接三角形来实现 特定的几何着色算法。为了使几何着色器可以顺利地获得这些邻接三角形的信息，我们就需要借助顶点 缓冲区与索引缓冲区（index buffer）将它们随主三角形一并提交至渲染流水线。另外，此时一定要将拓 扑类型指定为 D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ，只有这样，渲染流水线才能得知如何以顶点缓冲区中的顶点来构建主三角形及其邻接三角形。注意，邻接图元的顶点只能用作几何着色器的输入数据，却并不会被绘制出来。即便程序没有用到几何着色器，但依旧不会绘制邻接图元 控制点面片列表 D3D_PRIMITIVE_TOPOLOGY_N_CONTROL_POINT_PATCHLIST 拓扑类型表示：将顶点数据解释 为具有 N 个控制点（control point）的面片列表（patch list）。此图元常用于渲染流水线的曲面细分阶段 （tessellation stage，此环节为可选阶段） ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:5:2","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"索引 如前所述，三角形是 3D 实体对象的基本组成部分 为三角形指定顶点顺序是一项十分重要的工作，我们称这个顺序为绕序（winding order） 构成 3D 物体的不同三角形会共用许多顶点, 像八 边形那样的例子可就麻烦了. 因为每个三角形不仅都复制了一份中心顶点 v0，而且此八边 形边上的每个顶点都被两个三角形所同时共用。 一般来说，随着模型细节和复杂度的增加，复制顶点的数量亦会急剧上升。 我们不希望复制顶点数据的原因有两个： 增加内存的需求 — 为什么要多次存储同一个顶点数据呢? 增加图形硬件的处理负荷 — 为什么要多次处理同一个顶点数据呢？ 借助三角形带可以在某些情况下改善顶点的复制问题，前提是这些几何体能够被组织为带状结构。 但是，由于三角形列表更为灵活（该拓扑中的三角形都无需互相连接），所以值得花些心思研究一种利用三角形列表移除重复顶点的设计方案 在此，我们所采用的解决方法是使用索引（index）。 整个工作流程是这样的：先创建一个顶点列表和一个索引列表。在顶点列表中收录一份所有独立的顶点，并在索引列表中存储顶点列表的索引值，这些索引定义了顶点列表中的顶点是如何组合在一起，从而构成三角形的 待处理完顶点列表中那些独立的顶点之后，显卡就能通过索引列表把顶点组合成一系列三角形。 可以看到，我们已经将“复用的顶点数据”转化为索引列表，但是这样做的效果要比之前的方法更好，这是因为： 索引皆是简单的整数，不会像使用整个顶点结构体那样占用更多的内存（而且，随着顶点结构体中分量的不断增多，将会使内存的需求变得更为急迫）。 若辅以适当的顶点缓存排序，则图形硬件将不必再次处理重复使用的顶点，从缓存中直接取得即可（这种情况十分普遍） ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:5:3","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"顶点着色器阶段 待图元被装配完毕后，其顶点就会被送入顶点着色器阶段（vertex shader stage，简记作 VS）。我们可以把顶点着色器看作一种输入与输出数据皆为单个顶点的函数。每个要被绘制的顶点都须经过顶点着色器的处理再送往后续阶段 其中的顶点着色器函数（VertexShader）就是我们要实现的那一部分，因为在这一阶段中对顶点 的操作实际是由 GPU 来执行的，所以速度很快 我们可以利用顶点着色器来实现许多特效，例如变换、光照和位移贴图（displacement mapping，也译作置换贴图。map 有映射之意，因此也有译作位移映射，类似的还有在后面将见到的纹理贴图、法线 贴图等）。请牢记：在顶点着色器中，不但可以访问输入的顶点数据，也能够访问纹理和其他存于显存中 的数据（如变换矩阵与场景的光照信息）。 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:6:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"局部空间和世界空间 局部坐标系通常是一种以目标物体的中心为原点（也有例外，视具体情况 而定），并且坐标轴与该物体对齐的简易便用坐标系 根据物体的位置与朝向，指定其局部空间坐标系的原点和诸坐标轴相对于全局场景坐标系的坐标，再运用坐标变换即可将物体从局部空间变换至世界空间 将局部坐标系内的坐标转换到全局场景坐标系中的过程叫作世界变换（world transform），所使用的变换矩阵名为世界矩阵（world matrix）。 由于场景中每个物体的朝向和位置都可能各不相同，因此它们都有自己特定的世界 矩阵。当每个物体都从各自的局部空间变换到世界空间后，它们的坐标都将位于同一坐标系（即世界坐标系）之中。如果希望直接在世界空间内定义一个物体，那么就可以使用单位世界矩阵（identity world matrix）。 如果 $ Q_w = (Q_x, Q_y, Q_z, 1)， u_w = (u_x, u_y, u_z, 0)，v_w = (v_x, v_y, v_z, 0)和 w_w = (w_x, w_y, w_z, 0) $ 分别 描述了局部空间内的原点、x 轴、y 轴和 z 轴相对于世界空间的齐次坐标，那么从局部空间至世界空间的坐标变换矩阵为： $$ W = \\begin{bmatrix} u_x \u0026 u_y \u0026 u_z \u0026 0 \\\\ \\\\ v_x \u0026 v_y \u0026 v_z \u0026 0 \\\\ \\\\ w_x \u0026 w_y \u0026 w_z \u0026 0 \\\\ \\\\ Q_x \u0026 Q_y \u0026 Q_z \u0026 1 \\end{bmatrix} $$ 可以看到，为了构建一个世界矩阵，我们必须弄清局部空间中原点和各坐标轴相对于世界空间的坐标关系。但这样做有时并不简单亦不直观。 一种更常用的办法是定义一系列的变换组合 W，即 W = SRT。 首先，缩放矩阵 S 将物体缩放到世界空间；其次，旋转矩阵 R 用来定义局部空间相对于世界空间的朝向，最后，平移矩阵 T 定义的是局部空间的原点相对于世界空间的位置。 我们能够将这一系列变换视为一种坐标变换，而矩阵 W = SRT 中的行向量则分别存储的是局部空间的 x 轴、y 轴、z 轴及原点相对于全局空间的的齐次坐标。 示例 假设我们在局部空间定义了一个单位正方形，其最小点和最大点的坐标分别为(−0.5, 0, −0.5)与(0.5, 0, 0.5)。 现在要求出一个世界矩阵，使此正方形在世界空间中的边长为 2，在世界空间 xz 平面内顺时针旋转 45° ，且中心位于世界空间的坐标(10, 0, 10)处。据此，我们构造矩阵 S、R、T 及 W 的过程如下： $$ S = \\begin{bmatrix} 2 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 2 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} ~~~~~~~~~ R = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 -\\frac{\\sqrt{2}}{2} \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 \\frac{\\sqrt{2}}{2} \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} ~~~~~~~~~ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 10 \u0026 0 \u0026 10 \u0026 1 \\end{bmatrix} \\\\ \\\\ W = SRT = \\begin{bmatrix} \\sqrt{2} \u0026 0 \u0026 -\\sqrt{2} \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ \\sqrt{2} \u0026 0 \u0026 \\sqrt{2} \u0026 0 \\\\ \\\\ 10 \u0026 0 \u0026 10 \u0026 1 \\end{bmatrix} $$ 矩阵 W 中的行向量描述了此正方形局部坐标系的诸坐标轴与原点相对于世界空间的坐标 即有 $ u_w = (\\sqrt{2}, 0, -\\sqrt{2}, 0)，v_w = (0, 1, 0, 0)， w_w = (\\sqrt{2}, 0, \\sqrt{2}, 0), Q_w = (10, 0, 10, 1) $ , 如果我们利用矩阵 W 将此局部空间向世界空间进行坐标变换，则最终会把正方形置于题设中所期望的世界空间内的预定位置 $ [-0.5, 0, -0.5, 1]W = [10 - \\sqrt{2}, 0, 0, 1] $ $ [-0.5, 0, +0.5, 1]W = [0, 0, 10 + \\sqrt{2}, 1] $ $ [+0.5, 0, +0.5, 1]W = [10 + \\sqrt{2}, 0, 0, 1] $、 $ [+0.5, 0, -0.5, 1]W = [0, 0, 10 - \\sqrt{2}, 1] $ 此例的亮点是在不指明 $ Q_W、u_W、v_W和 w_W $ 的情况下，直接通过复合一系列简单的变换来建立世界矩阵。这通常比用 $ Q_W、u_W、v_W和 w_W $求取世界矩阵的方法要容易得多，因为我们只需了解物体在世界空间中的大小、朝向以及位置即可 另一种考虑世界变换的观点是把局部空间坐标当作世界 空间坐标来看待（此方法就相当于用单位矩阵进行世界变 换）。这样一来，如果在物体局部空间的原点处建模，那么该 物体也就位于世界空间的原点处。通常来说，我们不大可能 把物体全都建立在世界空间的原点处。所以往往还是要为每个 物体运用一系列变换，使之缩放、旋转，并令其位于世界空间 中的预定位置。从数学角度上来讲，这种变换与由局部空间转 换至世界空间所用的坐标变换矩阵进行的是同一种世界变换 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:6:1","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"观察空间 为了构建场景的 2D 图像，我们必须在场景中架设一台虚拟摄像机。该摄像机确定了观察者可见的视野， 也就是生成 2D 图像所需的场景空间范围。对此，我们先为该摄像机赋予一个图 5.19 所示的局部坐标系（这被称作观察空间（view space），也译作观察坐标系、视图空间、视觉空间（eye space）或摄像机空间（camera space）） 在此坐标系中，该虚拟摄像机位于原点 并沿 z 轴的正方向观察，x 轴指向摄像机的右侧， y 轴则指向摄像机的上方。与相对于世界空间来描述场景中的物体顶点不同，观察空间用于在渲染流水线的后续阶段中描述这些顶点相对于摄像机坐标系的坐标。由世界空间至观察空间的坐标变换称为取景变换（view transform，也译作观察变换、视图变换等），此变换所用的矩阵则称为观察 矩阵（view matrix，亦译作视图矩阵）。 如果 $ Q_w = (Q_x, Q_y, Q_z, 1)， u_w = (u_x, u_y, u_z, 0)，v_w = (v_x, v_y, v_z, 0)和 w_w = (w_x, w_y, w_z, 0) $ 分别 描述了局部空间内的原点、x 轴、y 轴和 z 轴相对于世界空间的齐次坐标，那么从局部空间至世界空间的坐标变换矩阵为： $$ W = \\begin{bmatrix} u_x \u0026 u_y \u0026 u_z \u0026 0 \\\\ \\\\ v_x \u0026 v_y \u0026 v_z \u0026 0 \\\\ \\\\ w_x \u0026 w_y \u0026 w_z \u0026 0 \\\\ \\\\ Q_x \u0026 Q_y \u0026 Q_z \u0026 1 \\end{bmatrix} $$ 然而这并不是我们所期待的变换。刚好相反，我们需要的是从世界空间到观察空间的这一逆变换。 逆变换可由变换矩阵的逆来求得，所以世界空间到观察空间的坐标变换矩阵为 $ W^{−1}。$ 世界坐标系和观察坐标系通常只有位置和朝向这两点差异，所以由观察空间到世界空间的变换可以直接表示为 W = RT（即世界矩阵可以分解为一个旋转矩阵与一个平移矩阵的乘积）。此形式使得上述逆变换更易于计算： $$ V = W^{-1} = (RT^{-1}) = T^{-1}R^{-1} = T^{-1}R^T = \\\\ \\\\ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ -Q_x \u0026 -Q_y \u0026 -Q_z, \u0026 1 \\end{bmatrix} \\begin{bmatrix} u_x \u0026 v_x \u0026 w_x \u0026 0 \\\\ \\\\ u_y \u0026 v_y \u0026 w_y \u0026 0 \\\\ \\\\ u_z \u0026 v_z \u0026 w_z \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} = \\begin{bmatrix} u_x \u0026 v_x \u0026 w_x \u0026 0 \\\\ \\\\ u_y \u0026 v_y \u0026 w_y \u0026 0 \\\\ \\\\ u_z \u0026 v_z \u0026 w_z \u0026 0 \\\\ \\\\ -Q \\cdot \\vec{u} \u0026 -Q \\cdot \\vec{v} \u0026 -Q \\cdot \\vec{w}, \u0026 1 \\end{bmatrix} $$ 现在我们来展示一种用以构建观察矩阵中诸向量的直观方法。设 Q 为虚拟摄像机的位置，T 为此摄像机对准的观察目标点（target point） 接下来，设 j 为表示世界空间“向上”方向的单位向量。（我们用世界空间中的平面 xo 作为场景中的“地平面”，并以世界空间的 y 轴来指示场景内“向上”的方向。 因此，j = (0, 1, 0)仅是平行于世界空间中 y 轴的一个单位向量。有时为了方便起见，一些应用程序也可能选择平面 xy 作为地平面，而选 z 轴来指示“向上”的方向）对于图 5.20 来讲，虚拟摄像机的观察方向为： $$ \\vec{w} = \\frac{T - Q}{|| T - Q ||} $$ 该向量表示虚拟摄像机局部空间的 z 轴。指向 w“右侧”的单位向量为： $$ \\vec{u} = \\frac{\\vec{j} \\times \\vec{w}}{|| \\vec{j} \\times \\vec{w} ||} $$ 它表示的是虚拟摄像机局部空间的 x 轴。最后，该摄像机局部空间的 y 轴为： $$ \\vec{v} = \\vec{w} \\times \\vec{u} $$ 因为 w 和 u 为互相正交的单位向量，所以 w x u 亦必为单位向量。由此，我们也就无须对向量 v 进 行规范化处理了。 综上所述，只要给定摄像机的位置、观察目标点以及世界空间中“向上”方向的向量，我们就能构建出对应的摄像机局部坐标系，并推导出相应的观察矩阵。 DirectXMath 库针对上述计算观察矩阵的处理流程提供了以下函数： MMATRIX XM_CALLCONV XMMatrixLookAtLH( // 输出观察矩阵 V FXMVECTOR EyePosition, // 输入虚拟摄像机位置 Q FXMVECTOR FocusPosition, // 输入观察目标点 T FXMVECTOR UpDirection); // 输入世界空间中向上方向的向量 一般来说，世界空间中的 y 轴方向与虚拟摄像机“向上”向量的方向相同，所以，我们通常将“向上”向量定为 j = (0, 1, 0)。举个例子，假设我们希望把虚拟摄像机架设于世界空间内点(5, 3, −10)的位置， 并令它观察世界空间的原点（0, 0, 0），则构建相应观察矩阵的过程为： XMVECTOR pos = XMVectorSet(5, 3, -10, 1.0f); XMVECTOR target = XMVectorZero(); XMVECTOR up = XMVectorSet(0.0f, 1.0f, 0.0f, 0.0f); XMMATRIX V = XMMatrixLookAtLH(pos, target, up); ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:6:2","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"投影和齐次裁剪空间 摄像机在世界空间中的位置和朝向，除此之外，它还有另一个关键组成要素：即摄像机可观察到的空间体积（volume of space）。此范围可用一个由四棱锥截取的平截头体（frustum，即 四棱台）来表示（如图 5.21 所示）。 我们将平截头体内的 3D 几何体投 影到一个 2D 投影窗口（projection window）之中。 根据前文所述的透视投影（perspective projection） 的原理可知，投影必将沿众平行线汇聚于消失点 上，而且随着物体 3D 深度的增加，其投影的尺寸也将逐渐变小 我们将由顶点到观察 点（eye point，也译作视点）的连线称为顶点的投影线（vertex’s line of projection）。继而就可以定义出：将 3D 顶点 v 变换至其投影线与 2D 投影平面交点 v’的透视投影变换（perspective projection transformation）。我们称点 v’为点 v 的投影。3D 物体的投影即为构成该物体上所有顶点的投影。 定义平截头体 在观察空间中，我们可以通过近平面（near plane，也译作近裁剪面）n、远平面（far plane，也译作远裁 剪面）f、垂直视场角（vertical field of view angle）α 以及纵横比（aspect ratio，也作宽高比）r 这 4 个参数来 定义一个：以原点作为投影的中心，并沿 z 轴正方向进行观察的平截头体（可参见图 5.23）。 值得注意的是， 位于观察空间中的远、近平面皆平行于平面 xy，因此，我们就能方便地确定出它们分别沿 z 轴到原点的距离。 纵横比的定义为 r = w/h，其中 w 为投影窗口的宽度，h 为投影窗口的高度（以观察空间的单位为准）。 我们通常将投影窗口的纵横比指定为后台缓冲区的纵横比 （比值并没有单位）如若投影窗口与后台缓冲区的纵横比不一致，那么映射的过程中，就需要对投影窗口在将投影窗口进行不等比缩放，继而导致图像出现拉伸变形的现象。 我们现在通过垂直视场角 α 和纵横比 r 来确定水平视场角 β 。注意，投影窗口的实际大小并不重要，关键在于确定纵横比。因此，出于方便， 我们将高定为 2，而宽则必满足： $$ r = \\frac{w}{h} = \\frac{w}{2} \\Rightarrow w = 2r $$ 为了求出具体的垂直视场角α ，我们假定投影窗口到原点的距离为 d： $$ \\tan({\\frac{\\alpha}{2}}) = \\frac{1}{d} \\Rightarrow d = \\cot{\\frac{\\alpha}{2}} $$ 因此，当投影窗口的高度为 2 且垂直视场角为 α 时，我们就能确定该投影窗口沿 z 轴到观察点的距离 d。已知这些条件，即可求取水平视场角 β 。观察图 5.23 中的平面 xz 可以发现： $$ \\tan{\\frac{\\beta}{2}} = \\frac{r}{d} = \\frac{r}{\\cot(\\frac{\\alpha}{2})} = r \\cdot \\tan({\\frac{\\alpha}{2}}) $$ 所以，一旦给定垂直视场角α 和纵横比 r，我们必能求出水平视场角 β ： $$ \\beta = 2arctan(r \\cdot \\tan(\\frac{\\alpha}{2})) $$ 投影顶点 我们希望求出给定点（x, y, z）在投影平面 z = d 中的投影（x’, y’, d），见图 5.24。通过在 x 轴和 y 轴 上分别利用相似三角形的性质，我们可以发现： $$ \\frac{x’}{d} = \\frac{x}{z} \\Rightarrow x’ = \\frac{xd}{z} = \\frac{x\\cot(\\alpha / 2)}{z} = \\frac{x}{z\\tan(\\alpha) / 2} \\\\ \\\\ \\frac{y’}{d} = \\frac{y}{z} \\Rightarrow y’ = \\frac{yd}{z} = \\frac{y\\cot(\\alpha / 2)}{z} = \\frac{y}{z\\tan(\\alpha) / 2} $$ 同时不难看出，若点(x, y, z)位于平截头体内，当且仅当： $$ -r \\le x’ \\le r \\\\ \\\\ -1 \\le y’ \\le 1 \\\\ \\\\ n \\le z \\le f $$ 规格化设备坐标 由于硬件会涉及一些与投影窗口大小有关的操作，我们要去除投影窗口对纵横比的依赖，对此，我们的解决办法是将 x 坐标上的投影区间从[−r, r]缩放至归一化区间[−1, 1]， 就像下面这样： $$ -r \\le x’ \\le r \\\\ \\\\ -1 \\le \\frac{x’}{r} \\le 1 $$ 经此映射处理后，x 坐标和 y 坐标就成为了规格化设备坐标 我们可以把由观察空间到 NDC 空间的变换视为一种单位换算 $$ x’ = \\frac{x}{rz\\tan(\\alpha/2)} \\\\ \\\\ y’ = \\frac{y}{z\\tan{\\alpha/2}} $$ 注意，在 NDC 坐标中，投影窗口的高和宽都为 2，所以它的大小是固定的，硬件也就无须知道纵横比。但是，我们一定要确保将投影坐标映射到 NDC 空间内（图形硬件假设我们会完成这项工作）。 用矩阵来表示投影公式 $$ P = \\begin{bmatrix} \\frac{1}{r\\tan(\\frac{\\alpha}{2})} \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 \\frac{1}{\\tan(\\frac{\\alpha}{2})} \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 \\frac{f}{f - n} \u0026 1 \\\\ \\\\ 0 \u0026 0 \u0026 \\frac{-nf}{f - n} \u0026 0 \\end{bmatrix} $$ 在顶点乘以投影矩阵之后但还未进行透视除法之前，几何体会处于所谓的齐次裁剪空间（homogeneous clip space）或投影空间（projection space）之中。待完成透视除法之后，便是用规格化设备坐标（NDC）来表示几何体了。 归一化深度值 待投影操作完毕后，所有的投影点都会位于 2D 投影窗口上，从而构成视觉上可见的 2D 图像。看起来，我 们似乎在此时就可以丢弃原始的 3D z 坐标了。然而，为了实现深度缓冲算法，我们仍需保留这些 3D 深度信息。 就像 Direct3D 希望将 x、y 坐标映射到归一化范围一样，深度坐标也要被映射到归一化区间[0, 1]以内。 XMMatrixPerspectiveFovLH 函数 我们可以利用 DirectXMath 库内的 XMMatrixPerspectiveFovLH 函数来构建透视投影矩阵： // 返回投影矩阵 XMMATRIX XM_CALLCONV XMMatrixPerspectiveFovLH( float FovAngleY, // 用弧度制表示的垂直视场角 float Aspect, // 纵横比 = 宽度 / 高度 float NearZ, // 到近平面的距离 float FarZ // 到远平面的距离 ); 下面的代码片段详细解释了 XMMatrixPerspectiveFovLH 函数的用法。在此例中，我们将垂直视场角指定为 45° ，近平面位于 z = 1 处，远平面位于 z = 1000 处（这些长度皆以观察空间中的单位表示）。 XMMATRIX P = XMMatrixPerspectiveFovLH(0.25f*XM_PI, AspectRatio(), 1.0f, 1000.0f); // 纵横比采用的是我们窗口的宽高比： float D3DApp::AspectRatio()const { return static_cast\u003cfloat\u003e(mClientWidth) / mClientHeight; } ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:6:3","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"曲面细分阶段 曲面细分阶段（tessellation stages）是利用镶嵌化处理技术对网格中的三角形进行细分（subdivide）， 以此来增加物体表面上的三角形数量。再将这些新增的三角形偏移到适当的位置，使网格表现出更加细腻的细节 使用曲面细分的优点有以下几方面 我们能借此实现一种细节层次（level-of-detail，LOD）机制，使离虚拟摄像机较近的三角形经镶嵌化处理得到更加丰富的细节，而对距摄像机较远的三角形不进行任何更改。通过这种方式， 即可只针对用户关注度高的部分网格增添三角形，从而提升其细节效果 我们在内存中仅维护简单的低模（low-poly，低精度模型，也有译作低面多边形、低面片等）网格（低 模网格是指三角形数量较少的网格，已逐渐形成一门独特画风的艺术制作手段），再根据需求为它动态地增添额外的三角形，以此节省内存资源 我们可以在处理动画和物理模拟之时采用简单的低模网格，而仅在渲染的过程中使用经镶嵌化 处理的高模（high-poly，与低模对应）网格 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:7:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"几何着色器阶段 几何着色器（geometry shader stage，GS）是一个可选渲染阶段 我们可以利用几何着 色器将输入的图元拓展为一个或多个其他图元，抑或根据某些条件而选择不输出任何图元。顶点着色器与之相比，则不能创建顶点：它只能接受输入的单个顶点，经处理后再将该顶点输出。几何着色器的常见拿手好戏是将一个点或一条线扩展为一个四边形 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:8:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"裁剪 完全位于视锥体（viewing frustum，用户在 3D 空间中的可视范围（形如平截头体）亦常被称为视锥 体，也有译作视平截头体、视体、视景体等）之外的几何体需要被丢弃，而处于平截头体交界以外的几 何体部分也一定要接受被裁剪（clip）的操作。因此，只有在平截头体之内的物体对象才会最终保留下来。 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:9:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"光栅化阶段 光栅化阶段（rasterization stage，RS，亦有将 rasterization 译作像素化或栅格化）的主要任务是为投影至屏幕上的 3D 三角形计算出对应的像素颜色。 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:10:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"视口变换 当裁剪操作完成之后，硬件会通过透视除法将物体从齐次裁剪空间变换为规格化设备坐标（NDC）。 一旦物体的顶点位于 NDC 空间内，构成 2D 图像的 2D 顶点 x、y 坐标就会被变换到后台缓冲区中称为视 口（viewport）的矩形里。待此变换完成后，这些 x、y 坐标都将以像素为单位表示。通常来讲，由于 z 坐标常在深度缓冲技术中用作深度值，因此视口变换是不会影响此值的。即便如此，我 们还是可以通过修改 D3D12_VIEWPORT 结构体中的 MinDepth 和 MaxDepth 值来做到这一点。届时， 我们只需保证 MinDepth 和 MaxDepth 的取值为 0～1 即可。 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:10:1","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"背面剔除 ** ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:10:2","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"顶点属性插值 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:10:3","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"像素着色器阶段 我们编写的像素着色器（pixel shader，PS）是一种由 GPU 来执行的程序。它会针对每一个像素片段（pixel fragment，亦有译作片元）进行处理（即每处理一个像素就要执行一次像素着色器），并根据顶点的插值属性作为输入来计算出对应的像素颜色。像素着色器既可以直接返回一种单一的恒定颜色，也可以实现如逐像素光照（per-pixel lighting）、反射（reflection）以及阴影（shadow）等更为复杂的效果 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:11:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"输出合并阶段 通过像素着色器生成的像素片段会被移送至渲染流水线的输出合并（Output Merger，OM）阶段。 在此阶段中，一些像素片段可能会被丢弃（例如，那些未通过深度缓冲区测试或模板缓冲区测试的像素 片段）。而后，剩下的像素片段将会被写入后台缓冲区中。混合（blend，也有译作融合）操作也是在此阶段实现的，此技术可令当前处理的像素与后台缓冲区中的对应像素相融合，而不仅是对后者进行完全 的覆写。一些如“透明”这样的特殊效果，也是由混合技术来实现的 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:12:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"小结 根据人们在真实生活中观察物体的经验，我们可以总结出一些规律。运用这些规律，我们便可 以通过 2D 图像模拟出 3D 效果的场景。我们可以观察到的规律有：平行线会聚于消失点，物体 的尺寸受其深度的影响（近大远小），离观察者近的物体会遮挡其后距观察者远的物体，光照与 阴影的明暗对比可刻画出 3D 物体的实体形状和体积感，阴影还暗示了光源的位置，并反映出场 景中不同物体之间的相对位置。 我们用三角形网格来近似地表示物体。并通过指定三角形的 3 个顶点来定义三角形。在许多网 格中都存在着顶点被不同三角形所共用的现象，而索引列表则可以用于避免因重复使用顶点而 复制顶点数据所带来的冗余信息 我们可以通过指定红、绿、蓝三色光的强度来描述颜色。利用此三色光不同强度的相加混色（additive mixing，也称加色法），可以使我们表示出数以千万计的颜色。我们通常用归一化范围 0～1 来描述 三色的强度，0 表示没有强度，1 表示最高强度，两者之间的值表示相应的中间强度。一般来说还会 加入另一种名为 alpha 分量（alpha component）的颜色分量。alpha 分量通常用于表示颜色的不透明 度，这在混合技术中是很有用的。算上 alpha 分量，我们就能用 4D 颜色向量(r, g, b, a)来表示颜色 给出某个 3D 场景的几何描述，并在此场景中设置一台具有特定位置与朝向的虚拟摄像机，那么 渲染流水线（rendering pipeline）就是根据该虚拟摄像机的视角，生成能呈现在显示器中对应 2D 图像的这一系列完整步骤 渲染流水线可以划分为输入装配（Input Assembly，IA）阶段、顶点着色器（Vertex Shader，VS） 阶段、曲面细分（tessellation）阶段、几何着色器（Geometry Shader，GS）阶段、裁剪阶段、光 栅化阶段（Rasterization Shage，RS）、像素着色器（Pixel Shader，PS）阶段以及输出合并（Output Merger，OM）等重要阶段 ","date":"2025-02-10","objectID":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/:13:0","tags":["Unreal","DirectX3D"],"title":"渲染流水线","uri":"/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["DirectX3D"],"content":"Direct3D的初始化","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"Direct3D的初始化 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:0:0","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"预备知识 通过 Direct3D 这种底层图形应用程序编程接口（Application Programming Interface，API），即可在 在应用程序中对图形处理器（Graphics Processing Unit，GPU）进行控制和编程。我们能够借此以硬件加 速的方式渲染出虚拟的 3D 场景 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:0","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"组件对象模型 组件对象模型（Component Object Model，COM）是一种令 DirectX 不受编程语言束缚，并且使之向后兼 容的技术。 我们通常将 COM 对象视为一种接口，但考虑当前编程的目的，遂将它当作一个 C++类来使用。 用 C++语言编写 DirectX 程序时，COM 帮我们隐藏了大量底层细节。 我们只需知道：要获取指向某 COM 接 口的指针，需借助特定函数或另一COM 接口的方法——而不是用C++语言中的关键字new 去创建一个COM 接口。 另外，COM 对象会统计其引用次数；因此，在使用完某接口时，我们便应调用它的 Release 方法（COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的，包括 Release 方法在内），而不是用 delete 来删除——当 COM 对象的引用计数为 0 时，它将自行释放自己所占用的内存。 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:1","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"纹理格式 2D 纹理（2D texture）是一种由数据元素构成的矩阵（可将此“矩阵”看作 2D 数组）。 它的用途之 一是存储 2D 图像数据，在这种情况下，纹理中每个元素存储的都是一个像素的颜色。然而，纹理的 用处并非仅此而已。 例如，有种称作法线贴图（normal mapping）的高级技术，其纹理内的每个元素存 储的就是一个 3D 向量而不是颜色信息。 因此，尽管纹理给人的第一印象通常是用来存储图像数据，但 其实际用途却十分广泛。 简单来讲，1D、2D、3D 纹理就相当于特定数据元素所构成 1D、2D、3D 数 组。但随着后续章节中对纹理讨论的逐渐深入，我们便会知道，纹理其实还不只是像“数据数组”那 样简单。它们可能还具有多种 mipmap 层级，而 GPU 则会据此对它们进行特殊的处理，例如运用过 滤器（filter）和进行多重采样（multisample）。另外，并不是任意类型的数据元素都能用于组成纹理， 它只能存储 DXGI_FORMAT 枚举类型中描述的特定格式的数据元素 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:2","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"交换链和页面翻转 为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为后台缓冲区的离屏 （off-screen，即不可直接呈现在显示设备上之意）纹理内。 只要将指定动画帧的整个场景绘到后台缓冲区 中，它就会以一个完整的帧画面展现在屏幕上； 依照此法，观者便不会察觉出帧的绘制过程——而只会 观赏到完整的动画帧。 为此，需要利用由硬件管理的两种纹理缓冲区：即所谓的前台缓冲区（front buffer） 和后台缓冲区（back buffer）。 前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被 绘制在后台缓冲区里。 当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换：后台缓冲区变 为前台缓冲区呈现新一帧的画面，而前台缓冲区则为了展示动画的下一帧转为后台缓冲区，等待填充数 据。前后台缓冲的这种互换操作称为呈现（presenting，亦有译作提交、显示等）。 呈现是一种高效的操 作，只需交换指向当前前台缓冲区和后台缓冲区的两个指针即可实现。 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:3","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"深度缓冲 深度缓冲区（depth buffer）这种纹理资源存储的并非图像数据，而是特定像素的深度信息。 深度值 的范围为 0.0～1.0。0.0 代表观察者在视锥体（view frustum， 亦有译作视域体、视景体、视截体或视体等，意即观察者 能看到的空间范围，形如从四棱锥中截取的四棱台，常称 该形为平截头体（frustum，见图 4.3，后文亦有详述））中 能看到离自己最近的物体，1.0 则代表观察者在视锥体中能 看到离自己最远的物体。 深度缓冲区中的元素与后台缓冲 区内的像素呈一 一对应关系（即后台缓冲区中第 i 行第 j 列 的元素对应于深度缓冲区内第 i 行第 j 列的元素）。所以， 如果后台缓冲区的分辨率为1280 × 1024 ，那么深度缓冲区 中就应当有1280 × 1024 个深度元素 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:4","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"资源与描述符 在渲染处理的过程中，GPU 可能会对资源进行读（例如，从描述物体表面样貌的纹理或者存有 3D 场景中几何体位置信息的缓冲区中读取数据）和写（例如，向后台缓冲区或深度/模板缓冲区写入数据） 两种操作。 在发出绘制命令之前，我们需要将与本次绘制调用（draw call）相关的资源绑定（bind 或称 链接，link）到渲染流水线上。 部分资源可能在每次绘制调用时都会有所变化，所以我们也就要每次按 需更新绑定。 但是，GPU 资源并非直接与渲染流水线相绑定，而是要通过一种名为描述符（descriptor） 的对象来对它间接引用，我们可以把描述符视为一种对送往 GPU 的资源进行描述的轻量级结构。 从本质上来讲，它实际上即为一个中间层；若指定了资源描述符，GPU 将既能获得实际的资源数据，也能了解到 资源的必要信息。 因此，我们将把绘制调用需要引用的资源，通过指定描述符的方式绑定到渲染流水线。 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:5","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"多重采样技术的原理 由于屏幕中显示的像素不可能是无穷小的，所以并不是任意一条直线都能在显示器上“平滑”而 完美地呈现出来。 *图 4.4 所示的，即为以像素矩阵（matrix of pixels，可以理解为“像素 2D 数组”）逼近 直线的方法所产生的“阶梯”（aliasing，锯齿状走样）效果。类似地，显示器中呈现的三角形之边也存 在着不同程度的锯齿效应。 * *通过提高显示器的分辨率就能够缩小像素的大小， 继而使上述问题得到显著地改善，使阶梯效应在很大 程度上不易被用户所察觉。 * 在不能提升显示器分辨率，或在显示器分辨率受 限的情况下，我们就可以运用各种反走样（antialiasing， 也有译作抗锯齿、反锯齿、反失真等）技术。 有一种 名为超级采样（supersampling，可简记作 SSAA，即 Super Sample Anti-Aliasing）的反走样技术，它使用 4 倍于屏幕分辨率大小的后台缓冲区和深度缓冲区。3D 场景将以这种更大的分辨率渲染到后台缓冲区中。当 数据要从后台缓冲区调往屏幕显示的时候，会将后台 缓冲区按 4 个像素一组进行解析（resolve，或称降采 样，downsample。把放大的采样点数降低回原采样点数）：每组用求平均值的方法得到一种相对平滑 的像素颜色。因此，超级采样实际上是通过软件的方式提升了画面的分辨率。 超级采样是一种开销高昂的操作，因为它将像素的处理数量和占用的内存大小都增加到之前的 4 倍。 对此，Direct3D 还支持一种在性能与效果等方面都较为折中的反走样技术，叫作多重采样（multisampling，可简记作 MSAA，即 MultiSample Anti-Aliasing）。 这种技术通过跨子像素①共享一些计算信息，从而使它比 超级采样的开销更低。现假设采用 4X 多重采样（即每个像素中都有 4 个子像素），并同样使用 4 倍于屏幕 分辨率的后台缓冲区和深度缓冲区。 值得注意的是，这种技术并不需要对每一个子像素都进行计算，而是仅 计算一次像素中心处的颜色，再基于可视性（每个子像素经深度/模板测试的结果）和覆盖性（子像素的中心 在多边形的里面还是外面？）将得到的颜色信息分享给其子像素 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:6","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"利用 Direct3D 进行多重采样 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:7","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"功能级别 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:8","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"功能支持的检测 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:9","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"资源驻留 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:1:10","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"初始化Direct3D 我们对 Direct3D 进行初始化的过程可以分为以下几个步骤 用 D3D12CreateDevice 函数创建 ID3D12Device 接口实例。 创建一个 ID3D12Fence 对象，并查询描述符的大小。 检测用户设备对 4X MSAA 质量级别的支持情况。 依次创建命令队列、命令列表分配器和主命令列表。 描述并创建交换链 创建应用程序所需的描述符堆 调整后台缓冲区的大小，并为他创建渲染目标视图 创建深度 / 模板缓冲区及与之关联的深度 / 模板视图 设置视口（viewport）和裁剪矩形（scissor rectangle） ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:0","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"创建设备（D3D12CreateDevice） 要初始化 Direct3D，必须先创建 Direct3D 12 设备（ID3D12Device）通过下面的函数就可以创建 Direct3D 12 设备： HRESULT WINAPI D3D12CreateDevice( _In_opt_ IUnknown* pAdapter, D3D_FEATURE_LEVEL MinimumFeatureLevel, _In_ REFIID riid, // Expected: ID3D12Device _COM_Outptr_opt_ void** ppDevice ) pAdapter：指定在创建设备时所用的显示适配器。若将此参数设定为空指针，则使用主显示适配器。我们在本书的示例中总是采用主适配器 MinimumFeatureLevel: 应用程序需要硬件所支持的最低功能级别。如果适配器不支持此功能级别，则设备创建失败。支持 Direct3D 11 的特性的话 指定的是 D3D_FEATURE_LEVEL_11_0 riid：所建 ID3D12Device 接口的 COM ID ppDevice：返回所创建的 Direct3D 12 设备 以下是此函数的调用示例 #if defined(DEBUG) || defined(_DEBUG) // 启用 D3D12 的调试层 { ComPtr\u003cID3D12Debug\u003e debugController; ThrowIfFailed(D3D12GetDebugInterface(IID_PPV_ARGS(\u0026debugController))); debugController-\u003eEnableDebugLayer(); } #endif ThrowIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(\u0026mdxgiFactory))); // 尝试创建硬件设备 HRESULT hardwareResult = D3D12CreateDevice( nullptr, // default adapter D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(\u0026md3dDevice) ); // 回退至 WARP 设备 if(FAILED(hardwareResult)) { ComPtr\u003cIDXGIAdapter\u003e pWarpAdapter; ThrowIfFailed(mdxgiFactory-\u003eEnumWarpAdapter(IID_PPV_ARGS(\u0026pWarpAdapter))); ThrowIfFailed(D3D12CreateDevice( pWarpAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(\u0026md3dDevice))); } 可以看到，为了进入调试模式，我们首先开启了调试层（debug layer）。 随后，Direct3D 便会开启额 外的调试功能，并在错误发生时向 VC++的输出窗口发送类似于下面的调试信息 D3D12 ERROR: ID3D12CommandList::Reset: Reset fails because the command list was not closed. （D3D12 ERROR: ID3D12CommandList::Reset: 由于没有关闭命令列表因此重置失败。） 还可以发现，当调用 D3D12CreateDevice 失败后，程序将回退到一种软件适配器：WARP 设备 WARP意为 Windows Advanced Rasterization Platform（Windows 高级光栅化平台）。 在 Windows 7 及以下版本的操作系统中，WARP 设备支持的最高功能级别是 10.1；在 Windows 8 系统中，WARP 设备支持的最高功能级别是11.1。 为了创建 WARP 适配器，需要先创建一个 IDXGIFactory4 对象，并通过它来枚举 WARP 适配器： ThrowIfFailed(mdxgiFactory-\u003eCreateSwapChain( mCommandQueue.Get(), \u0026sd, mSwapChain.GetAddressOf()) ); 作为 DXGI 的一部分，mdxgiFactory 对象也可用于创建交换链。 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:1","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"创建围栏并获取描述符的大小（CreateFence） 一旦创建好设备，便可以为 CPU/GPU 的同步而创建围栏了。 另外，若用描述符进行工作，还需要了解它们的大小，但描述符在不同的CPU平台上大小各异 随后我们会把描述符的大小缓存起来，需要时即可直接引用 ThrowIfFailed(md3dDevice-\u003eCreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(\u0026mFence))); mRtvDescriptorSize = md3dDevice-\u003eGetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); mDsvDescriptorSize = md3dDevice-\u003eGetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV); mCbvSrvUavDescriptorSize = md3dDevice-\u003eGetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV); ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:2","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"检测对 4X MSAA 质量级别的支持（D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS） 这里选择 4X，是因为借此采样数量就可以获 得开销不高却性能不凡的效果。而且，在一切支持 Direct3D 11 的设备上，所有的渲染目标格式就皆已支 持 4X MSAA 了。因此，凡是支持 Direct3D 11 的硬件，都会保证此项功能的正常开启，我们也就无须再 对此进行检验了。但是，对质量级别的检测还是不可或缺，为此，可采取下列方法加以实现： D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS msQualityLevels; msQualityLevels.Format = mBackBufferFormat; msQualityLevels.SampleCount = 4; msQualityLevels.Flags = D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE; msQualityLevels.NumQualityLevels = 0; ThrowIfFailed(md3dDevice-\u003eCheckFeatureSupport( D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS, \u0026msQualityLevels, sizeof(msQualityLevels)) ); m4xMsaaQuality = msQualityLevels.NumQualityLevels; assert(m4xMsaaQuality \u003e 0 \u0026\u0026 \"Unexpected MSAA quality level.\"); 由于我们所用的平台必能支持 4X MSAA 这一功能，其返回值应该也总是大于 0，所以对此而做出上述断言 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:3","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"创建命令队列和命令列表 ID3D12CommandQueue 接口表示命令队列 ID3D12CommandAllocator 接 口代表命令分配器 ID3D12GraphicsCommandList 接口表示命令列表 D3D12_COMMAND_QUEUE_DESC queueDesc = {}; queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT; queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE; ThrowIfFailed(md3dDevice-\u003eCreateCommandQueue(\u0026queueDesc, IID_PPV_ARGS(\u0026mCommandQueue))); ThrowIfFailed(md3dDevice-\u003eCreateCommandAllocator( D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(mDirectCmdListAlloc.GetAddressOf()))); ThrowIfFailed(md3dDevice-\u003eCreateCommandList( 0, D3D12_COMMAND_LIST_TYPE_DIRECT, mDirectCmdListAlloc.Get(), // 关联命令分配器 nullptr, // 初始化流水线状态对象 IID_PPV_ARGS(mCommandList.GetAddressOf()))); // 首先要将命令列表置于关闭状态。这是因为在第一次引用命令列表时，我们要对它进行重置，而在调用 // 重置方法之前又需先将其关闭 mCommandList-\u003eClose(); ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:4","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"描述并创建交换链（DXGI_SWAP_CHAIN_DESC） 初始化流程的下一步是创建交换链 首先，要填写一份 DXGI_SWAP_CHAIN_DESC 结构体实例，用 它来描述欲创建交换链的特性。此结构体的定义如下： typedef struct DXGI_SWAP_CHAIN_DESC { DXGI_MODE_DESC BufferDesc; DXGI_SAMPLE_DESC SampleDesc; DXGI_USAGE BufferUsage; UINT BufferCount; HWND OutputWindow; BOOL Windowed; DXGI_SWAP_EFFECT SwapEffect; UINT Flags; } DXGI_SWAP_CHAIN_DESC; BufferDesc：这个结构体描述了待创建后台缓冲区的属性。在这里我们仅关注它的宽度、高 度和像素格式属性 其中的 DXGI_MODE_DESC 类型则是另一种结构体，它的定义为： typedef struct DXGI_MODE_DESC { UINT Width; UINT Height; DXGI_RATIONAL RefreshRate; DXGI_FORMAT Format; DXGI_MODE_SCANLINE_ORDER ScanlineOrdering; DXGI_MODE_SCALING Scaling; } DXGI_MODE_DESC; SampleDesc：多重采样的质量级别以及对每个像素的采样次数。对于单次采 样来说，我们要将采样数量指定为 1，质量级别指定为 0 BufferUsage：由于我们要将数据渲染至后台缓冲区（即用它作为渲染目标），因此将此参数 指定为 DXGI_USAGE_RENDER_TARGET_OUTPUT BufferCount：交换链中所用的缓冲区数量。我们将它指定为 2，即采用双缓冲 OutputWindow：渲染窗口的句柄。 Windowed：若指定为 true，程序将在窗口模式下运行；如果指定为 false，则采用全屏模式。 SwapEffect：指定为 DXGI_SWAP_EFFECT_FLIP_DISCARD。 Flags：可选标志。如果将其指定为 DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH，那 么，当程序切换为全屏模式时，它将选择最适于当前应用程序窗口尺寸的显示模式。如果没有 指定该标志，当程序切换为全屏模式时，将采用当前桌面的显示模式 描述完交换链之后，我们用 IDXGIFactory::CreateSwapChain 方法来创建它： HRESULT STDMETHODCALLTYPE CreateSwapChain( /* [annotation][in] */ IUnknown *pDevice, // 指向 ID3D12CommandQueue 接口的指针 /* [annotation][in] */ DXGI_SWAP_CHAIN_DESC *pDesc, // 指向描述交换链的结构体的指针 /* [annotation][out] */ IDXGISwapChain **ppSwapChain // 返回所创建的交换链接口 ) 研究此函数的代码就会发现，我 们是按照可以对它进行多次调用来设计的。 即，在创建新的交换链之前，先要销毁旧的交换链。这样一来，我们就可以用不同的设置来重新创建交换链，借此在运行时修改多重采样的配置。 DXGI_FORMAT mBackBufferFormat = DXGI_FORMAT_R8G8B8A8_UNORM; void D3DApp::CreateSwapChain() { // Release the previous swapchain we will be recreating. mSwapChain.Reset(); DXGI_SWAP_CHAIN_DESC sd; sd.BufferDesc.Width = mClientWidth; sd.BufferDesc.Height = mClientHeight; sd.BufferDesc.RefreshRate.Numerator = 60; sd.BufferDesc.RefreshRate.Denominator = 1; sd.BufferDesc.Format = mBackBufferFormat; sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED; sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED; sd.SampleDesc.Count = m4xMsaaState ? 4 : 1; sd.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - 1) : 0; sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; sd.BufferCount = SwapChainBufferCount; sd.OutputWindow = mhMainWnd; sd.Windowed = true; sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD; sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH; // Note: Swap chain uses queue to perform flush. ThrowIfFailed(mdxgiFactory-\u003eCreateSwapChain( mCommandQueue.Get(), \u0026sd, mSwapChain.GetAddressOf()) ); } ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:5","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"创建描述符堆（ID3D12DescriptorHeap） 我们需要通过创建描述符堆来存储程序中要用到的描述符/视图 Direct3D 12 以 ID3D12DescriptorHeap 接口表示描述符堆，并用 ID3D12Device::CreateDescriptorHeap 方法来 创建它 我们将为交换链中 SwapChainBufferCount 个用于渲染数据的缓冲区 资源创建对应的渲染目标视图（Render Target View，RTV），并为用于深度测试（depth test）的深度/模 板缓冲区资源创建一个深度/模板视图（Depth/Stencil View，DSV）。 所以，我们此时需要创建两个描述符 堆，其一用来存储 SwapChainBufferCount 个 RTV，而那另一个描述堆则用来存储那 1 个 DSV 现通过下述代码来创建这两个描述符堆： Microsoft::WRL::ComPtr\u003cID3D12DescriptorHeap\u003e mRtvHeap; Microsoft::WRL::ComPtr\u003cID3D12DescriptorHeap\u003e mDsvHeap; void D3DApp::CreateRtvAndDsvDescriptorHeaps() { D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc; rtvHeapDesc.NumDescriptors = SwapChainBufferCount; rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV; rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; rtvHeapDesc.NodeMask = 0; ThrowIfFailed(md3dDevice-\u003eCreateDescriptorHeap(\u0026rtvHeapDesc, IID_PPV_ARGS(mRtvHeap.GetAddressOf()))); D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc; dsvHeapDesc.NumDescriptors = 1; dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV; dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE; dsvHeapDesc.NodeMask = 0; ThrowIfFailed(md3dDevice-\u003eCreateDescriptorHeap( \u0026dsvHeapDesc, IID_PPV_ARGS(mDsvHeap.GetAddressOf())) ); } 创建描述符堆之后，还要能访问其中所存的描述符。 ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart 在程序中，我们是通过句柄来引用描述符的， 并以 ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart 方法来获得描述符堆中第一个描述符的句柄 借助下列函数即可获取当前后台缓冲区的 RTV 与 DSV： D3D12_CPU_DESCRIPTOR_HANDLE D3DApp::CurrentBackBufferView()const { return CD3DX12_CPU_DESCRIPTOR_HANDLE( mRtvHeap-\u003eGetCPUDescriptorHandleForHeapStart(), mCurrBackBuffer, mRtvDescriptorSize ); } D3D12_CPU_DESCRIPTOR_HANDLE D3DApp::DepthStencilView()const { return mDsvHeap-\u003eGetCPUDescriptorHandleForHeapStart(); } 通过这段示例代码，我们就能够看出描述符大小的用途了。为了用偏移量找到当前后台缓冲区的 RTV 描述符①，我们就必须知道 RTV 描述符的大小 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:6","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"创建渲染目标视图 资源不能与渲染流水线中的阶段直接绑定，所以我们必须先为资源创建视图（描述符）并将其绑定到流水线阶段 为了将后台缓冲区绑定到流水线的输出合并阶段（output merger stage，这样 Direct3D 才能向其渲染），便需要为该后台缓冲区创建一个渲染目标视图。而这第一个步骤就是要获得存 于交换链中的缓冲区资源 HRESULT STDMETHODCALLTYPE GetBuffer( /* [in] */ UINT Buffer, /* [annotation][in] */ _In_ REFIID riid, /* [annotation][out][in] */ _COM_Outptr_ void **ppSurface ) Buffer：希望获得的特定后台缓冲区的索引（有时后台缓冲区并不只一个，所以需要用索引来 指明） riid：希望获得的 ID3D12Resource 接口①的 COM ID。 ppSurface：返回一个指向 ID3D12Resource 接口的指针，这便是希望获得的后台缓冲区。 调用 IDXGISwapChain::GetBuffer 方法会增加相关后台缓冲区的 COM 引用计数，所以在每次使用后一定要将其释放。通过 ComPtr 便可以自动做到这一点。 ID3D12Device::CreateRenderTargetView 接下来，使用 ID3D12Device::CreateRenderTargetView 方法来为获取的后台缓冲区创建渲染目标视图。 void STDMETHODCALLTYPE CreateRenderTargetView( ID3D12Resource *pResource, const D3D12_RENDER_TARGET_VIEW_DESC *pDesc, D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor ) pResource：指定用作渲染目标的资源。在上面的例子中是后台缓冲区（即为后台缓冲区创建 了一个渲染目标视图 pDesc：指向 D3D12_RENDER_TARGET_VIEW_DESC 数据结构实例的指针。该结构体描述了资源中元素的数据类型（格式）。如果该资源在创建时已指定了具体格式（即此资源不是无类型 格式，not typeless），那么就可以把这个参数设为空指针，表示采用该资源创建时的格式，为它的第一个 mipmap 层级（后台缓冲区只有一种 mipmap 层级）创建一个视图。由于已经指定了后台缓冲区的格式，因此就将这个参数设置为空指针。 DestDescriptor：引用所创建渲染目标视图的描述符句柄 下面的示例通过调用这两种方法为交换链中的每一个缓冲区都创建了一个 RTV： Microsoft::WRL::ComPtr\u003cID3D12Resource\u003e mSwapChainBuffer[SwapChainBufferCount]; CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHeapHandle(mRtvHeap-\u003eGetCPUDescriptorHandleForHeapStart()); for (UINT i = 0; i \u003c SwapChainBufferCount; i++) { ThrowIfFailed(mSwapChain-\u003eGetBuffer(i, IID_PPV_ARGS(\u0026mSwapChainBuffer[i]))); md3dDevice-\u003eCreateRenderTargetView(mSwapChainBuffer[i].Get(), nullptr, rtvHeapHandle); rtvHeapHandle.Offset(1, mRtvDescriptorSize); } ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:7","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"创建深度 / 模板缓冲区及其视图 深度缓冲区其实就是一种 2D 纹理， 它存储着离观察者最近的可视对象的深度信息（如果使用了模板，还会附有模板信息） D3D12_RESOURCE_DESC 纹理是一种 GPU 资源，因此我们要通过填写 D3D12_RESOURCE_DESC 结构体来描述纹理资源，再用 ID3D12Device:: CreateCommittedResource 方法来创建它 typedef struct D3D12_RESOURCE_DESC { D3D12_RESOURCE_DIMENSION Dimension; UINT64 Alignment; UINT64 Width; UINT Height; UINT16 DepthOrArraySize; UINT16 MipLevels; DXGI_FORMAT Format; DXGI_SAMPLE_DESC SampleDesc; D3D12_TEXTURE_LAYOUT Layout; D3D12_RESOURCE_FLAGS Flags; } D3D12_RESOURCE_DESC; Dimension：资源的维度，即为下列枚举类型中的成员之一。 enum D3D12_RESOURCE_DIMENSION { D3D12_RESOURCE_DIMENSION_UNKNOWN = 0, D3D12_RESOURCE_DIMENSION_BUFFER = 1, D3D12_RESOURCE_DIMENSION_TEXTURE1D = 2, D3D12_RESOURCE_DIMENSION_TEXTURE2D = 3, D3D12_RESOURCE_DIMENSION_TEXTURE3D = 4 } D3D12_RESOURCE_DIMENSION; Width：以纹素为单位来表示的纹理宽度。对于缓冲区资源来说，此项是缓冲区占用的字节数 Height：以纹素为单位来表示的纹理高度。 DepthOrArraySize：以纹素为单位来表示的纹理深度，或者（对于 1D 纹理和 2D 纹理来说） 是纹理数组的大小。注意，Direct3D 中并不存在 3D 纹理数组的概念 MipLevels：mipmap 层级的数量。。对于深度 / 模板缓冲区而言，只能有一个 mipmap 级别 Format：DXGI_FORMAT 枚举类型中的成员之一，用于指定纹素的格式 SampleDesc：多重采样的质量级别以及对每个像素的采样次数 Layout：D3D12_TEXTURE_LAYOUT 枚举类型的成员之一，用于指定纹理的布局。我们暂时还不用考虑这个问题，在此将它指定为D3D12_TEXTURE_LAYOUT_UNKNOWN 即可 Flags：与资源有关的杂项标志。对于一个深度/模板缓冲区资源来说，要将此项指定为 D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL ID3D12Device::CreateCommittedResource GPU 资源都存于堆（heap）中，其本质是具有特定属性的 GPU 显存块 ID3D12Device:: CreateCommittedResource 方法将根据我们所提供的属性创建一个资源与一个堆，并把该资源提交 到这个堆中。 HRESULT ID3D12Device::CreateCommittedResource( const D3D12_HEAP_PROPERTIES *pHeapProperties, D3D12_HEAP_FLAGS HeapFlags, const D3D12_RESOURCE_DESC *pDesc, D3D12_RESOURCE_STATES InitialResourceState, const D3D12_CLEAR_VALUE *pOptimizedClearValue, REFIID riidResource, void **ppvResource ); pHeapProperties：（资源欲提交至的）堆所具有的属性,有一些属性是针对高级用法而设。 typedef struct D3D12_HEAP_PROPERTIES { D3D12_HEAP_TYPE Type; D3D12_CPU_PAGE_PROPERTY CPUPageProperty; D3D12_MEMORY_POOL MemoryPoolPreference; UINT CreationNodeMask; UINT VisibleNodeMask; } D3D12_HEAP_PROPERTIES; 目前只需关心 D3D12_HEAP_PROPERTIES 中的 D3D12_HEAP_TYPE 枚举类型这一主要属性， 其中的成员列举如下 D3D12_HEAP_TYPE_DEFAULT：默认堆（default heap）。向这堆里提交的资源，唯独 GPU 可以访问。举一个有关深度/模板缓冲区的例子：GPU 会读写深度 / 模板缓冲区，而 CPU 从不需要访问它，所以深度/模板缓冲区应被放入默认堆中 D3D12_HEAP_TYPE_UPLOAD：上传堆（upload heap）。向此堆里提交的都是需要经 CPU 上传至 GPU 的资源 D3D12_HEAP_TYPE_READBACK：回读堆（read-back heap）。向这种堆里提交的都是需要由 CPU 读取的资源 D3D12_HEAP_TYPE_CUSTOM：此成员应用于高级场景 HeapFlags：与（资源欲提交至的）堆有关的额外选项标志。通常将它设为 D3D12_HEAP_ FLAG_NONE pDesc：指向一个 D3D12_RESOURCE_DESC 实例的指针，用它描述待建的资源 InitialResourceState：不管何时，每个资源都会处于一种特定的使用状态。在资源创建时，需要用此参数来设置它的初始状态。对于深度/模板缓冲 区来说，通常将其初始状态设置为 D3D12_RESOURCE_STATE_COMMON ，再利用 ResourceBarrier 方法辅以 D3D12_RESOURCE_ STATE_DEPTH_WRITE 状态，将其转换 为可以绑定在渲染流水线上的深度/模板缓冲区 pOptimizedClearValue：指向一个 D3D12_CLEAR_VALUE 对象的指针，它描述了一个用于 清除资源的优化值。选择适当的优化清除值，可提高清除操作的执行速度。若不希望指定优化 清除值，可把此参数设为 nullptr struct D3D12_CLEAR_VALUE { DXGI_FORMAT Format; union { FLOAT Color[ 4 ]; D3D12_DEPTH_STENCIL_VALUE DepthStencil; }; } D3D12_CLEAR_VALUE; riidResource：我们希望获得的 ID3D12Resource 接口的 COM ID ppvResource：返回一个指向 ID3D12Resource 的指针，即新建的资源 另外，在使用深度/模板缓冲区之前，一定要创建相关的深度/模板视图，并将它绑定到渲染流水线 上。这个流程类似于创建渲染目标视图 创建深度/模板纹理及相应的深度/模板视图 下面的代码演示了该如何创建深度/模板纹理及相应的深度/模 板视图： // 创建深度/模板缓冲区及其视图 D3D12_RESOURCE_DESC depthStencilDesc; depthStencilDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D; depthStencilDesc.Alignment = 0; depthStencilDesc.Width = mClientWidth; depthStencilDesc.Height = mClientHeight; depthStencilDesc.DepthOrArraySize = 1; depthStencilDesc.MipLevels = 1; depthStencilDesc.Format = mDepthStencilFormat; depthStencilDesc.SampleDesc.Count = m4xMsaaState ? 4 : 1; depthStencilDesc.SampleDesc.Quality = m4xMsaaState ? (m4xMsaaQuality - 1) : 0; depthStencilDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN; depthStencilDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL; D3D12_CLEAR_VALUE optClear; optClear.Format = mDepthStencilFormat; optClear.DepthStencil.Depth = 1.0f; optClear.DepthStencil.Stencil = 0; ThrowIfFailed(md3dDevice-\u003eCreateCommittedResource( \u0026CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT), D3D12_HEAP_FLAG_NONE, \u0026depthStencilDesc, D","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:8","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"设置视口 我们通常会将 3D 场景绘制到与整个屏幕（在全屏模式下）或整个窗口工作区大小相当的后台缓冲 区中。但是，有时只是希望把 3D 场景绘制到后台缓冲区的某个矩形子区域当中 D3D12_VIEWPORT 我们把后台缓冲区中的这种矩形子区域叫作视口（viewport），并通过下列结构体来描述它： typedef struct D3D12_VIEWPORT { FLOAT TopLeftX; FLOAT TopLeftY; FLOAT Width; FLOAT Height; FLOAT MinDepth; FLOAT MaxDepth; } D3D12_VIEWPORT; 结构体中的前 4 个数据成员定义了视口矩形（viewport rectangle）相对于后台缓冲区的绘制范围（由于数据成员是用 float 类型表示的，所以我们能够以小数精度来指定像素坐标） 在 Direct3D 中，存储在深度缓冲区中的数据都是范围在 0～1 的归一化深度值。 MinDepth 和 MaxDepth 这两个成员负责 将深度值从区间[0, 1]转换到区间[MinDepth, MaxDepth] 通过对深度范围进行转换即可实现某些特效， 例如，我们可以依次设置 MinDepth=0 和 MaxDepth=0，用此视口绘制的物体其深度值都为 0，它们将比场景中其他物体的位置都更靠前。 然而，在大多数情况下通常会把 MinDepth 与 MaxDepth 分别设置为 0 与 1，也就是令深度值保持不变 ID3D12GraphicsCommandList::RSSetViewports 只要填写好D3D12_VIEWPORT 结构体，便可以用ID3D12GraphicsCommandList::RSSetViewports 方法来设置 Direct3D 中的视口了。 下面的示例是通过创建并设置一个视口，将场景绘至整个后台缓冲区： D3D12_VIEWPORT vp; vp.TopLeftX = 0; vp.TopLeftY = 0; vp.Width = static_cast\u003cfloat\u003e(mClientWidth); vp.Height = static_cast\u003cfloat\u003e(mClientHeight); vp.MinDepth = 0.0f; vp.MaxDepth = 1.0f; mCommandList-\u003eRSSetViewports(1, \u0026vp); 第一个参数是要绑定的视口数量（有些高级效果需要使用多个视口） 第二个参数是一个指向视口数组的指针。 事实上，还可以用视口技术来实现双人游戏的分屏（split screen）模式。首先创建两个视口，一个占屏幕左半部，另一个占右半部。接下来，在左视口中以玩家 1 的视角来绘制 3D 场景，再在右视口中以 玩家 2 的视角来绘制 3D 场景即可。 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:9","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"设置裁剪矩形 我们可以相对于后台缓冲区定义一个裁剪矩形（scissor rectangle），在此矩形外的像素都将被剔除（即 这些图像部分将不会被光栅化（rasterize）至后台缓冲区）。 这个方法能用于优化程序的性能。例如，假设已知有一个矩形的 UI（user interface，用户界面）元素覆于屏幕中某块区域的最上层，那么我们也就无须对 3D 空间中那些被它遮挡的像素进行处理了 D3D12_RECT 裁剪矩形由类型为 RECT 的 D3D12_RECT 结构体（typedef RECT D3D12_RECT;）定义而成 typedef struct tagRECT { LONG left; LONG top; LONG right; LONG bottom; } RECT; ID3D12GraphicsCommandList::RSSetScissorRects 在 Direct3D 中，要用 ID3D12GraphicsCommandList::RSSetScissorRects 方法来设置裁剪矩形。下面的示例将创建并设置一个覆盖后台缓冲区左上角 1/4 区域的裁剪矩形： mScissorRect = { 0, 0, mClientWidth/2, mClientHeight/2 }; mCommandList-\u003eRSSetScissorRects(1, \u0026mScissorRect); 类似于 RSSetViewports 方法，RSSetScissorRects 方法的第一个参数是要绑定的裁剪矩形数量（为了实现一些高级效果有时会采用多个裁剪矩形） 第二个参数是指向一个裁剪矩形数组的指针。 ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:2:10","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["DirectX3D"],"content":"小结 可以把 Direct3D 看作是一种介于程序员和图形硬件之间的“桥梁”。借此，程序员便可以通过调 用 Direct3D 函数来实现把资源视图绑定到硬件渲染流水线、配置渲染流水线的输出以及绘制 3D 几何体等操作。 组件对象模型（COM）是一种可以令 DirectX 不依赖于特定语言且向后兼容的技术。Direct3D 程序员不需知道 COM 的具体实现细节，也无需了解其工作原理，只需知晓如何获取和释放 COM 接口即可。 1D、2D、3D 纹理分别类似于由数据元素所构成的 1D、2D、3D 数组。纹理元素的格式必定为 DXGI_FORMAT 枚举类型中的成员之一。除了常见的图像数据，纹理也能存储像深度信息等其 他类型的数据（如深度缓冲区就是一种存储深度值的纹理）。GPU 可以对纹理进行特殊的操作， 比如运用过滤器和进行多重采样。 为了避免动画中发生闪烁的问题，最好将动画帧完全绘制到一种称为后台缓冲区的离屏纹理中。 只要依此行事，显示在屏幕上的就会是一个完整的动画帧，观者也就不会察觉到帧的绘制过程。 当动画帧被绘制在后台缓冲区后，前台缓冲区与后台缓冲区的角色也就该互换了：为了显示下一帧动画，此前的后台缓冲区将变为前台缓冲区，而此前的前台缓冲区亦会变成后台缓冲区。 后台和前台缓冲区交换角色的行为称为呈现（present）。前台和后台缓冲区构成了交换链，在代 码中通过 IDXGISwapChain 接口来表示。使用两个缓冲区（前台和后台）的情况称作双缓冲。 假设场景中有一些不透明的物体，那么离摄像机最近的物体上的点便会遮挡住它后面一切物体上的对应点。深度缓冲就是一种用于确定在场景中离摄像机最近点的技术。通过这种技术，我 们就不必再担心场景中物体的绘制顺序了。 在 Direct3D 中，资源不能直接与渲染流水线相绑定。为此，我们需要为绘制调用时所引用的资 源指定描述符。我们可将描述符对象看作是 GPU 识别以及描述资源的一种轻量级结构体。而且， 我们还可以为同一种资源创建不同的描述符。如此一来，一种资源就可以具有多种用途。例如， 我们可以借此将同一种资源绑定到渲染流水线的不同阶段，或者用不同的 DXGI_FORMAT 成员 将它描述为不同的格式。应用程序可通过创建描述符堆来为描述符分配所需的内存。 ID3D12Device 是 Direct3D 中最重要的接口，我们可以把它看作是图形硬件设备的软件控制 器。我们能够通过它来创建 GPU 资源以及其他用于控制图形硬件的特定接口。 每个 GPU 中都至少有一个命令队列。CPU 可通过 Direct3D API 用命令列表向该队列提交命令， 而这些命令则指挥 GPU 执行某些操作。在命令没有到达队列首部以前，用户所提交的命令是无 法被执行的。如果命令队列内为空，则 GPU 会因为没有任务要去处理而处于空闲状态；但若命 令队列被装得太满，则 CPU 将在某个时刻因提交命令的速度追上 GPU 执行命令的速度而进入 空闲状态。值得一提的是，这两种情景其实都没有充分地利用系统资源。 GPU 是系统中与 CPU 一起并行工作的第二种处理器。有时，我们需要对 CPU 与 GPU 进行同步。 例如，若 GPU 命令队列中有一条引用某资源的命令，那么在 GPU 完成此命令的处理之前，CPU 就不能修改或销毁这一资源。任何同步方法都会导致其中的一种处理器处于一段等待和空闲的 状态，这意味着两种处理器并没有被充分利用，因此，我们应尽量减少同步的次数，并缩短同 步的时间。 性能计数器是一种高精度的计时器，它是测量微小时间差的一种有效工具。例如，我们 可以用它来测量两帧之间的间隔时间。性能计时器使用的时间单位称为计数（count）。 QueryPerformanceFrequency 函数输出的是性能计时器每秒的计数，可用它将计数单位转 换为秒。性能计时器的当前时间值（以计数为单位测量）可用 QueryPerformanceCounter 函数获得。 通过统计时间段 Δt 内处理的帧数即可计算出每秒的平均帧数（FPS）。设 n 为时间 Δt 内处理的帧 数，那么该时间段内每秒的平均帧数为 $ FPS_{avg}= n / Δt $ 。采用帧率进行考量可能会对性能造成一些 误判，相对而言，“处理一帧所花费时间”这个统计信息可能更加精准、直观。以秒为单位表示 的每帧平均处理时间可以用帧率的倒数来计算，即 $ 1 / FPS_{avg} $ ","date":"2025-02-10","objectID":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/:3:0","tags":["Unreal","DirectX3D"],"title":"DirectX3D的初始化","uri":"/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["3D图形学"],"content":"矩阵的变换","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"变换 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:0:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"变换矩阵 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"定义 先来研究一下数学函数 $ \\tau(\\vec{v}) = \\tau(x, y, z) = (x’, y’, z’) $。此函数的输入和输出都是 3D 向量。 我们称 τ 为 线性变换（linear transformation），当且仅当此函数具有下列性质： $ \\tau(\\vec{u} + \\vec{v}) = \\tau{\\vec{u}} + \\tau{\\vec{v}} $ $ \\tau({k\\vec{u}}) = k\\tau({u}) $ 其中，$ \\vec{u} = (u_x, u_y, u_z)和 \\vec{v} = (v_x, v_y, v_z) $是任意 3D 向量，k 为一个标量。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:1","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"示例 定义函数 $ \\tau(x, y, z) = (x^2, y^2, z^2) $, 例如 $ \\tau(1, 2, 3) = (1, 4, 9) $ 这个函数是非线性函数，因为当 k=2 且 $ \\vec{u} = (1, 2, 3) $时 $$ \\tau(k\\vec{u}) = \\tau(2，4，6) = (4, 16, 36) $$ 但 $$ k\\tau(u) = 2(1,4,9) = (2,8,18) $$ 因此，该函数不满足刚刚说的第二条性质 如果$ \\tau $ 是线性函数，那么有 $$ \\begin{align*} \\tau(a\\vec{u} + b\\vec{v} + c\\vec{w}) \u0026= \\tau(a\\vec{u} + (b\\vec{v} + c\\vec{w})) \\\\ \\\\ \u0026= a\\tau(\\vec{u}) + \\tau(b\\vec{v} + c\\vec{w}) \\\\ \\\\ \u0026= a\\tau(\\vec{u}) + b\\tau(\\vec{v}) + c\\tau(\\vec{w}) \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:2","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵表示法 设 $ \\vec{u} = (x, y, z) $，我们也可以将它写作 $$ \\vec{u} = (x, y, z) = x\\vec{i} + y\\vec{j} + z\\vec{k} = x(1, 0, 0) + y(0,1,0) + z(0,0,1) $$ $ \\vec{i} = (1, 0, 0)， \\vec{j} = (0, 1, 0)， \\vec{k} = (0, 0, 1) $ 分别表示位于当前坐标轴正方向上得3个单位向量，我们称之为 $ \\mathbb{R}^3 $（表示所有的3D坐标向量的集合）的标准基向量 现假设 $ \\tau $ 是一种线性变换，根据他的线性性质能够得到 $$ \\tau(u) = \\tau(x\\vec{i}, y\\vec{j}, z\\vec{k}) = x\\tau\\vec{i} + y\\tau\\vec{j} + z\\tau\\vec{k} $$ 可以看出，这个公式其实就是线性组合，可以表示为向量与矩阵的乘积。 这个公式还可以进一步优化： $$ \\begin{align} \\tau\\vec{u} \u0026= x\\tau\\vec{i} + y\\tau\\vec{j} + z\\tau\\vec{k} \\\\ \\\\ \u0026= \\vec{u}A \\\\ \\\\ \u0026= [x, y, z] \\begin{bmatrix} \\leftarrow \\tau(\\vec{i}) \\rightarrow \\\\ \\\\ \\leftarrow \\tau(\\vec{j}) \\rightarrow \\\\ \\\\ \\leftarrow \\tau(\\vec{k}) \\rightarrow \\end{bmatrix} \\\\ \\\\ \u0026= [x, y, z] \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\end{align} $$ 其中 $ \\tau\\vec{i} = A_{11}, A_{12}, A_{13}，\\tau\\vec{j} = A_{21}, A_{22}, A_{23}，\\tau\\vec{k} = A_{31}, A_{32}, A_{33} $。 我们称矩阵 A 是线性变换 τ 的矩阵表示法。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:3","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"缩放 缩放（scaling，也有译作比例变换）是指改变物体的大小 我们把缩放定义为 $$ S(x, y, z) = (s_x x, s_y y, s_z z) $$ 此变换将相对于当前坐标系中的原点，令向量在 x, y, z 轴上分别以系数 $ s_x, s_y, s_z $ 进行缩放 下面证明 S 其实就是一种线性变换: $$ \\begin{align} S(\\vec{u} + \\vec{v}) \u0026= (s_x(u_x + v_x), s_y(u_y, v_y), sz(u_z + v_z)) \\\\ \\\\ \u0026= (s_x u_x + s_x v_x, s_y u_y + s_y v_y, s_z u_z + s_z v_z) \\\\ \\\\ \u0026= (s_x u_x, s_y u_y, s_z u_z) + (s_x v_x, s_y v_y, s_z v_z) \\\\ \\\\ \u0026= S(\\vec{u}) + S(\\vec{v}) \\\\ \\\\ S(k\\vec{u}) \u0026= (s_x k u_x, s_y k u_y, s_z k u_z) \\\\ \\\\ \u0026= k(s_x u_x, s_y u_y, s_z u_z) \\\\ \\\\ \u0026= kS(\\vec{u}) \\end{align} $$ 因此，缩放变换 S 满足上述所有的性质。 这也就是说，S是线性变换并存在一种矩阵表示法。 为了求出S的矩阵表示，我们只需把每一个标准基向量一次代入 S，在将得到的向量作为矩阵的行向量 $$ \\begin{align*} S(i) = (s_x \\cdot 1, s_y \\cdot 0, s_z \\cdot 0) = (s_x, 0, 0) \\\\ \\\\ s(j) = (s_x \\cdot 0, s_y \\cdot 1, s_z \\cdot 0) = (0, s_y, 0) \\\\ \\\\ s(k) = (s_x \\cdot 0, s_y \\cdot 0, s_z \\cdot 1) = (0, 0, s_z) \\end{align*} $$ 这样就得到了缩放变换 S 的矩阵表示 $$ S= \\begin{bmatrix} s_x \u0026 0 \u0026 0 \\\\ 0 \u0026 s_y \u0026 0 \\\\ 0 \u0026 0 \u0026 s_z \\end{bmatrix} $$ 我们称此矩阵为缩放矩阵（scaling matrix，亦有译为比例变换矩阵）。 而其对用的逆矩阵则为： $$ S^{-1}= \\begin{bmatrix} \\frac{1}{s_x} \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{1}{s_y} \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{1}{s_z} \\end{bmatrix} $$ 例题 假设定义了一个最小点坐标为 (−4, −4, 0) 和最大点坐标为 (4, 4, 0) 的正方形。现欲将此正方形在 x 轴方 向上缩小 50%，在 y 轴方向上放大 2.0 倍，但在 z 轴方向上保持不变。其对应的缩放矩阵为： $$ S= \\begin{bmatrix} 0.5 \u0026 0 \u0026 0 \\\\ 0 \u0026 2 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 此时，若要对正方形进行缩放，只需将最小点、最大点坐标分别与缩放矩阵相乘即可： $$ \\begin{align} [-4, -4, 0] \\begin{bmatrix} 0.5 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 2 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \u0026= [-2, -8, 0] \\\\ \\\\ [4, 4, 0] \\begin{bmatrix} 0.5 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 2 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \u0026= [2, 8, 0] \\end{align} $$ 变换的效果如图所示 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:4","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"旋转 在本节中，我们将用数学的方式来描述令向量 v 绕轴 n 以角 θ 进行旋转 此过程如图 3.3 所示。注意，在沿 n 轴从上至下俯瞰时，我们按顺时针方向来测量角 θ ，并且假设 ||n|| = 1 将向量 v 分解为两部分：一部分平行于 n，另一部分正交于 n。 平行于 n 的部分即为 $ proj_n(\\vec{v}) $ ，正交于 n 的部分则是 $ \\vec{v_\\perp } = perp_n(\\vec{v}) = \\vec{v} = proj_n(\\vec{v}) $（由于 n 是单位向量，我们就可以得到 $ proj_n(\\vec{v}) = (\\vec{n} \\cdot \\vec{v})\\vec{n} $ ） 观察示意图能够发现这样一个关键信息：平行于 n 的部分 $ proj_n(\\vec{v}) $ 在旋转时是保持不变的。因此，我们只需考虑怎样旋转与 n 正交的部分。根据图 3.3 可知，旋转向量 $ R_n(\\vec{v}) = proj_n(\\vec{v}) + R_n(\\vec{v_\\perp}) $ 。 为了求出 $ R_n(\\vec{v_\\perp}) $，我们在旋转平面内建立一个2D坐标系，并将 $ \\vec (\\vec{v_\\perp} $ 作为一个参考向量 通过计算叉积 $ \\vec{n} x \\vec{v} $来获得既正交于 $ \\vec (\\vec{v_\\perp} $ 又正交于 $ \\vec{n}$ 的第二个参考向量（根据左手拇指法则） 基于图3.3所示的三角关系可知： $$ ||\\vec{n} \\times \\vec{v}|| = ||\\vec{n}|| \\cdot ||\\vec{v}|| sin\\alpha = ||\\vec{v}||sin\\alpha = ||v_\\perp|| $$ 其中，α 是 n 与 v 之间的夹角。由此可知：两个参考向量的长度相等，且都位于旋转的圆周之上。 根据三角学知识，我们就可以将这两个参考向量建立如下关系： $$ R_n(v_\\perp) = cos\\theta\\vec{v}_\\perp + sin\\theta(\\vec{n} \\times \\vec{v}) $$ 这样就推导除了下列旋转公式： $$ \\begin{align} R_n(\\vec{v}) \u0026= proj_n(\\vec{v}) + R_n(\\vec{v}_\\perp) \\\\ \\\\ \u0026= (\\vec{n} \\cdot \\vec{v})\\vec{n} + cos\\theta\\vec{v}_\\perp + sin\\theta(\\vec{n} \\times \\vec{v}) \\\\ \\\\ \u0026= (\\vec{n} \\cdot \\vec{v})\\vec{n} + cos\\theta(\\vec{v} - (\\vec{n} \\cdot \\vec{v})\\vec{n}) + sin\\theta(\\vec{n} \\times \\vec{v}) \\\\ \\\\ \u0026= cos\\theta\\vec{v} + (1 - cos\\theta)(\\vec{n} \\times \\vec{v})\\vec{n} + sin\\theta(\\vec{n} \\times \\vec{v}) \\end{align} $$ 若要得到旋转的变换矩阵表示，仅需将各个标准基向量代入到 Rn 中，再把得到的向量分别作为矩阵的行向量。 最终得到的结果为： $$ \\begin{align*} R_n \u0026= \\begin{bmatrix} c + (1 - c)x^2 \u0026 (1-c)xy + sz \u0026 (1-c)xz - sy \\\\ \\\\ (1-c)xy - sz \u0026 c + (1 - c)y^2 \u0026 (1-c)yz + sx \\\\ \\\\ (1-c)xz + sy \u0026 (1-c)yz - sx \u0026 c + (1-c)z^2 \\end{bmatrix} \\\\ \\\\ \u0026此处设 c = cos\\theta 且 s = sin\\theta \\end{align*} $$ 旋转矩阵有个有趣的性质：每个行向量都为单位长度且两两正交（请分别证明）。 也就是说，这些行 向量都是规范正交的（orthonormal，即互相正交且具有单位长度）。 若一个矩阵的行向量都是规范正交 的，则称此矩阵为正交矩阵（orthogonal matrix）。 正交矩阵有个引人注目的性质，即它的逆矩阵与转置 矩阵是相等的： $$ \\begin{align*} R^{-1}_n = R^T_n = \\begin{bmatrix} c + (1 - c)x^2 \u0026 (1-c)xy + sz \u0026 (1-c)xz - sy \\\\ \\\\ (1-c)xy - sz \u0026 c + (1 - c)y^2 \u0026 (1-c)yz + sx \\\\ \\\\ (1-c)xz + sy \u0026 (1-c)yz - sx \u0026 c + (1-c)z^2 \\end{bmatrix} \\\\ \\\\ 此处设 c = cos\\theta 且 s = sin\\theta \\end{align*} $$ 通常来说，由于正交矩阵的逆矩阵计算方便且高效，所以很受青睐。 特别地，如果选择绕 x 轴、y 轴或 z 轴进行旋转（即分别取 n = (1, 0, 0)、n = (0, 1, 0)和 n = (0, 0, 1)）， 便会获得以 x、y、z 为旋转轴的对应旋转矩阵： $$ R_x = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 cos\\theta \u0026 sin\\theta \\\\ \\ 0 \u0026 -sin\\theta \u0026 cos\\theta \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} ,R_y = \\begin{bmatrix} cos\\theta \u0026 0 \u0026 -sin\\theta \\\\ \\\\ 0 \u0026 1 \u0026 0 \\\\ \\ sin\\theta \u0026 0 \u0026 cos\\theta \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} ,R_z = \\begin{bmatrix} cos\\theta \u0026 sin\\theta \u0026 0 \\\\ \\\\ -sin\\theta \u0026 cos\\theta \u0026 0 \\\\ \\ 0 \u0026 0 \u0026 1 \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} $$ 例题 假设定义了一个最小点坐标为(−1, 0, −1)和最大点坐标为(1, 0, 1)的正方形。 现在，我们希望令它绕 y 轴顺时针旋转−30°（即按逆时针方向旋转 30°）。 根据问题所述可知， n = (0, 1, 0) ，代入 $ R_n $ 并进行化简， 可得到 y 轴的旋转矩阵为 $$ R_y = \\begin{bmatrix} \\cos\\theta \u0026 0 \u0026 -\\sin\\theta \\\\ 0 \u0026 1 \u0026 0 \\\\ \\sin\\theta \u0026 0 \u0026 \\cos\\theta \\end{bmatrix} = \\begin{bmatrix} \\cos(-30^\\circ) \u0026 0 \u0026 -\\sin(-30^\\circ) \\\\ 0 \u0026 1 \u0026 0 \\\\ \\sin(-30^\\circ) \u0026 0 \u0026 \\cos(-30^\\circ) \\end{bmatrix} = \\begin{bmatrix} \\frac{\\sqrt{3}}{2} \u0026 0 \u0026 \\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \\\\ -\\frac{1}{2} \u0026 0 \u0026 \\frac{\\sqrt{3}}{2} \\end{bmatrix} $$ 为了旋转该正方形，还需将其最小点、最大点坐标分别乘以得到的旋转矩阵 $$ \\begin{align*} [-1, 0, -1] \\begin{bmatrix} \\frac{\\sqrt{3}}{2} \u0026 0 \u0026 \\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \\\\ -\\frac{1}{2} \u0026 0 \u0026 \\frac{\\sqrt{3}}{2} \\end{bmatrix} \u0026\\approx [-0.36, 0, -1.36] \\\\ \\\\ [1, 0, 1] \\begin{bmatrix} \\frac{\\sqrt{3}}{2} \u0026 0 \u0026 \\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \\\\ -\\frac{1}{2} \u0026 0 \u0026 \\frac{\\sqrt{3}}{2} \\end{bmatrix} \u0026\\approx [0.36, 0, 1.36] \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:5","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"仿射变换 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"齐次坐标 仿射变换 是一个线性变换和一个平移变换组合而成的。对于向量而言，平移操作是没有意义的，因为向量只描述方向和大小，却与位置无关。换句话说，平移向量不应该作用于向量。因此，平移变换只能应用于点(即位置向量) 齐次坐标（homogeneous coordinate）所提供的表示机制，使我们可以方便地对点和向量进行统一的处理。在采用齐次坐标表示法时，我们将坐标扩充为四元组，其中，第四个坐标 w 的取值将根据被描述对象是点还是向量而定。具体来讲： (x, y, z, 0) 表示向量 (x, y, z, 1)表示点 在后面我们将会证明：设 w = 1 能使点被正确地平移，设 w = 0 则可以防止向量坐标受到平移操作的 影响（我们不希望对向量的坐标进行平移变换，因为这个计算过程会改变它的方向和大小——而平移操 作不应当修改向量的任何一种“属性”）。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:1","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"仿射变换的定义及其矩阵表示 线性变换并不能表示出我们需要的所有变换，因此，现将其扩充为一种称作仿射变换的映射范围更广的函数类。 仿射变换为一个线性变换加上一个平移向量 b，即： $$ \\alpha(\\vec{u}) = \\tau(\\vec{u}) + \\vec{b} $$ 或者用矩阵表示法 $$ \\alpha(\\vec{u}) = \\vec{u}A + \\vec{b} = [x, y, z] \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} + [b_x, b_y, b_z] = [x’, y’, z’] $$ 其中，A 是一个线性变换的矩阵表示。 如果用 w = 1 把坐标扩充为齐次坐标，那么就可以将上式更简洁地写作： $$ [x, y, z, 1] \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \u0026 0 \\\\ \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \u0026 0 \\\\ \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \u0026 0 \\\\ \\\\ b_x \u0026 b_y \u0026 b_z \u0026 1 \\end{bmatrix} = [x’, y’, z’, 1] $$ 此 4 x 4 矩阵称为仿射变换的矩阵表示。 可以看出，加上向量 b 的这步运算，从本质上来说是一种平移操作（使目标对象的位置发生了改变）。但是，我们既不希望将此平移操作应用到向量上（因为向量的性质中并没有位置这个概念），又想令向量 受到仿射变换中线性部分的处理。此时，如果将向量的第四个分量设为 w = 0，它便不会受到向量 b 平移 操作的影响（可通过矩阵的乘法运算来验证这一点）。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:2","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"平移 恒等变换（identity transformation）是一种直接返回其输入参数的线性变换，形如 I(u) = u。不难证 明，这种线性变换的矩阵表示即为单位矩阵 现将平移变换（translation transformation）定义为仿射变换，此时， 其中的线性变换就是一种恒等变换，即： $$ \\tau(\\vec{u}) = \\vec{u}I + \\vec{b} = \\vec{u} + \\vec{b} $$ 如您所见，此线性变换简单地利用向量 b 对点 u 进行平移（或位移）。 $ \\tau $ 的矩阵表示为 $$ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ b_x \u0026 b_y \u0026 b_z \u0026 1 \\end{bmatrix} $$ 该矩阵称为平移矩阵（translation matrix）。 平移矩阵的逆矩阵则为： $$ T^{-1} = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ -b_x \u0026 -b_y \u0026 -b_z \u0026 1 \\end{bmatrix} $$ 例子 假设定义了一个正方形，其最小点坐标为(−8, 2, 0)，最大点坐标为(−2, 8, 0)。我们希望将此正方形沿 x 轴正方向平移 12 个单位，沿 y 轴正方向平移 −10 个单位，在 z 轴方向保持不变 则其对应的平移矩阵为： $$ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 12 \u0026 -10 \u0026 0 \u0026 1 \\end{bmatrix} $$ 现对此正方形进行平移（变换），将其最小点、最大点坐标分别乘以上述平移矩阵： $$ \\begin{align*} [-8, 2, 0, 1] \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 12 \u0026 -10 \u0026 0 \u0026 1 \\end{bmatrix} \u0026= [4, -8, 0 ,1] \\\\ \\\\ [-2, -8, 0, 1] \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 12 \u0026 -10 \u0026 0 \u0026 1 \\end{bmatrix} \u0026= [10, -2, 0 ,1] \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:3","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"缩放和旋转的仿射矩阵 通过观察可以发现，如果 b = 0，则仿射变换将退化为线性变换。这样一来，我们就能用 b = 0 的仿射变换来表示任意线性变换。更进一步说，也就意味着仅通过一个 4 × 4 的仿射矩阵表达出任意的线性变换。例如，缩放矩阵与旋转矩阵可写作下列的 4 × 4矩阵： $$ \\begin{align*} S \u0026= \\begin{bmatrix} s_x \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 s_y \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 s_z \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\\\ \\\\ R_n \u0026= \\begin{bmatrix} c + (1 - c)x^2 \u0026 (1-c)xy + sz \u0026 (1-c)xz - sy \\\\ \\\\ (1-c)xy - sz \u0026 c + (1 - c)y^2 \u0026 (1-c)yz + sx \\\\ \\\\ (1-c)xz + sy \u0026 (1-c)yz - sx \u0026 c+ (1-c)z^2 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\end{align*} $$ 如此一来，就能用 4 × 4 矩阵统一地表示所有变换，并通过1 × 4 齐次行向量来表示点和向量。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:4","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"仿射变换矩阵的几何意义 首先让我们来考察刚体变换（rigid body transformation），其本质是一种保形（shape preserving，即保持形状） 变换。 以下便是刚体变换在现实生活中的一个例子：从书桌上拿起书，再将它放到书架上。在移动书的这个过程中（平移），很可能会改变它的朝向（旋转）。 设 $ \\tau $ 为描述物体旋转操作的旋转变换，而 b 为定义物体平移操作的平移向量。那么，刚体变换就可以用仿射变换来表示： $$ \\alpha(x, y, z) = \\tau(x, y, z) + \\vec{b} = x\\tau(\\vec{i}) + y\\tau(\\vec{j}) + z\\tau{\\vec{k}} + \\vec{b} $$ 在矩阵表示法中，若采用齐次坐标（表示点时，w = 1；表示向量时，w = 0，如此一来，平移变换就不会作用于向量），上式将被改写为： $$ [x, y, z, w] \\begin{bmatrix} \\leftarrow \\tau(\\vec{i}) \\rightarrow \\\\ \\\\ \\leftarrow \\tau(\\vec{j}) \\rightarrow \\\\ \\\\ \\leftarrow \\tau(\\vec{k}) \\rightarrow \\\\ \\\\ \\leftarrow \\vec{b} \\rightarrow \\end{bmatrix} = [x’, y’, z’, w] $$ 至此，为了理解此方程的几何意义，我们还要将矩阵中的行向量依次绘制出来（见图 3.7）。由于 $ \\tau $ 是一个 旋转变换，所以它具有保长性与保角性（详见章末习题 26）。 特别是我们能看到 $ \\tau $ 仅将标准基向量 i、j 和 k，分 别旋转到对应的新方向 $ \\tau(\\vec{i}) 、\\tau(\\vec{j}) 和 \\tau(\\vec{k}) $ 。而向量b 则是一个位置向量，它表示物体相对于原点的位移。现在来看图3.7，它以几何学的角度展示了如何通过计算 $ \\alpha(x, y, z) = x\\tau(\\vec{i}) + y\\tau(\\vec{j}) + z\\tau{\\vec{k}} + \\vec{b} $ 来求取变换后的点。 这种思路同样可以运用在缩放或斜切（skew，也有译作倾斜、扭曲等）变换上。请考虑这样一种线性变换 $ \\tau $，它将图 3.8 所示的正方形拉扯为一个平行四边形。斜切处理后的点即为斜切变换后的基向量的线性组合。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:5","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"变换的复合 假设 S 是一个缩放矩阵，R 是一个旋转矩阵，T 是一个平移矩阵。 现给定一个由 8 个顶点 $ v_i $（其 中 i = 0, 1, …, 7）构成的立方体，并希望将这 3 种变换相继应用到此正方体的每个顶点之上。 我们以下列简明的方式来逐步对顶点进行变换： $$ \\begin{align} ((\\vec{v}, S)R)T \u0026= (v’_i R)T = v’’_i T = v’’’_i \\\\ \\\\ 其中i\u0026=0,1, …,7 \\end{align} $$ 然后，由于矩阵乘法满足结合律，因而此式可以等价的改写为： $$ \\begin{align} v_i(SRT) \u0026= v’’’_i \\\\ \\\\ 其中 i \u0026= 0, 1, … , 7 \\end{align} $$ 还可将 C = SRT 视为一个矩阵，即提前将3种变换封装为一个净变换矩阵。换句话说，矩阵之间的乘法法则使我们将不同的变换连接在一起 这里十级还涉及性能问题，来看一个例子： 假设有一个由 20000 个点组成的 3D 物体，我们希望将 上述 3 种几何变换，逐个作用到这个物体上。 如果采用按部就班的计算方法，我们需要进行 20000 3 × 次 向量与矩阵的乘法运算。但通过上述组合矩阵的计算方法，只需要执行 20000 次的向量与矩阵乘法运算以及两次矩阵与矩阵的乘法运算即可。 显而易见的是，比起前者中近 3 倍的大量向量与矩阵乘法运算而 言，后者中两次额外的矩阵与矩阵乘法运算真可谓是九牛一毛。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:3:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"坐标系变换 根据标架 A 与另一不同标架 B 的关系，我们就可以将相对于标架 A 表示某量的标量 k，转换为相对于标架 B 描述同一种量的新标量 k' 我们把不 同标架间的坐标的转换称之为坐标系变换 值得注意的是，在坐标变换的过程中，几何体本身并没有随之发生改变。坐标变换改变的仅是物体的参考系（又称参照系），因此改变的实为几何体的坐标表示。 相比之下，我们可以认为旋转、平移和缩放这些操作才使几何体发生了实质上的移动或形变。 3D 计算机图形学中，我们往往会用到许多不同的坐标系，所以需要了解在它们之间互相转换坐标 的方法。由于位置是点的属性，与向量无关，所以点和向量的坐标变换是不同的 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"向量的坐标变换 思考图 3.11，其中有一向量 p 分别位于标架 A 和标架 B 之中。 假设给定向量 p 在标架 A 中的坐标为 $ p_A = (x, y) $，现希望求得向量 p 在标架 B 中的对应坐标 $ p_B = (x’, y’) $。 说人话就是，向量p在另一个坐标系的坐标是什么 从图可以看出 $$ \\vec{p} = x\\vec{u} + y\\vec{v} $$ 其中，u 和 v 分别是标架Ａ中 x 轴、y 轴正方向上的单位向量。用标架 B 中的坐标来表示以上公式中的单位向量，可得： $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B $$ 所以，如果给定 $ p_A = (x, y) $，也已知向量 u 和向量 v 相对于标架 B 的坐标分别为 $ u_B = (u_x, u_y) $ 以及 $ v_B = (v_x, v_y) $， 那么就一定能求出 $ p_B = (x’, y’) $。 现将向量的坐标变换推广到3D空间，如果 $ \\vec{p_A} = (x, y, z) $, 那么 $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B $$ 其中，u, v, w分别指向标价A中 x 轴，y 轴和 z 轴正方向上的单位向量 现将向量的坐标变换推广到 3D 空间，如果 $ p_A = (x, y, z) $，那么： $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B $$ 其中，u、v 和 w 分别是指向标架Ａ中 x 轴、y 轴和 z 轴正方向上的单位向量。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:1","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"点的坐标变换 点与向量的坐标变换稍有不同，这是由于位置是点的一个重要属性，因而不能将图 3.11 所示的向量 平移方法应用于点上。 图 3.12 展示了一个对点进行坐标变换的情景，通过观察，可以将点 p 表示为： $$ \\vec{p} = x\\vec{u} + y\\vec{v} + Q $$ 其中 u 和 v 是分别指向标架 A 中 x 轴和 y 轴正方向上的单位向量，且 Q 是标架 A 中的原点。用标架 B 中的坐标来表示上式中的每一个向量和点，可得： $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B + Q_B $$ 如果给出 $ p_A = (x, y) $，同时也知道向量 u、v 以及原点 Q 相对于标架 B 的坐标分别为 $ u_B = (u_x, u_y)、v_B = (v_x, v_y) $ 以及 $ Q_B = (Q_x, Q_y) $，那么，我们总能求出 $ p_B = (x’, y’) $ 现把点的坐标变换推广到 3D 空间，如果 $ p_A = (x, y, z) $，那么： $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B + Q_B $$ 其中，向量 u、v 和 w 是分别指向标架 A 中 x 轴、y 轴和 z 轴的正方向上的单位向量，Q 则为标架 A 中的原点。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:2","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"坐标变换的矩阵表示 到目前为止，我们已经分别探讨了向量和点的坐标变换： $$ \\begin{align*} (x’, y’, z’) \u0026= x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B \\\\ \\\\ (x’, y’, z’) \u0026= x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B + Q_B \\end{align*} $$ 如果使用齐次坐标，就可以用同一公式对点和向量进行处理： $$ (x’, y’, z’, w) = x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B + Q_B $$ 如果 w= 0, 此式化简为向量的坐标变换公式；如果 w = 1，则此时化简为点的坐标变换公式，此式子的优点在于：只要为其正确的 设置 w 分量值，他就能相应的处理点或向量的坐标变换。 这样，我们也就无需分别记住两个公式了，而且我们可以将此式子改写为矩阵形式： $$ \\begin{align*} [x’, y’, z’, w] \u0026= [x, y, z, w] \\begin{bmatrix} \\leftarrow \\vec{u}_B \\rightarrow \\\\ \\\\ \\leftarrow \\vec{u}_B \\rightarrow \\\\ \\\\ \\leftarrow \\vec{u}_B \\rightarrow \\\\ \\\\ \\leftarrow \\vec{u}_B \\rightarrow \\end{bmatrix} \\\\ \\\\ \u0026= [x, y, z, w] \\begin{bmatrix} u_x \u0026 u_y \u0026 u_z \u0026 0 \\\\ \\\\ v_x \u0026 v_y \u0026 v_z \u0026 0 \\\\ \\\\ w_x \u0026 w_y \u0026 w_z \u0026 0 \\\\ \\\\ Q_x \u0026 Q_y \u0026 Q_z \u0026 1 \\end{bmatrix} \\\\ \\\\ \u0026= x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B + wQ_B \\end{align*} $$ 其中，$ Q_B = (Q_x, Q_y, Q_z, 1)，\\vec{u}_B = (u_x, u_y, u_z, 0)，\\vec{v}_B = (v_x, v_y, v_z, 0)与 \\vec{w}_B = (w_x, w_y, w_z, 0) $分别表示标架 A 中的 原点和诸坐标轴相对于标架 B 的齐次坐标。我们把上述式子里能把标架 A 中的坐标转换（或映射， map）为标架 B 中坐标的 4 x 4矩阵，称为坐标变换矩阵（change of coordinate matrix）或标架变换矩阵 （change of frame matrix）。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:3","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"坐标变换矩阵及其结合律 现假设有 3 个标架 F、G 和 H。A 为将坐标从 F 转换到 G 的标架变换矩阵，B 为把坐标由 G 转换至 H 的标架变换矩阵 在标架 F 中，有一向量的坐标为 $ p_F $，我们希望求出此向量相对于标架 H 的坐标 $ p_H $。 可按一般顺序来逐步计算： $$ \\begin{align*} (\\vec{p}_FA)B \u0026= \\vec{p}_H \\\\ \\\\ (\\vec{p}_G)B \u0026= \\vec{p}_H \\end{align*} $$ 由于矩阵的乘法运算满足结合律，我们可将 $ (\\vec{p}_FA)B = \\vec{p}_H $ 写作： $$ (\\vec{p}_F)AB = \\vec{p}_H $$ 这样一来，就能把矩阵乘积 C = AB 看作是将坐标从标架 F 直接变换至标架 H 的标架变换矩阵，它将变换矩阵 A 和 B 结合为一个净矩阵——-其思路就类似于函数的复合。 这种计算方法还会对性能产生影响。为了说明这一点，我们假设一个由 20000 个点构成的 3D 物体， 现要对它的每个点进行两次标架变换。若使用逐步计算的方法，我们需进行 20000 × 2 次向量与矩阵的乘法运算。但利用结合矩阵的方法，我们只要进行 20000 次向量与矩阵的乘法运算以及一次矩阵与矩阵的乘法运算（用于结合两个标架变换矩阵）即可。不难看出，仅借助一次开销极低的矩阵之间的乘法运算， 便可以节省多次向量与矩阵乘法所需的大量计算资源。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:4","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"坐标变换矩阵及其逆矩阵 假设给定向量 p 相对于标架 B 的坐标 $p_B$，以及将坐标由标架 A 转换到标架 B 的变换矩阵 M，即有 $ p_B = p_AM $。现希望求得 $ p_A $。换句话说，我们这次是希望通过坐标变换矩阵，将标架 B 中的坐标映射到标架 A 中。 为了求出这个矩阵，我们假设矩阵 M 是可逆的（即存在 $ M^−1 $）。通过下列步骤，我们就能得到坐标 $ p_A $： $ \\vec{p}_B = \\vec{p}_AM $ $ \\vec{p}_B M^-1 = \\vec{p}_AM M^-1 $ 等式左右两次同时乘以矩阵 M^-1 $ \\vec{p}_B = \\vec{p}_AI$ 由逆矩阵的定义可知 MM^-1 = I $ \\vec{p}_B M^-1 = \\vec{p}_A 由单位矩阵的定义可知\\vec{p}_AI = \\vec{p}_A $ 所以矩阵 $ M^-1 $ 即为将坐标由标架B转换到标架A的变换矩阵 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:5","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"变换矩阵与坐标变换矩阵 到目前为止，我们已经对“使几何体本身发生改变”的变换（缩放、旋转和平移）与坐标变换进行了区分 在本节中，我们将证明：从数学角度上看，两者在数学上其实是等价的。即，可将改变几何体的变换解释为坐标变换，反之亦然。 如果我们能认识到这一点，会发现其意义非凡。对于坐标变换来说，标架之间的差异仅为位置和朝向。因此，令坐标在标架之间转换的数学公式实质上描述的即为所需执行的旋转和平移操作，最终也会得到与几何变换（对物体进行缩放、旋转和平移）相同的数学形式，可谓殊途同归。几何变换也好，坐标变换也罢，计算出的结果都是相同的，差别只在于解释变换的角度。对于某些情况来说，保持物体不变，使之在多个坐标系之间转换是种更直观的办法。但是，若描述对象的参考系发生了变化，则物体的 坐标表示也会随之改变。有些时候，我们又希望在同一个坐标系中表示物体的变换，而不改变其参考系，此时即可采用几何变换法。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:5:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"题目 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 的定义为 $ \\tau(x, y, z) = (x + y, x - 3, z) $ 。那么，$ \\tau $ 是一种线性变换吗？如果是，求出它 的标准矩阵表示。 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 的定义为 $ \\tau(x, y, z) = (3x + 4z, 2x - z, x + y + z) $ 。那么，$ \\tau $ 是一种线性变换吗？如果是，求出它的标准矩阵表示。 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 是一种线性变换，而且 $ \\tau(1, 0, 0) = (3, 1, 2)，\\tau(0, 1, 0) = (2, -1, 3)，\\tau(0, 0, 1) = (4, 0, 2) $, 求 $ \\tau(1, 1, 1)$ 构建一个缩放矩阵，使物体在 x 轴方向上放大 2 倍，在 y 轴方向上放大 − 3 倍，在 z 轴方向上保持不变。 构建一个旋转矩阵，使物体绕轴(1, 1, 1)旋转 30° 构建一个平移矩阵，使物体沿 x 轴正方向平移 4 个单位，在 y 轴方向保持不变，沿 z 轴正方向平移−9 个单位。 构建一个单独的变换矩阵，首先使物体在 x 轴方向上放大 2 倍，在 y 轴方向上放大−3 倍，在 z 轴上保持不变。接着将物体沿 x 轴正方向平移 4 个单位，在 y 轴上保持不变，沿 z 轴正方向平移 −9 个单位。 构建一个单独的变换矩阵，首先令物体绕 y 轴旋转 45° 。接着使之沿 x 轴正方向平移−2 个单位， 沿 y 轴正方向平移 5 个单位，最后沿 z 轴正方向平移 1 个单位。 重新计算例 3.2，但是这次使其中的正方形在 x 轴方向上放大 1.5 倍，在 y 轴方向上缩小至 0.75 倍，在 z 轴上保持不变。最后，绘制出变换前后的几何体，以确定所得到结果是否正确。 重新计算例 3.2，但是这次使其中的正方形在 x 轴方向上放大 1.5 倍，在 y 轴方向上缩小至 0.75 倍，在 z 轴上保持不变。最后，绘制出变换前后的几何体，以确定所得到结果是否正确。 重新计算例 3.4，此次将该正方形在 x 轴正方向平移−5 个单位，在 y 轴正方向平移−3.0 个单位， 沿 z 轴正方向平移 4.0 个单位。最后，画出变换前后的几何体，确认所得到结果的正确性。 ** ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:6:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第一题 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 的定义为 $ \\tau(x, y, z) = (x + y, x - 3, z) $ 。那么，$ \\tau $ 是一种线性变换吗？如果是，求出它 的标准矩阵表示。 $$ \\begin{align*} \\tau(\\vec{u} + \\vec{v}) \u0026= \\tau(u_x + v_x, u_y + v_y, u_z + v_z) \\\\ \\\\ \u0026= (u_x + v_x + u_y + v_y, u_x + v_x -3, u_z + v_z) \\\\ \\\\ \\tau{\\vec{u}} + \\tau{\\vec{v}} \u0026= (u_x + u_y, u_x - 3, u_z) + (v_x + v_y, v_x - 3, v_z) \\\\ \\\\ \u0026= (u_x + v_x + u_y + v_y, u_x + v_x - 6, u_z + v_z) \\\\ \\\\ \\tau(\\vec{u} + \\vec{v}) \u0026\\neq \\tau{\\vec{u}} + \\tau{\\vec{v}} \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:7:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第二题 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 的定义为 $ \\tau(x, y, z) = (3x + 4z, 2x - z, x + y + z) $ 。那么，$ \\tau $是一种线性变换吗？如果是，求出它的标准矩阵表示。 $$ \\begin{align*} \\tau(\\vec{u} + \\vec{v}) \u0026= \\tau(u_x + v_x, u_y + v_y, u_z + v_z) \\\\ \\\\ \u0026= (3u_x + 3v_x + 4u_z + 4v_z, 2u_x + 2v_x - u_z - v_z, u_x + v_x + u_y + v_y + u_z + v_z) \\\\ \\\\ \\tau{\\vec{u}} + \\tau{\\vec{v}} \u0026= (3u_x + 4u_z, 2u_x - u_z, u_x + u_y + u_z) + (3v_x + 4v_z, 2v_x - v_z, v_x + v_y + v_z) \\\\ \\\\ \u0026= (3u_x + 3v_x + 4u_z + 4v_z, 2u_x + 2v_x - u_z - v_z, u_x + v_x + u_y + v_y + u_z + v_z) \\\\ \\\\ \\tau({k\\vec{u}}) \u0026= \\tau(ku_x, ku_y, ku_z) \\\\ \\\\ \u0026= (3ku_x + 4ku_z, 2ku_x - ku_z, ku_x + ku_y + ku_z) \\\\ \\\\ k\\tau({u}) \u0026= k(3u_x + 4u_z, 2u_x - u_z, u_x + u_y + u_z) \\\\ \\\\ \u0026= (3ku_x + 4ku_z, 2ku_x - ku_z, ku_x + ku_y + ku_z) \\\\ \\\\ 因为 \u0026~ \\tau(\\vec{u} + \\vec{v}) = \\tau{\\vec{u}} + \\tau{\\vec{v}} ~ 并且 ~ \\tau({k\\vec{u}}) = k\\tau({u}) \\\\ \\\\ 故 \u0026~ \\tau ~ 为线性变换 \\\\ \\\\ \\tau(x, y, z) \u0026= (3x + 4z, 2x - z, x + y + z) \\\\ \\\\ \u0026= \\begin{bmatrix} 3x + 0y + 4z \\\\ \\\\ 2x + 0y - z \\\\ \\\\ x + y + z \\end{bmatrix} \\\\ \\\\ \u0026 \\begin{bmatrix} 3 \u0026 0 \u0026 4 \\\\ \\\\ 2 \u0026 0 \u0026 -1 \\\\ \\\\ 1 \u0026 1 \u0026 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ \\\\ y \\\\ \\\\ z \\end{bmatrix} = \\begin{bmatrix} 3x + 0y + 4z \\\\ \\\\ 2x + 0y - z \\\\ \\\\ x + y + z \\end{bmatrix} \\\\ \\\\ \u0026 所以 ~ \\tau ~ 的标准矩阵为 ~~~ \\begin{bmatrix} 3 \u0026 0 \u0026 4 \\\\ \\\\ 2 \u0026 0 \u0026 -1 \\\\ \\\\ 1 \u0026 1 \u0026 1 \\end{bmatrix} \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:8:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第三题 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 是一种线性变换，而且 $ \\tau(1, 0, 0) = (3, 1, 2)，\\tau(0, 1, 0) = (2, -1, 3)，\\tau(0, 0, 1) = (4, 0, 2) $, 求 $ \\tau(1, 1, 1)$ $$ \\begin{align*} A \u0026= \\begin{bmatrix} 3 \u0026 1 \u0026 2 \\\\ \\\\ 2 \u0026 -1 \u0026 3 \\\\ \\\\ 4 \u0026 0 \u0026 2 \\end{bmatrix} \\\\ \\\\ \\tau(1, 1, 1) \u0026= \\begin{bmatrix} 1 \u0026 1 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 3 \u0026 1 \u0026 2 \\\\ \\\\ 2 \u0026 -1 \u0026 3 \\\\ \\\\ 4 \u0026 0 \u0026 2 \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} 3 + 2 + 4 \u0026 1 - 1 + 0 \u0026 2 + 3 + 2 \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} 9 \u0026 0 \u0026 7 \\end{bmatrix} \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:9:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第四题 构建一个缩放矩阵，使物体在 x 轴方向上放大 2 倍，在 y 轴方向上放大 − 3 倍，在 z 轴方向上保持不变。 $$ \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 -3 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:10:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第五题 构建一个旋转矩阵，使物体绕轴(1, 1, 1)旋转 30° $$ \\begin{align*} \u0026 1. 首先将轴向量(1, 1, 1) 规范为单位向量 \\\\ \\\\ \\vec{u} \u0026= \\frac{(1, 1, 1)}{\\sqrt{1^2 + 1^2 + 1^2}} \\\\ \\\\ \u0026= (\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}) \\\\ \\\\ \u0026 2. 我们再构建其旋转矩阵 \\\\ \\\\ R_n \u0026= \\begin{bmatrix} c + (1 - c)x^2 \u0026 (1-c)xy + sz \u0026 (1-c)xz - sy \\\\ \\\\ (1-c)xy - sz \u0026 c + (1 - c)y^2 \u0026 (1-c)yz + sx \\\\ \\\\ (1-c)xz + sy \u0026 (1-c)yz - sx \u0026 c + (1-c)z^2 \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} \\frac{\\sqrt{3}}{2} + \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) \u0026 \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) - \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \u0026 \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) + \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \\\\ \\\\ \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) + \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \u0026 \\frac{\\sqrt{3}}{2} + \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) \u0026 \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) - \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \\\\ \\\\ \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) - \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \u0026 \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) + \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \u0026 \\frac{\\sqrt{3}}{2} + \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} \\frac{2\\sqrt{3} + 2}{6} \u0026 \\frac{1}{3} \u0026 \\frac{1 - \\sqrt{3}}{3} \\\\ \\\\ \\frac{1 - \\sqrt{3}}{3} \u0026 \\frac{2\\sqrt{3} + 2}{6} \u0026 \\frac{1}{3} \\\\ \\\\ \\frac{1}{3} \u0026 \\frac{1 - \\sqrt{3}}{3} \u0026 \\frac{2\\sqrt{3} + 2}{6} \\end{bmatrix} \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:11:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第六题 构建一个平移矩阵，使物体沿 x 轴正方向平移 4 个单位，在 y 轴方向保持不变，沿 z 轴正方向平移−9 个单位。 $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 4 \u0026 1 \u0026 -9 \u0026 1 \\end{bmatrix} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:12:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第七题 构建一个单独的变换矩阵，首先使物体在 x 轴方向上放大 2 倍，在 y 轴方向上放大−3 倍，在 z 轴上保持不变。接着将物体沿 x 轴正方向平移 4 个单位，在 y 轴上保持不变，沿 z 轴正方向平移 −9 个单位。 $$ S = \\begin{bmatrix} 2 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 -3 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} ~~~~~~~~~~~~~~ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 4 \u0026 0 \u0026 -9 \u0026 1 \\end{bmatrix} \\\\ \\\\ \\\\ \\\\ ST = \\begin{bmatrix} 2 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 -3 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 4 \u0026 0 \u0026 -9 \u0026 1 \\end{bmatrix} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:13:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第八题 构建一个单独的变换矩阵，首先令物体绕 y 轴旋转 45° 。接着使之沿 x 轴正方向平移−2 个单位， 沿 y 轴正方向平移 5 个单位，最后沿 z 轴正方向平移 1 个单位。 $$ R = \\begin{bmatrix} \\cos45^\\circ \u0026 0 \u0026 -\\sin45^\\circ \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\ \\sin45^\\circ \u0026 0 \u0026 \\cos45^\\circ \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{bmatrix} = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 -\\frac{\\sqrt{2}}{2} \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\ \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 \\frac{\\sqrt{2}}{2} \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{bmatrix} ~~~~~~~~~ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ -2 \u0026 5 \u0026 1 \u0026 1 \\end{bmatrix} \\\\ \\\\ RT = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 -\\frac{\\sqrt{2}}{2} \u0026 -\\sqrt{2} \\\\ 0 \u0026 1 \u0026 0 \u0026 5 \\\\ \\\\ \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 \\frac{\\sqrt{2}}{2} \u0026 -\\frac{\\sqrt{2}}{2} \\\\ \\\\ -2 \u0026 5 \u0026 1 \u0026 1 \\end{bmatrix} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:14:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵的概念及数学运算","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:0:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵的定义 一个规模为 m × n 的矩阵（matrix）M，是由 m 行 n 列实数所构成的矩形阵列。行数和列数的乘积表示了矩阵的维度。 矩阵中的数字则称作元素（element）或元（entry）。通过双下标表示法 Mij指定元素 的行和列就可以确定出对应的矩阵元素，Mij表示的是矩阵中第 i 行、第 j 列的元素。 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:1:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"例子 $$ A = \\quad \\begin{bmatrix} 3.5 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0.5 \u0026 0 \\\\ 2 \u0026 -5 \u0026 \\sqrt{2} \u0026 1 \\end{bmatrix} ~~~~~~~~ B = \\quad \\begin{bmatrix} B_{11} \u0026 B_{12} \\\\ B_{21} \u0026 B_{22} \\\\ B_{31} \u0026 B_{32} \\end{bmatrix} ~~~~~~~~ u = \\quad \\left[u_1, u_2 \\right] ~~~~~~~~ v = \\quad \\begin{bmatrix} 1 \\\\ 2 \\\\ \\sqrt{3} \\\\ \\pi \\end{bmatrix} $$ A是一个 4 x 4 矩阵，B是一个 3 x 2 矩阵，u 是一个特殊的 1 x 3矩阵，v是一个 4 x 1 矩阵 我们通过双下标表示法 A42 =−5 将矩阵 A 中第 4 行第 2 列的元素指定为−5，并以 B21表示矩阵 B中第 2 行第 1 列的这一元素。 u \u0026 v 是特殊的矩阵，其实他们就是向量，分别只用一行或者一列来表示矩阵，有时候也被称为行向量或者列向量，我们只需要使用单下标表示就好了 在某些情况下，我们倾向于把矩阵的每一行都看作一个向量 比如 A1,* 第一个索引 1 表示特定的行，第二个索引\"*\" 表示该行的整个向量\u0026#42 自然而然，A,1 第一个索引\"\" 表示该列的整个向量，第二个表示特定的列 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:1:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"算数运算 $$ A = \\begin{bmatrix} 1 \u0026 5 \\\\ -2 \u0026 3 \\end{bmatrix} ~~~~~~~ B = \\begin{bmatrix} 6 \u0026 2 \\\\ 5 \u0026 -8 \\end{bmatrix} ~~~~~~~ C = \\begin{bmatrix} 1 \u0026 5 \\\\ -2 \u0026 3 \\end{bmatrix} ~~~~~~~ D = \\begin{bmatrix} 2 \u0026 1 \u0026 -3 \\\\ -6 \u0026 3 \u0026 0 \\end{bmatrix} ~~~~~~~ $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:2:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"相等 A = C ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:2:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"加减 $$ A + B = \\begin{bmatrix} 1 \u0026 5 \\\\ -2 \u0026 3 \\end{bmatrix} + \\begin{bmatrix} 6 \u0026 2 \\\\ 5 \u0026 -8 \\end{bmatrix} = \\begin{bmatrix} 1+6 \u0026 5+2 \\\\ -2+5 \u0026 3+(-8) \\end{bmatrix} = \\begin{bmatrix} 7 \u0026 7 \\\\ 3 \u0026 -5 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:2:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"标量相乘 $$ 3D = 3\\begin{bmatrix} 2 \u0026 1 \u0026 -3 \\\\ -6 \u0026 3 \u0026 0 \\end{bmatrix} = \\begin{bmatrix} 3(2) \u0026 3(1) \u0026 3(-3) \\\\ 3(-6) \u0026 3(3) \u0026 3(0) \\end{bmatrix} = \\begin{bmatrix} 6 \u0026 3 \u0026 -9 \\\\ -18 \u0026 9 \u0026 0 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:2:3","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵乘法 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:3:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"定义 如果 A 是一个 m × n 矩阵，B 是一个 n × p 矩阵，那么，两者乘积 AB 的结果是一个规模为 m × p 的矩阵 C。矩阵 C 中第 i 行、第 j 列的元素，由矩阵 A 的第 i 个行向量与矩阵 B 的第 j 个列向量的点积求得 为了使矩阵乘积 AB 有意义，矩阵 A 中的列数与矩阵 B 中的行数必须相同 ! 不能运算的例子 $$ A = \\begin{bmatrix} 1 \u0026 5 \\\\ -2 \u0026 3 \\end{bmatrix} \\quad 和 \\quad B = \\begin{bmatrix} 2 \u0026 -6 \\\\ 1 \u0026 3 \\\\ -3 \u0026 0 \\end{bmatrix} $$ 因为矩阵 A 的行向量维数为 2，矩阵 B 的列向量维数为 3，所以乘积 AB 无定义。 不妨这么想，由于 2D向量不能与 3D 向量进行点积计算，因此，矩阵 A 中的第一个行向量与矩阵 B 中的第一个列向量也就无法开展点积运算 能运算的例子 $$ A = \\begin{bmatrix} -1 \u0026 5 \u0026 -4 \\\\ 3 \u0026 2 \u0026 1 \\end{bmatrix} \\quad 和 \\quad B = \\begin{bmatrix} 2 \u0026 1 \u0026 0 \\\\ 0 \u0026 -2 \u0026 1 \\\\ -1 \u0026 2 \u0026 3 \\end{bmatrix} $$ 由于矩阵 A 的列数与矩阵 B 的行数相同，可首先指出乘积 AB 是有意义的 我们还可以发现乘积 BA 却没有意义，因为矩阵 B 的列数不等于矩阵 A 的行数。这表明，矩阵的乘法一般不满足交换律，即 AB ≠ BA $$ \\begin{align*} AB \u0026= \\begin{bmatrix} -1 \u0026 5 \u0026 -4 \\\\ 3 \u0026 2 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026 1 \u0026 0 \\\\ 0 \u0026 -2 \u0026 1 \\\\ -1 \u0026 2 \u0026 3 \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} (-1,5,-4) ~ \\cdot ~ (2, 0, -1) \u0026 (-1,5,-4) \\cdot (1,-2,2) \u0026 (-1,5,-4) \\cdot (0,1,3) \\\\ (3,2,1) \\cdot (2,0.-1) \u0026 (3,2,1) \\cdot (1,-2,2) \u0026 (3,2,1) \\cdot (0,1,3) \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} 2 \u0026 -19 \u0026 -7 \\\\ 5 \u0026 1 \u0026 5 \\end{bmatrix} \\end{align*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:3:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"向量与矩阵的乘法 $$ \\vec{u}A = \\begin{bmatrix} x,y,z \\end{bmatrix} \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} = \\begin{bmatrix} x,y,z \\end{bmatrix} \\begin{bmatrix} \\uparrow \u0026 \\uparrow \u0026 \\uparrow \\\\ A_{*,1} \u0026 A_{*,2} \u0026 A_{*,3} \\\\ \\downarrow \u0026 \\downarrow \u0026 \\downarrow \\end{bmatrix} $$ 可以观察到：该例中，uA 的计算结果是一个规模为 1 × 3 的行向量 $$ \\begin{align*} uA \u0026= \\left[ \\vec{u} \\cdot A_{*,1}, \\vec{u} \\cdot A_{*,2}, \\vec{u} \\cdot A_{*,3} \\right] \\\\ \\\\ \u0026= \\left[ xA_{11} + yA_{21} + zA_{31}, xA_{12} + yA_{22} + zA_{32}, xA_{13} + yA_{23} + zA_{33} \\right] \\\\ \\\\ \u0026= \\left[ xA_{11}, xA_{12}, xA_{13} \\right] + \\left[ yA_{21}, yA_{22}, yA_{23} \\right] + \\left[ zA_{31}, zA_{32}, zA_{33} \\right] \\\\ \\\\ \u0026= x\\left[ A_{11}, A_{12}, A_{13} \\right] + y\\left[ A_{21}, A_{22}, A_{23} \\right] + z\\left[ A_{31}, A_{32}, A_{33} \\right] \\\\ \\\\ \u0026= xA_{1,*} + yA_{2,*} + zA_{3,*} \\end{align*} $$ 这个结果实为一种线性组合（linear combination），这意味着向量与矩阵的乘积 uA 就相当于：向量 u 给定的标量系数 x、y、z 与矩阵 A 中各行向量的线性组合。注意，尽管我们只展示了1 × 3 行向量与 3 × 3 矩阵的乘法，但是这个结论却具有一般性。也就是说，对于一个 1 × n 行向量 u 与一个 n × m 矩阵 A，我们总可得到 u 所给出的标量系数与 A 中诸行向量的线性组合 uA ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:3:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"转置矩阵 转置矩阵（transpose matrix）指的是将原矩阵的行与列进行互换所得到的新矩阵。所以，根据一个 m × n 矩阵可得到一个规模为 n × m的转置矩阵。我们将矩阵 M 的转置矩阵记作 MT ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:4:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"例子 $$ \\begin{gather*} A = \\begin{bmatrix} 2 \u0026 -1 \u0026 8 \\\\ 3 \u0026 6 \u0026 -4 \\end{bmatrix} ~~~~~~~~ B = \\begin{bmatrix} a \u0026 b \u0026 c \\\\ d \u0026 e \u0026 f \\\\ g \u0026 h \u0026 i \\end{bmatrix} ~~~~~~~~ C = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix} \\\\ \\\\ A^T = \\begin{bmatrix} 2 \u0026 3 \\\\ -1 \u0026 6 \\\\ 8 \u0026 -4 \\end{bmatrix} ~~~~~~~~ B^T = \\begin{bmatrix} a \u0026 d \u0026 g \\\\ b \u0026 e \u0026 h \\\\ c \u0026 f \u0026 i \\end{bmatrix} ~~~~~~~~ C^T = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \\end{bmatrix} \\end{gather*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:4:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"实用性质 ( A + B )T = AT + BT ( cA )T = cAT ( AB )T = BTAT ( AT )T = A ( A-1 )T = ( AT )-1 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:4:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"单位矩阵 单位矩阵（identity matrix）比较特殊，是一种主对角线上的元素均为 1，其他元素都为 0 的方阵。例如，下列依次是规模为 2 × 2， 3 × 3 和 4 × 4 的单位矩阵 $$ \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 单位矩阵是矩阵的乘法单位元（multiplicative identity）。即如果 A 为 m n × 矩阵，B 为 n × p 矩阵，而 I 为 n × n 的单位矩阵，那么 AI = A 且 IB = B; 换句话说，任何矩阵与单位矩阵相乘，得到的依然是原矩阵。我们可以将单位矩阵看作是矩阵中的“数字 1”。特别地，如果 M 是一个方阵，那么它与单位矩阵的乘法满足交换律：MI = IM = M ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:5:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"证明 MI = IM = M $$ \\begin{gather*} 设 ~ M = \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} ~ 以及 ~ I = \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\\\ \\\\ MI = \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} = \\begin{bmatrix} (1, 2) \\cdot (1,0) \u0026 (1,2) \\cdot (0,1) \\\\ (0,4) \\cdot (1,0) \u0026 (0,4) \\cdot (0,1) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} \\\\ \\\\ IM = \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} = \\begin{bmatrix} (1, 0) \\cdot (1,0) \u0026 (1,0) \\cdot (2,4) \\\\ (0,1) \\cdot (1,0) \u0026 (0,1) \\cdot (2,4) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} \\\\ \\\\ 所以 ~ MI = IM = M ~ 是成立的 \\end{gather*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:5:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"证明 AI = A $$ \\begin{gather*} 设 ~ \\vec{u} = \\begin{bmatrix} -1, \u0026 2 \\end{bmatrix} 且 ~ I = \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix} ~ 验证 ~ \\vec{u}I = \\vec{u} \\\\ \\\\ \\vec{u}I = \\begin{bmatrix} -1 \u0026 2 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix} = \\begin{bmatrix} (-1,2) \\cdot (1,0), \u0026 (-1,2) \\cdot (0,1) \\end{bmatrix} = \\begin{bmatrix} -1, \u0026 2 \\end{bmatrix} \\\\ \\\\ 所以 ~ \\vec{u}I = \\vec{u} ~ 另外我们也可以看出，我们无法计算乘积 ~ I\\vec{u}, 因为此矩阵乘法是无定义的 \\end{gather*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:5:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵的行列式 行列式是一个特殊的函数，他以一个方阵作为输出，并输出一个实数。方阵A的行列式通常表示为 $ \\det(A) $ 我们可以从几何的角度来解释行列式。行列式反映了在线性变换下，（n 维多面体）体积变化的相关信息。另外，行列式也应用于解线性方程组的克莱姆法则（Cramer’s Rule，亦称克莱默法则）。 然而，我们在此学习行列式的主要目的是：利用它推导出求逆矩阵的公式 此外， 行列式还可以用于证明：方阵 A 是可逆的，当且仅当 det A ≠ 0 。这个结论很实用，因为它为我们确认矩阵的可逆性提供了一种行之有效的计算工具。不过在定义行列式之前，我们先要介绍一下余子阵的 概念 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:6:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"余子阵 指定一个 n × n 的矩阵 A，余子阵（minor matrix）$ \\overline{A}_{ij} $ 即为从 A 中去除第 i 行和第 j 列的 (n-1)x(n-1) 矩阵。 例子 求出下列矩阵的余子阵 $ \\overline{A}_{11} ~ \\overline{A}_{22} ~ \\overline{A}_{13} $ $$ A = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} $$ 去除矩阵A的第一行和第一列，得到 $ \\overline{A}_{11} $ 为: $ A = \\begin{bmatrix} A_{22} \u0026 A_{23} \\\\ A_{32} \u0026 A_{33} \\end{bmatrix} $ 去除矩阵A的第二行和第二列，得到 $ \\overline{A}_{22} $ 为: $ A = \\begin{bmatrix} A_{11} \u0026 A_{13} \\\\ A_{31} \u0026 A_{33} \\end{bmatrix} $ 去除矩阵A的第一行和第三列，得到 $ \\overline{A}_{13} $ 为：$ A = \\begin{bmatrix} A_{21} \u0026 A_{22} \\\\ A_{31} \u0026 A_{32} \\end{bmatrix} $ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:6:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"行列式的定义 矩阵的行列式有一种递归定义 例如，一个 4 × 4 矩阵的行列式要根据 3 × 3 矩阵的行列式来定义，而 3 × 3 矩阵的行列式要靠 2 × 2 矩阵的行列式来定义，最后， 2 × 2 矩阵的行列式则依赖于1 × 1矩阵的行列式来定义： 1 x 1 矩阵 $ A = [A_{11}] $ 的行列式被简单的定义为 $ \\det{[A_{11}]} = A_{11} $ 例子 设 A 为一个 $ n \\times n $ 的矩阵. 那么 n \u003e 1时， 我们定义： $$ \\det{A} = \\sum_{j=1}^{n} A_{1j}(-1)^{1+j} \\det{\\overline{A}_{ij}} $$ 对照余子阵 $ \\overline{A}_{ij} $ 的定义可知，对于 2 x 2 矩阵来说，其相应的行列式公式为： $$ \\det{\\begin{bmatrix} A_{11} \u0026 A_{12} \\\\ A_{21} \u0026 A_{22} \\end{bmatrix}} = A_{11} \\det[A_{22}] - A_{12} \\det{[A_{21}]} = A_{11}A_{22} - A_{12}A_{21} $$ 对于3 x 3矩阵来说，其行列式计算公式为： $$ \\det{\\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix}} = A_{11} \\det{\\begin{bmatrix} A_{22} \u0026 A_{23} \\\\ A_{32} \u0026 A_{33} \\end{bmatrix}} - A_{12} \\det{\\begin{bmatrix} A_{21} \u0026 A_{23} \\\\ A_{31} \u0026 A_{33} \\end{bmatrix}} + A_{13} \\det{\\begin{bmatrix} A_{21} \u0026 A_{22} \\\\ A_{31} \u0026 A_{32} \\end{bmatrix}} $$ 对于 4 x 4 矩阵, 其行列式计算公式为： 在 3D 图形学中，主要使用 4 × 4矩阵。因此，我们不再继续推导 n \u003e 4 的行列式公式。 例子2 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:6:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"伴随矩阵 设A为一个 n x n 矩阵。 乘积 $ C_{ij} = (-1)^{i+j}\\det{\\overline{A}_ij} $ 称为元素 $ A_{ij} $的代数余子式 如果为矩阵A中的每个元素分别计算出 $ C_{ij} $，并将他置于 $ C_A $中的第i行，第j列的相应位置, 那么将获得矩阵A的代数余子式; $$ C_A = \\begin{bmatrix} C_{11} \u0026 C_{12} \u0026 \\cdots \u0026 C_{1n} \\\\ \\\\ C_{21} \u0026 C_{22} \u0026 \\cdots \u0026 C_{2n} \\\\ \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\\\ C_{n1} \u0026 C_{n2} \u0026 \\cdots \u0026 C_{nn} \\end{bmatrix} $$ 若取矩阵 $ C_A $ 的转置矩阵, 将得到矩阵A的伴随矩阵, 记作: $ A^* = C^T_A $ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:7:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"逆矩阵 矩阵代数不存在除法运算的概念，但是却另外定义了一种矩阵乘法的逆运算。下面总结了与矩阵逆 运算有关的关键信息。 只有方阵才具有逆矩阵。因此，当提到逆矩阵时，我们便假设要处理的是一个方阵。 n x n 矩阵 M 的逆也是一个 n x n矩阵，并表示为 $ M^-1 $。 不是每个方阵都有逆矩阵。存在逆矩阵的方阵称为可逆矩阵（invertible matrix），不存在逆矩阵 的方阵称作奇异矩阵（singular matrix）。 可逆矩阵的逆矩阵是唯一的。 矩阵与其逆矩阵相乘将得到单位方阵：$ MM^-1 = M^-1M = I $。可以发现，矩阵与其逆矩阵的乘法运 算满足交换律。 另外，可以利用逆矩阵来解矩阵方程。例如，设矩阵方程 p’ = pM，且已知 p’与 M，求 p。假设矩阵 M 是可逆的（即存在 $ M^{−1} $），我们就能解得 p。过程如下： p’ = pM $ p^‘M^{-1} = pMM^{-1} $，方程两端各乘 $ M^{-1} $ $ p^‘M^{-1} = pI $，根据可逆矩阵的定义，有 $ MM^{-1} = I$ $ p^‘M^{-1} = p $，根据单位矩阵的定义，有 $ pI = p $ 在任何一本大学水平的线性代数教科书里，都可以找到求逆矩阵公式的推导过程，这里也就不再赘述了。此公式由原矩阵的伴随矩阵和行列式构成： $$ A^{-1} = \\frac{A^*}{detA} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:8:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"例子 推导 2 × 2矩阵 A = $ \\begin{bmatrix} A_{11} \u0026 A_{12} \\\\ \\\\ A_{21} \u0026 A_{22} \\end{bmatrix} $ 的逆矩阵通式，并利用此式求出矩阵 M = $ \\begin{bmatrix} 3 \u0026 0 \\\\ \\\\ -1 \u0026 2 \\end{bmatrix} $ 的逆矩阵 $$ \\begin{gather} \\det A = A_{11}A_{22} - A_{12}A_{21} \\\\ \\\\ C_A = \\begin{bmatrix} (-1)^{1+1} \\det \\overline{A}_{11} \u0026 (-1)^{1+2} \\det \\overline{A}_{12} \\\\ (-1)^{2+1} \\det \\overline{A}_{21} \u0026 (-1)^{2+2} \\det \\overline{A}_{22} \\end{bmatrix} = \\begin{bmatrix} A_{22} \u0026 -A_{21} \\\\ -A_{12} \u0026 A_{11} \\end{bmatrix} \\end{gather} $$ 因此： $$ A^{-1} = \\frac{A^*}{\\det A} = \\frac{C_A^T}{\\det A} = \\frac{1}{A_{11}A_{22} - A_{12}A_{21}} \\begin{bmatrix} A_{22} \u0026 -A_{12} \\\\ \\\\ -A_{21} \u0026 A_{11} \\end{bmatrix} $$ 现在运用此公式来求矩阵 M = $ \\begin{bmatrix} 3 \u0026 0 \\\\ \\\\ -1 \u0026 2 \\end{bmatrix} $ 的逆矩阵： $$ M^{-1} = \\frac{1}{3 \\cdot 2 - 0 \\cdot (-1)} \\begin{bmatrix} 2 \u0026 0 \\\\ \\\\ 1 \u0026 3 \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{3} \u0026 0 \\\\ \\\\ \\frac{1}{6} \u0026 \\frac{1}{2} \\end{bmatrix} $$ 为了核实结果，我们来验证 $ MM^{−1} = M^{−1}M = I $： $$ \\begin{bmatrix} 3 \u0026 0 \\\\ \\\\ -1 \u0026 2 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{3} \u0026 0 \\\\ \\\\ \\frac{1}{6} \u0026 \\frac{1}{2} \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 0 \\\\ \\\\ 0 \u0026 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{3} \u0026 0 \\\\ \\\\ \\frac{1}{6} \u0026 \\frac{1}{2} \\end{bmatrix} \\begin{bmatrix} 3 \u0026 0 \\\\ \\\\ -1 \u0026 2 \\end{bmatrix} $$ 我们以下列“矩阵乘积的逆”这一实用的代数性质，为此节画上句号： $$ (AB)^{-1} = B^{-1}A^{-1} $$ 该性质假设矩阵 A 与矩阵 B 都是可逆的，而且皆为同维方阵。为了证明 $ B^{−1} A^{−1} $ 是乘积 AB 的逆，我 们必须证实 $ (AB)(B^{−1}A^{−1}) = I $ 以及 $ (B^{−1}A^{−1}) (AB) = I $。证明过程如下： $$ \\begin{gather} (AB)(B^{-1}A^{-1}) = A(BB^{-1})A^{-1} = AIA^{-1} = AA^{-1} = I \\\\ \\\\ (B^{-1}A^{-1})(AB) = B^{-1}(A^{-1}A)B = B^{-1}IB = B^{-1}B = I \\end{gather} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:8:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"基本运算定律 由于在矩阵的加法和标量乘法的运算过程中，是以元素为单位展开计算的，所以它们实际上也分别从实数运算中继承了下列性质 A + B = B + A 加法交换律 (A + B) + C = A + (B + C) 加法结合律 r (A + B) = rA + rB 标量乘法对矩阵加法的分配律 (r + s) A = rA + sA 矩阵乘法对标量加法的分配律 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:9:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"小结 m × n 矩阵 M 是一个由 m 行 n 列实数所构成的矩形阵列 如果 A 是一个 m × n矩阵，且 B 为一个 n × p矩阵，那么两者乘积 AB 的结果是一个规模为 m × p 的矩阵 C。 矩阵乘法不满足交换律（即一般来说， AB ≠ BA ），但是却满足结合律 (AB)C = A(BC) 转置矩阵由原矩阵互换行与列来求得。所以， m × n矩阵的转置矩阵为 n × m矩阵。我们将矩阵 M 的转置矩阵表示为 $ M^T $。 单位矩阵是一种除主对角线上的元素为 1 外，其他元素均为 0 的方阵。 行列式 det A 是一种特殊的函数，向它传入一个方阵便会计算出一个对应的实数。方阵 A 是可逆的，当且仅当 det A ≠ 0。行列式常常用于计算逆矩阵。 矩阵与其逆矩阵的乘积结果为单位矩阵，即 $ MM^−1 = M^−1M = I $。如果一个矩阵是可逆的，则此矩阵的逆矩阵是唯一的。只有方阵才可能有逆矩阵，即便是方阵也未必可逆。逆矩阵可由公式 $ A^{-1} = \\frac{A^}{detA} $ 来计算，其中 * A 是伴随矩阵（即矩阵 A 的代数余子式矩阵的转置矩阵）。* ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:10:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"作业 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"题目大纲 求解下列矩阵方程中的矩阵 X $ 3(\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix}- 2X) = 2\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix} $ 计算下列矩阵的乘积： （a）$ \\begin{bmatrix}-2 \u0026 0 \u0026 3 \\\\ \\\\ 4 \u0026 1 \u0026 -1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026 -1 \\\\ \\\\ 0 \u0026 6 \\\\ \\\\ 2 \u0026 -3 \\end{bmatrix} $ （b）$ \\begin{bmatrix}1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\end{bmatrix} \\begin{bmatrix} -2 \u0026 0 \\\\ \\\\ 1 \u0026 1 \\end{bmatrix} $ （c）$ \\begin{bmatrix} 2 \u0026 0 \u0026 2 \\\\ \\\\ 0 \u0026 -1 \u0026 -3 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ \\\\ 2 \\\\ \\\\ 1 \\end{bmatrix} $ 计算下列矩阵的转置矩阵 （a）$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\end{bmatrix} $ （b）$ \\begin{bmatrix} x \u0026 y \\\\ \\\\ z \u0026 w \\end{bmatrix} $ （c）$ \\begin{bmatrix} 1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\\\ \\\\ 5 \u0026 6 \\\\ \\\\ 7 \u0026 8 \\end{bmatrix} $ 将下列线性组合写作向量与矩阵乘积的形式： （a）v = 2(1, 2, 3) − 4(−5, 0, −1) + 3(2, −2, 3) （b）v = 3(2, −4) + 2(1, 4) − 1(−2, −3) + 5(1, 1) 证明：$ AB = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33}\\end{bmatrix}\\begin{bmatrix} B_{11} \u0026 B_{12} \u0026 B_{13} \\\\ B_{21} \u0026 B_{22} \u0026 B_{23} \\\\ B_{31} \u0026 B_{32} \u0026 B_{33} \\end{bmatrix} =\\begin{bmatrix} \\leftarrow A_{1,*}B \\rightarrow \\\\ \\\\ \\leftarrow A_{2,*}B \\rightarrow\\\\ \\\\ \\leftarrow A_{3,*}B \\rightarrow \\end{bmatrix} $ 证明：$ A\\vec{u} = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = xA_{*,1} + y A_{*,2} + zA_{*,3} $ 证明向量的叉积可以用矩阵的乘积来表示：$ \\vec{u} \\times \\vec{v} = \\begin{bmatrix} v_x \u0026 v_y \u0026 v_z \\end{bmatrix} \\begin{bmatrix} 0 \u0026 u_z \u0026 -u_y \\\\ \\\\ -u_z \u0026 0 \u0026 u_x \\\\ \\\\ u_y \u0026 -u_x \u0026 0 \\end{bmatrix} $ 设矩阵A = $ \\begin{bmatrix} 2 \u0026 0 \u0026 1 \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $, 那么请问矩阵B = $ \\begin{bmatrix} \\frac{1}{2} \u0026 0 \u0026 - \\frac{1}{2} \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $ 是 A 的逆矩阵吗 设矩阵A = $ \\begin{bmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{bmatrix} $, 那么请问矩阵B = $ \\begin{bmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 \\frac{1}{2} \\end{bmatrix} $ 是A的逆矩阵吗 求下列矩阵的行列式：$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $ 求下列矩阵的逆矩阵：$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $ 下列矩阵是可逆矩阵吗？\\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ \\\\ 0 \u0026 4 \u0026 5 \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} 假设矩阵A是可逆矩阵，证明 $ (A^{-1})^T = (A^T)^{-1} $ 所有的线性代数书籍都会证明 $ det(AB) = detA \\cdot detB $这一性质。设A和B皆为 n x n 矩阵，并假设A是可逆的，试根据 $ det I = 1 $与上述性质来证明 $ detA^{-1} = \\frac{1}{detA}$ 证明2D矩阵 $ \\begin{bmatrix} u_x \u0026 u_y \\\\ v_x \u0026 v_y \\end{bmatrix} $的行列式得到的是：由 $ \\vec{u} = (u_x, u_y) $与向量 $ \\vec{v} = (v_x, v_y) $ 张成的平行四边形的有向面积。如果向量 u 以逆时针方向旋转角θ ∈(0, π) 能与向量 v 重合，则结果为正，否则为负。 求由下列向量张成的平行四边形面积： u = (3, 0)与 v = (1, 1) u = (−1, −1)与 v = (0, 1) 设 A = $ \\begin{bmatrix} A_{11} \u0026 A_{12} \\\\ A_{21} \u0026 A_{22} \\end{bmatrix} $. B = $ \\begin{bmatrix} B_{11} \u0026 B_{12} \\\\ B_{21} \u0026 B_{22} \\end{bmatrix} $, C = $ \\begin{bmatrix} C_{11} \u0026 C_{12} \\\\ C_{21} \u0026 C_{22} \\end{bmatrix} $。证明 A(BC) = (AB)C。这个结论说明了 2 × 2矩阵之间的乘法运算满足结合律。（事实上，只要矩阵的乘法有意义，任意规模的矩阵乘法都满足结合律。） ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第一题 求解下列矩阵方程中的矩阵 X $ 3(\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix}- 2X) = 2\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix} $ $$ \\begin{gather*} 3(\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix}- 2X) = 2\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix} \\\\ \\\\ \\begin{bmatrix} -6 \u0026 0 \\\\ \\\\ 3 \u0026 9 \\end{bmatrix} - 6X = \\begin{bmatrix} -4 \u0026 0 \\\\ \\\\ 2 \u0026 6 \\end{bmatrix} \\\\ \\\\ -6X = \\begin{bmatrix} -4 \u0026 0 \\\\ \\\\ 2 \u0026 6 \\end{bmatrix} - \\begin{bmatrix} -6 \u0026 0 \\\\ \\\\ 3 \u0026 9 \\end{bmatrix} \\\\ \\\\ -6X = \\begin{bmatrix} 2 \u0026 0 \\\\ \\\\ -1 \u0026 -3 \\end{bmatrix} \\\\ \\\\ X = \\begin{bmatrix} -\\frac{1}{3} \u0026 0 \\\\ \\\\ \\frac{1}{6} \u0026 \\frac{1}{2} \\end{bmatrix} \\end{gather*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第二题 计算下列矩阵的乘积： （a）$ \\begin{bmatrix}-2 \u0026 0 \u0026 3 \\\\ \\\\ 4 \u0026 1 \u0026 -1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026 -1 \\\\ \\\\ 0 \u0026 6 \\\\ \\\\ 2 \u0026 -3 \\end{bmatrix} $ $$ \\begin{bmatrix}-2 \u0026 0 \u0026 3 \\\\ \\\\ 4 \u0026 1 \u0026 -1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026 -1 \\\\ \\\\ 0 \u0026 6 \\\\ \\\\ 2 \u0026 -3 \\end{bmatrix} = \\begin{bmatrix} 2 \u0026 -7 \\\\ \\\\ 6 \u0026 5 \\end{bmatrix} $$ （b）$ \\begin{bmatrix}1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\end{bmatrix} \\begin{bmatrix} -2 \u0026 0 \\\\ \\\\ 1 \u0026 1 \\end{bmatrix} $ $$ \\begin{bmatrix}1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\end{bmatrix} \\begin{bmatrix} -2 \u0026 0 \\\\ \\\\ 1 \u0026 1 \\end{bmatrix} = \\begin{bmatrix} 0 \u0026 2 \\\\ \\\\ -2 \u0026 4 \\end{bmatrix} $$ （c）$ \\begin{bmatrix} 2 \u0026 0 \u0026 2 \\\\ \\\\ 0 \u0026 -1 \u0026 -3 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ \\\\ 2 \\\\ \\\\ 1 \\end{bmatrix} $ $$ \\begin{bmatrix} 2 \u0026 0 \u0026 2 \\\\ \\\\ 0 \u0026 -1 \u0026 -3 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ \\\\ 2 \\\\ \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 4 \\\\ \\\\ -5 \\\\ \\\\ 1 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:3","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第三题 计算下列矩阵的转置矩阵 （a）$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\end{bmatrix} $ $$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\end{bmatrix}^T = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} $$ （b）$ \\begin{bmatrix} x \u0026 y \\\\ \\\\ z \u0026 w \\end{bmatrix} $ $$ \\begin{bmatrix} x \u0026 y \\\\ \\\\ z \u0026 w \\end{bmatrix} ^ T = \\begin{bmatrix} x \u0026 z \\\\ \\\\ y \u0026 w \\end{bmatrix} $$ （c）$ \\begin{bmatrix} 1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\\\ \\\\ 5 \u0026 6 \\\\ \\\\ 7 \u0026 8 \\end{bmatrix} $ $$ \\begin{bmatrix} 1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\\\ \\\\ 5 \u0026 6 \\\\ \\\\ 7 \u0026 8 \\end{bmatrix} ^ T = \\begin{bmatrix} 1 \u0026 3 \u0026 5 \u0026 7 \\\\ \\\\ 2 \u0026 4 \u0026 6 \u0026 8 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:4","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第四题 将下列线性组合写作向量与矩阵乘积的形式： （a）v = 2(1, 2, 3) − 4(−5, 0, −1) + 3(2, −2, 3) $$ \\begin{bmatrix} 1 \u0026 -5 \u0026 2 \\\\ \\\\ 2 \u0026 0 \u0026 -2 \\\\ \\\\ 3 \u0026 -1 \u0026 3 \\end{bmatrix} \\begin{bmatrix} 2 \\\\ \\\\ -4 \\\\ \\\\ 3 \\end{bmatrix} $$ （b）v = 3(2, −4) + 2(1, 4) − 1(−2, −3) + 5(1, 1) $$ \\begin{bmatrix} 2 \u0026 1 \u0026 -2 \u0026 1 \\\\ \\\\ -4 \u0026 4 \u0026 -3 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 3 \\\\ \\\\ 2 \\\\ \\\\ -1 \\\\ \\\\ 5 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:5","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第五题 证明：$ AB = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33}\\end{bmatrix}\\begin{bmatrix} B_{11} \u0026 B_{12} \u0026 B_{13} \\\\ B_{21} \u0026 B_{22} \u0026 B_{23} \\\\ B_{31} \u0026 B_{32} \u0026 B_{33} \\end{bmatrix} =\\begin{bmatrix} \\leftarrow A_{1,*}B \\rightarrow \\\\ \\\\ \\leftarrow A_{2,*}B \\rightarrow\\\\ \\\\ \\leftarrow A_{3,*}B \\rightarrow \\end{bmatrix} $ $$ AB = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\begin{bmatrix} B_{11} \u0026 B_{12} \u0026 B_{13} \\\\ B_{21} \u0026 B_{22} \u0026 B_{23} \\\\ B_{31} \u0026 B_{32} \u0026 B_{33} \\end{bmatrix} = \\begin{bmatrix} \\leftarrow A_{1,*}B \\rightarrow \\\\ \\\\ \\leftarrow A_{2,*}B \\rightarrow \\\\ \\\\ \\leftarrow A_{3,*}B \\rightarrow \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:6","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第六题 证明：$ A\\vec{u} = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = xA_{*,1} + y A_{*,2} + zA_{*,3} $ $$ A\\vec{u} = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = xA_{*,1} + y A_{*,2} + zA_{*,3} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:7","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第七题 证明向量的叉积可以用矩阵的乘积来表示：$ \\vec{u} \\times \\vec{v} = \\begin{bmatrix} v_x \u0026 v_y \u0026 v_z \\end{bmatrix} \\begin{bmatrix} 0 \u0026 u_z \u0026 -u_y \\\\ \\\\ -u_z \u0026 0 \u0026 u_x \\\\ \\\\ u_y \u0026 -u_x \u0026 0 \\end{bmatrix} $ $$ \\vec{u} \\times \\vec{v} = \\begin{bmatrix} v_x \u0026 v_y \u0026 v_z \\end{bmatrix} \\begin{bmatrix} 0 \u0026 u_z \u0026 -u_y \\\\ \\\\ -u_z \u0026 0 \u0026 u_x \\\\ \\\\ u_y \u0026 -u_x \u0026 0 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:8","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第八题 设矩阵A = $ \\begin{bmatrix} 2 \u0026 0 \u0026 1 \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $, 那么请问矩阵B = $ \\begin{bmatrix} \\frac{1}{2} \u0026 0 \u0026 - \\frac{1}{2} \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $ 是 A 的逆矩阵吗 $$ \\begin{bmatrix} 2 \u0026 0 \u0026 1 \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{2} \u0026 0 \u0026 - \\frac{1}{2} \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:9","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第九题 设矩阵A = $ \\begin{bmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{bmatrix} $, 那么请问矩阵B = $ \\begin{bmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 \\frac{1}{2} \\end{bmatrix} $ 是A的逆矩阵吗 $$ \\begin{bmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{bmatrix} \\begin{bmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 \\frac{1}{2} \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:10","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第十题 求下列矩阵的行列式：$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $ $$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:11","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第十一题 求下列矩阵的逆矩阵：$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $ $$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:12","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第十二题 下列矩阵是可逆矩阵吗？$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ \\\\ 0 \u0026 4 \u0026 5 \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} $ $$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ \\\\ 0 \u0026 4 \u0026 5 \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:13","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第十三题 假设矩阵A是可逆矩阵，证明 $ (A^{-1})^T = (A^T)^{-1} $ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:14","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第十四题 所有的线性代数书籍都会证明 $ det(AB) = detA \\cdot detB $这一性质。设A和B皆为 n x n 矩阵，并假设A是可逆的，试根据 $ det I = 1 $与上述性质来证明 $ detA^{-1} = \\frac{1}{detA}$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:15","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第十五题 证明2D矩阵 $ \\begin{bmatrix} u_x \u0026 u_y \\\\ v_x \u0026 v_y \\end{bmatrix} $的行列式得到的是：由 $ \\vec{u} = (u_x, u_y) $与向量 $ \\vec{v} = (v_x, v_y) $ 张成的平行四边形的有向面积。如果向量 u 以逆时针方向旋转角θ ∈(0, π) 能与向量 v 重合，则结果为正，否则为负。 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:16","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第十六题 求由下列向量张成的平行四边形面积： u = (3, 0)与 v = (1, 1) u = (−1, −1)与 v = (0, 1) ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:17","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"第十七题 设 A = $ \\begin{bmatrix} A_{11} \u0026 A_{12} \\\\ A_{21} \u0026 A_{22} \\end{bmatrix} $. B = $ \\begin{bmatrix} B_{11} \u0026 B_{12} \\\\ B_{21} \u0026 B_{22} \\end{bmatrix} $, C = $ \\begin{bmatrix} C_{11} \u0026 C_{12} \\\\ C_{21} \u0026 C_{22} \\end{bmatrix} $。证明 A(BC) = (AB)C。这个结论说明了 2 × 2矩阵之间的乘法运算满足结合律。（事实上，只要矩阵的乘法有意义，任意规模的矩阵乘法都满足结合律。） ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:11:18","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"标量与向量","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:0:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量的定义 向量（vector）是一种兼具大小（也称为模，magnitude）和方向的量。具有这两种属性的量皆 称为向量值物理量（vector-valued quantity） 与向量值物理量相关的例子有作用力（在特定方向上施 加的力—力的大小即为向量的模）、位移（质点沿净方向移动的距离）和速度（速率和方向）。这 样一来，向量就能用于表示力、位移和速度 另外，有时也用向量单指方向，例如玩家在 3D 游戏 里的视角方向、一个多边形的朝向、一束光线的传播方向以及它照射在某表面后的反射方向等 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:1:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"几何意义 通过图像中的一条有向线段即可表示一个向量， 其中，线段长度代表向量的模，箭头的指向代表向量的方向。我们可以注意到：向量的绘制位置之于其 自身是无足轻重的，因为改变某向量的位置并不会对其大小或方向这两个属性造成任何影响。因此，我 们说：两个向量相等，当且仅当它们的长度相等且方向相同。所以，图中的向量 u 和向量 v 相等， 因为它们的长度相等且方向相同 事实上，由于位置对于向量是无关紧要的，所以我们总是能在平移一 个向量的同时又完全不改变它的几何意义（因为平移操作既不影响它的长度，也不改变它的方向）。显而 易见，我们可以将向量 u 完全平移到向量 v 处（反之亦可），使两者完全重合，分毫不差—由此即可证明它们是相等的 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:1:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量与坐标系 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:2:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"左 /右手坐标系 Direct3D 采用的是左手坐标系（left-handed coordinate system）。 同一个向量在不同的坐标系中有着不同的坐标表示 对于向量来说，它的方向和模都表现 在对应的有向线段上，不会更改；只有在改变 描述它的参考系时，其坐标才会相应地改变。这一点是很重要的，因为这意味着：每当我们根据坐标来 确定一个向量时，其对应的坐标总是相对于某一参考系而言的。在 3D 计算机图形学中，我们通常会用 到较多的参考系。因此，我们需要记录向量在每一种坐标系中的对应坐标。另外，我们也需要知道如何 将向量坐标在不同的标架之间进行转换。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:2:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量的基本运算 $$ \\vec{u} = (u_x, u_y, u_z) ~ 和 ~ \\vec{v} = (v_x, v_y, v_z) $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量相等 两个向量相等，当且仅当他们的对应分量相等。即 $ \\vec{u} = \\vec{v} $ , 当且仅当 $ u_x = v_x，u_y = v_y，u_z = v_z $ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量相加 向量的加法即令两个向量的对应分量分别相加： $ \\vec{u} = \\vec{v} = ( u_x + v_x, u_y + v_y, u_z + v_z)$ 注意，只有同维 的向量之间才可以进行加法运算 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量相减 向量减法可以通过向量加法和标量乘法表示： $$ \\vec{u} - \\vec{v} = \\vec{u} + (-1 \\cdot \\vec{v}) = \\vec{u} + (-\\vec{v}) = (u_x - v_x, u_y - v_y, u_z - v_z) $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:3","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"标量 x 向量 向量可以与标量（即实数）相乘，所得到的结果仍是一个向量。 例如，设 k 为一个标量，则 $ k\\vec{u} = (ku_x, ku_y, ku_z) $。这种运算叫作标量乘法 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:4","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"零向量 有个叫作零向量（zero-vector）的特殊向量，它的所有分量都为 0， 可直接将它简记作 0 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:4:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量的几何意义 见图 1.6a由此可知，把一个向量的系数变为其相反数，就相当于在几何学中“翻 转”此向量的方向，而且对向量进行标量乘法即为对其长度进行缩放。 图 1.6b 展示了向量加法运算的几何意义：把 向量 u 进行平移，使 u 的尾部与 v 的头部重合。此时，向量 u 与向量 v 的和即：以 v 的尾部为 起点、以平移后 u 的头部为终点所作的向量（如果令向量 u 的位置保持不变，平移向量 v，使 v 的尾部与 u 的头部重合也能得到同样的结果。在这种情况下，u + v 的和就可以表示为以 u 的尾 部为起点、以平移后 v 的头部为终点所作的向量）。 可以看出，向量的加法运算与物理学中不同 作用力合成合力的规则是一致的。如果有两个力（两个向量）作用在同一方向上，则将在这个 方向上产生更大的合力（更长的向量）；如果有两个力（两个向量）作用于彼此相反的方向上， 那么便会产生更小的合力（更短的向量），如图 1.7 所示 图 1.6c 展示了向量减法运算的几何意义。从本质 上讲，v − u 的差值仍是一个向量，该向量自 u 的头部始至 v 的头部终。如果我们将 u 和 v 看作两个 点，那么 v − u 得到的是一个从点 u 指向点 v 的向量； 这种解释方式的重点在于使我们找出向量的方 向。同时，不难看出，在把 u 与 v 看作点的时候，v − u 的长度也就是“点 u 到点 v 的距离” ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:5:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"长度和单位向量 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:6:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"长度（模 ） 向量大小（亦称为模）的几何意义是对应有向线段的长度，用双竖线表示（例如||u||代表向量 u 的 模） 现给出向量 u = (x, y, z)，我们希望用代数的方法计算它的 模。3D 向量的模可通过运用两次勾股定理得出 $$ \\Vert u \\Vert = \\sqrt{y^2 + a^2 } = \\sqrt{y^2 + (\\sqrt x^2 + z^2)^2} = \\sqrt{x^2 + y^2 + z^2} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:6:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"单位向量 当向量的模为1的时候他就是单位向量 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:6:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量的规范化 在某些情况下，我们并不关心向量的长度，仅用它来表示方向。对此，我们希望使该向量的长度为 1。把一个向量的长度变为单位长度称为向量的规范化（normalizing）处理。具体实现方法是，将向量 的每个分量分别除以该向量的模 $$ \\begin{gather*} \\hat{u} = \\frac{\\vec{u}}{\\Vert \\vec{u} \\Vert} = (\\frac{x}{\\Vert \\vec{u} \\Vert}, \\frac{y}{\\Vert \\vec{u} \\Vert}, \\frac{z}{\\Vert \\vec{u} \\Vert}) \\\\ \\\\ 为了验证公式的正确性，下面计算 \\hat{u} 的长度，也就是模: \\\\ \\\\ \\Vert \\hat{u} \\Vert = \\sqrt{(\\frac{x}{\\Vert u \\Vert})^2 (\\frac{x}{\\Vert u \\Vert})^2 (\\frac{z}{\\Vert u \\Vert})^2} = \\frac{\\sqrt{x^2 + y^2 + z^2}}{\\sqrt{\\Vert u \\Vert ^ 2}} = \\frac{\\Vert u \\Vert}{\\Vert u \\Vert} = 1 \\\\ \\\\ 由此可见， \\hat{u} 确实是一个单位向量（unit vector） \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:6:3","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"点积 点积（dot product，亦称数量积或内积）是一种计算结果为标量值的向量乘法运算，因此有时也称 为标量积（scalar product）。 $$ \\begin{gather*} 设向量 \\vec{u} = ( u_x, u_y, u_z),~ \\vec{v} = (v_x, v_y, v_z) \\\\ \\\\ 则点积的定义为: \\vec{u} \\cdot \\vec{v} = u_x v_x + u_y v_y + u_z v_z \\\\ \\\\ 可见，点积就是向量间对应分量的乘积之和。 \\end{gather*} $$ 点积的定义并没有明显地体现出其几何意义。但是我们却能根据余弦定理（law of cosines)，找到二向量点积的几何关系 $$ \\vec{u} \\cdot \\vec{v} = \\Vert u \\Vert \\Vert v \\Vert \\cos\\theta $$ 其中，$ \\theta $ 是向量 $ \\vec{u} $与向量 $ \\vec{v} $ 之间的夹角，$ 0 \\leq \\theta \\leq \\pi $ 如果向量 u 和向量 v 都是单位向量，那么 u ⋅ v 就等 于两向量夹角的余弦值，即 u⋅ v= cosθ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:7:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"点积几何性质 如果 u⋅ v = 0 ，那么 u ⊥ v （即两个向量正交） 如果 u⋅ v \u003e 0 ，那么两向量之间的夹角 θ 小于 90°（即两向量间的夹角为一锐角） 如果 u⋅ v \u003c 0 ，那么两向量之间的夹角 θ 大于 90°（即两向量间的夹角为一钝角） ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:7:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"正交投影 考虑图 1.10。给出向量 v 和单位向量 n，请借助点积公式求出用 v 和 n 表示向量 p 的公式。 $$ \\begin{align*} \\vec{p} \u0026= k\\vec{n} ~ (观察图示存在标量k，使得 \\vec{p} = k\\vec{n}。 只要都在同一方向 就可以用这个公式) \\\\ \\\\ \u0026= (\\Vert \\vec{v} \\Vert \\cos\\theta)\\vec{n} ~ (这是利用三角函数, \\cos \\theta = \\frac{k}{\\vec{v}}) \\\\ \\\\ \u0026= (\\Vert \\vec{v} \\Vert \\cdot 1 \\cos\\theta)\\vec{n} ~ (这个 1 其实就是单位向量n) \\\\ \\\\ \u0026= (\\Vert \\vec{v} \\Vert \\Vert \\vec{n} \\Vert \\cos\\theta)\\vec{n} \\\\ \\\\ \u0026= (\\vec{v} \\cdot \\vec{n})\\vec{n} \\end{align*} $$ 特别是这里证明了：当 n 是单位向量时， k = v ⋅ n 顺带也解释了在这种情况下 v ⋅ n的几何意义。我们 称 p 为向量 v 落在向量 n 上的正交投影（orthogonal projection），通常将它表示为： $$ \\vec{p} = proj_n(\\vec{v}) $$ 如果 n 不具有单位长度，就先对它进行规范化处理，使之成为单位向量。通过把向量 n 替换为单位向量 $ \\frac{n}{\\Vert n \\Vert} $，即可得到更具一般性的投影公式： $$ \\vec{p} = proj_n(\\vec{v}) = (\\vec{v} \\cdot \\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert})\\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert} = (\\frac{(\\vec{v} \\cdot \\vec{n})}{\\Vert \\vec{n} \\Vert ^ 2}) \\vec{n} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:7:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"正交化 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"规范正交 如果向量集 $ {v_0, …, v_{n-1}} $中的每个向量都是互相正交（集合内的任一向量都与集合中的其他所有向量 相互正交）且皆具单位长度，那么我们就称此集合是规范正交（orthonormal）的 有时我们会接到一个 近乎（但并不完全）规范正交的集合。这时，一个常见的工作就是通过正交化手段，使之成为规范正交集。 例如，我们有时会在 3D 计算机图形学中用到规范正交集，但是由于处理过程中数值精度的问题， 它会随之逐步变为非规范正交集。这时就要用到正交化这一手段了 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"2个向量的正交化 先来考察相对简单的 2D 情况吧(也就是说，集合内只有 2 个向量的情况)。假设我们有向量集合$ {v_0, v_1} $，现欲将它正交化为图 1.11 中所示的 正交集${w_0, w_1}$ 首先设 $ w_0 = v_0 $，通过使 $v_1$减去它在 $w_0$上的分量（投影）来令它正交于 $w_0$ $$ \\vec{w}_1 = \\vec{v}_1 - proj_{\\vec{w}_0}(\\vec{v}_1) $$ 此时，我们便得到了一个元素互相正交的向量集合${w_0, w_1}$；最后一步是构建一个规范正交集，将向量 $w_0$和 $w_1$规范化为单位向量即可。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"3个向量的正交化 假设有向量集${v_0, v_1, v_2}$，现希望将它正交化为 正交集${w_0, w_1, w_2}$，过程如图 1.12 所示。 首先使 $w_0 = v_0$，通过令 $v_1$减去它在 $w_0$方向上的分量，让它正交 于 $w_0$： $$ \\vec{w}_1 = \\vec{v}_1 - proj_{\\vec{w}_0}(\\vec{v}_1) $$ 接下来，通过令 $v_2$依次减去它在 $w_0$方向与 $w_1$方向上的分量（投影），使之同时正交于 $w_0、w_1$： $$ \\vec{w}_2 = \\vec{v}_2 - proj_{\\vec{w}_0}(\\vec{v}_2) - proj_{\\vec{w}_1}(\\vec{v}_2) $$ 现在我们就得到了所有元素都彼此正交的向量集${w_0, w_1, w_2}$；最后一步是通过将 $w_0、w_1、 w_2$规范化为单位向量来构建一个规范正交集 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:3","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"n个向量的正交化(格拉姆—施密特正交化) 基本步骤：设$ \\vec{w}_0 = \\vec{v}_0 $ 对于 $ 1 \\leq i \\leq n-1 $ , 令 $ \\vec{w}_i = \\vec{v}_i - \\sum_{j=0}^{i-1} \\text{proj}_{\\mathbf{w}_j} (\\mathbf{v}_i) $ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:4","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"叉积 向量乘法的第二种形式是叉积（cross product，亦称向量积、外积）。与计算结果为标量的点积不同， 叉积的计算结果亦为向量。此外，只有 3D 向量的叉积有定义（不存在 2D 向量叉积）。 假设 3D 向量 u 和 v 的叉积得到的是另一个向量 w，则 w 与向量 u、v 彼此正交。也就是说，向量 w 既正交于 u，也正交于 v $$ \\begin{gather*} \\vec{u} = (u_x, u_y, u_z),~ \\vec{v} = (v_x, v_y, v_z) \\\\ \\\\ 那么叉积的计算方法是 \\\\ \\\\ \\vec{w} = \\vec{u} \\times \\vec{v} = (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_x) \\end{gather*} $$ 根据计算结果可以明确地得出一项结论：一般来说 $ \\vec{u} \\times \\vec{v} \\neq \\vec{v} \\times \\vec{u} $ ，即向量的叉积不满足交换律 事实上， 我们同时也能够证明 $ \\vec{u} \\times \\vec{v} = -\\vec{v} \\times \\vec{u} $ ，这正是叉积的反交换律。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:9:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"叉积的模长公式 $$ \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:9:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"2D 向量的伪叉积 我们刚刚证明了：通过叉积可以求出与两个指定 3D 向量 正交的向量。在 2D 空间中虽然不存在这种情况，但是若给定 一个 2D 向量 $u = (u_x, u_y)$，我们还是能通过与 3D 向量叉积相似 的方法，求出与 向量u 正交的向量 v $$ \\vec{u} \\cdot \\vec{v} = (u_x, u_y) \\cdot (-v_y, v_x) $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:9:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"通过叉积来进行正交化处理 我们也可以通过叉积来进行正交化处理,但是收到数值精度误差累计的影响，也许会导致成为非规范正交集 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:10:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"点 在一个坐标系中，通 过一个处于标准位置的向量就能表示出 3D 空间中的特定位置，我们称这种向量为位置向 量（position vector） 在这种情况下，向量箭头的位置才是值得关注的主要特征，而方向和大小都是无足 轻重的。“位置向量”和“点”这两个术语可以互相替代，这是因为一个位置向量足以确定一个点。 然而，用向量表示点也有副作用，在代码中则更为明显，因为部分向量运算对点来说是没有意义的。 例如，两点之和的意义何在？但从另一方面来讲，一些运算却可以在点上得到推广 可以将两个点 的差 q−p 定义为由点 p 指向点 q 的向量。 同样，也可以定义点 p 与向量 v 相加，其意义为：令点 p 沿向量 v 位移而得到点 q。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:11:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"小结 向量可以用来模拟同时具有大小和方向的物理量。 在几何学上，我们用有向线段表示向量。当 向量平移至尾部与所在坐标系原点恰好重合的位置时，向量位于标准位置。一旦向量处于标准 位置，我们便可以用向量头部相对于坐标系的坐标来作为它的数学描述 假设有向量 $\\vec{u} = (u_x, u_y, u_z)$ 和向量 $ \\vec{v} = (v_x, v_y, v_z) $，那么就能对他们进行下列向量计算 （a）加法运算： $$ \\begin{gather*} \\vec{u} + \\vec{v} = (u_x + v_x, u_y + v_y, u_z + v_z) ~~~~~ 公式 \\\\ \\\\ \\vec{u} + \\vec{v} = \\vec{v} + \\vec{u} ~~~~~ 满足交换律 \\\\ \\\\ (\\vec{u} + \\vec{v}) + \\vec{w} = \\vec{u} + (\\vec{v} + \\vec{w}) ~~~~~ 满足结合律 \\\\ \\\\ (\\vec{u} + \\vec{v})k = k\\vec{u} + k\\vec{v} ~~~~~ 满足与标量相乘的分配律 \\end{gather*} $$ （b） 减法运算： $$ \\begin{gather*} \\vec{u} - \\vec{v} = (u_x - v_x, u_y - v_y, u_z - v_z) ~~~~~ 公式 \\\\ \\\\ \\vec{u} - \\vec{v} \\neq \\vec{v} - \\vec{u} ~~~~~ 不满足交换律 ~ 除非 \\vec{u} = \\vec{v} \\\\ \\\\ (\\vec{u} - \\vec{v}) - \\vec{w} \\neq \\vec{u} - (\\vec{v} - \\vec{w}) ~~~~~ 不满足结合律 ~ 除非\\vec{w} 是零向量 \\\\ \\\\ (\\vec{u} - \\vec{v})k = k\\vec{u} - k\\vec{v} ~~~~~ 满足与标量相乘的分配律 \\end{gather*} $$ （c）标量乘法运算： $$ k\\vec{u} = (ku_x, ku_y, ku_z) $$ （d） 向量长度（模）: $$ \\Vert \\vec{u} \\Vert = \\sqrt{x^2 + y^2 + z^2} $$ （e） 规范化： $$ \\hat{u} = \\frac{\\vec{u}}{\\Vert \\vec{u} \\Vert} = (\\frac{x}{\\Vert \\vec{u} \\Vert}, \\frac{y}{\\Vert \\vec{u} \\Vert}, \\frac{z}{\\Vert \\vec{u} \\Vert}) $$ （f） 点积： 点积的一个重要几何应用是计算两个向量之间的夹角 点积可以利用正交投影公式来一个向量在另一个向量方向上的投影 点积可以判断两条直线或两个平面是否垂直 $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = \\Vert u \\Vert \\Vert v \\Vert \\cos\\theta = u_x v_x + u_u v_y + u_z v_z ~~~~~ 公式 \\\\ \\\\ \\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u} ~~~~~ 满足交换律 \\\\ \\\\ (\\vec{u} \\cdot \\vec{v}) \\cdot \\vec{w} = \\vec{u} \\cdot (\\vec{v} \\cdot \\vec{w}) ~~~~~ 满足分配律 \\\\ \\\\ (k \\vec{u}) \\cdot \\vec{v} = \\vec{u} \\cdot (k\\vec{v}) ~~~~~ 满足标量的结合律 \\\\ \\\\ (\\vec{u} \\cdot \\vec{v}) \\cdot \\vec{w} \\neq \\vec{u} \\cdot (\\vec{v} \\cdot \\vec{w}) \\\\ \\\\ \\downarrow \\\\ \\\\ 不满足 点积与点积的结合律 这是因为点积的结果是一个标量，而标量与向量的点积没有定义。 \\end{gather*} $$ （g） 叉积： 叉积的结果向量垂直于 向量u 和 向量v 所在的平面，因此常用于计算平面的法向量。 叉积的模长等于以 向量u 和 向量v 为邻边的平行四边形的面积 || u x v || 叉积的方向由右手定则确定，常用于判断向量的旋转方向。 在物理学中，叉积常用于计算力矩、角动量等与旋转相关的物理量。 $$ \\begin{gather*} \\vec{w} = \\vec{u} \\times \\vec{v} = (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_x) ~~~~~ 公式 \\\\ \\\\ \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta ~~~~~~ 叉积的模长公式 \\\\ \\\\ \\vec{u} \\times \\vec{v} = \\vec{v} \\times \\vec{u} ~~~~~ 满足交换律 \\\\ \\\\ \\vec{u} \\times \\vec{v} = -\\vec{v} \\times \\vec{u} ~~~~~ 反交换律 \\\\ \\\\ \\vec{u} \\times (\\vec{v} + \\vec{w}) = \\vec{u} \\times \\vec{c} + \\vec{u} \\times \\vec{v} ~~~~~ 满足分配律 \\\\ \\\\ k\\vec{u} \\times \\vec{v} = \\vec{u} \\times k\\vec{v} ~~~~~~ 满足标量的结合律 \\\\ \\\\ (\\vec{u} \\times \\vec{v}) \\times\\vec{w} \\neq \\vec{u} \\times (\\vec{v} \\times\\vec{w}) ~~~~~ 不满足叉积与叉积的结合律 \\end{gather*} $$ 向量的几何意义 当向量的模为1的时候他就是单位向量 点积几何性质 正交投影 $$ \\vec{p} = proj_n(\\vec{v}) = (\\vec{v} \\cdot \\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert})\\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert} = (\\frac{(\\vec{v} \\cdot \\vec{n})}{\\Vert \\vec{n} \\Vert ^ 2}) \\vec{n} $$ 向量的正交化其实就是一个递归，在将给定集合内的向量 $ \\vec{v_i} $添加到规范正交集中时，我们需要令 $ \\vec{v_i} $减去它 在现有规范正交集中其他向量$ {w_0, w_1, …, w_i−1} $方向上的分量（投影） 基本步骤：设$ \\vec{w}_0 = \\vec{v}_0 $ 对于 $ 1 \\leq i \\leq n-1 $ , 令 $ \\vec{w}_i = \\vec{v}_i - \\sum_{j=0}^{i-1} \\text{proj}_{\\mathbf{w}_j} (\\mathbf{v}_i) $ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:12:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"作业 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"题目大纲 设向量 u = (1, 2)和向量 v = (3, –4)。写出下列各式的演算过程，并在 2D 坐标系内画出相应的向量 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。写出下列问题的解答过程 证明式子 (a) $ \\vec{u} + \\vec{v} = \\vec{v} + \\vec{u} $ （加法交换律） (b) $ \\vec{u} + (\\vec{v} + \\vec{w}) = (\\vec{u} + \\vec{v}) + \\vec{w} $ （加法结合律） (c) $ (ck)\\vec{u} = c(k\\vec{u}) $ （标量乘法的结合律） (d) $ k(\\vec{u} + \\vec{v}) = k\\vec{u} + k\\vec{v} $ （分配律 1） (e) $ \\vec{u}(k + c) = k\\vec{u} + c\\vec{u} $ （分配律 2） 根据等式 “2[(1, 2, 3) − x] − (−2, 0, 4) = −2(1, 2, 3)\"，求其中的向量 x。 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。对 u 和 v 进行规范化处理。 设 k 为标量，$向量 u = (u_x, u_y, u_z)。求证||ku|| = ||k|| ||u||$ 下列各组向量中，u 与 v 之间的夹角是直角、锐角还是钝角？ （a）u = (1, 1, 1)，v = (2, 3, 4) （b）u = (1, 1, 0)，v = (−2, 2, 0) （c）u = (−1, −1, −1)，v = (3, 1, 0) 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。计算 u 和 v 之间的夹角 θ 设向量 $ u = (u_x, u_y, u_z)、v = (v_x, v_y, v_z)和 w = (w_x, w_y, w_z)，且 c 和 k 为标量。证明下列点积性质。 （a）$ \\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u} $ （b）$ \\vec{u} \\cdot (\\vec{v} + \\vec{w}) = \\vec{u} \\cdot \\vec{v} + \\vec{u} \\cdot \\vec{w} $ （c）$ k(\\vec{u} \\cdot \\vec{v}) = (k\\vec{u}) \\cdot \\vec{v} = \\vec{u} \\cdot (k\\vec{v}) $ （d）$ \\vec{v} \\cdot \\vec{v} = ||v||^2 $ （e）$ 0 \\cdot \\vec{v} = 0 $ 利用余弦定理 （ $ c^2 = a^2 + b^2 - 2ab \\cos\\theta $ ，其中 a、b、c 分别是三角形 3 条边的边长， θ 为 a 与 b 之间的夹角）来证明：$ u_x v_x + u_y v_y + u_z v_z = ||u|| ||v|| \\cos\\theta $ 设向量 n = (−2, 1)。将向量 g = (0, −9.8) 分解为两个相互正交的向量之和，使它们一个平行于 n、 一个正交于 n。最后，在同一 2D 坐标系中画出这些向量。 设向量 u = (−2, 1, 4)和向量 v = (3, −4, 1)。求向量 w = u × v ，再证明 w⋅ u= 0 及 w ⋅ v= 0 。 设 A = (0, 0, 0)，B = (0, 1, 3)和 C = (5, 1, 0)三点在某坐标系中定义了一个三角形。求出一正交于此三角形的向量。 证明 $ \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta $ 证明：由向量 u 和向量 v 张成的平行四边形面积为|| u × v || ，如图 1.21 所示。 举例证明：存在 3D 向量 u、v 和 w，满足 u x (v x w) ≠ (u x v) x w 。这说明叉积一般不满足结合律。 证明两个非零且相互平行向量的叉积为零向量，即 $ \\vec{u} \\times k\\vec{u} = 0 $。 利用格拉姆—施密特正交化方法，令向量集 {(1, 0, 0), (1, 5, 0), (2, 1, −4)} 规范正交化。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第一题 设向量 u = (1, 2)和向量 v = (3, –4)。写出下列各式的演算过程，并在 2D 坐标系内画出相应的向量 $$ \\begin{align*} \\vec{u} + \\vec{v} \u0026= (u_x + v_x, u_y + v_y) \\\\ \\\\ \u0026= (1 + 3, 2 + (-4)) \\\\ \\\\ \u0026= (4, -2) \\end{align*} $$ $$ \\begin{align*} \\vec{u} - \\vec{v} \u0026= (u_x - v_x, u_y - v_y) \\\\ \\\\ \u0026= (1 - 3, 2 - (-4)) \\\\ \\\\ \u0026= (-2, 6) \\end{align*} $$ $$ \\begin{align*} 2\\vec{u} + \\frac{1}{2} \\vec{v} \u0026= (2u_x, 2u_y) + (\\frac{1}{2} v_x, \\frac{1}{2} v_y) \\\\ \\\\ \u0026= (2u_x + \\frac{1}{2} v_x, 2u_y + \\frac{1}{2} v_y) \\\\ \\\\ \u0026= (2 + 1.5, 4 + (-2)) \\\\ \\\\ \u0026= (3.5, 2) \\end{align*} $$ $$ \\begin{align*} -2\\vec{u} + \\vec{v} \u0026= (-2u_x, -2u_y) + (v_x,v_y) \\\\ \\\\ \u0026= (-2u_x + v_x, -2u_y, v_y) \\\\ \\\\ \u0026= (-2 + 3, -4 + -4) \\\\ \\\\ \u0026= (1, -8) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第二题 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。写出下列问题的解答过程 $$ \\begin{align*} \\vec{u} + \\vec{v} \u0026= (u_x + v_x, u_y + v_y, u_z + v_z) \\\\ \\\\ \u0026= (-1 + 3, 3 + (-4), 2 + 1) \\\\ \\\\ \u0026= (2, -1, 3) \\end{align*} $$ $$ \\begin{align*} \\vec{u} - \\vec{v} \u0026= (u_x - v_x, u_y - v_y, u_z - v_z) \\\\ \\\\ \u0026= (-1 - 3, 3 - (-4), 2 - 1) \\\\ \\\\ \u0026= (-4, 7, 1) \\end{align*} $$ $$ \\begin{align*} 3\\vec{u} + 2\\vec{v} \u0026= (3u_x, 3u_y, 3u_z) + (2v_x, 2v_y, 2v_z) \\\\ \\\\ \u0026= (-3, 9, 6) + (6, -8, 2) \\\\ \\\\ \u0026= (-3 + 6, 9 + (-8), 6 + 2) \\\\ \\\\ \u0026= (3, 1, 8) \\end{align*} $$ $$ \\begin{align*} -2\\vec{u} + \\vec{v} \u0026= (-2u_x, -2u_y, -2u_z) + (v_x, v_y, v_z) \\\\ \\\\ \u0026= (2, -6, -4) + (3, -4, 1) \\\\ \\\\ \u0026= (2 + 3, -6 + (-4), -4 + 1) \\\\ \\\\ \u0026= (5, -10, -3) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:3","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第三题 (a) $ \\vec{u} + \\vec{v} = \\vec{v} + \\vec{u} $ （加法交换律） $$ \\vec{u} + \\vec{v} = (u_x + v_x, u_y + v_y, u_z + v_z) = (v_x + u_x, v_y + u_y, v_z + u_z) = \\vec{v} + \\vec{u} $$ (b) $ \\vec{u} + (\\vec{v} + \\vec{w}) = (\\vec{u} + \\vec{v}) + \\vec{w} $ （加法结合律） $$ \\begin{align*} \\vec{u} + (\\vec{v} + \\vec{w}) \u0026= (u_x, u_y, u_z) + (v_x + w_x, v_y + w_y, v_z + w_z) \\\\ \\\\ \u0026= (u_x + (v_x + w_x), u_y + (v_y + w_y), u_z + (v_z + w_z)) \\\\ \\\\ \u0026= ((u_x + v_x) + w_x, (u_y + v_y) + w_y, (u_z + v_z) + w_z) \\\\ \\\\ \u0026= (u_x + v_x, u_y + v_y, u_z + v_z) + (w_x, w_y, w_z) \\\\ \\\\ \u0026= (\\vec{u} + \\vec{v}) + \\vec{w} \\end{align*} $$ (c) $ (ck)\\vec{u} = c(k\\vec{u}) $ （标量乘法的结合律） $$ \\begin{align*} (ck)\\vec{u} \u0026= (ck)(u_x, u_y, u_z) \\\\ \\\\ \u0026= ((ck)u_x, (ck)u_y, (ck)u_z) \\\\ \\\\ \u0026= (c(ku_x), c(ku_y), c(ku_z)) \\\\ \\\\ \u0026= c(k\\vec{u}) \\end{align*} $$ (d) $ k(\\vec{u} + \\vec{v}) = k\\vec{u} + k\\vec{v} $ （分配律 1） $$ \\begin{align*} k(\\vec{u} + \\vec{v}) \u0026= k(u_x + v_x, u_y + v_y, u_z + v_z) \\\\ \\\\ \u0026= (ku_x + kv_x, ku_y + kv_y, ku_z + kv_z) \\\\ \\\\ \u0026= k\\vec{u} + k\\vec{v} \\end{align*} $$ (e) $ \\vec{u}(k + c) = k\\vec{u} + c\\vec{u} $ （分配律 2） $$ \\begin{align*} \\vec{u}(k + c) \u0026= (u_x(k+c), u_y(k+c), u_z(k+c)) \\\\ \\\\ \u0026= (ku_x + cu_x, ku_y + cu_y, ku_z + cu_z) \\\\ \\\\ \u0026= k\\vec{u} + c\\vec{u} \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:4","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第四题 根据等式 “2[(1, 2, 3) − x] − (−2, 0, 4) = −2(1, 2, 3)\"，求其中的向量 x。 $$ \\begin{align*} 2[(1, 2, 3) − \\vec{x}] − (−2, 0, 4) \u0026= -2(1, 2, 3) \\\\ \\\\ [(2, 4, 6) - 2(\\vec{x})] - (-2, 0, 4) \u0026= (-2, -4, -6) \\\\ \\\\ [(2, 4, 6) - 2(\\vec{x})] \u0026= (-2, -4, -6) + (-2, 0, 4) \\\\ \\\\ [(2, 4, 6) - 2(\\vec{x})] \u0026= (-4, -4, -2) \\\\ \\\\ - 2(\\vec{x}) \u0026= (-4, -4, -2) - (2, 4, 6) \\\\ \\\\ 2(\\vec{x}) \u0026= - (-6, -8, -8) \\\\ \\\\ \\vec{x} \u0026= (3, 4, 4) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:5","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第五题 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。对 u 和 v 进行规范化处理。 $$ \\begin{align*} \\vec{u} = \\frac{\\vec{u}}{\\Vert \\vec{u} \\Vert} = \\frac{(u_x, u_y, u_z)}{\\sqrt{u_x^2 + u_y^2 + u_z^2}} = \\frac{(-1, 3, 2)}{\\sqrt{1 + 9 + 4}} = \\frac{(-1, 3, 2)}{\\sqrt{14}} = (\\frac{-1}{\\sqrt{14}}, \\frac{3}{\\sqrt{14}}, \\frac{2}{\\sqrt{14}}) \\\\ \\\\ \\vec{v} = \\frac{\\vec{v}}{\\Vert \\vec{v} \\Vert} = \\frac{(v_x, v_y, v_z)}{\\sqrt{v_x^2 + v_y^2 + v_z^2}} = \\frac{(3, -4, 1)}{\\sqrt{9 + 16 + 1}} = \\frac{(3, -4, 1)}{\\sqrt{26}} = (\\frac{3}{\\sqrt{26}}, \\frac{-4}{\\sqrt{26}}, \\frac{1}{\\sqrt{26}}) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:6","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第六题 设 k 为标量，$向量 u = (u_x, u_y, u_z)。求证||ku|| = ||k|| ||u||$ $$ \\begin{align*} ||ku|| \u0026= ||ku_x, ku_y, ku_z|| \\\\ \\\\ \u0026= \\sqrt{(ku_x)^2 + (ku_y)^2 + (ku_z)^2} \\\\ \\\\ \u0026= \\sqrt{k^2u_x^2 + k^2u_y^2 + k^2u_z^2} \\\\ \\\\ \u0026= \\sqrt{k^2 + (u_x^2, u_y^2, u_z^2)} \\\\ \\\\ \u0026= \\sqrt{k^2} + \\sqrt{\\vec{u}^2} \\\\ \\ \u0026= ||k|| + ||\\vec{u}|| \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:7","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第七题 下列各组向量中，u 与 v 之间的夹角是直角、锐角还是钝角？ （a）u = (1, 1, 1)，v = (2, 3, 4) $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = ||u|| ||v|| \\cos\\theta \\\\ \\\\ \\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{||u|| ||v||} \\\\ \\\\ \\cos\\theta = \\frac{u_x v_x + u_y v_y + u_z v_z}{\\sqrt{u_x^2 + u_y^2 + u_z^2} \\cdot \\sqrt{v_x^2 + v_y^2 + v_z^2}} \\\\ \\\\ \\cos\\theta = \\frac{2 + 3 + 4}{\\sqrt{3} \\cdot \\sqrt{29}} \\\\ \\\\ \\cos\\theta = \\frac{9}{\\sqrt{87}} \\\\ \\\\ 因\\cos\\theta \u003e 0, 故为锐角 \\\\ \\\\ 如果想求出角度 则可以 θ=arccos(\\frac{9}{\\sqrt{87}})≈15.8^\\circ \\end{gather*} $$ （b）u = (1, 1, 0)，v = (−2, 2, 0) $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = ||u|| ||v|| \\cos\\theta \\\\ \\\\ \\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{||u|| ||v||} \\\\ \\\\ \\cos\\theta = \\frac{u_x v_x + u_y v_y + u_z v_z}{\\sqrt{u_x^2 + u_y^2 + u_z^2} \\cdot \\sqrt{v_x^2 + v_y^2 + v_z^2}} \\\\ \\\\ \\cos\\theta = \\frac{-2 + 2 + 0}{\\sqrt{2} \\cdot \\sqrt{8}} \\\\ \\\\ \\cos\\theta = \\frac{0}{\\sqrt{16}} = 0 \\\\ \\\\ 因\\cos\\theta = 0, 故为直角 \\end{gather*} $$ （c）u = (−1, −1, −1)，v = (3, 1, 0) $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = ||u|| ||v|| \\cos\\theta \\\\ \\\\ \\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{||u|| ||v||} \\\\ \\\\ \\cos\\theta = \\frac{u_x v_x + u_y v_y + u_z v_z}{\\sqrt{u_x^2 + u_y^2 + u_z^2} \\cdot \\sqrt{v_x^2 + v_y^2 + v_z^2}} \\\\ \\\\ \\cos\\theta = \\frac{(-3) + (-1) + 0}{\\sqrt{3} \\cdot \\sqrt{10}} \\\\ \\\\ \\cos\\theta = \\frac{-4}{\\sqrt{30}} \\\\ \\\\ 因\\cos\\theta \u003c 0, 故为钝角 \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:8","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第八题 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。计算 u 和 v 之间的夹角 θ $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = ||u|| ||v|| \\cos\\theta \\\\ \\\\ \\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{||u|| ||v||} \\\\ \\\\ \\cos\\theta = \\frac{u_x v_x + u_y v_y + u_z v_z}{\\sqrt{u_x^2 + u_y^2 + u_z^2} \\cdot \\sqrt{v_x^2 + v_y^2 + v_z^2}} \\\\ \\\\ \\cos\\theta = \\frac{(-3) + (-12) + 2}{\\sqrt{14} \\cdot \\sqrt{26}} \\\\ \\\\ \\cos\\theta = \\frac{-13}{\\sqrt{2\\sqrt{91}}} \\\\ \\\\ θ=arccos(\\frac{-13}{2\\sqrt{91}})≈123.7^\\circ \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:9","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第九题 设向量 $ u = (u_x, u_y, u_z)、v = (v_x, v_y, v_z)和 w = (w_x, w_y, w_z)，且 c 和 k 为标量。证明下列点积性质。 （a）$ \\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u} $ $$ \\begin{align*} \\vec{u} \\cdot \\vec{v} \u0026= (u_x, u_y, u_z) + (v_x, v_y, v_z) \\\\ \\\\ \u0026= (u_x v_x + u_y v_y + u_z v_z) \\\\ \\\\ \u0026= (v_x, v_y, v_z) + (u_x, u_y, u_z) \\\\ \\\\ \u0026= \\vec{v} \\cdot \\vec{u} \\end{align*} $$ （b）$ \\vec{u} \\cdot (\\vec{v} + \\vec{w}) = \\vec{u} \\cdot \\vec{v} + \\vec{u} \\cdot \\vec{w} $ $$ \\begin{align*} \\vec{u} \\cdot (\\vec{v} + \\vec{w}) \u0026= (u_x, u_y, u_z) \\cdot ((v_x + w_x, v_y + w_y, v_z + w_z)) \\\\ \\\\ \u0026= u_x(v_x + w_x) + u_y(v_y + w_y) + u_z(v_z + w_z) \\\\ \\\\ \u0026= (u_x v_x + u_x w_x) + (u_y v_y + u_y w_y) + (u_z v_z + u_z w_z) \\\\ \\\\ \u0026= (u_x v_x + u_y v_y + u_z v_z) + (u_x w_x + u_y w_y + u_z w_z) \\\\ \\\\ \u0026= \\vec{u} \\cdot \\vec{v} + \\vec{u} \\cdot \\vec{w} \\end{align*} $$ （c）$ k(\\vec{u} \\cdot \\vec{v}) = (k\\vec{u}) \\cdot \\vec{v} = \\vec{u} \\cdot (k\\vec{v}) $ $$ \\begin{align*} k(\\vec{u} \\cdot \\vec{v}) \u0026= k(u_x v_y + u_y v_y + u_z v_z) \\\\ \\\\ \u0026= (ku_x)v_x + (ku_y)v_y + (ku_z)v_z \\\\ \\\\ \u0026= (k\\vec{u}) \\cdot \\vec{v} \\\\ \\\\ \u0026= u_x(kv_x) + u_y(kv_y) + u_z(kv_z) \\\\ \\\\ \u0026= \\vec{u} \\cdot (k\\vec{v}) \\end{align*} $$ （d）$ \\vec{v} \\cdot \\vec{v} = ||v||^2 $ $$ \\begin{align*} \\vec{v} \\cdot \\vec{v} \u0026= v_x v_x + v_y v_y + v_z v_z \\\\ \\\\ \u0026= v_x^2 + v_y^2 + v_z^2 \\\\ \\\\ \u0026= \\sqrt{v_x^2 + v_y^2 + v_z^2}^2 \\\\ \\\\ \u0026= ||v||^2 \\end{align*} $$ （e）$ 0 \\cdot \\vec{v} = 0 $ $$ \\begin{align*} 0 \\cdot \\vec{v} \u0026= 0v_x + 0v_y + 0v_z \\\\ \\\\ \u0026= 0 + 0 + 0 \\\\ \\\\ \u0026= 0 \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:10","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十题 利用余弦定理 （ $ c^2 = a^2 + b^2 - 2ab \\cos\\theta $ ，其中 a、b、c 分别是三角形 3 条边的边长， θ 为 a 与 b 之间的夹角）来证明：$ u_x v_x + u_y v_y + u_z v_z = ||u|| ||v|| \\cos\\theta $ $$ \\begin{gather*} c^2 = a^2 + b^2 - 2ab \\cos\\theta \\\\ \\\\ ||w||^2 = ||u||^2 + ||v||^2 - 2||u|| ||v|| \\cos\\theta ~~~~~~ (因为 c a b都是各边对应的模) \\\\ \\\\ ||w||^2 = (\\vec{u} - \\vec{v})^2 = ||u||^2 + ||v||^2 - 2(\\vec{u} \\cdot \\vec{v}) ~~~~~ (点积分配律) \\\\ \\\\ ||u||^2 + ||v||^2 - 2||u|| ||v|| \\cos\\theta = ||u||^2 + ||v||^2 - 2(\\vec{u} \\cdot \\vec{v}) ~~~~~ (||w||^2 = ||w||^2) \\\\ \\\\ - 2||u|| ||v|| \\cos\\theta = - 2(\\vec{u} \\cdot \\vec{v}) \\\\ \\\\ ||u|| ||v|| \\cos\\theta = \\vec{u} \\cdot \\vec{v} \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:11","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十一题 设向量 n = (−2, 1)。将向量 g = (0, −9.8) 分解为两个相互正交的向量之和，使它们一个平行于 n、 一个正交于 n。最后，在同一 2D 坐标系中画出这些向量。 $$ \\begin{align*} \\vec{g_{||}} \u0026= proj_n(\\vec{g}) \\\\ \\\\ \u0026= (\\vec{g} \\cdot \\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert})\\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert} \\\\ \\\\ \u0026= (\\frac{(\\vec{g} \\cdot \\vec{n})}{\\Vert \\vec{n} \\Vert ^ 2}) \\vec{n} \\\\ \\\\ \u0026= (\\frac{(g_x n_x + g_y n_y)}{\\sqrt{n_x^2 + n_y^2}}) (-2, 1) \\\\ \\\\ \u0026= (\\frac{(0 + (-9.8))}{\\sqrt{5}})(-2, 1) \\\\ \\\\ \u0026= −1.96(−2,1) \\\\ \\\\ \u0026= (-3.92, −1.96) \\\\ \\\\ \\vec{g}_\\perp \u0026= \\vec{g} - \\vec{g_{||}} \\\\ \\\\ \u0026= (0, −9.8) − (3.92, −1.96) \\\\ \\\\ \u0026= (−3.92, −7.84) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:12","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十二题 设向量 u = (−2, 1, 4)和向量 v = (3, −4, 1)。求向量 w = u × v ，再证明 w⋅ u= 0 及 w ⋅ v= 0 。 $$ \\begin{align*} \\vec{w} = \\vec{u} \\times \\vec{v} \u0026= (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_x) \\\\ \\\\ \u0026= (1 - (-16), 12 - (-2), 8 - 3) \\\\ \\\\ \u0026= (17, 14, 5) \\\\ \\\\ \\vec{w} \\cdot \\vec{u} \u0026= (w_x u_x + w_y u_y + w_z u_z) \\\\ \\\\ \u0026= (-34 + (14) + (20)) \\\\ \\\\ \u0026= 0 \\\\ \\\\ \\vec{w} \\cdot \\vec{v} \u0026= (w_x v_x + w_y v_y + w_z v_z) \\\\ \\\\ \u0026= (51 + (-56) + 5) \\\\ \\\\ \u0026= 0 \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:13","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十三题 设 A = (0, 0, 0)，B = (0, 1, 3)和 C = (5, 1, 0)三点在某坐标系中定义了一个三角形。求出一正交于此三角形的向量。 $$ \\begin{align*} \\vec{AB} \u0026= B - A = (0 - 0, 1 - 0, 3 - 0) = (0, 1, 3) \\\\ \\\\ \\vec{AC} \u0026= C - A = (5 - 0, 1 - 0, 0 - 0) = (5, 1, 0) \\\\ \\\\ \\vec{ABC_\\perp} \u0026= \\vec{AB} \\times \\vec{AC} \\\\ \\\\ \u0026= (AB_y AC_z - AB_z AC_y, AB_z AC_x - AB_x AC_z, AB_x AC_y - AB_y AC_x) \\\\ \\\\ \u0026= (0 - 3, 15 - 0, 0 - 5) \\\\ \\\\ \u0026= (-3, 15, -5) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:14","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十四题 证明 $ \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta $ $$ \\begin{gather*} \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta \\\\ \\\\ \\Vert \\vec{u} \\times \\vec{v} \\Vert = (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_z) \\\\ \\\\ \\Vert \\vec{u} \\times \\vec{v} \\Vert^2 = (u_y v_z - u_z v_y)^2 + (u_z v_x - u_x v_z)^2 + (u_x v_y - u_y v_z)^2 \\\\ \\\\ \\Vert \\vec{u} \\times \\vec{v} \\Vert^2 = (u_y^2 v_z^2 - 2u_yv_zu_zv_y + u_z^2 v_y^2) + (u_z^2 v_x^2 - 2u_zv_xu_xv_z + u_x^2 v_z^2) + (u_x^2 v_y^2 - 2u_xv_yu_yv_x + u_y^2 v_x^2) \\\\ \\\\ \\Vert \\vec{u} \\Vert^2 \\Vert \\vec{v} \\Vert^2 - (\\vec{u} \\cdot\\vec{v})^2 = (u_y^2 v_z^2 + u_z^2 v_y^2) + (u_z^2 v_x^2 + u_x^2 v_z^2) + (u_x^2 v_y^2 + u_y^2 v_x^2) - 2(u_yv_zu_zv_y + u_zv_xu_xv_z + u_xv_yu_yv_x) \\\\ \\\\ \\Vert \\vec{u} \\Vert^2 \\Vert \\vec{v} \\Vert^2 - (\\vec{u} \\cdot\\vec{v}) \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:15","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十五题 证明：由向量 u 和向量 v 张成的平行四边形面积为 || u x v || ，如图 1.21 所示。 $$ A = \\Vert \\vec{v} \\Vert h \\\\ \\\\ h = \\Vert \\vec{u} \\Vert \\sin\\theta \\\\ \\\\ A = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta \\\\ \\\\ A = \\Vert \\vec{u} \\times \\vec{v} \\Vert $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:16","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十六题 举例证明：存在 3D 向量 u、v 和 w，满足 u x (v x w) ≠ (u x v) x w 。这说明叉积一般不满足结合律。 $$ \\begin{gather*} 设 \\vec{u} = (1, 0, 0), \\vec{v} = (1, 1, 0), \\vec{w} = (0, 1, 1) \\\\ \\\\ \\vec{u} \\times (\\vec{v} \\times \\vec{w}) = \\vec{u} \\times (1, -1, 1) = (0, -1, -1) \\\\ \\\\ (\\vec{u} \\times \\vec{v}) \\times \\vec{w} = (0, 0, 1) \\times \\vec{w} = (-1, 0, 0) \\\\ \\\\ 故 \\vec{u} \\times (\\vec{v} \\times \\vec{w}) \\neq (\\vec{u} \\times \\vec{v}) \\times \\vec{w} \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:17","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十七题 证明两个非零且相互平行向量的叉积为零向量，即 $ \\vec{u} \\times k\\vec{u} = 0 $。 $$ \\begin{align*} \\vec{u} \\times k\\vec{u} \u0026= (u_y ku_z - u_z ku_y, u_z ku_x - u_x ku_z, u_x ku_y - u_y ku_x ) \\\\ \\\\ \u0026= k(u_y u_z - u_z u_y, u_z u_x - u_x u_z, u_x u_y - u_y u_x) \\\\ \\\\ \u0026= k(0, 0, 0) \\\\ \\\\ \u0026= (0, 0, 0) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:18","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"第十八题 利用格拉姆—施密特正交化方法，令向量集 {(1, 0, 0), (1, 5, 0), (2, 1, −4)} 规范正交化。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:13:19","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["Unreal Shader"],"content":"HLSL ","date":"2024-12-22","objectID":"/unreal-hlsl/:0:0","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["Unreal Shader"],"content":"数据类型 代码基于以下蓝图 ","date":"2024-12-22","objectID":"/unreal-hlsl/:1:0","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["Unreal Shader"],"content":"bool bool b = false; ","date":"2024-12-22","objectID":"/unreal-hlsl/:1:1","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["Unreal Shader"],"content":"int 数据范围为 “-2147483648 ~ 2147483647” int C = A + B; return C; ","date":"2024-12-22","objectID":"/unreal-hlsl/:1:2","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["Unreal Shader"],"content":"half 这个也是整形 只不过 int 占4byte，half占2byte，为什么这么设计 因为在shader里面有时候不需要这么大的 half 范围在 “-60000~60000” return half(1); ","date":"2024-12-22","objectID":"/unreal-hlsl/:1:3","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["Unreal Shader"],"content":"float float f = 1.234; ","date":"2024-12-22","objectID":"/unreal-hlsl/:1:4","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["Unreal Shader"],"content":"double double d = 1.0; ","date":"2024-12-22","objectID":"/unreal-hlsl/:1:5","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["Unreal Shader"],"content":"uint 取值范围是 “0 ~ 4294967295” uint ui = 1; ","date":"2024-12-22","objectID":"/unreal-hlsl/:1:6","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["Unreal Shader"],"content":"Vector ","date":"2024-12-22","objectID":"/unreal-hlsl/:1:7","tags":["Unreal"],"title":"Unreal HLSL","uri":"/unreal-hlsl/"},{"categories":["游戏"],"content":"游戏","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"环世界Mod ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:0","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"1. harmony 必装，运行库文件，很多mod需要此文件才能正常运行 无需汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:1","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"2. HugsLib 绝大多数Mod的必备前置 需要汉化：HugsLib - 简\u0026繁中文汉化包 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:2","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"3. Vanilla Expanded Framework 原版扩展系列的前置Mod，现已整合派系侦测Mod。 派系侦测：原先翻译叫 “派系发现”，游戏过程中会随机生成新派新、新派系基地，可以在Mod设置里调节参数，老档加入新派系mod时，可以不用重开，用此mod刷出新派系 需要汉化 ：Vanilla Expanded Framework - 简\u0026繁中文汉化包 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:3","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"4. Humanoid Alien Races 外星人框架，所有非人类种族、派系Mod的必备前置。 需要汉化 ：Humanoid Alien Races - 简\u0026繁中文汉化包 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:4","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"6. FSharp.Core 本地语言支持 无需汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:5","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"7. XML Extensions mod框架补丁，当XML扩展处于活动状态时，所有XML修补程序错误现在也将生成堆栈跟踪！这意味着您可以准 确地找出哪个修补程序失败了，在某些情况下，它甚至会告诉您修补程序的哪个部分失败了。 需要汉化 ：XML Extensions简繁中文汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:6","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"8. MoHAR framework 为种族模组提供支持 无需汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:7","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"9. Map Reroll 可以在选择落地点的时候直接预览大地图上的当前地形 需要汉化：Map Reroll - 简\u0026繁中文汉化包 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:8","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"10. Character Editor 可以开局修改人物属性，极度正义 需要汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:9","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"11. Allow Tool 最强大的快捷工具模组，功能包含允许全图操作、一键收割成熟的植物、紧急搬运等等功能，并且他还是智能化的你敢信，举个例子，他直接开掘一大片矿时，它会自己规划开掘的区域避免坍塌，这个绝对是我最推荐的环世界辅助mod，极大地方便了玩家的操作，极为推荐。 需要汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:10","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"12. Pick Up And Haul 将原版中极其简单的搬运逻辑彻底的进行优化，直接改写了原版的搬运机制，让小人的搬运不再傻傻的操作一个，这个可以说是提高了小人相当高的操作效率，可以说是开档必备，每一个人我都极为推荐。 需要汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:11","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"13. Smart Medicine 也是一个逻辑优化mod，完美解决了原本在药物上的逻辑操作问题，医生再也不会跑老远拿极其昂贵的药品治疗一个小小的伤口，可以根据内置的选项自己更改觉得病态的机制，这模组图片可以说真形象了。 需要汉化 但是没找到汉化 14. RocketMan 环世界优化性能，必备 需要汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:12","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["Steam Deck"],"content":"SteamDeck 最近在折腾steam deck 放一个博客存一些命令，以防格式化或者啥的，又得重弄 但是专门为deck弄一个分类不太好，所以放生活吧~ 在前言放一个niu b的网站: https://ohmydeck.net/ 还有放一些游戏的攻略及一些相关东西 ","date":"2024-01-23","objectID":"/index_zh-cn/:0:0","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"刚拿到机子必须要做的事 ","date":"2024-01-23","objectID":"/index_zh-cn/:1:0","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"注意事项 千万不能把桌面模式改成中文 会出不少问题 如果改了就恢复出厂!!! ","date":"2024-01-23","objectID":"/index_zh-cn/:1:1","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"前置 进入桌面模式 设置密码 passwd 解锁只读权限 sudo steamos-readonly disable ","date":"2024-01-23","objectID":"/index_zh-cn/:1:2","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"加速桌面模式下的商店 sudo flatpak remote-modify flathub --url=https://mirror.sjtu.edu.cn/flathub ","date":"2024-01-23","objectID":"/index_zh-cn/:1:3","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"桌面模式下 安装中文输入法 首先，打开Discover应用商店，搜索“input”并找到Fcitx 5应用。点击安装按钮，开始下载并安装这款输入法应用 安装完成后，进入Fcitx 5的详情页面，找到Addons选项。在这里，你可以找到并安装Chinese Addons，为你的输入法增添中文支持。 安装完毕后，记得先启动Fcitx 5哦！然后，你可以通过右键点击状态栏中的输入法图标，选择Configure来配置你的输入法。在配置窗口中，输入“pinyin”并添加到左侧，即可开启拼音输入法功能。 最后，为了确保每次开机都能自动启动Fcitx 5和中文输入法，你需要进入系统设置，选择Startup and shutdown选项，然后添加Fcitx 5到自启动列表中 ","date":"2024-01-23","objectID":"/index_zh-cn/:2:0","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"安装UU加速器插件 curl -s uudeck.com|sudo sh ","date":"2024-01-23","objectID":"/index_zh-cn/:3:0","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"Clash - ToMoon ","date":"2024-01-23","objectID":"/index_zh-cn/:4:0","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"安装 如果已经安装过 Plugin Loader 2.0 以上版本，直接从第 8 点开始即可。 打开到 Steam Deck 设置界面 系统 -\u003e 系统设置 -\u003e 打开开发者模式 回到设置向下翻，找到开发者 -\u003e 打开 CEF 远程调试 等待 Steam Deck 重启 按电源键切换到 Desktop 桌面模式 打开 Konsole，输入 curl -L http://dl.ohmydeck.net | sh 安装 Plugin Loader 输入 curl -L http://i.ohmydeck.net | sh 安装 Tomoon 切换回到 Gamming 游戏模式，按下右侧摇杆下的快捷按钮（三个点的按钮），可以看到多了一个 Decky 插件面板 ","date":"2024-01-23","objectID":"/index_zh-cn/:4:1","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"使用 打开 Manage Subscriptions，添加你服务商提供的 Clash 订阅链接并下载 下载完成后，切换回主界面选择订阅并点击启动 在桌面模式可通过浏览器 http://127.0.0.1:9090/ui 打开仪表盘 ","date":"2024-01-23","objectID":"/index_zh-cn/:4:2","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["Steam Deck"],"content":"复原 DNS，解决插件消失而导致无法联网 在桌面模式打开 Konsole，输入以下命令。 注意：不熟悉 Linux 的朋友请务必输入正确，看到命令执行完后有错误出现就是输入错了。 sudo chattr -i /etc/resolv.conf sudo systemctl stop systemd-resolved sudo chmod a+w /etc/NetworkManager/conf.d/dns.conf sudo echo -e \"[main]\\ndns=auto\" \u003e /etc/NetworkManager/conf.d/dns.conf sudo nmcli general reload 如果安装的是 v0.0.5 (2022/11/18) 以上版本，可以使用脚本直接恢复。 bash ~/tomoon_recover.sh ","date":"2024-01-23","objectID":"/index_zh-cn/:4:3","tags":["Steam Deck"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["设计模式"],"content":"设计模式-备忘录","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"备忘录 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:0:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"状态变化模式 什么是状态变化 在组件构建过程中, 某些对象的状态面临变化, 如何对这些变化进行有效的管理? 同时又保证高层的稳定? 典型模式 Memento State ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:1:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 某些对象的状态在转换过程中, 可能由于某种需要, 要求程序能够回溯到对象之前的状态 如果使用一些公有接口来让其他对象得到对象的状态, 便会暴露对象的细节实现 如何实现对象状态的良好保存与恢复? 但同时又不会因此而破坏对象本身的封装性 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:2:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"模式定义 在不破坏封装性的的前提下, 捕获一个对象的内部状态, 并在该对象之外保存此状态，这样以后就可以将该对象恢复到原先保存的状态 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:3:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"要点总结 备忘录(Memento)存储原发器对象的内部状态 在需要时恢复原发器状态 Memento模式的核心是信息隐藏, 即原发器需要向外接隐藏信息, 保持其封装性，但同时有需要将状态保持到外界 (Memento) 由于现代语言运行时都具有相当的对象序列化支持, 因此往往采用效率高、又较容器正确实现的序列化方案来实现Memento模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:4:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"设计模式-策略模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"策略模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:0:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"组件协作模式 什么是组件协作模式 现代软件专业分工之后的第一个结果就是 框架与应用程序的划分 组件协作 模式通过晚绑定，来实现框架和应用之间的松耦合，是二者之间协作时常用的模式 典型模式 Template Method Observer / Event Strategy ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用策略模式的动机 在软件构建的过程中，某些对象使用的算法可能多种多样的，经常改变，如果将这种算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担 如何在运行时根据需要透明的更改对象的算法? 将算法与对象本身解藕 从而避免上述问题 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"静态代码 场景 每个国家税不同 所以要根据税去计算 演示代码及代码思路 这里的思路 就是 直接用一个枚举 记录各个国家的税 然后 根据不同的税 进行 if else if 计算，这里带来的需求变化 也是麻烦的 如果要加一个法国的税 就得新加else if 巨麻烦 这个就违反了 开放封闭 面向对象设计原则 支持扩展 拒绝更改，这样代码就会变成静态思路 这时候 我们扩展一下思路 加个\"时间轴\" 变成动态的 enum TaxBase { CN_Tax, US_Tax, DE_Tax }; class SalesOrder { TaxBase tax; public: double CalculateTax() { if (tax == CN_Tax) { // CN.... } else if (tax == US_Tax) { // US... } else if (tax == DE_Tax) { // DE... } //... } } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动态代码 场景 每个国家税不同 所以要根据税去计算 演示代码及思路 在下述代码中，如果我们要增加一个法国的税，只需要写一个法国的子类，这样就是扩展，而不是更改了枚举，还有增加了if else 当然你其实会有这样的疑问，在静态代码的思路，if else 的代码不是也没有动，就只是加了一个 else if 这不也是复用扩展嘛 这肯定不叫复用，复用是编译级别，编译之后，部署之后，原封不动，而且你想的太美好，在大量的else中，很有可能也要改变前面的思路，从而引发bug ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 定义一系列算法 把他们一个个封装起来 并且使他们可互相替换(变化) 该算法使得算法可独立于使用他的客户程序(稳定)而变化(扩展，子类化) ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Strategy及其子类为组件提供了一系列可重用的算法 从而可以使得类型在运行时方便的根据需要在各个算法之间进行切换 Strategy模式提供了在条件判断语句以外的另一种选择 消除条件判断语句 就是在解耦合 含有许多条件判断语句的代码通常都需要策略模式 如果Strategy对象没有实例变量， 那么各个上下文可以共享一个Strategy对象 从而节省对象开销 额外的解释 运行时 这个词 就是代码中多态调用的时候 其实 if else if 和 switch case 就是 分解 这个思路，我们将各种具体的计算税的算法抽象成了算法类，这个就是抽象的概念 不是所有的 if else策略模式就适用 在 if else绝对不变的情况下就可以用 if else 比如一周有7天的情况下 不能多出第八天 所以就可以用if else ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:7:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-抽象工厂","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"抽象工厂 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:0:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"对象创建模式 什么是对象创建 通过对象创建模式，绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)从而支持对象创建 他是接口抽象之后的第一步工作 典型模式 Factory Method Abstract Factory Prototype Builder ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:1:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"抽象工厂动机 在软件系统中 经常面临着 “一系列相互依赖的对象\"的创建工作，同时, 由于需求的变化, 往往存在更多系列对象的创建工作 如果应对这种变化? 如何绕过常规的对象创建方法(new), 提供一种\"封装机制\"来避免客户程序和这种\"多系列具体对象创建工作\"的紧耦合? ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:2:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"初始代码 class EmployeeDAO{ public: vector\u003cEmployeeDO\u003e GetEmployees(){ SqlConnection* connection = new SqlConnection(); connection-\u003eConnectionString = \"...\"; SqlCommand* command = new SqlCommand(); command-\u003eCommandText=\"...\"; command-\u003eSetConnection(connection); SqlDataReader* reader = command-\u003eExecuteReader(); while (reader-\u003eRead()){ } } }; ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:3:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"运用了工厂模式代码 //数据库访问有关的基类 class IDBConnection{ }; class IDBConnectionFactory{ public: virtual IDBConnection* CreateDBConnection()=0; }; class IDBCommand{ }; class IDBCommandFactory{ public: virtual IDBCommand* CreateDBCommand()=0; }; class IDataReader{ }; class IDataReaderFactory{ public: virtual IDataReader* CreateDataReader()=0; }; //支持SQL Server class SqlConnection: public IDBConnection{ }; class SqlConnectionFactory:public IDBConnectionFactory{ }; class SqlCommand: public IDBCommand{ }; class SqlCommandFactory:public IDBCommandFactory{ }; class SqlDataReader: public IDataReader{ }; class SqlDataReaderFactory:public IDataReaderFactory{ }; //支持Oracle class OracleConnection: public IDBConnection{ }; class OracleCommand: public IDBCommand{ }; class OracleDataReader: public IDataReader{ }; class EmployeeDAO{ IDBConnectionFactory* dbConnectionFactory; IDBCommandFactory* dbCommandFactory; IDataReaderFactory* dataReaderFactory; public: vector\u003cEmployeeDO\u003e GetEmployees(){ IDBConnection* connection = dbConnectionFactory-\u003eCreateDBConnection(); connection-\u003eConnectionString(\"...\"); IDBCommand* command = dbCommandFactory-\u003eCreateDBCommand(); command-\u003eCommandText(\"...\"); command-\u003eSetConnection(connection); //关联性 IDBDataReader* reader = command-\u003eExecuteReader(); //关联性 while (reader-\u003eRead()){ } } }; ## 运用了抽象工厂的代码 ```cpp //数据库访问有关的基类 class IDBConnection{ }; class IDBCommand{ }; class IDataReader{ }; class IDBFactory{ public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; }; //支持SQL Server class SqlConnection: public IDBConnection{ }; class SqlCommand: public IDBCommand{ }; class SqlDataReader: public IDataReader{ }; class SqlDBFactory:public IDBFactory{ public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; }; //支持Oracle class OracleConnection: public IDBConnection{ }; class OracleCommand: public IDBCommand{ }; class OracleDataReader: public IDataReader{ }; class EmployeeDAO{ IDBFactory* dbFactory; public: vector\u003cEmployeeDO\u003e GetEmployees(){ IDBConnection* connection = dbFactory-\u003eCreateDBConnection(); connection-\u003eConnectionString(\"...\"); IDBCommand* command = dbFactory-\u003eCreateDBCommand(); command-\u003eCommandText(\"...\"); command-\u003eSetConnection(connection); //关联性 IDBDataReader* reader = command-\u003eExecuteReader(); //关联性 while (reader-\u003eRead()){ } } }; ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:4:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"模式定义 提供一个接口, 让该接口负责创建一系列”相关或者互相依赖的对象\", 无需确定他们具体的类 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:5:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:6:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"要点总结 如果没有应对\"多系列对象构建\"的需求变化, 则没有必要使用 Abstract Factory模式, 这时候使用简单的工厂完全可以 “系列对象\"指的是在某一个特定系列下的对象之间有互相依赖\\或作用的关系.不同系列的对象自建不能相互依赖 Abstract Factory模式主要在于应对\"新系列\"的需求变动. 其缺点在于难以应对\"新对象\"的需求改动 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:7:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"设计模式-代理模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代理模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:0:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"接口隔离模式 什么是接口隔离 在组件构建过程中, 某些接口之间直接的依赖 常常会带来很多问题 甚至根本无法实现 采用添加一层间接(稳定)接口, 来隔离本来互相紧密关联的接口是一种常见的解决方案 典型模式 Façade Proxy Mediator Adapter ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 在面向对象系统中, 有些对象由于某种原因(比如对象创建的开销很大, 或者某些操作需要安全控制, 或者需要进程外的访问等)直接访问会给使用者或者系统结构带来很多麻烦 如何在不是去透明操作对象的同时来管理或者控制这些对象特有的复杂性？ 增加一层间接层是软件开发中常见的解决方式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:2:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"初始代码 class ISubject{ public: virtual void process(); }; class RealSubject: public ISubject{ public: virtual void process(){ //…. } }; class ClientApp{ ISubject* subject; public: ClientApp(){ subject=new RealSubject(); } void DoTask(){ //... subject-\u003eprocess(); //.... } }; ## 重构代码 1. ```cpp class ISubject{ public: virtual void process(); }; //Proxy的设计 class SubjectProxy: public ISubject{ public: virtual void process(){ //对RealSubject的一种间接访问 //.... } }; class ClientApp{ ISubject* subject; public: ClientApp(){ subject=new SubjectProxy(); } void DoTask(){ //... subject-\u003eprocess(); //.... } }; ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:3:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 为其他对象提供一种代理以控制(隔离，使用接口) 对这个对象的访问 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:4:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 “增加一层间接层\"是软件系统中对许多复杂问题的一种常见解决方法. 在面向对象系统中, 直接使用某些对象会带来很多问题, 作为间接层的proxy对象便是解决这一问题的常用手段 具体proxy设计模式的实现方法 实现粒度都相差很大 有些可能对单个对象做细粒度的控制, 如copy-on-write技术, 有些可能对组件模块提供抽象代理层, 在架构层次对对象做proxy proxy并不一定要求保持接口完整的一致性, 只要能够实现间接控制, 有时候损失一些透明性是可以接受的 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:5:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-单例模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单例模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"对象性能模式 什么是对象性能 面向对象很好的解决了\"抽象\"的问题, 但是必不可免的要付出一定的代价，对于通常情况来讲, 面向对象的成本大都可以忽略不计，但是某些情况, 面向对象所带来的成本必须谨慎处理 典型模式 Singleton Flyweight ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单例模式动机 在软件系统中 经常有这样一些特殊的类, 必须保证他们在系统中只存在一个实例, 才能确保他们的逻辑正确性以及良好的效率 如何绕过常规的构造器, 提供一种机制来保证一个类只有一个实例 ps：这个是类设计者的责任, 而不是使用者的责任 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"演示代码 class Singleton{ private: Singleton(); Singleton(const Singleton\u0026 other); public: static Singleton* getInstance(); static Singleton* m_instance; }; Singleton* Singleton::m_instance=nullptr; //线程非安全版本 Singleton* Singleton::getInstance() { if (m_instance == nullptr) { m_instance = new Singleton(); } return m_instance; } //线程安全版本，但锁的代价过高 Singleton* Singleton::getInstance() { Lock lock; if (m_instance == nullptr) { m_instance = new Singleton(); } return m_instance; } //双检查锁，但由于内存读写reorder不安全 Singleton* Singleton::getInstance() { if(m_instance==nullptr){ Lock lock; if (m_instance == nullptr) { m_instance = new Singleton(); } } return m_instance; } //C++ 11版本之后的跨平台实现 (volatile) std::atomic\u003cSingleton*\u003e Singleton::m_instance; std::mutex Singleton::m_mutex; Singleton* Singleton::getInstance() { Singleton* tmp = m_instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence if (tmp == nullptr) { std::lock_guard\u003cstd::mutex\u003e lock(m_mutex); tmp = m_instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new Singleton; std::atomic_thread_fence(std::memory_order_release);//释放内存fence m_instance.store(tmp, std::memory_order_relaxed); } } return tmp; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 保证一个类仅有一个实例, 并提供一个该实例的全局访问点 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Singleton模式中的实例构造器可以设置为protected以允许子类派生 Singleton模式一般不要支持拷贝构造函数和clone接口, 因为这有可能导致多个对象实例, 与Singleton模式的初衷违背 如何实现多线程环境下安全的Singleton？ 注意对双检查锁的正确实现 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-迭代器","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"迭代器 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:0:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"数据结构模式 什么是数据结构 常常有一些组件在内部具有特定的数据结构, 如果让客户程序依赖这些特定的数据结构, 将极大的破坏组件的复用 典型模式 Composite Iterator Chain of Resposibility ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"迭代器前言 这个模式 在 c++ 上其实已经过时了 GoF 对迭代器的定义 是面向对象的迭代器 要去遍历很多的虚函数 然而虚函数是有性能代价的 运行时依赖 懂得STL 泛型编程的朋友都知道 STL 里面定义了很多迭代器 这里面的迭代器是 模板方法的迭代器 编译时依赖 但是一个模式过时 不代表思想会过时 c++的迭代器也是根据这个思想 把算法和容器给隔离开来，而且其他语言 比如java 这个面向对象的迭代器也在使用，所以我们还是得对这个模式一探究竟 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:2:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 集合对象内部结构常常变化各异，但对于这些集合对象, 我们希望在不暴露其内部结构的同时, 可以让外部客户代码透明的访问其中包含的元素，同时这种\"透明遍历\"也为\"同一种算法在多种集合对象上进行操作\"提供了可能 使用面向对象技术将这种遍历机制抽象为\"迭代器对象\"，为\"应对变化中的集合对象\"提供了一种优雅的方式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:3:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露(稳定)该对象的内部表示 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:4:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 迭代抽象: 访问一个聚合对象的内容而无需暴露他的内部表示 迭代多态: 为遍历不同的集合结构提供一个统一的接口, 从而支持同样的算法在不同的集合结构上进行操作 迭代器的健壮性考虑: 遍历的同时更改迭代器所在的集合结构, 会导致问题 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:5:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-访问器","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"访问器 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:0:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"行为变化模式 什么是行为变化 在组件的构建过程中, 组件行为的变化经常导致组件本身剧烈的变化，“行为变化\"模式将组件的行为和组件本身进行解藕, 从而支持组件行为的变化, 实现两者之间的松耦合 典型模式 Command Visitor ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:1:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"访问器 - 前言 访问器这个模式 有一个很难的前提 就是在扩展的类的子类个数必须稳定 也就是说要提前就知道有多少个子类 不能增加 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:2:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 由于需求的改变, 某些类层次结构中常常需要增加新的行为(方法)，如果直接在基类中做这样的更改, 将会给子类带来很繁重的变更负担, 甚至破坏原有设计 如何在不更改层次结构的前提下, 在运行时根据需要透明的为类层次结构上的各个类动态添加新的操作, 从而避免上述问题? ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:3:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 表示一个作用于某对象结构中的各元素操作，使得可以在不改变(稳定)各元素的类的前提下定义(扩展)作用于这些元素的新操作(变化) ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:4:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 Visitor模式通过所有双重分发来实现在不更改类层次结构的前提下, 在运行时透明的为类层次结构上的各个类动态添加新的操作 所有双重分发即Visitor模式中间包含了两个多态分发 第一个为accept方法的多态辨析 第二个为visitElementX方法的多态辨析 Visitor模式的最大缺点为扩展类层次结构, 会导致visitor类的改变，因此这个模式适用于类层次结构稳定, 而其中的操作方法频繁变化 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:5:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-分类","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"分类 模式分类 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:0:0","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"从目的来看 创建型模式 将对象的部分创建工作延后到子类或者其他对象，从而应对需求变化为对象创建时带来的冲击 结构型模式 通过类继承或者对象组合获得灵活的结构，从而应对需求变化为对象的结构带来冲击 行为型模式 通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:1:0","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"从范围来看 类模式处理类与子类的静态关系 对象模式处理对象间的动态关系 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:2:0","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"从封装变化角度来看 组件协作 Template Method Observer / Event Strategy 单一职责 Decorator Bridge 对象创建 Factory Method Abstract Factory Prototype Builder 对象性能 Singleton Flyweight 接口隔离 Façade Proxy Mediator Adapter 状态变化 Memento State 数据结构 Composite Iterator Chain of Resposibility 行为变化 Command Visitor 领域问题 Interpreter 重构获得模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:3:0","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"重构获得模式 怎么去看待设计模式 面向对象模式是 “好的面向对象设计”，所谓好的面向对象设计就是指那些可以满足 应对变化，提高复用性 现代软件设计的特征就是 需求的频繁变化，所以设计模式重点在于 寻求变化点，然后在变化点应用设计模式，从而来更好的应对需求的变化 所以说，什么时候，什么地点应用设计模式比理解设计模式结构本身更为重要!!! 同时，设计模式的应用不宜先入为主，一上来就是用设计模式，这是最大的错误，而且也没有一步到位的设计模式让你去使用 重构与模式 很重要!!! 还有脚踏实地!!! ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:4:0","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"重构关键方法 静态 -\u003e 动态 早绑定 -\u003e 晚绑定 继承 -\u003e 组合 编译时依赖 -\u003e 运行时依赖 紧耦合 -\u003e 松耦合 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:5:0","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"设计模式-工厂模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:0:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"对象创建模式 什么是对象创建 通过对象创建模式，绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)从而支持对象创建 他是接口抽象之后的第一步工作 典型模式 Factory Method Abstract Factory Prototype Builder ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂模式动机 在软件系统中 经常面临着创建对象的工作 由于需求的变化 需要创建的对象的具体类型经常变化 如何应对这种变化? 如何绕过常规的对象创建方法(new), 提供一种\"封装机制\"来避免客户程序和这种\"具体对象创建工作\"的紧耦合? ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"初始代码 class ISplitter{ public: virtual void split()=0; virtual ~ISplitter(){} }; class BinarySplitter : public ISplitter{ }; class TxtSplitter: public ISplitter{ }; class PictureSplitter: public ISplitter{ }; class VideoSplitter: public ISplitter{ }; class MainForm : public Form { TextBox* txtFilePath; TextBox* txtFileNumber; ProgressBar* progressBar; public: void Button1_Click(){ ISplitter * splitter= new BinarySplitter();//依赖具体类 splitter-\u003esplit(); } }; ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"重构代码 //具体类 class BinarySplitter : public ISplitter{ }; class TxtSplitter: public ISplitter{ }; class PictureSplitter: public ISplitter{ }; class VideoSplitter: public ISplitter{ }; //具体工厂 class BinarySplitterFactory: public SplitterFactory{ public: virtual ISplitter* CreateSplitter(){ return new BinarySplitter(); } }; class TxtSplitterFactory: public SplitterFactory{ public: virtual ISplitter* CreateSplitter(){ return new TxtSplitter(); } }; class PictureSplitterFactory: public SplitterFactory{ public: virtual ISplitter* CreateSplitter(){ return new PictureSplitter(); } }; class VideoSplitterFactory: public SplitterFactory{ public: virtual ISplitter* CreateSplitter(){ return new VideoSplitter(); } }; //抽象类 class ISplitter{ public: virtual void split()=0; virtual ~ISplitter(){} }; //工厂基类 class SplitterFactory{ public: virtual ISplitter* CreateSplitter()=0; virtual ~SplitterFactory(){} }; class MainForm : public Form { SplitterFactory* factory;//工厂 public: MainForm(SplitterFactory* factory){ this-\u003efactory=factory; } void Button1_Click(){ ISplitter * splitter= factory-\u003eCreateSplitter(); //多态new splitter-\u003esplit(); } }; ## 模式定义 1. *定义一个用于创建对象的接口，让子类决定实例化哪一个类* 2. *Factory Method使得一个类的实例化延迟**(目的: 解藕，手段: 虚函数)**到子类* ## 类图 ![工厂模式类图](https://raw.githubusercontent.com/vlicecream/cloudImage/main/data/imagesimage-20220529155731948.png) ## 要点总结 1. *Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系，面对一个经常变化的具体类型,紧耦合关系(new)会导致软件的脆弱* 2. *Factor Method模式通过面向对象的手法,将所要创建的具体对象工作延迟到子类,从而实现一种扩展(并非更改)的策略，较好的解决了这种紧耦合关系* 3. *Factor Method模式解决\"单个对象\"的需求变化. 缺点在于要求创建方法/参数相同* ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-构建器","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"构建器 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:0:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"对象创建模式 什么是对象创建 通过对象创建模式，绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)从而支持对象创建 他是接口抽象之后的第一步工作 典型模式 Factory Method Abstract Factory Prototype Builder ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:1:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"构建器动机 在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？ ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:2:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化) ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:3:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。 变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs. C#) ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:4:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-观察者模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"观察者模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:0:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"组件协作模式 什么是组件协作模式 现代软件专业分工之后的第一个结果就是 框架与应用程序的划分 组件协作 模式通过晚绑定，来实现框架和应用之间的松耦合，是二者之间协作时常用的模式 典型模式 Template Method Observer / Event Strategy ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 定义对象间的一种一对多(变化)的依赖关系 以便当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并自动更新 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 使用面向对象的抽象思想，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合 目标发送通知时，无需指定观察者，通知（可以携带通知信息作 为参数）会自动传播 观察者自己决定是否需要订阅通知，目标对象对此一无所知 Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"具体代码先不展出 回头会补 想法是直接使用行为树的例子 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-简介","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"面向对象设计原则 设计模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:0:0","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"设计模式 什么是设计模式 每一个模式描述了一个在我们周围不断重复发生的问题以及该问题的解决方案的核心，这样你就能一次又一次的使用该方案而不必重复劳动 设计模式有可以说是 可复用面向对象软件的基础 重点在于 可复用 面向对象 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:1:0","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"如何解决复杂性 分解 分而治之，将大问题分成多个小问题，将复杂问题分成多个简单问题 这个在算法是一个最重要的核心思路，但是在设计模式，只能说可以用，但是不够用!!! 抽象 由于不能掌握全部的复杂对象，我们选择忽视他的非本质问题，而去处理泛化和理想化的对象模型 这个就是设计模式的核心思路 面向对象 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:2:0","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"面向对象设计 变化是复用的天敌，而面向对象设计就是抵御变化！！！ ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:3:0","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"重新认识面向对象 理解隔离变化 从宏观层面来看，面向对象的构建方式更能适应软件变化，能将变化所带来的影响度减为最小 从微观层面来看，面向对象的方式更强调每个类的责任，由于需求变化导致的新增类型不应该影响原来类型的实现 对象是什么 从语言实现层面来看，对象封装了代码和数据 从规格层面讲，对象是一系列可被使用的公共接口 从概念层面讲，对象是某种拥有责任的抽象 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:4:0","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"面向对象设计原则 依赖倒置原则 高层模块（稳定）不应该依赖于底层模块（变化），二者应该依赖于抽象（稳定） 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象 开放封闭原则 对扩展开放，对更改封闭，类模块应该是可扩展的，并且不能修改 单一职责原则 每个类引起他变化的原因只准一个，不能是多个 要多用组合，而不是多用继承 继承会造成子类的数目和功能急剧膨胀，所以要多用组合 封装变化 将变化点封装起来，不要去影响稳定点 替换原则 子类应该去重写父类方法，而不是去隐藏父类方法 接口隔离原则 接口应该小而完备，不应该强迫客户程序依赖他们不用的方法 针对接口编程，而不是针对实现编程 不将变量类型声明为某个特定的具体类，而是抽象出来声明为某个接口 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口 减少系统中各部分的依赖关系，从而实现 “高内聚， 松耦合” 的类型设计 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:5:0","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"设计模式-解析器","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"解析器 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:0:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"领域规则模式 什么是领域规则 在特定领域中, 某些变化虽然频繁, 但可以抽象为某种规则，这时候, 结合特定领域, 将问题抽象为语法规则, 从而给出在该领域下的一般性的解决方案 典型模式 Interpreter ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:1:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 如果某一特定领域的问题比较复杂, 类似的结构不断重复出现, 如果使用普通的编程方式来实现将面临非常频繁的变化 在这种情况下, 将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子, 从而达到解决问题的目的 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:2:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 给定一个语言, 定义他的文法的一种表示, 并定义一种解释器, 这个解释器使用该表示来解释语言中的句子 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:3:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 Interpreter模式的应用场景是这个模式的一个难点，只有满足 “业务规则频繁变化, 且类似的结构不断重复出现, 并且容易抽象为语言规则的问题\"才适合这种模式 使用这种模式来表示文法规则, 从而可以使用面向对象技巧来方便的 扩展 文法 Interpreter模式适合简单的文法表示, 对于复杂的文法表示, 这种模式会产生较大的类层次结构，需要求助于第三方的语法分析器 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:4:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-门面模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"门面模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:0:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"接口隔离模式 什么是接口隔离 在组件构建过程中, 某些接口之间直接的依赖 常常会带来很多问题 甚至根本无法实现 采用添加一层间接(稳定)接口, 来隔离本来互相紧密关联的接口是一种常见的解决方案 典型模式 Façade Proxy Mediator Adapter ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:1:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合, 随着外部客户程序和各子系统的演化, 这种过多的耦合面临很多变化的挑战 如何简化外部客户程序和系统间的交互接口? 如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解藕? ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:2:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 为子系统中的一组接口提供一个一致(稳定)的界面, Facade模式定义了一个高层接口, 这个接口使得这一子系统更加容易复用 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:3:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 这个模式下的类图其实没有很明确的概念 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:4:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 从客户程序的角度来看, 门面模式简化了整个组件系统的接口, 对于组件内部与外部客户程序来说, 达到了一种\"解藕\"的效果—-内部子系统的任何变化不会影响到Facade接口的变化 Facade设计模式更注重从架构的层次去看整个系统, 而不是单个类的层次 门面模式很多时间更是一种架构设计模式 Facade设计模式并非一个集装箱, 可以任意的放进任何多个对象. Facade模式中组件的内部应该是\"相互耦合关系比较大的一系列组件\", 而不是一个简单的功能集合 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:5:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-命令模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"命令模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:0:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"行为变化模式 什么是行为变化 在组件的构建过程中, 组件行为的变化经常导致组件本身剧烈的变化，“行为变化\"模式将组件的行为和组件本身进行解藕, 从而支持组件行为的变化, 实现两者之间的松耦合 典型模式 Command Visitor ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:1:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"命令模式前言 这个模式跟迭代器模式的地位很像，如果在c++中 其实这个模式很少用到 因为泛型编程里的函数对象已经优化的很好，然后在其他语言 java之类的 这个模式应用的也是很广泛 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:2:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, “行为请求者\"与\"行为实现者\"通常呈现一种\"紧耦合”，但在某一个场合—-比如需要对行为进行\"记录、撤销/重(undo/redo)、事务等处理”, 这种无法抵御变化的紧耦合是不合适的 在这种情况下, 如何将\"行为请求者\"与\"行为实现者\"解藕? 将一组行为抽象为对象, 可以实现二者之间的松耦合 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:3:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 将一个请求(行为)封装为一个对象, 从而使你可用不同的请求对客户进行参数化，对请求排队或记录日志, 以及支持可撤销的操作 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:4:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Command模式的根本目的在于将\"行为请求者\"与\"行为实现者\"解藕, 在面向对象语言中, 常见的实现手段是\"将行为抽象为对象\" 实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式, 可以将多个命令封装为一个复合命令 Command模式与c++中的函数对象有些类似, 但两者行为接口的规范有所区别，Command以面向对象中的\"接口-实现\"来定义行为函数规范, 更严格, 但有性能损失，c++函数对象以函数签名来定义行为函数规范, 更灵活, 性能更高 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:5:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-模板方法","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"模板方法 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:0:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"组件协作模式 什么是组件协作模式 现代软件专业分工之后的第一个结果就是 框架与应用程序的划分 组件协作 模式通过晚绑定，来实现框架和应用之间的松耦合，是二者之间协作时常用的模式 典型模式 Template Method Observer / Event Strategy ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:1:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"使用模板方法的动机 在软件构建的过程中，对于某一项任务，他尝尝有稳定的整体操作结构，但是各个子步骤却有很多改变的需求，或者由于固有原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现 那么如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:2:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"早绑定代码 什么是早绑定 早绑定代码演示 程序库开发人员 为了实现一个库 写了三个步骤 class Library{ public: void Step1(){ //... } void Step3(){ //... } void Step5(){ //... } }; app开发人员也要做步骤 并且还要写出一个步骤走的流程 class Application{ public: bool Step2(){ //... } void Step4(){ //... } }; int main() { Library lib(); Application app(); lib.Step1(); if (app.Step2()){ lib.Step3(); } for (int i = 0; i \u003c 4; i++){ app.Step4(); } lib.Step5(); } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:3:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"晚绑定代码 什么是晚绑定 晚绑定演示代码 程序库开发人员在开发的时候直接把主流程写好 调用每一步流程，把应用程序开发人员要开发的步骤定义成虚函数 class Library{ public: // 稳定 template method void Run() { Step1(); if (Step2()) Step3; // 支持变化 --\u003e 虚函数的多态调用 for (int i = 0; i \u003c 4; i++) Step4(); // 支持变化 --\u003e 虚函数的多态调用 Step5(); } virtual ~Library() { } protected: void Step1() { ... } void Step3() { ... } void Step5() { ... } virtual bool Step2() = 0; //变化 virtual void Step4() = 0; //变化 }; 应用程序开发人员只需要子类重写就即可 class Application : public Library { protected: virrual bool Step2() { // 子类重写实现 } virtual void Step4() { // 子类重写实现 } }; int main() { Library* pLib = new Application; lib-\u003eRun(); delete pLib; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:4:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"模式定义 定义一个操作中的算法骨架（稳定） —–\u003e 也就是上面晚绑定代码，先把流程写出来 讲一些步骤延迟（变化）到子类中 —–\u003e 也就是上面晚绑定代码，子类去实现 “2” “4” 两个方法 Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:5:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"再次强调的点 如果一个骨架不稳定(代码中) 那么这个模版方法就不适用 如果夸张一点 都不稳定 那没有任何一种设计模式适合 设计模式就是需要一个稳定点 如果反过来也是一样的道理，如果一个代码都是稳定的，那设计模式都不用存在的 所以，别闲的胃疼了，这两种极端都是不存在的，但是从这可以看出来，我们一定要分出哪些是稳定的 那些是变化的 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:6:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"要点总结 Template Method模式是一种非常基础性的设计模式, 在面向对象系统中有着大量的应用，他用最简洁的机制（虚函数的多态），为很多应用程序框架提供了灵活的扩展点 Template Method模式除了可以灵活应对子步骤的变化外，他也实现了早绑定 -\u003e 晚绑定的这一思路，也就是不要调用我，让我来调用你，反向控制结构是模版方法的典型应用 在具体实现方面，被模板方法调用的虚函数可以实现，也可以没有任何实现，可以把他们设置为protected方法 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:7:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"设计模式-桥模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"桥模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:0:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单一职责模式 什么是单一职责 在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充满着重复代码 这时候最关键是划清责任，每个类引起他变化的原因只有一个 典型模式 Decorator Bridge ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用桥模式动机 由于某些类型的固有的实现逻辑 使得它们具有两个变化的维度 乃至多个维度的变化 如何应对这种\"多维度的变化\" 如何利用面向对象技术来使得类型可以轻松的沿着两个乃至多个方向变化 而不引入额外的复杂度 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"初始代码 代码演示 class Messager{ public: virtual void Login(string username, string password)=0; virtual void SendMessage(string message)=0; virtual void SendPicture(Image image)=0; virtual void PlaySound()=0; virtual void DrawShape()=0; virtual void WriteText()=0; virtual void Connect()=0; virtual ~Messager(){} }; //平台实现 class PCMessagerBase : public Messager{ public: virtual void PlaySound(){ //********** } virtual void DrawShape(){ //********** } virtual void WriteText(){ //********** } virtual void Connect(){ //********** } }; class MobileMessagerBase : public Messager{ public: virtual void PlaySound(){ //========== } virtual void DrawShape(){ //========== } virtual void WriteText(){ //========== } virtual void Connect(){ //========== } }; //业务抽象 class PCMessagerLite : public PCMessagerBase { public: virtual void Login(string username, string password){ PCMessagerBase::Connect(); //........ } virtual void SendMessage(string message){ PCMessagerBase::WriteText(); //........ } virtual void SendPicture(Image image){ PCMessagerBase::DrawShape(); //........ } }; class PCMessagerPerfect : public PCMessagerBase { public: virtual void Login(string username, string password){ PCMessagerBase::PlaySound(); //******** PCMessagerBase::Connect(); //........ } virtual void SendMessage(string message){ PCMessagerBase::PlaySound(); //******** PCMessagerBase::WriteText(); //........ } virtual void SendPicture(Image image){ PCMessagerBase::PlaySound(); //******** PCMessagerBase::DrawShape(); //........ } }; class MobileMessagerLite : public MobileMessagerBase { public: virtual void Login(string username, string password){ MobileMessagerBase::Connect(); //........ } virtual void SendMessage(string message){ MobileMessagerBase::WriteText(); //........ } virtual void SendPicture(Image image){ MobileMessagerBase::DrawShape(); //........ } }; class MobileMessagerPerfect : public MobileMessagerBase { public: virtual void Login(string username, string password){ MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::Connect(); //........ } virtual void SendMessage(string message){ MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::WriteText(); //........ } virtual void SendPicture(Image image){ MobileMessagerBase::PlaySound(); //******** MobileMessagerBase::DrawShape(); //........ } }; void Process(){ //编译时装配 Messager *m = new MobileMessagerPerfect(); } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"利用 组合 重构代码 代码示例 class Messager{ protected: MessagerImp* messagerImp;//... public: virtual void Login(string username, string password)=0; virtual void SendMessage(string message)=0; virtual void SendPicture(Image image)=0; virtual ~Messager(){} }; class MessagerImp{ public: virtual void PlaySound()=0; virtual void DrawShape()=0; virtual void WriteText()=0; virtual void Connect()=0; virtual MessagerImp(){} }; //平台实现 n class PCMessagerImp : public MessagerImp{ public: virtual void PlaySound(){ //********** } virtual void DrawShape(){ //********** } virtual void WriteText(){ //********** } virtual void Connect(){ //********** } }; class MobileMessagerImp : public MessagerImp{ public: virtual void PlaySound(){ //========== } virtual void DrawShape(){ //========== } virtual void WriteText(){ //========== } virtual void Connect(){ //========== } }; //业务抽象 m //类的数目：1+n+m class MessagerLite :public Messager { public: virtual void Login(string username, string password){ messagerImp-\u003eConnect(); //........ } virtual void SendMessage(string message){ messagerImp-\u003eWriteText(); //........ } virtual void SendPicture(Image image){ messagerImp-\u003eDrawShape(); //........ } }; class MessagerPerfect :public Messager { public: virtual void Login(string username, string password){ messagerImp-\u003ePlaySound(); //******** messagerImp-\u003eConnect(); //........ } virtual void SendMessage(string message){ messagerImp-\u003ePlaySound(); //******** messagerImp-\u003eWriteText(); //........ } virtual void SendPicture(Image image){ messagerImp-\u003ePlaySound(); //******** messagerImp-\u003eDrawShape(); //........ } }; void Process(){ //运行时装配 MessagerImp* mImp=new PCMessagerImp(); Messager *m =new Messager(mImp); } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 将抽象部分(业务功能)与实现部分(平台实现)分离，使他们都可以独立的变化 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们 Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。 Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:7:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-示例c++代码","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"c++ 示例代码 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:0:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"前言 在被吐槽代码写的烂之后 看了很多源码 学习别人怎么写的 也专门去看了设计模式 在学艺术的我 还是特别热衷于极简艺术的我 自己之前写的代码也实在看不进去 现在设计模式都看完了 用golang 还有 c++ 综合一下每个模式的代码示例 但是因为只是示范设计模式 不会遵守c++的代码规范,甚至是伪代码 本篇是 c++ 但是听我一句劝 虽然看代码模板也可以让你去应付一些场景 但是还是要真正去学设计模式 学设计模式 = 学面向对象 要理清 稳定与变化 设计模式有些模式也是应用于架构层次的 所以有些模式 并没有好的代码模板 而且设计模式 是人们智慧的精华 很值得我们去学习其中的思路精髓 不要被眼前的表象代码迷惑了 好的代码是一种艺术 也可以通过你的代码诉说你的生活极简品味 ---壬寅年七月初二 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:1:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"模板方法 /* * 模版方法讲解 * eg: 厨房做菜的流程 * 流程: 先开火 再做具体的菜 随后关火 * */ #include \u003ciostream\u003e using namespace std; class Cooker { public: void CookProcess() { Fire(); CookDishes(); OutFire(); }; void Fire() { cout \u003c\u003c \"开火~\" \u003c\u003c endl; }; // 具体做什么菜 交给子类去实现 virtual void CookDishes() = 0; // 关火 void OutFire() { cout \u003c\u003c \"关火~\" \u003c\u003c endl; } }; class CookTomato : public Cooker { void CookDishes() { cout \u003c\u003c \"干西红柿\" \u003c\u003c endl; }; }; int main() { Cooker* cooker = new CookTomato(); cooker-\u003eCookProcess(); return 0; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:2:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"简单工厂 #include \u003ciostream\u003e using namespace std; // 具体类 class Product { public: Product() {} virtual ~Product() {} virtual void Function() = 0; }; class ProductA : public Product { public: void Function() { cout \u003c\u003c \"ProductA\" \u003c\u003c endl; } }; class ProductB : public Product { public: void Function() { cout \u003c\u003c \"ProductB\" \u003c\u003c endl; } }; // 具体工厂 class NewProductFactory { public: virtual Product* CreateProduct() = 0; virtual ~NewProductFactory() {}; }; class NewProductAFactory : public NewProductFactory { public: virtual Product* CreateProduct() { return new ProductA(); }; }; class NewProductBFactory : public NewProductFactory { public: virtual Product* CreateProduct() { return new ProductB; }; }; // 调用product class类 class MainFrom { NewProductFactory* factory; // 工厂 public: MainFrom(NewProductFactory* factory) { this-\u003efactory = factory; } void click() { Product* product = factory -\u003e CreateProduct(); // 多态new product-\u003eFunction(); } }; int main() { NewProductAFactory* pa = new NewProductAFactory(); MainFrom* mf = new MainFrom(pa); mf-\u003eclick(); } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:3:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"抽象工厂 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; // 访问数据库有关基类 class IDBConnection { }; class IDBCommand { }; class IDataReader { }; class IDBFactory { public: virtual IDBConnection* CreateDBConnection() = 0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; }; //支持MYSQL class SqlConnection: public IDBConnection{ }; class SqlCommand: public IDBCommand{ }; class SqlDataReader: public IDataReader{ }; class SqlDBFactory:public IDBFactory{ public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; }; //支持Oracle class OracleConnection: public IDBConnection{ }; class OracleCommand: public IDBCommand{ }; class OracleDataReader: public IDataReader{ }; class OracleDBFactory : public IDBFactory { public: virtual IDBConnection* CreateDBConnection() = 0; virtual IDBCommand* CreateDBCommand() = 0; virtual IDataReader* CreateDataReader() = 0; }; class EmployeeDAO { IDBFactory* dbFactory; public: vector\u003cEmployeeDAO\u003e GetEmployees() { // 以下是伪代码 因为如果每个实现出来还挺麻烦 // 重要的思路就是 在你只需要用一个工厂 你就可以把这个工厂下的都 多态new出来 还不失关联性 IDBConnection* connection = dbFactory-\u003eCreateDBConnection(); connection-\u003eConnectionString(\"...\"); IDBCommand* command = dbFactory-\u003eCreateDBCommand(); command-\u003eCommandText(\"...\"); command-\u003eSetConnection(connection); //关联性 IDBDataReader* reader = command-\u003eExecuteReader(); //关联性 while (reader-\u003eRead()){ } } }; ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:4:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"策略模式 /* 策略模式 * eg: 计算不同国家的税 * */ #include \u003ciostream\u003e using namespace std; // 税的基类 class TaxStrategy { public: // 税的具体算法 virtual double Calculate(const double\u0026 Money) = 0; virtual ~TaxStrategy() { }; }; // 中国税收 class CNTax : public TaxStrategy { public: double Calculate(const double\u0026 Money) { return TaxBase * Money; }; private: double TaxBase = 2; }; // 德国税收 class GermanyTax : public TaxStrategy { public: double Calculate(const double\u0026 Money) { return TaxBase * Money + 10; } private: double TaxBase = 1.5; }; // 工厂 class NewTaxFactory { public: virtual TaxStrategy* CreateTax() = 0; virtual ~NewTaxFactory() { }; }; class NewCNTaxFactory : public NewTaxFactory { public: virtual TaxStrategy* CreateTax() { return new CNTax(); } }; class NewGermanyTaxFactory { public: virtual TaxStrategy* CreateTax() { return new GermanyTax(); } }; // 计算税的类 class SalesOrder { public: SalesOrder(NewTaxFactory* TaxFactory) { this -\u003e strategy = TaxFactory-\u003eCreateTax(); } ~SalesOrder() { delete this-\u003estrategy; } double CalculateTax() { double Money = 10000; double val = strategy-\u003eCalculate(Money); return val; } private: TaxStrategy* strategy; }; int main() { // 算中国税收 NewCNTaxFactory* CNTax = new NewCNTaxFactory(); SalesOrder* SO = new SalesOrder(CNTax); double val = SO-\u003eCalculateTax(); cout \u003c\u003c val \u003c\u003c endl; return 0; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:5:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"装饰模式 /* 装饰模式 * eg: 男人类 有叫功能 在叫完之后 需要戴帽子和穿鞋子 * */ #include \u003ciostream\u003e using namespace std; class Man { public: void Speak() { cout \u003c\u003c \"男人使用了 尖叫 技能\" \u003c\u003c endl; } virtual void Cloth() {}; virtual ~Man() { } }; // 装饰抽象类 class ManWithCloth : public Man { public: // 构造函数 ManWithCloth(Man* PMan) :PMan(PMan) {} // 流程 void Cloth() { PMan-\u003eSpeak(); DressUp(); } // 穿衣服的方法 virtual void DressUp() {} // 重写析构函数 virtual ~ManWithCloth() { if (PMan != nullptr) { delete PMan; PMan = nullptr; } } private: Man* PMan; }; // 通过抽象类实现戴帽子 class ManWearHat : public ManWithCloth { public: ManWearHat(Man* PMan) : ManWithCloth(PMan) {} virtual void DressUp() { cout \u003c\u003c \"男人带上了绿帽子 奇怪的属性增加了\" \u003c\u003c endl; } }; // 通过抽象类实现穿鞋子 class ManWearShoes : public ManWithCloth { public: ManWearShoes(Man* PMan) : ManWithCloth(PMan) {} virtual void DressUp() { cout \u003c\u003c \"男人穿上了小鞋 防御力up\" \u003c\u003c endl;} }; // 工厂 class ManFactory { public: virtual Man* CreateMan() { return new Man(); }; virtual ~ManFactory() {}; }; // 抽象类工厂 class ManWithClothFactory { public: virtual ManWithCloth* CreateManWithCloth(Man* PMan) = 0; virtual ~ManWithClothFactory() {}; }; class ManWearHatFactory : public ManWithClothFactory { public: virtual ManWithCloth* CreateManWithCloth(Man* PMan) { return new ManWearHat(PMan); } }; class ManWearShoesFactory : public ManWithClothFactory { public: virtual ManWithCloth* CreateManWithCloth(Man* PMan) { return new ManWearShoes(PMan); } }; int main() { ManFactory* manFactory = new ManFactory(); Man* man = manFactory-\u003eCreateMan(); ManWearHatFactory* manWearHatFactory = new ManWearHatFactory(); ManWearHat a = manWearHatFactory-\u003eCreateManWithCloth(man); a.DressUp(); return 0; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:6:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"桥模式 /* * 场景: * 假如你有一个几何形状(shape)类, 可以扩展出两个子类(圆形, 方形) * 但是你又想给每一个几何都上颜色 比如现有(red, blue) * 但是，由于你已有两个子类，所以总共需要创建四个类才能覆盖所有组合，例如蓝色圆形(BlueCircle)和红色方形(RedSquare) * * 坏处: * 在层次结构中和颜色将导致代码复杂程序指数增长 * 例如添加三角状, 你需要增加两个子类,也就是每种颜色一个 * 此后新增一种新颜色就需要新增三个子类 * 满满的子类数目将会急剧膨胀 * * 可以利用桥模式去改善这个坏处 并封装变化 */ #include \u003ciostream\u003e using namespace std; class Color { public: virtual void Draw() = 0; }; // 红色 class Red : public Color { public: void Draw() { cout \u003c\u003c \"红色\" \u003c\u003c endl; } }; // 蓝色 class Blue : public Color { public: void Draw() { cout \u003c\u003c \"蓝色\" \u003c\u003c endl; } }; class Shape { public: Shape(Color* c): color(c) {}; virtual void Self() = 0; protected: Color* color; }; // 圆形 class Cyclo : public Shape { public: Cyclo(Color* color) : Shape(color) {}; void Self() { cout \u003c\u003c \"我是圆形\" \u003c\u003c endl; color-\u003eDraw(); } }; // 方形 class Square : public Shape { public: void Self() { cout \u003c\u003c \"我是方形\" \u003c\u003c color \u003c\u003c endl; color-\u003eDraw(); } }; int main() { Red* red = new Red(); Cyclo* c = new Cyclo(red); c-\u003eSelf(); return 0; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:7:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"原型模式 class MainForm : public Form { ISplitter* prototype;//原型对象 public: MainForm(ISplitter* prototype){ this-\u003eprototype=prototype; } void Button1_Click(){ ISplitter * splitter= prototype-\u003eclone(); //克隆原型 splitter-\u003esplit(); } }; //具体类 class BinarySplitter : public ISplitter{ public: virtual ISplitter* clone(){ return new BinarySplitter(*this); } }; class TxtSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new TxtSplitter(*this); } }; class PictureSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new PictureSplitter(*this); } }; class VideoSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new VideoSplitter(*this); } }; //抽象类 class ISplitter{ public: virtual void split()=0; virtual ISplitter* clone()=0; //通过克隆自己来创建对象 virtual ~ISplitter(){} }; ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:8:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"单例模式 /* * 单例模式 * \"单例模式\" 是 \"性能优化\" 的作用 全程下只存在一个实例 * 在内部会提供一个供外接访问的接口 * 他是将其构造函数和拷贝构造函数设为私有 * 它分为饿汉模式和懒汉模式 * 懒汉模式 由于用到实例才会实例化 所以需要注意线程安全 * 饿汉模式 由于一开始直接实例化 不需要注意线程安全 但是要注意返回一个指针实例 * */ //*********************************懒汉********************************* // 简单实现 class Singleton { private: Singleton(); Singleton(const Singleton\u0026 other); public: static Singleton* getInstance(); static Singleton* m_instance; }; Singleton* Singleton::m_instance = nullptr; //线程非安全版本 Singleton* Singleton::getInstance() { if (m_instance == nullptr) { m_instance = new Singleton(); } return m_instance; } //双检查锁，但由于内存读写reorder不安全 Singleton* Singleton::getInstance() { if(m_instance==nullptr){ Lock lock; if (m_instance == nullptr) { m_instance = new Singleton(); } } return m_instance; } //*******************************************饿汉********************************* class Singleton { private: Singleton() {} static Singleton instance; //静态变量只会有一份数据存在 从而保证只有一个实例 public: static Singleton* GetInstance() { return \u0026instance; } } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:9:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"享元模式 /* FileName: flyweight.h * Author: ting * Detail: { * 1. 享元模式示例 * 2. flyweight模式 跟 单例模式 的作用是一样的 都是性能优化 为了减少对象的实例个数 * } * */ #include \u003ciostream\u003e #include\u003cstring\u003e #include\u003cmap\u003e using namespace std; //用户类 用户网站的客户账号，是\"网站\"类的外部状态 class User { private: string m_name; public: User(string name) { m_name = name; } std::string GetName() { return m_name; } }; //抽象网站类 定义对象的内部状态和外部状态及其对应的方法 class WebSite { public: virtual ~WebSite() = default; virtual void Use(User user) = 0; }; //此处为具体网站类 实现抽象享元角色的方法，在具体的角色中，实现具体方法时需要注意将内部状态与外部状态区分开，不应出现二者同时被修改的方法。 class ConcreteWebSite :public WebSite { private: string m_name; public: ConcreteWebSite(std::string name) { m_name = name; } void Use(User user)override { cout \u003c\u003c \"网站分类：\" \u003c\u003c m_name \u003c\u003c \" 用户：\" + user.GetName() \u003c\u003c endl; } }; //此处为网站工程类 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象， //如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 class WebSiteFactory { private: std::map\u003cstd::string, WebSite*\u003e flyweights; public: ~WebSiteFactory() { for (auto it = flyweights.begin(); it != flyweights.end(); ++it) delete it-\u003esecond; } WebSite* GetWebSiteCategory(string key) { for (auto it = flyweights.begin(); it != flyweights.end(); ++it) { if (it-\u003efirst == key) return it-\u003esecond; } WebSite* website = new ConcreteWebSite(key); flyweights.insert(pair\u003cstd::string, WebSite*\u003e(key, website)); return website; } int GetWebSiteCount() { return flyweights.size(); } }; int main() { WebSiteFactory f; WebSite* fx = f.GetWebSiteCategory(\"产品展示\"); fx-\u003eUse(User(\"小菜\")); WebSite* fy = f.GetWebSiteCategory(\"产品展示\"); fy-\u003eUse(User(\"大鸟\")); WebSite* fz = f.GetWebSiteCategory(\"产品展示\"); fz-\u003eUse(User(\"娇娇\")); WebSite* fl = f.GetWebSiteCategory(\"博客\"); fl-\u003eUse(User(\"老顽童\")); WebSite* fm = f.GetWebSiteCategory(\"博客\"); fm-\u003eUse(User(\"桃谷六仙\")); WebSite* fn = f.GetWebSiteCategory(\"博客\"); fn-\u003eUse(User(\"南海鳄神\")); cout \u003c\u003c \"得到网站分类总数：\" \u003c\u003c f.GetWebSiteCount() \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:10:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"状态模式 /* Author: ting * Mail: vlicecream520@gmail.com * Detail: ( * 1. 状态模式示例 * 一个程序员会随着一天的不同时间处于不同状态 * * 2. 状态模式适用于 根据自己的状态发生变化 行为也随之发现变化 * 他跟观察者模式不一样 观察者模式是 一个或多个对象 根据 一个对象的状态发生变化而发生变化 * ) * */ #include \u003ciostream\u003e using namespace std; class Work; // 状态接口 class State { public: // 与 work 行为相关的函数 virtual void WriteProgram(Work *w) = 0; }; // 工作类 class Work { private: // 当前状态 State* current; // 当前时间 double hour; // 工作是否完成 bool taskFinish; public: Work() { taskFinish = false; } // 设置/获取时间 void SetTime(double hour) { this-\u003ehour = hour; } double GetTime() { return this-\u003ehour; } // 设置状态 void SetState(State *s) { current = s; } // 设置工程是否完成 void SetFinish() { this-\u003etaskFinish = true; } // 获取工作是否完成状态 bool GetFinish() { return taskFinish; } // work 行为 void WriteProgram() { current-\u003eWriteProgram(this); } }; //下班休息状态 class RestState : public State { public: void WriteProgram(Work *w) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 工作完成，下班回家了\" \u003c\u003c endl; } }; //睡眠工作状态 class SleepingState : public State { public: void WriteProgram(Work *w) { cout \u003c\u003c \"受不了了,\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点了，先睡吧\" \u003c\u003c endl; } }; //晚上工作状态 class EveningState : public State { public: void WriteProgram(Work *w) { //任务完成了，可以休息了 if(w-\u003eGetFinish()) { w-\u003eSetState(new RestState()); w-\u003eWriteProgram(); } else { if(w-\u003eGetTime()\u003c21) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 加班了，疲惫至极\" \u003c\u003c endl; } else { //找过21点 w-\u003eSetState(new SleepingState()); w-\u003eWriteProgram(); } } } }; //下午工作状态 class AfternoonState : public State { public: void WriteProgram(Work *w) { if(w-\u003eGetTime()\u003c17) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 状态还不错，继续努力\" \u003c\u003c endl; } else { w-\u003eSetState(new EveningState()); w-\u003eWriteProgram(); } } }; //中午工作状态 class NoonState : public State { public: void WriteProgram(Work *w) { if (w-\u003eGetTime()\u003c13) cout\u003c\u003c\"当前时间:\"\u003c\u003cw-\u003eGetTime()\u003c\u003c\"点 饿了，午饭:犯困，午休\"\u003c\u003cendl; else { w-\u003eSetState(new AfternoonState()); w-\u003eWriteProgram(); } } }; //上午工作状态 class ForenoonState : public State { public: void WriteProgram(Work *w) { if(w-\u003eGetTime()\u003c12) cout\u003c\u003c\"当前时间:\"\u003c\u003cw-\u003eGetTime()\u003c\u003c\"点 上午工作，精神百倍\"\u003c\u003cendl; else { w-\u003eSetState(new NoonState()); w-\u003eWriteProgram(); } } }; void main() { //紧急项目 Work *emergencyProjects = new Work(); emergencyProjects-\u003eSetState(new ForenoonState()); emergencyProjects-\u003eSetTime(9); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(10); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(12); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(14); emergencyProjects-\u003eWriteProgram(); //完成工作，不需要再加班了 //emergencyProjects-\u003eSetFinish(); emergencyProjects-\u003eSetTime(19); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(22); emergencyProjects-\u003eWriteProgram(); } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:11:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"组合模式 /* Author: ting * Date: 2022-08-14 * Detail: 组合模式示例 * 将多个对象依据树形结构看为一个整体 实现 \"部分 - 整体\"的效果 * 1. 抽象示例(Component)角色: 他的主要作用是为了树叶构件声明公共接口, 并实现他们的默认行为 * 2. 树叶构件(Composite)角色: 是组合中的分支节点对象, 他有子结点, 用于继承和实现抽象构件 * 主要作用是存储和管理子部件 通常包含 Add() Remove() GetChild() 等方法 * 3. 树叶构件(Leaf)角色: 是组合中的叶节点对象, 他没有子节点, 用于继承和实现抽象构件 * */ // 计数 class Counter { public: virtual ~Counter() {}; virtual int Count() = 0; }; // 树叶构件 class City : public Counter { public: City(int sum) : sum(sum) { }; int Count() override { return sum; } private: int sum; }; // 树枝构件 class Composite : public Counter { public: ~Composite() { for (auto\u0026 counter : counters) { delete counter; } } void add(Counter* counter) { counters.push_back(counter); } void del(Counter* counter) { auto it = find(counters.begin(), counters.end(), counter); counters.erase(it); } int count() { int sum = 0; for (const auto\u0026 counter : counters) { sum += counter-\u003ecount(); } return sum; } private: vector\u003cCounter*\u003e counters; }; // 使用：统计人口数量 int main() { Composite* china = new Composite(); City* beijing = new City(100000); // 直辖市 City* shanghai = new City(50000); // 直辖市 china-\u003eadd(beijing); china-\u003eadd(shanghai); Composite* shanxi = new Composite(); shanxi-\u003eadd(new City(3000)); // 大同市 shanxi-\u003eadd(new City(2000)); // 太原市 china-\u003eadd(shanxi); cout \u003c\u003c china-\u003ecount() \u003c\u003c endl; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:12:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"设计模式-适配器","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"适配器 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:0:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"接口隔离模式 什么是接口隔离 在组件构建过程中, 某些接口之间直接的依赖 常常会带来很多问题 甚至根本无法实现 采用添加一层间接(稳定)接口, 来隔离本来互相紧密关联的接口是一种常见的解决方案 典型模式 Façade Proxy Mediator Adapter ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:1:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"动机 在软件系统中, 由于应用环境的变化, 常常需要将\"一些现存的对象\"放在新的环境中应用, 但是新环境要求的接口是这些现存对象所不满足的 如何应对这种\"迁移的变化\"? 如何既能利用现有对象的良好实现, 同时又能满足新的应用环境所要求的接口? ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:2:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 将一个类的接口转换成客户希望的另一个接口 Adapter模式使得由于接口不兼容而不能一起工作的那些类可以一起工作 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:3:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 Adapter模式主要应用于\"希望复用一些现存的类, 但是接口又与复用环境要求不一致的情况\", 在遗留代码复用、类库迁移等方面非常有用 GoF 23 定义了两种Adapter模式的实现结构, 对象适配器和类适配器 不推荐使用类适配器 因为类适配器用的是多继承的方法 推荐使用对象适配器 因为对象适配器使用的组合方法 Adapter模式的使用非常灵活, 不必拘泥于上述两种模式 例如 完全可以将Adapter模式中的现存对象作为新的接口方法参数, 来达到适配的目的 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:4:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-享元模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"享元模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:0:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"对象性能模式 什么是对象性能 面向对象很好的解决了\"抽象\"的问题, 但是必不可免的要付出一定的代价，对于通常情况来讲, 面向对象的成本大都可以忽略不计，但是某些情况, 面向对象所带来的成本必须谨慎处理 典型模式 Singleton Flyweight ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:1:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"享元模式动机 在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中， 从而带来很高的运行时代价–主要指内存需求方面的代价. 如何在避免大量细粒度对象问题的同时, 让外部客户程序仍然能够透明的使用面向对象的方式来进行操作 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:2:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"演示代码 /* FileName: flyweight.h * Author: ting * Detail: { * 1. 享元模式示例 * 2. flyweight模式 跟 单例模式 的作用是一样的 都是性能优化 为了减少对象的实例个数 * } * */ #include \u003ciostream\u003e #include\u003cstring\u003e #include\u003cmap\u003e using namespace std; //用户类 用户网站的客户账号，是\"网站\"类的外部状态 class User { private: string m_name; public: User(string name) { m_name = name; } std::string GetName() { return m_name; } }; //抽象网站类 定义对象的内部状态和外部状态及其对应的方法 class WebSite { public: virtual ~WebSite() = default; virtual void Use(User user) = 0; }; //此处为具体网站类 实现抽象享元角色的方法，在具体的角色中，实现具体方法时需要注意将内部状态与外部状态区分开，不应出现二者同时被修改的方法。 class ConcreteWebSite :public WebSite { private: string m_name; public: ConcreteWebSite(std::string name) { m_name = name; } void Use(User user)override { cout \u003c\u003c \"网站分类：\" \u003c\u003c m_name \u003c\u003c \" 用户：\" + user.GetName() \u003c\u003c endl; } }; //此处为网站工程类 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象， //如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 class WebSiteFactory { private: std::map\u003cstd::string, WebSite*\u003e flyweights; public: ~WebSiteFactory() { for (auto it = flyweights.begin(); it != flyweights.end(); ++it) delete it-\u003esecond; } WebSite* GetWebSiteCategory(string key) { for (auto it = flyweights.begin(); it != flyweights.end(); ++it) { if (it-\u003efirst == key) return it-\u003esecond; } WebSite* website = new ConcreteWebSite(key); flyweights.insert(pair\u003cstd::string, WebSite*\u003e(key, website)); return website; } int GetWebSiteCount() { return flyweights.size(); } }; int main() { WebSiteFactory f; WebSite* fx = f.GetWebSiteCategory(\"产品展示\"); fx-\u003eUse(User(\"小菜\")); WebSite* fy = f.GetWebSiteCategory(\"产品展示\"); fy-\u003eUse(User(\"大鸟\")); WebSite* fz = f.GetWebSiteCategory(\"产品展示\"); fz-\u003eUse(User(\"娇娇\")); WebSite* fl = f.GetWebSiteCategory(\"博客\"); fl-\u003eUse(User(\"老顽童\")); WebSite* fm = f.GetWebSiteCategory(\"博客\"); fm-\u003eUse(User(\"桃谷六仙\")); WebSite* fn = f.GetWebSiteCategory(\"博客\"); fn-\u003eUse(User(\"南海鳄神\")); cout \u003c\u003c \"得到网站分类总数：\" \u003c\u003c f.GetWebSiteCount() \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:3:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 运用共享技术有效的支持大量细粒度的对象 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:4:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 面向对象很好的解决了抽象性的问题， 但是作为一个运行在机器中的程序实体, 我们需要考虑对象的代价问题，Flyweight主要解决面向对象的代价问题, 一般不触及面向对象的抽象性问题 Flyweight采用对象共享的做法来降低系统中对象的个数, 从而降低细粒度对象给系统带来的内存压力，在具体实现方面, 要注意对象状态的处理 对象的数量太大从而导致对象内存开销加大—什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估, 而不能凭空臆断 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:5:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-原型模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"原型模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:0:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"对象创建模式 什么是对象创建 通过对象创建模式，绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)从而支持对象创建 他是接口抽象之后的第一步工作 典型模式 Factory Method Abstract Factory Prototype Builder ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"原型动机 在软件系统中，经常面临着\"某些接口复杂的对象\"的创建工作，由于需求的变化, 这些对象经常面临着剧烈的变化, 但是他们却拥有比较稳定一致的接口 如何应对这种变化? 如何向客户程序(使用这些对象的程序)隔离出 “这些易变对象”, 从而使得\"依赖这些易变对象的客户程序\"不随着需求改变而改变 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"在工厂方法重构的基础上再次用原型模式重构的代码 class MainForm : public Form { ISplitter* prototype;//原型对象 public: MainForm(ISplitter* prototype){ this-\u003eprototype=prototype; } void Button1_Click(){ ISplitter * splitter= prototype-\u003eclone(); //克隆原型 splitter-\u003esplit(); } }; //具体类 class BinarySplitter : public ISplitter{ public: virtual ISplitter* clone(){ return new BinarySplitter(*this); } }; class TxtSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new TxtSplitter(*this); } }; class PictureSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new PictureSplitter(*this); } }; class VideoSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new VideoSplitter(*this); } }; //抽象类 class ISplitter{ public: virtual void split()=0; virtual ISplitter* clone()=0; //通过克隆自己来创建对象 virtual ~ISplitter(){} }; ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 prototype模式同样用语隔离类对象的使用者和具体类型(易变类)之间的耦合关系, 他同样要求这些\"易变类\"拥有\"稳定的接口\" prototype模式对于\"如何创建易变类的实体对象\"采用\"原型克隆\"的方法来做。 他使得我们可以非常灵活的动态创建\"拥有某些稳定接口\"的新对象，所需工作仅仅是注册一个新类的对象(即原型) 然后在任何需要的地方clone prototype模式中的clone方法可以利用某些框架中的序列化来实现深拷贝 c++里面一般都是拷贝构造 我们什么时候用factory method 或者 原型模式呢，简单来说 就是如果用几个步骤就用factory method模式，如果对象很复杂 有中间状态 你还想保留中间状态 就用 原型模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-职责链","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"职责链 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:0:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"数据结构模式 什么是数据结构模式 常常有一些组件在内部具有特定的数据结构, 如果让客户程序依赖这些特定的数据结构, 将极大的破坏组件的复用 典型模式 Composite Iterator Chain of Resposibility ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:1:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"职责链前言 这个模式 其实随着现在数据结构的发展 也过时了 但是还是老话 模式过时 思想不会过时 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:2:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 一个请求可能被多个对象处理, 但是每个请求在运行时只能有一个接受者，如果显式指定, 将必不可少的带来发送者和接受者的紧耦合 如何使请求的发送者不需要指定具体的接受者? 让请求的接受者自己在运行时决定来处理请求, 从而使两者解藕 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:3:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"模式定义 使多个对象都有机会处理请求, 从而避免请求的发送者和接受者之间的耦合关系，将这些对象形成一条链表, 并沿着这条链传递请求, 直到有一个对象处理它为止 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:4:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"要点总结 职责链模式的应用场合在于 “一个请求可能有多个接受者, 但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合有可能出现\"变化脆弱\"的症状, 职责链的目的就是将二者解藕, 从而更好的应对变化 应用了职责链模式后, 对象的职责分派将更具有灵活性，我们可以在运行时动态添加/修改请求的处理职责 如果请求传递到职责链的末尾仍得不到处理, 应该有一个合理的缺省机制，这也是每一个接受对象的责任, 而不是发出 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:5:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"设计模式-中介者","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"中介者 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:0:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"接口隔离模式 什么是接口隔离 在组件构建过程中, 某些接口之间直接的依赖 常常会带来很多问题 甚至根本无法实现 采用添加一层间接(稳定)接口, 来隔离本来互相紧密关联的接口是一种常见的解决方案 典型模式 Façade Proxy Mediator Adapter ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:1:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 经常会出现多个对象互相关联交互的情况, 对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改, 这种直接的引用关系将面临不断的变化 在这种情况下, 我们可使用一个\"中介对象\"来管理对象之间的关联关系, 避免相互交互的对象之间的紧耦合引用关系, 从而抵御变化 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:2:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"模式定义 用一个中介对象来封装(变化)一系列的对象交互 中介者使各对象不需要显式的相互引用(编译时依赖 -\u003e 运行时依赖), 从而使得耦合松散, 而且可以独立的改变他们之间的交互 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:3:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"要点总结 将多个对象间复杂的关联关系, Mediator模式将多个对象间的控制逻辑进行集中管理 变\"多个对象互相关联\"为\"多个对象和一个中介者关联\", 简化了系统的维护, 抵御了可能的变化 随着控制逻辑的复杂变化, Mediator具体对象的实现可能相当复杂，这个时候可对Mediator对象进行分解处理 Facade模式是解耦系统间(单向)的对象关联关系 Mediator模式是解耦系统内各个对象间(双向)的关联关系 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:4:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"设计模式-装饰模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"装饰模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:0:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单一职责模式 什么是单一职责 在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充满着重复代码 这时候最关键是划清责任，每个类引起他变化的原因只有一个 典型模式 Decorator Bridge ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:1:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用装饰模式动机 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？ ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:2:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"初始代码 类图 代码演示 //业务操作 class Stream{ public： virtual char Read(int number)=0; virtual void Seek(int position)=0; virtual void Write(char data)=0; virtual ~Stream(){} }; //主体类 class FileStream: public Stream{ public: virtual char Read(int number){ //读文件流 } virtual void Seek(int position){ //定位文件流 } virtual void Write(char data){ //写文件流 } }; class NetworkStream :public Stream{ public: virtual char Read(int number){ //读网络流 } virtual void Seek(int position){ //定位网络流 } virtual void Write(char data){ //写网络流 } }; class MemoryStream :public Stream{ public: virtual char Read(int number){ //读内存流 } virtual void Seek(int position){ //定位内存流 } virtual void Write(char data){ //写内存流 } }; //扩展操作 class CryptoFileStream :public FileStream{ public: virtual char Read(int number){ //额外的加密操作... FileStream::Read(number);//读文件流 } virtual void Seek(int position){ //额外的加密操作... FileStream::Seek(position);//定位文件流 //额外的加密操作... } virtual void Write(byte data){ //额外的加密操作... FileStream::Write(data);//写文件流 //额外的加密操作... } }; class CryptoNetworkStream : :public NetworkStream{ public: virtual char Read(int number){ //额外的加密操作... NetworkStream::Read(number);//读网络流 } virtual void Seek(int position){ //额外的加密操作... NetworkStream::Seek(position);//定位网络流 //额外的加密操作... } virtual void Write(byte data){ //额外的加密操作... NetworkStream::Write(data);//写网络流 //额外的加密操作... } }; class CryptoMemoryStream : public MemoryStream{ public: virtual char Read(int number){ //额外的加密操作... MemoryStream::Read(number);//读内存流 } virtual void Seek(int position){ //额外的加密操作... MemoryStream::Seek(position);//定位内存流 //额外的加密操作... } virtual void Write(byte data){ //额外的加密操作... MemoryStream::Write(data);//写内存流 //额外的加密操作... } }; class BufferedFileStream : public FileStream{ //... }; class BufferedNetworkStream : public NetworkStream{ //... }; class BufferedMemoryStream : public MemoryStream{ //... } class CryptoBufferedFileStream :public FileStream{ public: virtual char Read(int number){ //额外的加密操作... //额外的缓冲操作... FileStream::Read(number); //读文件流 } virtual void Seek(int position){ //额外的加密操作... //额外的缓冲操作... FileStream::Seek(position); //定位文件流 //额外的加密操作... //额外的缓冲操作... } virtual void Write(byte data){ //额外的加密操作... //额外的缓冲操作... FileStream::Write(data); //写文件流 //额外的加密操作... //额外的缓冲操作... } }; void Process(){ //编译时装配 CryptoFileStream *fs1 = new CryptoFileStream(); BufferedFileStream *fs2 = new BufferedFileStream(); CryptoBufferedFileStream *fs3 =new CryptoBufferedFileStream(); } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:3:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"利用 组合 重构代码 类图 代码示例 //业务操作 class Stream{ public: virtual char Read(int number)=0; virtual void Seek(int position)=0; virtual void Write(char data)=0; virtual ~Stream(){} }; //主体类 class FileStream: public Stream{ public: virtual char Read(int number){ //读文件流 } virtual void Seek(int position){ //定位文件流 } virtual void Write(char data){ //写文件流 } }; class NetworkStream :public Stream{ public: virtual char Read(int number){ //读网络流 } virtual void Seek(int position){ //定位网络流 } virtual void Write(char data){ //写网络流 } }; class MemoryStream :public Stream{ public: virtual char Read(int number){ //读内存流 } virtual void Seek(int position){ //定位内存流 } virtual void Write(char data){ //写内存流 } }; //扩展操作 class DecoratorStream: public Stream{ protected: Stream* stream;//... DecoratorStream(Stream * stm):stream(stm){ } }; class CryptoStream: public DecoratorStream { Stream* stream;//... public: CryptoStream(Stream* stm):DecoratorStream(stm){ } virtual char Read(int number){ //额外的加密操作... stream-\u003eRead(number);//读文件流 } virtual void Seek(int position){ //额外的加密操作... stream::Seek(position);//定位文件流 //额外的加密操作... } virtual void Write(byte data){ //额外的加密操作... stream::Write(data);//写文件流 //额外的加密操作... } }; class BufferedStream : public DecoratorStream{ Stream* stream;//… public: BufferedStream(Stream* stm):DecoratorStream(stm){ } //... }; void Process(){ //运行时装配 FileStream* s1=new FileStream(); CryptoStream* s2=new CryptoStream(s1); BufferedStream* s3=new BufferedStream(s1); BufferedStream* s4=new BufferedStream(s2); } ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:4:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 \u0026 减少子类个数） ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:5:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。 Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类 Decorator模式的目的并非解决“多子类衍生的多继承”问题， Decorator模式应用的要点在于解决“主体类在多个方向上的扩展 功能”——是为“装饰”的含义 其实能看到一个类 继承又组合了自己父类 绝大多数就是 装饰模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:6:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-状态模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"状态模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:0:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"状态变化模式 什么是状态变化 在组件构建过程中, 某些对象的状态面临变化, 如何对这些变化进行有效的管理? 同时又保证高层的稳定? 典型模式 Memento State ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:1:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 某些对象的状态如果改变, 其行为也会随之而发生变化 比如文档处于只读状态, 其支持的行为和读写状态支持的行为就可能完全不同 如何在运行时根据对象的状态来透明的更改对象的行为? 而不会为对象操作和状态转化之间引入紧耦合? ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:2:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 允许一个对象在其内部状态改变时改变他的行为, 从而使对象看起来似乎修改了其行为 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:3:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 /* Author: ting * Mail: vlicecream520@gmail.com * Detail: ( * 1. 状态模式示例 * 一个程序员会随着一天的不同时间处于不同状态 * * 2. 状态模式适用于 根据自己的状态发生变化 行为也随之发现变化 * 他跟观察者模式不一样 观察者模式是 一个或多个对象 根据 一个对象的状态发生变化而发生变化 * ) * */ #include \u003ciostream\u003e using namespace std; class Work; // 状态接口 class State { public: // 与 work 行为相关的函数 virtual void WriteProgram(Work *w) = 0; }; // 工作类 class Work { private: // 当前状态 State* current; // 当前时间 double hour; // 工作是否完成 bool taskFinish; public: Work() { taskFinish = false; } // 设置/获取时间 void SetTime(double hour) { this-\u003ehour = hour; } double GetTime() { return this-\u003ehour; } // 设置状态 void SetState(State *s) { current = s; } // 设置工程是否完成 void SetFinish() { this-\u003etaskFinish = true; } // 获取工作是否完成状态 bool GetFinish() { return taskFinish; } // work 行为 void WriteProgram() { current-\u003eWriteProgram(this); } }; //下班休息状态 class RestState : public State { public: void WriteProgram(Work *w) { cout « “当前时间:” « w-\u003eGetTime() « “点 工作完成，下班回家了” « endl; } }; //睡眠工作状态 class SleepingState : public State { public: void WriteProgram(Work *w) { cout « “受不了了,” « w-\u003eGetTime() « “点了，先睡吧” « endl; } }; //晚上工作状态 class EveningState : public State { public: void WriteProgram(Work *w) { //任务完成了，可以休息了 if(w-\u003eGetFinish()) { w-\u003eSetState(new RestState()); w-\u003eWriteProgram(); } else { if(w-\u003eGetTime()\u003c21) { cout « “当前时间:” « w-\u003eGetTime() « “点 加班了，疲惫至极” « endl; } else { //找过21点 w-\u003eSetState(new SleepingState()); w-\u003eWriteProgram(); } } } }; //下午工作状态 class AfternoonState : public State { public: void WriteProgram(Work *w) { if(w-\u003eGetTime()\u003c17) { cout « “当前时间:” « w-\u003eGetTime() « “点 状态还不错，继续努力” « endl; } else { w-\u003eSetState(new EveningState()); w-\u003eWriteProgram(); } } }; //中午工作状态 class NoonState : public State { public: void WriteProgram(Work *w) { if (w-\u003eGetTime()\u003c13) cout«“当前时间:\"«w-\u003eGetTime()«“点 饿了，午饭:犯困，午休”«endl; else { w-\u003eSetState(new AfternoonState()); w-\u003eWriteProgram(); } } }; //上午工作状态 class ForenoonState : public State { public: void WriteProgram(Work *w) { if(w-\u003eGetTime()\u003c12) cout«“当前时间:\"«w-\u003eGetTime()«“点 上午工作，精神百倍”«endl; else { w-\u003eSetState(new NoonState()); w-\u003eWriteProgram(); } } }; void main() { //紧急项目 Work *emergencyProjects = new Work(); emergencyProjects-\u003eSetState(new ForenoonState()); emergencyProjects-\u003eSetTime(9); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(10); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(12); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(14); emergencyProjects-\u003eWriteProgram(); //完成工作，不需要再加班了 //emergencyProjects-\u003eSetFinish(); emergencyProjects-\u003eSetTime(19); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(22); emergencyProjects-\u003eWriteProgram(); } ## 要点总结 1. *State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中, 在对象状态切换时, 切换相对应的对象，但同时维持State的接口, 这样实现了具体操作与状态转换之间的解藕* 2. *为不同的状态引入不同的对象使得状态转换变得更加明确, 而且可以保证不会出现状态不一致的情况, 因为转换是原子性的，即要么彻底转换过来 要么不转换* 3. *如果State对象没有实例变量, 那么各上下文可以共享一个State对象, 从而节省对象开销* ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:4:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-组合模式","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"组合模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:0:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"数据结构模式 什么是数据结构模式 常常有一些组件在内部具有特定的数据结构, 如果让客户程序依赖这些特定的数据结构, 将极大的破坏组件的复用 典型模式 Composite Iterator Chain of Resposibility ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:1:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 在软件某些情况下, 客户代码过多的依赖于对象容器复杂的内部实现结构, 对象容器内部实现结构(而非对象接口)的变化将引起客户代码的频繁变化, 带来了代码的维护性、扩展性等弊端 如何将\"客户代码与复杂的对象容器结构\"解藕? 让对象容器自己来实现自身的复杂结构, 从而使得客户代码就像处理简单对象一样来处理复杂的对象容器? ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:2:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 将对象组合成树形结构以表示 “部分 - 整体” 的层次结构 Composite使得用户对单个对象和组合对象的使用具有一致性(稳定) ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:3:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 /* Author: ting * Date: 2022-08-14 * Detail: 组合模式示例 * 将多个对象依据树形结构看为一个整体 实现 \"部分 - 整体\"的效果 * 1. 抽象示例(Component)角色: 他的主要作用是为了树叶构件声明公共接口, 并实现他们的默认行为 * 2. 树叶构件(Composite)角色: 是组合中的分支节点对象, 他有子结点, 用于继承和实现抽象构件 * 主要作用是存储和管理子部件 通常包含 Add() Remove() GetChild() 等方法 * 3. 树叶构件(Leaf)角色: 是组合中的叶节点对象, 他没有子节点, 用于继承和实现抽象构件 * */ // 计数 class Counter { public: virtual ~Counter() {}; virtual int Count() = 0; }; // 树叶构件 class City : public Counter { public: City(int sum) : sum(sum) { }; int Count() override { return sum; } private: int sum; }; // 树枝构件 class Composite : public Counter { public: ~Composite() { for (auto\u0026 counter : counters) { delete counter; } } void add(Counter* counter) { counters.push_back(counter); } void del(Counter* counter) { auto it = find(counters.begin(), counters.end(), counter); counters.erase(it); } int count() { int sum = 0; for (const auto\u0026 counter : counters) { sum += counter-\u003ecount(); } return sum; } private: vector\u003cCounter*\u003e counters; }; // 使用：统计人口数量 int main() { Composite* china = new Composite(); City* beijing = new City(100000); // 直辖市 City* shanghai = new City(50000); // 直辖市 china-\u003eadd(beijing); china-\u003eadd(shanghai); Composite* shanxi = new Composite(); shanxi-\u003eadd(new City(3000)); // 大同市 shanxi-\u003eadd(new City(2000)); // 太原市 china-\u003eadd(shanxi); cout \u003c\u003c china-\u003ecount() \u003c\u003c endl; } ## 要点总结 1. *Composite模式采用树形结构来实现普遍存在的对象容器, 从而将\"一对多\"的关系转化为\"一对一\"的关系, 使得客户代码可以一致的(复用)处理对象和对象容器, 无需关心处理的是单个的对象, 还是组合的对象容器* 2. *将\"客户代码与复杂的对象容器结构\"解藕是Composite模式的核心思想，解藕之后, 客户代码将与纯粹的抽象接口----而非对象容器内部实现结构 发生依赖, 从而更能\"应对变化\"* 3. *Composite模式在具体实现中, 可以让父对象中的子对象反向追溯，如果父对象有频繁的遍历需求, 可使用缓存* ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:4:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["nvim"],"content":"配置nvim ","date":"2023-03-29","objectID":"/nvim/:0:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"centos7 这里说明 这里只配置了 ccls 因为golang的编译特性 其实什么平台写go都一样 /* 更新yum库 yum update centos7 python 默认为 3.6.8 升级为 3.8.11 yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make yum -y install epel-release yum -y install zlib zlib yum -y install zlib zlib-devel wget http://npm.taobao.org/mirrors/python/3.8.12/Python-3.8.12.tar.xz xz -d Python-3.8.12.tar.xz tar -xf Python-3.8.12.tar cd Python-3.8.12 ./configure prefix=/usr/local/python3 make \u0026\u0026 make install mv /usr/bin/python /usr/bin/python.bak ln -s /usr/local/python3/bin/python3.8 /usr/bin/python python --version vi /usr/bin/yum 把#! /usr/bin/python修改为#! /usr/bin/python2 vi /usr/libexec/urlgrabber-ext-down 把#! /usr/bin/python 修改为#! /usr/bin/python2 为何这样配是因为yum需要使用python2才能正常运行,而之前的python指向python3 ,版本不对应,所以将其改成python2 cd /usr/bin ll pip* rm pip3 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 pip3 install -U setuptools (有啥问题 可以看看 别人博客 https://www.cnblogs.com/yahoon/p/16172517.html) 下载nodejs curl -sL install-node.now.sh/lts | bash 下载nvim curl -o /usr/local/bin/nvim -LO https://github.com/neovim/neovim/releases/download/stable/nvim.appimage chmod u+x /usr/local/bin/nvim cp /usr/local/bin/nvim /usr/bin/nvim 安装插件管理器 使用新的 vim-plug sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' 创建初始化 neovim 配置文件 mkdir ~/.config/nvim/ nvim ~/.config/nvim/init.vim 下载 nodejs \u0026 npm wget https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz tar -xvf node-v16.15.1-linux-x64.tar.xz coc插件 需要的步骤 npm install neovim pip3 install neovim 下载 ccls sudo yum install epel-release sudo yum install snapd sudo systemctl enable --now snapd.socket sudo ln -s /var/lib/snapd/snap /snap sudo snap install ccls --classic vim ~/.bash_profile export PATH=\"$PATH:/snap/bin/\" 安装wget(如果没有wget) yum -y install gcc make gcc-c++ openssl-devel wget 使用 clash vpn 防止nvim下载插件失败 wget -c https://github.com/Dreamacro/clash/releases/download/v1.11.8/clash-linux-amd64-v1.11.8.gz gzip -d ./clash-linux-armv6-v1.10.6.gz chmod u+x ./clash-linux-armv6-v1.10.6.gz 处理 配置文件 wget -O config.yaml \u003c配置文件的url\u003e 启动clash ./clash-linux-armv6-v1.10.6.gz 启动 http 代理 export http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 验证是否ok curl https://www.google.com.hk/ 下载插件 nvim ~/.config/nvim/init.vim :PlugInstall 检查健康 :checkhealth 修复err 一般都会是coc出现问题 如果是 build/index.js cd ~/.vim/plugged/coc.nvim git checkout release */ ","date":"2023-03-29","objectID":"/nvim/:1:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"Mac /* mac 自带的python是 3.8 版本 可以跳过 安装nvim brew install neovim 安装vim-plug sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' 如果 443 可以通过 /ect/hosts 解决 具体的可以百度 创建初始化 neovim 配置文件 mkdir ~/.config/nvim/ nvim ~/.config/nvim/init.vim 下载node.js brew install nodejs coc插件 需要的步骤 npm install neovim pip3 install neovim brew install ccls 下载插件 nvim ~/.config/nvim/init.vim :PlugInstall 如果timeout请开启 vpn 并配置gitconfig 检查健康 :checkhealth 解决 checkhealth 错误后 nvim test.go :GoInstallB... 然后如果不行就重新启动命令行 随后即可 */ ","date":"2023-03-29","objectID":"/nvim/:2:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"Windows // 未完待续 ","date":"2023-03-29","objectID":"/nvim/:3:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"clash配置文件功能详解 # HTTP 代理端口 port: 7890 # SOCKS5 代理端口 socks-port: 7891 # Linux 和 macOS 的 redir 代理端口 redir-port: 7892 # 允许局域网的连接 allow-lan: true # 规则模式：Rule（规则） / Global（全局代理）/ Direct（全局直连） mode: rule # 设置日志输出级别 (默认级别：silent，即不输出任何内容，以避免因日志内容过大而导致程序内存溢出）。 # 5 个级别：silent / info / warning / error / debug。级别越高日志输出量越大，越倾向于调试，若需要请自行开启。 log-level: silent # Clash 的 RESTful API external-controller: '0.0.0.0:9090' # RESTful API 的口令 secret: '' # 您可以将静态网页资源（如 clash-dashboard）放置在一个目录中，clash 将会服务于 `RESTful API/ui` # 参数应填写配置目录的相对路径或绝对路径。 # external-ui: folder ","date":"2023-03-29","objectID":"/nvim/:4:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"Init.vim \" ==================== Editor behavior ==================== \" http://blog.guorongfei.com/2015/09/03/vim-shortcut/ set nu syntax on set foldmethod=marker set tabstop=2 set shiftwidth=2 set softtabstop=2 set showmode set showcmd set mouse=a set encoding=utf-8 set t_Co=256 set autoindent set cursorline set linebreak set showmatch set hlsearch set incsearch \"设置vim可以使用back键\" set backspace=2 nnoremap \u003cC-l\u003e :tabn\u003cCR\u003e \"移动到下一个标签\" nnoremap \u003cC-h\u003e :tabp\u003cCR\u003e \"移动到上一个标签\" au BufReadPost * if line(\"'\\\"\") \u003e 1 \u0026\u0026 line(\"'\\\"\") \u003c= line(\"$\") | exe \"normal! g'\\\"\" | endif inoremap ' ''\u003cESC\u003ei inoremap \" \"\"\u003cESC\u003ei inoremap ( ()\u003cESC\u003ei inoremap [ []\u003cESC\u003ei inoremap { {}\u003cESC\u003ei \"设置跳出自动补全的括号 func SkipPair() if getline('.')[col('.') - 1] == '\u003c' || getline('.')[col('.') - 1] == ')' || getline('.')[col('.') - 1 ] == ']' || getline('.')[col('.') - 1] == '\"' || getline('.')[col('.') - 1] == \"'\" || getline('.')[col('.' ) - 1] == '}' return \"\\\u003cESC\u003ela\" else return \"\\t\" endif endfunc \" ===================== Install Plugins with Vim-Plug ================= call plug#begin('~/.vim/plugged') \" style \" Plug 'crusoexia/vim-monokai' Plug 'shaunsingh/nord.nvim' \" Go Plug 'fatih/vim-go' , { 'for': ['go', 'vim-plug'], 'tag': '*' } \" Python Plug 'Vimjas/vim-python-pep8-indent', { 'for' :['python', 'vim-plug'] } Plug 'numirias/semshi', { 'do': ':UpdateRemotePlugins', 'for' :['python', 'vim-plug'] } Plug 'tweekmonster/braceless.vim', { 'for' :['python', 'vim-plug'] } \" Visual indentation Plug 'Yggdroot/indentLine' \" vim-monokai Plug 'crusoexia/vim-monokai' \" annotation Plug 'scrooloose/nerdcommenter' \" Nested parentheses are highlighted Plug 'luochen1990/rainbow' \" Directory management plug-in Plug 'preservim/nerdtree' Plug 'Xuyuanp/nerdtree-git-plugin' Plug 'ryanoasis/vim-devicons' \" Coc.nvim Plug 'neoclide/coc.nvim', {'branch': 'release'} \" dashboard Plug 'glepnir/dashboard-nvim' \" lualine Plug 'nvim-lualine/lualine.nvim' \" barbar Plug 'kyazdani42/nvim-web-devicons' Plug 'romgrk/barbar.nvim' \" diffview Plug 'nvim-lua/plenary.nvim' Plug 'sindrets/diffview.nvim' \" telescope Plug 'nvim-lua/plenary.nvim' Plug 'nvim-telescope/telescope.nvim', { 'tag': '0.1.0' } Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'} \" lazygit Plug 'kdheepak/lazygit.nvim' \" delve Plug 'sebdah/vim-delve' call plug#end() \" ==================== lazygit ======================== \" https://github.com/kdheepak/lazygit.nvim nnoremap \u003csilent\u003e \u003cleader\u003egg :LazyGit\u003cCR\u003e \" ==================== telescope ====================== \" https://github.com/nvim-telescope/telescope.nvim \" Find files using Telescope command-line sugar. nnoremap \u003cleader\u003eff \u003ccmd\u003eTelescope find_files\u003ccr\u003e nnoremap \u003cleader\u003efg \u003ccmd\u003eTelescope live_grep\u003ccr\u003e nnoremap \u003cleader\u003efb \u003ccmd\u003eTelescope buffers\u003ccr\u003e nnoremap \u003cleader\u003efh \u003ccmd\u003eTelescope help_tags\u003ccr\u003e \" Using Lua functions nnoremap \u003cleader\u003eff \u003ccmd\u003elua require('telescope.builtin').find_files()\u003ccr\u003e nnoremap \u003cleader\u003efg \u003ccmd\u003elua require('telescope.builtin').live_grep()\u003ccr\u003e nnoremap \u003cleader\u003efb \u003ccmd\u003elua require('telescope.builtin').buffers()\u003ccr\u003e nnoremap \u003cleader\u003efh \u003ccmd\u003elua require('telescope.builtin').help_tags()\u003ccr\u003e \" ==================== diffview ======================= \" https://github.com/sindrets/diffview.nvim \" ==================== barbar ======================== \" Move to previous/next nnoremap \u003csilent\u003e \u003cA-,\u003e \u003cCmd\u003eBufferPrevious\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-.\u003e \u003cCmd\u003eBufferNext\u003cCR\u003e \" Re-order to previous/next nnoremap \u003csilent\u003e \u003cA-\u003c\u003e \u003cCmd\u003eBufferMovePrevious\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-\u003e\u003e \u003cCmd\u003eBufferMoveNext\u003cCR\u003e \" Goto buffer in position... nnoremap \u003csilent\u003e \u003cA-1\u003e \u003cCmd\u003eBufferGoto 1\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-2\u003e \u003cCmd\u003eBufferGoto 2\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-3\u003e \u003cCmd\u003eBufferGoto 3\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-4\u003e \u003cCmd\u003eBufferGoto 4\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-5\u003e \u003cCmd\u003eBufferGoto 5\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-6\u003e \u003cCmd\u003eBufferGoto 6\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-7\u003e \u003cCmd\u003eBufferGoto 7\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-8\u003e \u003cCmd\u003eBufferGoto 8\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-9\u003e \u003cCmd\u003eBufferGoto 9\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-0\u003e \u003cCmd\u003eBufferLast\u003cCR\u003e \" Pin/un","date":"2023-03-29","objectID":"/nvim/:5:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"coc-settings.json { \"coc.preferences.semanticTokensHighlights\": false, \"coc.preferences.enableFloatHighlight\": true, \"coc.preferences.snippetStatusText\": \"Ⓢ \", \"coc.preferences.extensionUpdateCheck\": \"daily\", \"coc.preferences.messageLevel\": \"error\", \"coc.source.around.firstMatch\": false, \"coc.source.buffer.firstMatch\": false, \"coc.source.syntax.firstMatch\": false, \"suggest.detailMaxLength\": 60, \"suggest.noselect\": true, \"suggest.enablePreselect\": false, \"suggest.triggerAfterInsertEnter\": true, \"suggest.autoTrigger\": \"always\", \"suggest.timeout\": 5000, \"suggest.enablePreview\": true, \"suggest.floatEnable\": true, \"suggest.detailField\": \"preview\", \"suggest.snippetIndicator\": \"\", \"suggest.triggerCompletionWait\": 100, \"suggest.echodocSupport\": true, \"suggst.completionItemKindLabels\": { \"class\": \"\\uf0e8\", \"color\": \"\\ue22b\", \"constant\": \"\\uf8fe\", \"default\": \"\\uf29c\", \"enum\": \"\\uf435\", \"enumMember\": \"\\uf02b\", \"event\": \"\\ufacd\", \"field\": \"\\uf93d\", \"file\": \"\\uf723\", \"folder\": \"\\uf115\", \"function\": \"\\u0192\", \"interface\": \"\\uf417\", \"keyword\": \"\\uf1de\", \"method\": \"\\uf6a6\", \"module\": \"\\uf40d\", \"operator\": \"\\uf915\", \"property\": \"\\ue624\", \"reference\": \"\\ufa46\", \"snippet\": \"\\ue60b\", \"struct\": \"\\ufb44\", \"text\": \"\\ue612\", \"typeParameter\": \"\\uf728\", \"unit\": \"\\uf475\", \"value\": \"\\uf89f\", \"variable\": \"\\ue71b\" }, \"diagnostic.signOffset\": 2, \"diagnostic.errorSign\": \"!\", \"diagnostic.warningSign\": \"!!\", \"diagnostic.infoSign\": \"\\uf129\", \"diagnostic.hintSign\": \"\\uf864\", \"diagnostic.displayByAle\": false, \"diagnostic.refreshOnInsertMode\": false, \"diagnostic.checkCurrentLine\": true, \"diagnostic.virtualTextPrefix\": \" ❯❯❯ \", \"diagnostic.virtualText\": false, \"codeLens.enable\": true, \"list.previewHighlightGroup\": \"Statement\", \"list.nextKeymap\": \"\u003cC-e\u003e\", \"list.previousKeymap\": \"\u003cC-u\u003e\", \"importCost.bundleSizeDecoration\": \"both\", \"importCost.typescriptExtensions\": [\"\\\\.tsx?$\"], \"importCost.javascriptExtensions\": [\"\\\\.jsx?$\"], \"importCost.showCalculatingDecoration\": true, \"importCost.debug\": false, \"snippets.ultisnips.directories\": [ \"$HOME/.config/nvim/Ultisnips/\", \"$HOME/.config/nvim/plugged/vim-snippets/UltiSnips/\" ], \"coc.preferences.formatOnSaveFiletypes\": [ \"javascript\", \"typescript\", \"typescriptreact\", \"html\", \"css\", \"json\", \"jsonc\", \"java\", \"python\", \"vue\", \"svelte\", \"cs\", \"racket\", \"prisma\" ], \"yaml.format.enable\": true, \"signature.target\": \"float\", \"yank.enableCompletion\": false, \"typescript.suggestionActions.enabled\": true, \"typescript.format.enabled\": true, \"jest.watch\": false, \"explorer.width\": 38, \"explorer.quitOnOpen\": true, \"explorer.sources\": [ { \"name\": \"buffer\", \"expand\": false }, { \"name\": \"file\", \"expand\": true } ], \"explorer.file.column.indent.indentLine\": true, \"explorer.file.showHiddenFiles\": true, \"explorer.icon.enableNerdfont\": true, \"explorer.file.column.git.showIgnored\": true, \"explorer.keyMappingMode\": \"none\", \"explorer.buffer.showHiddenBuffers\": false, \"explorer.keyMappings.global\": { \"u\": \"nodePrev\", \"e\": \"nodeNext\", \"h\": \"toggleSelection\", \"\u003ctab\u003e\": \"actionMenu\", \"gl\": \"expandRecursive\", \"gh\": \"collapseRecursive\", \"i\": [\"wait\", \"expandable?\", \"expand\", \"open\"], \"\u003ccr\u003e\": [\"wait\", \"expandable?\", \"cd\", \"open\"], \"I\": \"open:vsplit\", \"o\": [\"wait\", \"expanded?\", \"collapse\", \"expand\"], \"O\": \"open:tab\", \"n\": \"collapse\", \"l\": \"gotoParent\", \"yp\": \"copyFilepath\", \"yn\": \"copyFilename\", \"yy\": \"copyFile\", \"dd\": \"cutFile\", \"pp\": \"pasteFile\", \"dD\": \"deleteForever\", \"a\": \"addFile\", \"k\": \"addFile\", \"M\": \"addDirectory\", \"cw\": \"rename\", \".\": \"toggleHidden\", \"zh\": \"toggleHidden\", \"R\": \"refresh\", \"?\": \"help\", \"q\": \"quit\", \"X\": \"systemExecute\", \"gd\": \"listDrive\", \"f\": \"search\", \"F\": \"searchRecursive\", \"B\": \"gotoSource:file\", \"b\": \"gotoSource:buffer\", \"[[\": \"sourcePrev\", \"]]\": \"sourceNext\", \"[d\": \"diagnosticPrev\", \"]d\": \"diagnosticNext\", \"[c\": \"gitPrev\", \"]c\": \"gitNext\", \"\u003c\u003c\": \"gitStage\", \"\u003e\u003e\": \"gitUnstage\" }, \"flutter.outlineWidth\": 40, \"flutter.outlineIconPadding\": 0, \"flutter.UIPath\": true, \"flutter.openDevLogSplitCommand\": \"botright 12split\", \"flutter.lsp.init","date":"2023-03-29","objectID":"/nvim/:6:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"C++ PImpl ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:0:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl惯用法 PImpl术语，即\"pointer to implementation\" （指向实现的指针），由Jeff Summer最先引入。 该技巧可以避免在头文件中暴露私有细节，是促进API接口和实现保持完全分离的重要机制 PImpl并不是严格意义上的设计模式，而是桥模式的一种特例 在本人博客中有介绍《设计模式-桥模式》 如下图，Class A只提供公有接口Function1，Function2，其实现细节由Impl类实现，Class A通过一格Impl指针来提供服务，这样做的目的在于，使用Class A公有接口的用户，不必关系其实现细节，而且实现的变动，对用户也是透明的 注：- : private, + : public, # : protected 特点：该技巧在公有接口中完全隐藏内部细节。支持将私有成员数据和方法，从.h转移到.cpp文件。是构建接口和实现恰当分离的API的不可或缺的工具 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:1:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"使用PImpl PImpl将类的数据成员定义为指向某个已经声明过的类型的指针，如上面的例子中的impl。这里类型仅作为名字引入，没有被完整定义，只需要前向声明即可，隐藏可以将该类型定义隐藏在.cpp文件中。该指针也称为不透明指针，因为用户无法看到所指对象细节 示例：“自动定时器（AutoTimer）API，对象被销毁时打印出生存时间” // autotimer.h #ifdef _WIN32 #include \u003cwindows.h\u003e #else #include \u003csys/time.h\u003e #endif #include \u003cstring\u003e class AutoTimer { public: /// 使用易于理解的名字创建新定时器 explicit AutoTimer(const std::string\u0026 name); ~AutoTimer(); private: // 返回对象已经存在了多长时间 double GetElapsed() const; std::string name_; #ifdef _WIN32 DWORD startTime_; #else struct timeval startTime_; #endif }; 该API的问题：暴露了定时器在不同平台上存储的底层细节，任何人都可以从头文件看到这些平台的定义 可取之处：仅将必要的方法暴露为public方法（构造函数、析构函数），其余方法、数据标记为private 由于C++语言特性，要求这些private成员都声明在公有头文件中，导致API包含平台相关#if指令。而设计者的真正目的是将所有private成员隐藏在.cpp文件中 PImpl惯用法将所有private成员放在一个class/struct中，这个类在头文件中仅做前置声明，在.cpp中定义。可以像下面这样，利用pimpl重构前面的头文件 autotimer.h #include \u003cstring\u003e class AutoTimer // 接口类 { public: explicit AutoTimer(const std::string \u0026name); ~AutoTimer(); private: class Impl; // 前置声明 Impl *impl; // 通过私有内嵌类, 将实现细节封装到内嵌类中 }; autotimer.cpp // autotimer.cpp #include \"autotimer.h\" #include \u003ciostream\u003e #if _WIN32 #include \u003cwindows.h\u003e #else #include \u003csys/time.h\u003e #endif class AutoTimer::Impl // 实现类 { public: double GetElapsed() const { #ifdef _WIN32 return (GetTickCount() - startTime_) / 1e3; #else struct timeval end_time; gettimeofday(\u0026end_time, NULL); double t1 = startTime_.tv_usec / 1e6 + startTime_.tv_sec; double t2 = end_time.tv_usec / 1e6 + end_time.tv_sec; return t2 - t1; #endif } std::string name_; #ifdef _WIN32 DWORD starTime_; #else struct timeval startTime_; #endif }; AutoTimer::AutoTimer(const std::string \u0026name) : impl_(new AutoTimer::Impl()) { impl_-\u003ename_ = name; #ifdef _WIN32 imp_-\u003estartTime_ = GetTickCount(); #else gettimeofday(\u0026impl_-\u003estartTime, NULL); #endif } AutoTimer::~AutoTimer() { std::cout \u003c\u003c impl_-\u003ename_ \u003c\u003c \": took \" \u003c\u003c impl_-\u003eGetElapsed() \u003c\u003c \" secs\" \u003c\u003c std::endl; delete impl_; impl_ = NULL; } 这样，将原本暴露在原有头文件中的所有private方法和数据，转移到了.cpp文件中定义的AutoTimer::Impl类中 将Impl类（实现类）声明为AutoTimer类的private内嵌类，是为了避免与该实现相关的符号污染全局命名空间，只有AutoTimer的方法才能访问Impl成员 在Impl类中放哪些逻辑？接口类中有哪些部分，需要放到Impl类中？ 通常，有以下选择 仅private成员变量 private成员变量和方法 所有public方法。接口类中public方法只是对Impl类中等价方法进行简单包装 推荐第2项，将priavet变量和方法都放到Impl类中，这样可以保持数据和操作这些数据的方法的封装性，从而避免在public头文件中声明private方法。 不过，有2项需要注意 不能在impl类中隐藏private虚方法。virtual方法必须出现在接口类中，以保证任何派生类都能覆盖它 虽然可以将接口类传递给Impl类的方法，但必要时，可以在Impl类中增加指回接口类的指针，便于Impl类调用公有方法 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:2:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"复制语义 复制使用PImpl惯用法的接口类，存在潜在风险 当没有为类显式定义copy构造函数、assignment运算符（operator=）时，C++编译器会默认创建（trivial版本）。但这种trivail版本的copy构造函数、assigment运算符，只能执行浅复制。显然不利于使用PImpl惯用法，因为如果客户复制了接口类对象，那么2个对象就会指向同一个Impl实现类对象，析构时，就会删除同一个Impl对象2次，从而可能导致程序崩溃 *针对该问题，有2种可选方案： 禁止复制类 如果不打算让用户创建接口类对象副本，可以将对象声明为不可复制。 禁止编译器生成默认copy函数，有以下几种方法： 将方法设为private，禁止客户调用 如果使用Boost库，可以让接口类继承自boost::noncopyable C++11以后，可以将方法声明为\"=delete\" 显式定义复制语义 如果希望客户能复制采用PImpl的对象，就应该声明并定义自己的copy构造函数、assignment运算符，进行对象的深拷贝，创建Impl对象的副本 下面展示如何使得接口类AutoTimer禁止拷贝 #include \u003cstring\u003e // 方式1 class AutoTimer { public: explicit AutoTimer(const std::string \u0026name); ~AutoTimer(); private: // 使对象不可复制 AutoTimer(const AutoTimer\u0026); const AutoTimer\u0026 operator=(const AutoTimer\u0026); class Impl; Impl *impl_; }; // 方式2 class AutoTimer : boost::noncopyable // 使对象不可复制 { public: explicit AutoTimer(const std::string \u0026name); ~AutoTimer(); private: class Impl; Impl *impl_; }; // 方式3 class AutoTimer : boost::noncopyable { public: explicit AutoTimer(const std::string \u0026name); ~AutoTimer(); private: // 使对象不可复制 AutoTimer(const AutoTimer\u0026) = delete; const AutoTimer\u0026 operator=(const AutoTimer\u0026)= delete; class Impl; Impl *impl_; }; ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:3:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl与智能指针 详情可以看《Effective Modern c++ 条款22》 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:4:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl优点 信息隐藏 实现细节可以隐藏到Impl类实现中，保护闭源API专有性。同时，接口头文件也能更干净、清晰表达真正的公有接口，易于阅读和理解 降低耦合 接口类只用知道Impl类即可，不用包含私有成员变量所需头文件，也不必包含平台依赖的windows.h或sys/time.h。 加速编译 将实现相关头文件移入.cpp，API的引用层次降低，会导致编译时间减少。 更好的二进制兼容性 采用PImpl的对象大小从不改变，因为对象总是单个指针大小。对私有成员变量做任何修改，都只影响隐藏在cpp文件内的实现类大小。而对象的二进制表示可以不变 惰性分配 Impl类可以在需要时再构造，而不必在接口类构造时立即构造。 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:5:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl缺点 必须为你创建的每个对象分配并释放实现对象。这使得对象增加了一个指针（Impl impl），同时增加了通过指针访问成员的开销，增加了new和delete对象的开销* 必须通过impl-\u003e的形式访问私有成员，给开发人员带来了不便。 编译器不能捕获接口类中const对成员变量修改。因为成员变量现在存在于独立的对象（impl指针所指对象）中。编译器仅检查impl指针是否发生变化，而不会检查其成员。 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:6:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["C++"],"content":"inline ","date":"2023-03-17","objectID":"/c-inline/:0:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"什么是内联函数-inline 引出 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行 一个 C/C++程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如return 0;）来结束自己的生命，从而结束整个程序 函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码 如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视 为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数 怎么定义内联函数 #include \u003ciostream\u003e using namespace std; //内联函数，交换两个数的值 inline void swap(int *a, int *b){ int temp; temp = *a; *a = *b; *b = temp; } int main(){ int m, n; cin\u003e\u003em\u003e\u003en; cout\u003c\u003cm\u003c\u003c\", \"\u003c\u003cn\u003c\u003cendl; swap(\u0026m, \u0026n); cout\u003c\u003cm\u003c\u003c\", \"\u003c\u003cn\u003c\u003cendl; return 0; } 内联函数要注意的点 要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字 对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做 内联函数的坑 使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数 ","date":"2023-03-17","objectID":"/c-inline/:1:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline 工作原理 inline 不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现inline的调用表达式用内联函数的函数体来替换，普通函数调用时，需要切换栈帧寄存器，同时栈中压入参数，返回值，然后跳转，这些都需要开销，而内联函数不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销 虽然内联函数在调用时直接进行展开，但实际在编译后代码中存在内联函数的定义，可以供编译器进行调用。普通函数可以有指向它的函数指针，内敛函数也可以有指向它的函数指针 ","date":"2023-03-17","objectID":"/c-inline/:2:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline的优点 不会产生函数调用开销。节省了调用函数时在堆栈上推送/弹出变量的开销。节省了函数返回调用的开销。 当你inline一个函数的时候，你可以让编译器对函数体执行上下文特定的优化，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化 ","date":"2023-03-17","objectID":"/c-inline/:3:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline的缺点 从内联函数中添加的变量会消耗额外的寄存器，在内联函数之后，如果要使用寄存器的变量数量增加，则可能会在寄存器变量资源利用方面产生开销，在函数调用点替换内联函数体时，函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加 如果你使用太多的内联函数，那么二进制可执行文件的大小会很大，因为相同的代码重复 过多的内联也会降低指令缓存命中率，从而降低从缓存内存到主内存的指令获取速度 如果有人更改内联函数内的代码，内联函数可能会增加编译时间开销，那么所有调用位置都必须重新编译，因为编译器需要再次替换所有代码，否则它将继续使用旧功能 内联函数可能会导致抖动，因为内联可能会增加二进制可执行文件的大小。内存抖动会导致计算机性能下降 ","date":"2023-03-17","objectID":"/c-inline/:4:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline的使用场景 内联函数一般只适用于比较短小，处理较为简单的函数。内联只是对编译器的请求，而不是命令。编译器可以忽略内联请求。编译器可能不会在以下情况下执行内联 如果函数包含循环（for, while, do-while）； 如果一个函数包含静态变量； 如果一个函数是递归的； 如果函数返回类型不是 void，并且函数体中不存在 return 语句； 如果函数包含 switch 或 goto 语句； ","date":"2023-03-17","objectID":"/c-inline/:5:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"c++内联函数也可以用来代替宏 先来讲讲宏 使用宏的一个经典例子是求一个数的平方，如下所示： #include \u003ciostream\u003e using namespace std; #define SQ(y) y*y int main(){ int n, sq; cin\u003e\u003en; sq = SQ(n); cout\u003c\u003csq\u003c\u003cendl; return 0; } // 运行结果 9↙ 81 看运行结果是没有啥问题的，但是当我们将宏调用 SQ(n) 换成 SQ(n+1) 后，就会出现意想不到的状况 #include \u003ciostream\u003e using namespace std; #define SQ(y) y*y int main(){ int n, sq; cin\u003e\u003en; sq = SQ(n+1); cout\u003c\u003csq\u003c\u003cendl; return 0; } // 运行结果 9↙ 19 我们期望的结果是 100，但这里却是 19，两者大相径庭。这是因为，宏展开仅仅是字符串的替换，不会进行任何计算或传值，上面的 sq = SQ(n+1); 在宏展开后会变为sq = n+1*n+1;，这显然是没有道理的 如果希望得到正确的结果，应该将宏定义改为如下的形式： #define SQ(y) (y)*(y) 这样宏调用 sq = SQ(n+1); 就会展开为 sq = (n+1)*(n+1);，得到的结果就是 100。 如果你认为这样就万事大吉了，那下面的结果会让你觉得考虑不周： #include \u003ciostream\u003e using namespace std; #define SQ(y) (y)*(y) int main(){ int n, sq; cin\u003e\u003en; sq = 200 / SQ(n+1); cout\u003c\u003csq\u003c\u003cendl; return 0; } 9↙ 200 之所以会出现这么奇怪的结果，是因为宏调用 sq = 200 / SQ(n+1); 会被展开为sq = 200 / (n+1) * (n+1);，当 n 被赋值 9 后，相当于 sq = 200 / 10 * 10，结果显然是 200 要想得到正确的结果，还应该对宏加以限制，在两边增加 ( )，如下所示： #define SQ(y) ( (y)*(y) ) 这样宏调用 sq = 200 / SQ(n+1); 就会展开为sq = 200 / ( (n+1) * (n+1) );，得到的结果就是 2 说了这么多，我最终想强调的是，宏定义是一项 “细思极密” 的工作，一不小心就会踩坑，而且不一定在编译和运行时发现，给程序埋下隐患 如果在 1 的基础上将宏替换成 inline函数呢 #include \u003ciostream\u003e using namespace std; inline int SQ(int y){ return y*y; } int main(){ int n, sq; cin\u003e\u003en; //SQ(n) sq = SQ(n); cout\u003c\u003csq\u003c\u003cendl; //SQ(n+1) sq = SQ(n+1); cout\u003c\u003csq\u003c\u003cendl; //200 / SQ(n+1) sq = 200 / SQ(n+1); cout\u003c\u003csq\u003c\u003cendl; return 0; } 9↙ 81 100 2 看，一切问题迎刃而解！发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，这和简单的字符串替换相比省去了很多麻烦，所以在编写 C++ 代码时我推荐使用内联函数来替换带参数的宏 使用inline函数替换宏的优点 和宏一样，内联函数可以定义在头文件中（不用加 static 关键字），并且头文件被多次#include 后也不会引发重复定义错误。这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次#include 后会引发重复定义错误 内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏 ","date":"2023-03-17","objectID":"/c-inline/:6:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline的规范 inline 是一种\"用于实现的关键字\"，而不是一种\"用于声明的关键字\" inline 关键字可以只在函数定义处添加，也可以只在函数声明处添加，也可以同时添加；但是在函数声明处添加 inline 关键字是无效的，编译器会忽略函数声明处的 inline 关键字 更为严格地说，内联函数不应该有声明，应该将函数定义放在本应该出现函数声明的地方，这是一种良好的编程风格 将内联函数的声明和定义分散到不同的文件中会出错 在多文件编程中，我们通常将函数的定义放在源文件中，将函数的声明放在头文件中，希望调用函数时，引入对应的头文件即可，我们鼓励这种将函数定义和函数声明分开的做法。但这种做法不适用于内联函数，将内联函数的声明和定义分散到不同的文件中会出错，请看下面的例子 main.cpp 代码 #include \u003ciostream\u003e using namespace std; //内联函数声明 void func(); int main(){ func(); return 0; } module.cpp 代码 #include \u003ciostream\u003e using namespace std; //内联函数定义 inline void func(){ cout\u003c\u003c\"inline function\"\u003c\u003cendl; } 上面的代码能够正常编译，但在链接时会出错。func() 是内联函数，编译期间会用它来替换函数调用处，编译完成后函数就不存在了，链接器在将多个目标文件（.o或.obj文件）合并成一个可执行文件时找不到 func() 函数的定义，所以会产生链接错误 内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质 函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用 规范小结 内联函数看起来简单，但是有很多细节需要注意，从代码重复利用的角度讲，内联函数已经不再是函数了。我认为将内联函数作为带参宏的替代方案更为靠谱，而不是真的当做函数使用 在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举） ","date":"2023-03-17","objectID":"/c-inline/:7:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"Effective c++ Item 对于更多的inline知识请看《Effective c++ Item30》 ","date":"2023-03-17","objectID":"/c-inline/:8:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"c++ 关键字与关键库函数 ","date":"2023-03-16","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:0:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"前言 想了想，最好的复习方法其实就是去写出来，good idea~ ","date":"2023-03-16","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:1:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"strlen V.S sizeof 什么是strlen strlen 是头文件 \u003ccstring\u003e 中的函数 strlen测量的是字符串的实际长度（其源代码如下）以\\0结尾 size_t strlen(const char *str) { size_t length = 0; while (*str++) ++length; return length; } 什么是sizeof sizeof是c++里的一个操作符，用来测量对象或者表达式类型所占字节的大小 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; int main() { char arr[10] = \"hello\"; cout \u003c\u003c strlen(arr) \u003c\u003c endl; // 5 cout \u003c\u003c sizeof(arr) \u003c\u003c endl; // 10 return 0; } 两者的不同点 若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; void size_of(char arr[]) { cout \u003c\u003c sizeof(arr) \u003c\u003c endl; // warning: 'sizeof' on array function parameter 'arr' will return size of 'char*' . cout \u003c\u003c strlen(arr) \u003c\u003c endl; } int main() { char arr[20] = \"hello\"; size_of(arr); return 0; } /* 输出结果： 8 5 */ strlen 本身是库函数，因此在程序运行过程中，计算长度 / 而 sizeof 是在编译时计算长度； strlen 的参数必须是 char * 类型的变量 / sizeof 的参数可以是类型，也可以是变量，且必须是完整类型 strlen 是一个函数，如果接受表达式则会对表达式进行运算 / sizeof 接受的参数可以是对象也可以是表达式，但是 sizeof(expression) 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小； #include \u003ciostream\u003e using namespace std; int main(int argc, char * argv[]) { int x = 4; char *s = \"12345678\"; char *p = s; sizeof(x++); printf(\"%d\\n\", x); strlen(p++); return 0; } ","date":"2023-03-16","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:2:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C 和 C++ static 中的作用 指路，在static的专题有讲解 https://vlicecream.github.io/c-static/ ","date":"2023-03-16","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:3:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"const 作用及用法 指路，在const的专题有讲解 https://vlicecream.github.io/c-const/ ","date":"2023-03-16","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:4:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"define V.S const 编译阶段 define 是在编译预处理阶段进行替换 / const 是在编译阶段确定其值 安全性 define 定义的宏常量没有数据类型，只是进行简单的代码替换，不会进行类型安全的检查 const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误 存储空间 define 定义的宏定义只是作为代码替换的表达式而已，宏定义本身不占用内存空间，define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，实际使用宏定义替换代码时占用的是代码段的空间 const 定义的常量占用静态存储区的只读空间，程序运行过程中常量只有一份 调试 define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了 const 定义的常量可以进行调试 接受参数 define 可以接受参数构造非常复杂的表达式 const 不能接受参数 ","date":"2023-03-16","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:5:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"inline 作用及使用方法 指路，在inline专题有讲解 https://vlicecream.github.io/c-inline/ ","date":"2023-03-16","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:6:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"inline V.S define 编译阶段 内联函数是在编译时展开，而宏在编译预处理时展开 在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换 安全性 宏定义编写较为复杂，常需要增加一些括号来避免歧义。宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查，因此在实际使用宏时非常容易出错 / 而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查 调试 内联函数可以进行调试 / 宏定义的“函数”无法调试 类 由于类的成员函数全部为内联函数，通过内联函数，可以访问类的数据成员，而宏不能访问类的数据成员 传递参数 在 inline 函数传递参数只计算一次，而在使用宏定义的情况下，每次在程序中使用宏时都会计算表达式参数，因此宏会对表达式参数计算多次 ","date":"2023-03-16","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:7:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"const const object non-const object const member functions ✅ ✅ non-const member functions ❌ ✅ ","date":"2023-03-16","objectID":"/c-const/:0:0","tags":["C++"],"title":"const","uri":"/c-const/"},{"categories":["C++"],"content":"object 与 member func 的关系 我们根据上述表格来看看例子 我们创建了一个常量 str 并且调用print方法，但是如果当初设计 string::print() 时候没有指明const 那么会直接报错， 因为 “const obj” 调用 non-const 成员函数的时候 是不允许的～～ const String str(\"hello world\"); str.print(); 我们再来看一个标准库 string 的例子 class template std::basic_string\u003c...\u003e 有如下两个 成员函数 chatT operator[] (size_type pos) const { ... } // 不必考虑copy on write reference operator[] (size_type pos) { ... } // 必须考虑copy on write 在设计字符串的时候 因为字符串是共享的 可能a拷贝一份 b拷贝一份 就有多份 最致命的是 如果a修改了 b的字符串也随之修改了，所以我们必须要考虑这个共享的问题 所以这个就考虑到了 const 下面没有const，那么可能就会修改字符串，上面的有 const 那么就不允许修改 下面也是可行的 因为 non-const member func 是可以创建 non-const obj 的 但是上面的 const member func 又可以创建 const obj 又可以创建 non-const obj，那么编译器怎么调用呢 当成员函数的 “const\" 和 “non-const” 版本同时存在 const obj 只能调用const 版本 “non-const obj” 只能调用\"non-const\"版本 ","date":"2023-03-16","objectID":"/c-const/:1:0","tags":["C++"],"title":"const","uri":"/c-const/"},{"categories":["C++"],"content":"const修饰 const 修饰基本数据类型 基本数据类型，修饰符 const 可以用在类型说明符前，也可以 用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值即可 const 修饰指针变量和引用变量 const int* p1; //指向整形常量的指针，它指向的值不能修改 int* const p2; //指向整形的常量指针 ，它不能在指向别的变量，但指向(变量)的值可以修改。 const int* const p3; //指向整形常量的常量指针 。它既不能再指向别的常量，指向的值也不能修改。 const 应用到函数中 作为参数的 const 修饰符： 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化，保护了原对象的属性 注意：参数 const 通常用于参数为指针或引用的情况 作为函数返回值的 const 修饰符： 声明了返回值后，const 按照\"修饰原则\"进行修饰，起到相应的保护作用 const 在类中的用法 const成员变量 只在某个对象生命周期内是常量，而对于整个类而言 是可以改变的 const 数据成员的初始化只能在类的构造函数的初始化列表中进行 因为类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员，因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么 const成员函数 const 成员函数的主要目的是防止成员函数修改对象的内容 要注意，const 关键字和 static 关键字对于成员函数来说是不能同时使用的 因为 static 关键字修饰静态成员 函数不含有 this 指针，即不能实例化，const 成员函数又必须具体到某一个函数 const 修饰类对象，定义常量对象 常量对象只能调用常量函数，别的成员函数都不能调用 C++ 中的 const类成员函数(用法和意义) 常量对象可以调用类中的 const member func，但不能调用non-const member func 这是因为对象调用成员函数的时候，在形参列表最前面加一个形参this，但是这个是隐式的。this 指针是默认指向调用函数的当前对象的，所以，很自然，this是一个常量指针test* const，因为不可修改this指针代表的地址。但当member func的参数列表后加了 const 关键字 void print() const; ，此成员函数为常量成员函数，此时他的隐式this形参为 const test* const 即 不可以通过this指针来改变指向对象的值 非常量对象可以调用类中的 const 成员函数，也可以调用非 const 成员函数。 ","date":"2023-03-16","objectID":"/c-const/:2:0","tags":["C++"],"title":"const","uri":"/c-const/"},{"categories":["C++"],"content":"Effective c++ Item 对于更多的const的相关知识，可以查看《Effective c++ Item3 - 尽量使用const》 ","date":"2023-03-16","objectID":"/c-const/:3:0","tags":["C++"],"title":"const","uri":"/c-const/"},{"categories":["C++"],"content":"friend ","date":"2023-03-16","objectID":"/c-friend/:0:0","tags":["C++"],"title":"friend","uri":"/c-friend/"},{"categories":["C++"],"content":"友元 什么是友元 Friend 的意义在于打开封装的大门，可以直接从私有区域拿取数据 好比借钱，陌生人不可能借钱给他，但是朋友是可以的，但是朋友太多借太多钱也不太好，所以你自己选择，如果不设置friend，绕个弯从函数拿，也是可以的 private: double re, im; friend complex\u0026 __dopal (conplex*, const complex\u0026) inline complex\u0026 __doapl (complex* ths, const complex\u0026 r) { ths-\u003ere += r.re; ths-\u003eim += r.im; return *ths } ","date":"2023-03-16","objectID":"/c-friend/:1:0","tags":["C++"],"title":"friend","uri":"/c-friend/"},{"categories":["C++"],"content":"友元的使用场景 普通函数定义为类的友元函数，使得普通函数能够访问该类的私有成员和保护成员 #include \u003ciostream\u003e using namespace std; class A { friend ostream \u0026operator\u003c\u003c(ostream \u0026_cout, const A \u0026tmp); // 声明为类的友元函数 public: A(int tmp) : var(tmp) { } private: int var; }; ostream \u0026operator\u003c\u003c(ostream \u0026_cout, const A \u0026tmp) { _cout \u003c\u003c tmp.var; return _cout; } int main() { A ex(4); cout \u003c\u003c ex \u003c\u003c endl; // 4 return 0; } 友元类 由于类的 private 和 protected 成员变量只能由类的成员函数访问或者派生类访问，友元类则提供提供一种通用的方法，使得不同类之间可以访问其 private 和 protected 成员变量，用于不同类之间共享数据 #include \u003ciostream\u003e using namespace std; class A { friend class B; public: A() : var(10){} A(int tmp) : var(tmp) {} void fun() { cout \u003c\u003c \"fun():\" \u003c\u003c var \u003c\u003c endl; } private: int var; }; class B { public: B() {} void fun() { cout \u003c\u003c \"fun():\" \u003c\u003c ex.var \u003c\u003c endl; // 访问类 A 中的私有成员 } private: A ex; }; int main() { B ex; ex.fun(); // fun():10 return 0; } ","date":"2023-03-16","objectID":"/c-friend/:2:0","tags":["C++"],"title":"friend","uri":"/c-friend/"},{"categories":["C++"],"content":"相同class的各个obj互为friend 在下述代码中，我们竟然可以通过func直接获取到private中的值，我们也没有设置friend，这是因为相同class的各个obj互为friend class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} int func(const complex\u0026 param) { return param.re + param.im; } private: double re, im; }; { complex c1(2, 1); complex c2; c2.func(c1); } ","date":"2023-03-16","objectID":"/c-friend/:3:0","tags":["C++"],"title":"friend","uri":"/c-friend/"},{"categories":["C++"],"content":"lambda ","date":"2023-03-16","objectID":"/c-lambda/:0:0","tags":["C++"],"title":"lambda","uri":"/c-lambda/"},{"categories":["C++"],"content":"lambda 怎么去定义一个lambda [] { std::cout \u003c\u003c \"hello lambdas\" \u003c\u003c std::endl; } 对于上述代码，我们可以写成这个样子 [] { std::cout \u003c\u003c \"hello lambdas\" \u003c\u003c std::endl; } (); // prints \"hello lambdas\" 那我们改进后 看着也有点怪怪的，我们大费周章就为了一个cout，干嘛呢，假如要100次cout还不如抽出来 然后调用100次呢，所以多半我们会这么写 auto l = [] { std::cout \u003c\u003c \"hello lambdas\" \u003c\u003c std::endl; }; ... l(); // prints \"hello lambdas\" lambda是可以在语句和表达式中定义的功能定义。因此，您可以将lambda用作内联函数。最小lambd函数没有参数，只是简单地做一些事情，所以跟上述的不太一样，lambda是可以不用取名字，直接在语句或者表达式中定义，用完就直接不管的 lambdas的模板 [ capture-list ] ( params ) mutable(optional) constexpr(optional)(c++17) exception attribute -\u003e ret { body } // 可选的简化语法 [ capture-list ] ( params ) -\u003e ret { body } [ capture-list ] ( params ) { body } [ capture-list ] { body } capture-list: 捕捉列表，这个不用多说，前面已经讲过，它不能省略 [] // 没有定义任何变量。使用未定义变量会引发错误。 [x, \u0026y] // x pass by value（默认），y pass by reference。 [\u0026] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [\u0026, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, \u0026z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 params:参数列表，可以省略(但是后面必须紧跟函数体) mutable:可选，将 lambda 表达式标记为 mutable 后，函数体就可以修改传值方式捕获的变量 constexpr:可选 exception:可选，指定 attribute:可选，指定 ret:可选，返回值类型 body:函数执行体 ","date":"2023-03-16","objectID":"/c-lambda/:1:0","tags":["C++"],"title":"lambda","uri":"/c-lambda/"},{"categories":["C++"],"content":"lambda 的本质 最前边的 [] 是 lambda 表达式的一个很重要的功能，就是 闭包 先说明一下 lambda 表达式的大致原理 每当你定义一个 lambda 表达式后，编译器会自动生成一个匿名类，这个类当然重载载了()运算符，我们称为闭包类型* 那么在运行时，这个 lambda 表达式就会返回一个匿名的闭包实例，其实是一个右值 所以，我们上面的 lambda 表达式的结果就是一个个闭包实例 闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为 lambda 捕捉块。例子如下 int main() { int x = 10; auto add_x = [x](int a) { return a + x; }; // 复制捕捉x,lambda 表达式无法修改此变量 auto multiply_x = [\u0026x](int a) { return a * x; }; // 引用捕捉x，lambda 表达式可以修改此变量 cout \u003c\u003c add_x(10) \u003c\u003c \" \" \u003c\u003c multiply_x(10) \u003c\u003c endl; // 输出:20 100 return 0; } 而 lambda 表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数 其实，最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量， 通过 lambda 表达式给出条件，传递给 count_if 函数 int val = 3; vector\u003cint\u003e v {1, 8, 5, 3, 6, 10}; int count = std::count_if(v.beigin(), v.end(), [val](int x) { return x \u003e val; }); // v中大于3的元素数􏰁 ","date":"2023-03-16","objectID":"/c-lambda/:2:0","tags":["C++"],"title":"lambda","uri":"/c-lambda/"},{"categories":["C++"],"content":"Summary c++ 11引入了lambda，允许定义内联函数，可以作为参数或局部对象使用 从本质上来讲，表达式只是一种语法糖，因为所有其能完成的工作都可以用其它稍微复杂的代码来实现，但是它简便的语法却给 C++ 带来了深远的影响 从广义上说， 表达式产生的是函数对象。 在类中，可以重载函数调用运算符()，此时类的对象可以将具有类似函数的行为，我们称这些对象为函数对象或者仿函数 相比 lambda表达式，函数对象有自己独特的优势 lambda是可以在语句和表达式中定义的功能定义。因此，您可以将lambda用作内联函数。最小lambda函数没有参数，只是简单地做一些事情 要弄清楚lambda的模板并且分清楚\"[ ]“的传值使用，想要修改值就pass by reference + mutable ","date":"2023-03-16","objectID":"/c-lambda/:3:0","tags":["C++"],"title":"lambda","uri":"/c-lambda/"},{"categories":["C++"],"content":"static ","date":"2023-03-16","objectID":"/c-static/:0:0","tags":["C++"],"title":"static","uri":"/c-static/"},{"categories":["C++"],"content":"static 什么是static 下述代码括号里面传的就是this pointer 当不是静态方法的时候 c1, c2, c3调用同一个函数 那么就是靠this point区分到底是c1 还是 c2 的 complex c1, c2, c3; cout \u003c\u003c c1.real(); cout \u003c\u003c c2.real(); // 上述代码其实要是看透本质等于下面代码 complex c1, c2, c3; cout \u003c\u003c complex::real(\u0026c1); cout \u003c\u003c complex::real(\u0026c2); 所以静态就是不带这个this pointer 静态用在哪 - 存储静态的数据 不会变动的 ","date":"2023-03-16","objectID":"/c-static/:1:0","tags":["C++"],"title":"static","uri":"/c-static/"},{"categories":["C++"],"content":"static的修饰 static 修饰局部变量 存放原本从栈区变成了静态存储区 生命周期原本从包含语句模块结束变成了延续到整个程序结束 作用域不发生变化 static 修饰全局变量 static全局变量会存在静态存储区 生命周期会延续到整个程序结束 作用域从原本的全文件共享，变成了定义文件共享 static 修饰函数 跟全局变量类似，作用域发生了改变 static 修饰成员变量 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和 private、public、protected 访问规则 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象，且只能该变量只能被初始化一次，不能在类的构造函数中对静态成员变量进行初始化 静态成员变量可以作为成员函数的参数，而普通成员变量不可以 静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用 static 修饰成员函数 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数 静态成员函数不能声明成 virtual function、const funciton、volatile function static 对象 静态对象的生存周期为整个程序的生命周期，而非静态对象的生命周期只存在于某个循环中 ","date":"2023-03-16","objectID":"/c-static/:2:0","tags":["C++"],"title":"static","uri":"/c-static/"},{"categories":["C++"],"content":"inline 与 static 在c++17之后 静态成员直接类内inline就可以省去类外初始化的麻烦 class Person { public: ... private: inline static uint8_t age = 0; } ","date":"2023-03-16","objectID":"/c-static/:3:0","tags":["C++"],"title":"static","uri":"/c-static/"},{"categories":["C++"],"content":"体系结构 标准库与STL 标准库与STL的差别 标准库 \u003e STL / 标准库里面百分之70 80 都是STL STL六大部件 容器 / 分配器 / 算法 / 迭代器 / 仿函数 / 适配器 // 标准库以header files 形式呈现// C++标准库的head files 不带.h 例如: #include \u003cvector\u003e// 新式 C header files 不带.h 例如 #include \u003ccstdio\u003e// 旧式 C header files 带.h 仍然可用 例如 #include \u003cstdio.h\u003e // 新式headers内的组件封装于 命名空间namespace \"std\"using namespace std; // 代表直接打开这个namespace 里面的随便用 推荐用这个using std::cout // 就可以直接用cout来表示 // example: #include \u003cstring\u003e #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; 这里推荐直接用新式的习惯 ","date":"2023-03-16","objectID":"/c-stl-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/:0:0","tags":["C++"],"title":"stl-体系结构","uri":"/c-stl-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"标准库重要网页 // 标准库网页 CPlusPlus.com CppReference.com gcc.gnu.org// 书籍介绍 THE C++ STANDARD LIBRARY STL源码剖析 ","date":"2023-03-16","objectID":"/c-stl-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/:1:0","tags":["C++"],"title":"stl-体系结构","uri":"/c-stl-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"STL六大部件 /* 容器: 存放data的地方 分配器: 分配内存的作用 迭代器: 可以理解为一个指针 算法: 比如 sort 之类的 仿函数: 作用跟函数类似 适配器: 相当于转换xxx的功能*/ #include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003cfunctional\u003e#include \u003ciostream\u003eusing namespace std;int main() { int ia[6] = { 27, 210, 12, 47, 109, 83 }; vector\u003cint, allocator\u003cint\u003e\u003e vi(ia, ia+6); cout \u003c\u003c count_if(vi.begin(), vi.end(), not1(bind2nd(less\u003cint\u003e(), 40))); return 0;}/*代码解析: vector 其实就是一个容器 allocator: 分配器 可以不写 源代码会有默认的分配器用来分配内存 count_if: 一种算法 能够帮我们在某种条件下计算元素的个数 vi.begin(): 迭代器 传元素 less: 仿函数 比大小 跟a, b比大小 取小 bind2nd: 适配器 绑定第二个参数 此处就是可以跟40来比 not1: 否定 原本是小于40 现在是大于等于40*/ ","date":"2023-03-16","objectID":"/c-stl-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/:2:0","tags":["C++"],"title":"stl-体系结构","uri":"/c-stl-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"前闭后开 区间 #include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003cfunctional\u003e#include \u003ciostream\u003eusing namespace std;int main() { int ia[6] = { 27, 210, 12, 47, 109, 83 }; vector\u003cint, allocator\u003cint\u003e\u003e vi(ia, ia+6); cout \u003c\u003c count_if(vi.begin(), vi.end(), not1(bind2nd(less\u003cint\u003e(), 40))); return 0;}/* vi.begin() 指向ia数组的第一个元素的位置 vi.end() 指向ia数组最后一个元素的下一个位置 这种的我们就叫做前闭后开 [ ) 所以利用这个我们可以对这个容器用伪代码遍历*/Container\u003cT\u003e c; // 创建一个容器... // 往容器塞值container\u003cT\u003e::iterator ite = c.begin() // 给一个迭代器for (; ite != c.end(); ++ite) { // 如果这个迭代器不到c.end() 就执行代码 ...}// 现在有一个可以优化上面的伪代码的方法std::vector\u003cdouble\u003e vec;...for ( auto elem : vec) { // auto的作用就是代替 container\u003cT\u003e::iterator std::cout \u003c\u003c elem \u003c\u003c std::end1;}// 对auto也可以优化for ( auto\u0026 elem : vec) { elem *= 3}// 对auto再一次解释list\u003cstring\u003e c;...list\u003cstring\u003e::iterator ite;ite = ::find(c.begin(), c.end(), target);// 上述代码利用auto可以写成list\u003cstring\u003e c;...auto ite = ::find(c.begin(), c.end(), target); ","date":"2023-03-16","objectID":"/c-stl-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/:3:0","tags":["C++"],"title":"stl-体系结构","uri":"/c-stl-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"value \u0026 poionter \u0026 reference ","date":"2023-03-16","objectID":"/c-value-pointer-reference/:0:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"引用 什么是引用 reference 其实就是一个漂亮的 pointer 引用的代码 int x = 0; int* p = \u0026x; // p is a pointer to x int\u0026 p = x; // r is a reference to x int x2 = 5; r = x2; int\u0026 r2= r; int*是 pointer to int，int\u0026是 reference to int，比如 int* p = \u0026x; 我们会说指针p指向了x，而int\u0026 r = x;我们会说 r 代表了 x，其实r里面有一个指针指向了x ，r 只要代表了 x 就不可以代表别的变量，pointer不同，pointer还可以指向别的变量 假象 我们观察上面的 x 和 r的地址和大小，就发现 sizeof(r) = sizeof(x) \u0026x == \u0026r object 和其 reference的大小相同，地址也相同（但是都是假象） reference的常见用途 reference一般不用在声明变量，而用在参数类型和返回类型的描述 void func1(Cls* pobj) { pobj-\u003exxx(); } // pass by pointer void func2(Cls obj) { obj.xxx(); } // pass by value void func3(Cls\u0026 obj) { obj.xxx(); } // pass by reference Cls obj; func1(\u0026obj); func2(obj); func(obj); 我们能发现 pass by pointer 跟其他的都不一样，而\"value\" “reference\"被调用端的写法相同，调用端接口也相同 所以最好用 reference 不行的情况下 比如返回临时对象的情况下，用value ","date":"2023-03-16","objectID":"/c-value-pointer-reference/:1:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"签名 什么是签名 不含return type的函数部分叫做签名 如下述代码 他们的签名都是 image(const double im) 所以他们两者不能同时存在 double image(const double\u0026 im) { ... } double image(const double im) { ... } const 也算函数签名 ","date":"2023-03-16","objectID":"/c-value-pointer-reference/:2:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"指针和引用的区别 指针和引用都是内存地址的一个概念，区别就是指针是一个实体，引用是一个别名 指针他指向一个内存，在编译的时候会以 “指针名 - 指向的内存地址” 存入符号表，所以说 指针包含的内容是可以改变的，并且是可以 const修饰的，允许拷贝和赋值，甚至可以为空，sizeof得到的就是指针类型的大小 引用则就是相当于一个内存的别名，在添加到符号表的时候，是以 “引用变量名 - 引用对象的地址\"添加到符号表中，符号表一经完成不能改变，所以引用必须而且只能在定义时被绑 定到一块内存上，后续不能更改，也不能为空，也没有 const 和非 const 区别 sizeof sizeof 引用得到代表对象的大小 sizeof 指针得到的是指针本身的大小 参数传递 传指针的实质是传值，传递的值是指针的地址。指针需要被解引用后才可以对对象进行操作 传引用的实质是传地址，传递的是参数的地址。直接对引用进行的修改会直接作用到引用对象上 ","date":"2023-03-16","objectID":"/c-value-pointer-reference/:3:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"参数传递 pass by value 形参是实参的拷⻉，函数内部对形参的操作并不会影响到外部的实参 值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参 值，从而形成了实参的一个副本(替身) 值传递的特点就是被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值(形参指针变了，实参指针不会变) pass by pointer 指针参数本质上就是一个值传递，他所传递的是一个地址值 当对地址值的指向操作时，就相当于对实参本身进行操作 pass by reference 被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时 存放的是由主调函数放进来的实参变量的地址 被调函数对形参(本体)的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量(根据别名找到主调函数中的 本体) 因此，被调函数对形参的任何操作都会影响主调函数中的实参变量 引用传递和指针传递是不同的 虽然他们都是被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量，而对于指针传递的参数，如果改变被调函数中的指针地址，他将应用不到主调函数的相关变量。 如果想通过指针参数传递来改变主调函数中的相关变量(地址)，那就得使用指向指针的指针或者指针引用 ","date":"2023-03-16","objectID":"/c-value-pointer-reference/:4:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"野指针 什么是野指针 就是没有被初始化过的指针 如何避免野指针 在平时的编码中，养成定义指针后初始化或者使用智能指针的习惯 ","date":"2023-03-16","objectID":"/c-value-pointer-reference/:5:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"悬空指针 什么是悬空指针 是指针最初指向的内存已经被释放的一种指针 ","date":"2023-03-16","objectID":"/c-value-pointer-reference/:6:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"编写头文件的思路流程(reference) ","date":"2023-03-16","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/:0:0","tags":["C++"],"title":"编写头文件的思路流程(reference)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/"},{"categories":["C++"],"content":"class内 编写防卫式声明 #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 #endif 编写class head #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { }; #endif 编写数据 放入private #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { private: char* m_data; }; #endif // __STRING__ 编写构造函数 类的名称要相同 有哪些参数要传，需不需要默认值，参数传递是 pass by value 还是 pass by reference 合理利用初始列，初始列就是设初始值 { } 内可能会有内存分配哦~ const!!! #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { public: String(const char* cstr = 0); // 构造函数 private: char* m_data; }; #endif // __STRING__ 设计三大函数 #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { public: String(const char* cstr = 0); // 构造函数 String(const String\u0026 str); // 拷贝构造 String\u0026 operator=(const String\u0026 str); // 拷贝赋值 ~String(); // 析构函数 private: char* m_data; }; #endif // __STRING__ 设计其他函数 当我们设计一个函数的时候，一定要思考，要不要加const 到底要不要加，只需要看，这个参数会不会被改变，如果不会改变或不能改变，则加const 结合此处代码考虑，取出和构造的拷贝的时候，都不会改变str，所以就加一个const class String { public: String(const char* cstr = 0); // 构造函数 String(const String\u0026 str); // 拷贝构造 String\u0026 operator=(const String\u0026 str); // 拷贝赋值 ~String(); // 析构函数 char* get_c_str() const { return m_data; } // 拿到私有的数据 private: char* m_data; }; #endif // __STRING__ ","date":"2023-03-16","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/:1:0","tags":["C++"],"title":"编写头文件的思路流程(reference)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/"},{"categories":["C++"],"content":"class外 构造函数和析构函数 inline String::String(const char* cstr = 0) { if (cstr) { m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); } else { m_data = new char[1]; *m_data = '\\0'; } } // c里面字符串是以 '\\0' 为结束符号 这是构造函数 inline String::~String() { delete[] m_data; } // 析构函数 因为上述构造函数 为str分配了一个内存 所以要释放内存 要不然会内存泄漏 // class 有指针 多半要做动态分配 所以就要在析构函数 释放内存 拷贝构造函数 // 拷贝构造没有返回值 inline String::String(const String\u0026 str) { m_data = new char[ strlen(str.m_data) + 1 ]; strcpy(m_data, str.m_data); } 拷贝赋值函数 inline String\u0026 String::operator=(const String\u0026 str) { // 这一行与下一行的\u0026不一样 第一行是引用(reference) 第二行是取\"str\"地址 if (this == \u0026str) return *this; // 判断是不是自我赋值 delete[] m_data; m_data = new char [ strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); return *this; } ","date":"2023-03-16","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/:2:0","tags":["C++"],"title":"编写头文件的思路流程(reference)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/"},{"categories":["C++"],"content":"编写头文件的思路流程(value) ","date":"2023-03-16","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/:0:0","tags":["C++"],"title":"编写头文件的思路流程(value)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/"},{"categories":["C++"],"content":"class内 编写防卫式声明 #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 #endif 编写class head #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { }; #endif 编写数据 放入private #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { private: double re, im; }; #endif // __COMPLEX__ 编写构造函数 类的名称要相同 有哪些参数要传，需不需要默认值，参数传递是 pass by value 还是 pass by reference 合理利用初始列，初始列就是设初始值 { } 内可能会有内存分配哦~ #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} private: double re, im; }; #endif // __COMPLEX__ 设计\"+=“函数 这里需要考虑是否为成员函数，如果是则在class内定义，如果不是则在class内定义，这里选择是 #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex\u0026 operator+=(const complex\u0026); private: double re, im; }; #endif // __COMPLEX__ 设计其他函数 当我们设计一个函数的时候，一定要思考，要不要加const 到底要不要加，只需要看，这个参数会不会被改变，如果不会改变或不能改变，则加const *结合此处代码考虑 real imag 是取出 re im 没有改动 所以 要加const * #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex\u0026 operator+=(const complex\u0026); double real() const { return re; } double imag() const { return im; } private: double re, im; }; #endif // __COMPLEX__ 想拿私有数据，我们可以交个朋友 #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex\u0026 operator+=(const complex\u0026); double real() const { return re; } double imag() const { return im; } private: double re, im; friend complex\u0026 __doapl(complex*, const complex\u0026); }; #endif // __COMPLEX__ ","date":"2023-03-16","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/:1:0","tags":["C++"],"title":"编写头文件的思路流程(value)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/"},{"categories":["C++"],"content":"class外 接口部分 inline complex\u0026 complex::operator += (const complex\u0026 r) inline complex\u0026 __doapl(complex* ths, const complex\u0026 r) /* 思考 参数 / const / pass by reference / return by reference / return type / class之外 inline */ 定义部分 inline complex\u0026 complex::operator += (const complex\u0026 r) { return __doapl(this, r); } inline complex\u0026 __doapl(complex* ths, const complex\u0026 r) { ths-\u003ere += r.re; ths-\u003eim += r.im; return *ths; } \"+” 非成员函数 为什么 “+” 要写为非成员函数 因为 “+” 其实有很多情况 比如复数+复数 复数+实数等 inline complex operator + (const complex\u0026 x, const complex\u0026 y) { return complex( real(x) + real(y), imag(x) + imag(y) ); } /* 思考 返回类型 参数类型 */ ","date":"2023-03-16","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/:2:0","tags":["C++"],"title":"编写头文件的思路流程(value)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/"},{"categories":["C++"],"content":"操作符重载 !!!本文基于这个一个 complex的类去讲解 操作符重载 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex\u0026 operator+=(const complex\u0026); double real() const { return re; } double imag() const { return im; } private: double re, im; friend complex\u0026 __doapl(complex *, const complex \u0026); }; ","date":"2023-03-16","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:0:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"操作符重载 示例操作符重载 “+=” +=就是一个操作符，那么操作符是怎么被编译器看待的 下述代码 += 会用到左边的c2上，如果c2有对+=的定义，就会调用+=的函数，操作符本来也就是一个函数 c2 += c1; 我们来示范一下重载 += 这个代码就是重写了+=函数，多包装了一层 inline complex\u0026 __doapl(complex* ths, const complex\u0026 r) { ths-\u003ere += r.re; ths-\u003eim += r.im; return *ths; // 返回的是一个value } inline complex\u0026 complex::operator+=(const complex\u0026 r) { return __doapl(this, r); } ","date":"2023-03-16","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:1:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"成员函数 - this 我们将上面的代码更深一层看，其实是这样的 这个this就是操作符左边的-也就是c2，但是在我们代码里面不可以写出来，知道他的存在就好 那么this就一定在第一个参数吗？ 其实不一定的，但是不用考虑 inline complex\u0026 complex::operator+=(this, const complex\u0026 r) { return __doapl(this, r); } ","date":"2023-03-16","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:2:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"Return by reference 还是上面的代码 我们来分析分析一个问题 *为什么 complex *ths 是指针的方式传进来的，return 的时候 ths 是返回指针所指向的value，然而声明返回值的时候，说返回的是一个内存地址\u0026 inline complex\u0026 __doapl(complex* ths, const complex\u0026 r) { // ... return *ths; } 这其实是允许的，你返回一个value，接收端怎么接收，是不需要管的，所以 传递者无需知道接收者是以reference形式接收 ","date":"2023-03-16","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:3:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"非成员函数 一个操作符也可以有很多个重载 下面三个操作符 + 由复数和实数组成三种，所以需要有三种全局函数 { complex c1(2, 1); complex c2; c2 = c1 + c2; c2 = c1 + 5; c2 = 7 + c1; } inline complex operator + (const complex\u0026 x, const complex\u0026 y) { return complex (real(x) + real(y), imag(x) + imag(y)); } inline complex operator + (const complex\u0026 x, double y) { return complex (real(x) + y, imag(x); } inline complex operator + (double x, const complex\u0026 y) { return complex (x + real(y), imag(y)); } ","date":"2023-03-16","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:4:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"临时对象 我们来看看上面 三个 +重载，他们绝不可return by reference 上述的 + 并非等同于 +=，x 和 y相加后的数据并没有地方放，所以在函数里一定会放在一个东西里 这里就是complex() conplex()相当于int()都会创建一个临时对象，这样的意思就是这个临时对象下一行就挂了，只是临时的作用 ","date":"2023-03-16","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:5:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"总结 const需不需要使用取决于这个值需不需要修改 pass by reference \u0026 return by reference 一切都优先考虑 reference，如果像需要用到临时对象，则使用return by value 同时也要注意 需不需要加上const ","date":"2023-03-16","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:6:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"构造析构/拷贝构造/拷贝赋值 ","date":"2023-03-16","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:0:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"三个特殊函数 class String { public: String(const char* cstr = 0); // 构造函数 String(const String \u0026str); // 他是接受自己的东西 所以这是一个拷贝构造 String\u0026 operator = (const String\u0026 str); // 操作符重载 =右手边也是自己的东西 所以这是拷贝赋值 ~String(); // 析构函数 当这个类死亡的时候 就会调用 析构函数 char* get_c_str() const { return m_data; } private: char* m_data }; ","date":"2023-03-16","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:1:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"构造函数和析构函数 代码演示 inline String::String(const char* cstr = 0) { if (cstr) { m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); } else { m_data = new char[1]; *m_data = '\\0'; } } // c里面字符串是以 '\\0' 为结束符号 这是构造函数 inline String::~String() { delete[] m_data; } // 析构函数 因为上述构造函数 为str分配了一个内存 所以要释放内存 要不然会内存泄漏 // class 有指针 多半要做动态分配 所以就要在析构函数 释放内存 构造函数析构函数里能不能抛出异常 C++只会析构已经完成的对象，对象只有其构造函数执行完毕才算是完成，在构造函数中发生异常，控制权转交给析构函数之外。因此，在对象b的构造函数中发生异常，并不会调用对象b的析构函数，所以会造成内存泄漏 用 auto_ptr 对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄 漏的危机，不再需要在析构函数中手动释放资源 如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++ 会调 用 terminate 函数让程序结束 如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完全他应该做的每一件事 ","date":"2023-03-16","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:2:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"深拷贝与浅拷贝 什么是浅拷贝 拷贝后，两个对象指向同一个内存地址，如果修改了其一个，另一个也会受到影响 String a(\"Hello\"); // 这个时候 a 的 data 指向了 'Hello\\0' 的地址 String b(\"World\"); // 这个时候 b 的 data 指向了 ‘World\\0’ 的地址 b = a; // 这个时候 b 就会指向 'Hello\\0' 的地址 a\u0026b都指向了同一个地址 可是 'World\\0' 还在 造成内存泄漏 而且你改a b就会受到影响 所以这种 'b = a' 叫做浅拷贝 出现类的等号赋值时，会调用拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调 用默认的拷⻉函数-即浅拷⻉，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷⻉是可行的，但当数据成员中有指针时，如果采用简单的浅拷⻉，则两类中的两个指针指向同一个地址，当对象快要结束时，会调用两次析构函数，而导致野指针的问题 什么是深拷贝 拷贝后，两个对象的值相同，但是不是同一个内存地址 简而言之，当数据成员中有指针时，必需要用深拷⻉更加安全 ","date":"2023-03-16","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:3:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"拷贝构造函数 什么是拷贝构造函数及实现 inline String::String(const String\u0026 str) { // 为什么叫构造 因为这是一个构造函数 为什么叫拷贝 因为传参是自己 m_data = new char[strlen(str.m_data)+1]; // 直接取另一个object的private data strcpy(m_data, str.m_data); } // 这也是深拷贝 什么情况会调用拷贝构造函数 一个对象以值传递传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间 一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时对象作为返回值 一个对象需要通过另一个对象进行初始化 为什么拷贝构造函数必须是pass by reference，不能是 pass by value 是为了防止死递归 当一个对象需要以值方式进行传递时，编译器会生成代码调用它的拷⻉构造函数生成一个副本，如果类 A 的拷⻉构造函数的参数不是引用传递，而是采用值传递，那么就又需要为了创建传递给拷⻉构造函数的参数的临时对象，而又一次调用类 A的拷⻉构造函数，这就是一个死递归 ","date":"2023-03-16","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:4:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"拷贝赋值函数 // 这个函数就是 如果 有 1 a\u0026b 先把 a 清销毁, 2 在new一个内存空间 , 3 在把 b 拷贝到 a 里面来 inline String\u0026 String::operator = (const String\u0026 str) { if (this == \u0026str) { // 检测自我赋值 return *this; } delete[] m_data; // 1 m_data = new char[ strlen(str.m_data)+1 ]; // 2 strcpy(m_data, str.m_data); // 3 return *this; } // 一定要检测自我赋值 要不然 a\u0026b 同时指向一个内存地址 然后杀掉之后 a\u0026b就指定不到值 ","date":"2023-03-16","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:5:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"Effective c++ Item 对于更多的三个特殊函数一些规范及其知识点，请看《Effective c++ Item5~Item12》 ","date":"2023-03-16","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:6:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"模版 ","date":"2023-03-16","objectID":"/c-%E6%A8%A1%E7%89%88/:0:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模板 class template 类模板的作用就是可变类型 template\u003ctypename T\u003e class complex { public: complex(T r = 0, T i = 0) : re(r), im(i) {} complex \u0026operator+=(const complex \u0026); T real() const { return re; } T imag() const { return im; } private: T re, im; friend complex \u0026__doapl(complex *, const complex \u0026); }; complex\u003cdouble\u003e c1(2.5, 3.5); func template func template 也是相当于 class template 如果我们用stone类型去生成对象，实参推导结果：T为stone，于是调用stone::operator \u003c，所以stone必须实现\"\u003c“方法 class stone { public: stone(int w, int h, int we) : _w(w), _h(h), _weight(we) {} bool operator \u003c (const stone\u0026 rns) const { return _weight \u003c rhs._weight; } private: int _w, _h, _weight; }; template \u003cclass T\u003e inline const T\u0026 min(const T\u0026 a, const T\u0026 b) { return b \u003c a ? b : a; } stone r1(2, 3), r2(3, 3), r3; r3 = min(r1, r2); member template 成员模版就是我们在外面设置了T1，T2后，在里面的成员模版又可以让我们在设置一个U1，U2 template \u003cclass T1, class T2\u003e struct pair { typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair() : first(T1()), second(T2()) { } pair()(const T1\u0026 a, const T2\u0026 b) : first(a), second(b) { } template \u003cclass U1, class U2\u003e pair(const pair\u003cU1, U2\u003e\u0026 p) : first(p.first), second(p.second) { } }; 是不是有点听不太懂，我们这么去想 Base1 鱼类 Dervied1 鲫鱼 / Base2 鸟类 Dervied2 麻雀 我们有这4个类 对应着继承关系 pair\u003cBase1, Base2\u003ep2\u003cpair\u003cDervied1, Dervied2\u003e()\u003e; 把一个由鲫鱼和麻雀组成的pair 放进(拷贝到)一个由鱼类和鸟类构成的pair中 可以吗 反之 可以嘛* 正着当然可以，反之，逻辑上说不通，因为 鸟类 \u003e 麻雀，为了显示这种逻辑，成员模板就因此而来 ","date":"2023-03-16","objectID":"/c-%E6%A8%A1%E7%89%88/:1:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模板特化 TODO: ","date":"2023-03-16","objectID":"/c-%E6%A8%A1%E7%89%88/:2:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模版偏特化 个数上的偏 template \u003ctypename T, typename Alloc=...\u003e // Alloc 分配器 class vector { ... }; // 如果第一个typename 一直为bool 的话 为了节省空间 我们可以进行绑定优化 template \u003ctypename Alloc=....\u003e // Alloc 分配器 class vector\u003cbool, Alloc\u003e { ... }; 范围上的偏 template \u003ctypename T\u003e class C { ... }; template \u003ctypename T\u003e class C\u003cT*\u003e { ... }; // 这样的意思就是我要求编译器 如果是指针的T 就走这个 不是就走上方 ","date":"2023-03-16","objectID":"/c-%E6%A8%A1%E7%89%88/:3:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模板模板参数 TODO: ","date":"2023-03-16","objectID":"/c-%E6%A8%A1%E7%89%88/:4:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模板的可变长参数 // 就是python 和 golang 的可变长参数 template \u003ctypename T, typename... Types\u003e void print (const T\u0026 firstArg, const Types\u0026.. args) { cout \u003c\u003c firstArg \u003c\u003c endl; print(args...); } ","date":"2023-03-16","objectID":"/c-%E6%A8%A1%E7%89%88/:5:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"虚函数 ","date":"2023-03-16","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:0:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"虚函数 虚函数的种类 non-virtual： 你不希望派生类重新定义 virtual：你希望派生类重新定义，且他有默认定义 pure virtual：你希望派生类一定要重新定义，你对他没有默认定义 class Shape { public: virtual void draw() const = 0; // pure virtual virtual void error(const std::string \u0026msg); // impure virtual int objectID() const; // non-virtual }; ","date":"2023-03-16","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:1:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"虚函数的实现原理 虚表与虚指针 我们先把下述代码扫一遍，并且来看看图，我们可以看到最左边的表 上面记录着 继承的父类和 自己的数据，但是除了这些之外，是不是还有一个记录着内存地址的，这个就是虚指针（vtpr）这个虚指针指向着一张虚表（vtbl） class A { pubilc: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; }; class B : public A { pubilc: virtual void vfunc1(); void func2(); private: int m_data3; }; class C : public B { pubilc: virtual void vfunc1(); void func2(); private: int m_data1, m_data4; }; c++对一个虚函数进行调用的过程 他首先会考虑是静态绑定还是动态绑定 静态绑定 就是 call xxx call(汇编语言的一个动作) xxx(addr) 如果是满足三个条件就会动态绑定 通过指针来调用 指针满足向上转型 调用的是虚函数 只要满足这三个条件 就会变成 (*(p-\u003evptr)[n])(p); 或者 (*p-\u003evptr[n] )(p); 为什么叫动态绑定，因为要看\"p\"是什么 ","date":"2023-03-16","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:2:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"虚函数的妙用 通过虚指针我们可以实现多态 比如 一个list 需要放多个不同大小的 比如 矩形 圆形 长方形 各种的 就可以直接放父类A 的指针 指向不同大小的 具体图形 因为对于指针来说 都是4个byte list\u003cA*\u003e myList; ","date":"2023-03-16","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:3:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"虚函数的注意点 析构函数要写成虚函数 是为了降低内存泄漏的可能性 一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指 针类型就会认为当前对象的类型是基类，调用基类的析构函数，仅执行基类的析构，所以造成内存泄漏 构造函数不写成虚函数 我们创建一个对象，是需要知道对象的完整信息的。特别是要知道对象的具体类型，而虚函数只需要知道函数接口，而不需要知道具体类型，所以构造函数不应该被定义为虚函数 从目前编译器实现虚函数进行多态的方式来看，虚函数的调用是通过实例化之后对象 的虚函数表指针来找到虚函数的地址进行调用的，如果说构造函数是虚的，那么虚函数表 指针则是不存在的，无法找到对应的虚函数表来调用虚函数，那么这个调用实际上也是违 反了先实例化后调用的准则 构造函数和析构函数中不要调用虚函数 举例来说，有一个动物的基类，基类中定义了一个动物本身行为的虚函数 action_type()， 在基类的构造函数中调用了这个虚函数 派生类中重写了这个虚函数，我们期望着根据对象的真实类型不同，而调用各自实现的虚函 数，但实际上当我们创建一个派生类对象时，首先会创建派生类的基类部分，执行基类的构造 函数，此时，派生类的自身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当 它们还不存在作为一种安全的方法 派生类中重写了这个虚函数，我们期望着根据对象的真实类型不同，而调用各自实现的虚函 数，但实际上当我们创建一个派生类对象时，首先会创建派生类的基类部分，执行基类的构造 函数，此时，派生类的自身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当 它们还不存在作为一种安全的方法 在析构函数中也是同理，派生类执行了析构函数后，派生类的自身成员呈现未定义的状态，那 么在执行基类的析构函数中是不可能调用到派生类重写的方法的 哪些函数不能写成虚函数 构造函数： 上述已说明 内联函数： 内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行 类型确定，所以内联函数不能是虚函数 静态函数： 静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚 函数没有任何意义 友元函数： 友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数 的说法 普通函数： 普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数 ","date":"2023-03-16","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:4:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"组合与继承 ","date":"2023-03-16","objectID":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/:0:0","tags":["C++"],"title":"组合与继承","uri":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"Composition 组合 什么是组合及实现 组合就是一个类里面用了另一个类，并且可以用另一个类的方法 template \u003cclass T, class Sequence = deque\u003cT\u003e\u003e class queue { ... protected: Sequence c; // 底层容器 public: // 以下完全利用 c 的操作函数完成 bool empty() const { return c.empty(); } size_type size() const { retiurn c.size(); } reference front() { return c.front(); } // deque 是两端可进出 queue 是先进先出 void push(const value_type \u0026x) { c.push_back(x); } void pop() { c.pop_front(); } } 组合其实是一个最容易被忽视的东西，设计模式的桥模式跟装饰模式组合是一个最重要的思路 组合下的构造和析构 比如 Container 类里面调用了 Component Container的构造函数首先调用Component的default构造函数然后才执行自己（从内到外） Container的析构函数首先执行自己 然后才调用Component的析构函数（从外到内） ","date":"2023-03-16","objectID":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/:1:0","tags":["C++"],"title":"组合与继承","uri":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"Inheritance 继承 什么是继承 所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类 子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用 struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; }; template\u003ctypename _Tp\u003e struct _List_node : public _List_node_base { _Tp _m_data; }; // 父类的数据 子类都可以继承下来 继承下的构造和析构 Base: 父类 / Derived: 派生类 Derived 的构造函数首先调用Base的default构造函数 然后才执行自己（从内到外） Derived 的析构函数首先执行自己, 然后才调用Base的析构函数（从外到内） 注意: base class 的 dtor 必须是virtual 否则会出现 underfined behavior ","date":"2023-03-16","objectID":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/:2:0","tags":["C++"],"title":"组合与继承","uri":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"组合\u0026继承的构造和析构 Base: 父类 / Derived: 派生类 Derived 的构造函数 首先调用Base的default构造函数，然后调用Component的default构造函数，然后才执行自己 Derived 的析构函数首先执行自己，然后调用Component的析构函数，然后调用Base的析构函数 ","date":"2023-03-16","objectID":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/:3:0","tags":["C++"],"title":"组合与继承","uri":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"左值/右值/左值引用/右值引用 ","date":"2023-03-16","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:0:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"前言 此篇博客会按照一个逻辑推导 带你们区分到底什么是 左值/右值/左值引用/右值引用 ","date":"2023-03-16","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:1:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"逻辑推导1 我们来看这一行简单的代码 int i = 10; i 在左边 -\u003e 左值 / 10 在右边 -\u003e 右值 这句话，在这行代码是适用的，但是！这句话不准确 我们看 i 在内存中是有位置的实际变量 / 而 10 没有存储地址，也就是在内存中是没有职位的 所以我们不能说 10 = i;，因为10是没有位置的，不能存储数据 但是 i 是一个左值，我们可以用另一个变量a 等于 i int a = i; 这就是为什么说 “i 在左边-\u003e左值 / 10 在右边-\u003e右值” 这句话是不准确的 ","date":"2023-03-16","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:2:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"逻辑推导2 现在我们来加一个函数 int GetValue() { return 10; } 随后调用这个函数 int i = GetValue(); 在这个例子中，GetValue返回了一个临时值，也就是右值，然后将这个右值保存到左值 当然因为这是一个右值，所以我们是这给这个右值赋值，那么就会失败 GetValue() = 10; // Error!!! 我们在试着修改一下，如果将函数返回值改成返回左值，那就变得很有趣了 int\u0026 GetValue() { } 将\"int\"加上\"\u0026“就变成了左值引用 这时候需要为我的值提供某种存储空间 比如一个静态int，然后返回他 int\u0026 GetValue() { static int value = 10; return value; } int main() { int i = GetValue(); GetValue() = 10; // true! 我就可以给他赋值，这个表达式也没有啥问题了，这就是左值引用 return 0; } ","date":"2023-03-16","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:3:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"逻辑推导3 我们再再再展开看一下，现在再加了一个SetValue() void SetValue(int value) { } int main() { int i = value; SetValue(i); // true! SetValue(10); // true } 当函数调用时，传左值是可以的，传右值也是可以的，因为这个右值会被用来创建一个左值 So? 我们可以马上看出，哪个变量是临时的，哪个不是，这个规则就是你不能将右值赋给左值引用 我们可以很容易的去检查这个，如果我在 int 加一个 \u0026，现在我在取一个 referebce to int，这是一个左值引用，SetValue(10)马上这个就会error 因为非const引用的初始值必须是左值 所以 const int\u0026 i = 10; 这个是一个特殊的规则 实际情况就是 编译器可能会用你的存储创建一个临时变量，然后赋值给那个引用 const int\u0026 i = 10; ===\u003e int temp = 10; const int\u0026 a = temp; 所以实际上 还是不可避免的创建了一个左值 但是也同时支持了左值右值 ","date":"2023-03-16","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:4:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"题目 好！ 讲到了这里 来出道题目 来看看你们到底懂得了怎么区分左右值 题目: 请找出 所有的左值 和 所有的右值! int main() { std::string firstName = \"lin\"; std::string secondName = \"ting\"; std::string fullName = firstName + secondName; } 答案 /* 左值: firstName/secondName/fullName 右值: \"lin\"/\"ting\"/firstName + secondName \"firstName + secondName\" 为什么是右值 因为 两个字符串相加是一个临时变量 所以他是临时值 也就是右值 */ ","date":"2023-03-16","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:5:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"逻辑推导4 好 我们再次进行拓展 void PrintName(std::string\u0026 name) { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { std::string firstName = \"lin\"; std::string secondName = \"ting\"; std::string fullName = firstName + secondName; PrintName(firstName); // true!! PrintName(secondName); // true!! PrintName(firstName + secondName); // error!! 因为他是一个右值 } 这就是为什么会看到很多用c++写的常量引用 因为他支持左右值，所以我们可以通过这种方法来检测哪些是左值 哪些是右值 那我们有没有办法写一个函数，只接受临时对象，肯定是有的，那就是右值引用 右值引用跟左值引用差不多，只不过多了一个”\u0026“符号 void PrintName(std::string\u0026\u0026 name) { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { std::string firstName = \"lin\"; std::string secondName = \"ting\"; std::string fullName = firstName + secondName; PrintName(firstName); // error!! 右值不能绑定到左值 PrintName(firstName + secondName); // true!! } 这就说得通了！这很coooool，因为这意味着我们可以写函数重载，他只接受临时对象 void PrintName(const std::string\u0026 name) { std::cout \u003c\u003c name \u003c\u003c std::endl; } void PrintName(std::string\u0026\u0026 name) { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { std::string firstName = \"lin\"; std::string secondName = \"ting\"; std::string fullName = firstName + secondName; PrintName(firstName); // true!! PrintName(firstName + secondName); // true!! } 那么他有啥作用呢 作用非常大 尤其是在移动语义方面 当然 我这里不会讲这个 这里代码的主要优势是优化，如果我们传入的是一个临时对象，那么我们就不需要担心他们是否活着 是否完整 是否拷贝，我们可以简单的偷他的资源 给到特定对象 或者其他地方使用它们，因为我们知道他是暂时的 他不会存在很长时间， 而如果你传入的不是右值，除了他是const之外 你不能从这个左值中窃取任何东西，因为他可能会在很多函数中使用 ","date":"2023-03-16","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:6:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"总结 左值是有某种存储支持的变量 右值是临时值 左值引用仅仅接受左值 除了const 右值引用仅仅接受右值 ","date":"2023-03-16","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:7:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["Effective Modern C++ 条款"],"content":"条款18~22 智能指针","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款18~22 智能指针 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:0:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"前言 其实《Effective C++ Item13》已经过时了，所以我们可以在《Effective Modern c++ Item18~Item22》条款中去理解智能指针 我们不爱裸指针的原因 裸指针的声明没办法告诉我们它指向的是单个对象还是数组 没办法知道用完这个裸指针后要不要销毁它指向的对象 没办法知道怎么销毁这个裸指针，是用operator delete还是什么其它自定义的途径 参照原因1，没办法知道该用delete还是delete[]，如果用错了，结果未定义 很难保证调用路径上恰好销毁这个指针一次，可能内存泄露，也可能double free 通常没办法知道裸指针是否是空悬指针，即是否指向已销毁的对象 智能指针的作用 智能指针就是来解这些问题的，它们用起来像裸指针，但能避免以上的很多陷阱 C++11中有4种智能指针：std::auto_ptr、std::unique_ptr、std::shared_ptr、std::weak_ptr 其中std::auto_ptr已经过时了，C++11中可以被std::unique_ptr取代了 正式看本博客之前，需要去弄懂\"PImpl\" 具体关于PImpl是什么，可以查看我这个博客《PImpl》 还有如果前言都没好好看，导致Item22不知道PImpl是啥，这时候你是不是应该要质疑一下自己，学习是不是太浮躁了? ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:1:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款18 对于占有性资源使用unique_ptr std::unique_ptr的特点 默认情况下，std::unique_ptr与裸指针一样大，且对于绝大多数操作来说（包括解引用），他们编译后的指令都是完全一样的，所有裸指针的空间和性能开销能满足要求的场景，std::unique_ptr一样能满足 std::unique_ptr体现了显式所有权的语义 非空的std::unique_ptr总是拥有他指向的对象 移动一个std::unique_ptr，所有权会从源指针转移到目的指针（之后源指针会设置为空指针） 拷贝std::unique_ptr是不允许的，因为如果你可以拷贝它，那么就有两个std::unique_ptr指向相同的资源，每一个都认为它拥有（和负责销毁）那份资源 因此std::unique_ptr是只可移动类型 当销毁的时候，一个非空的std::unique_ptr会销毁它的资源 默认情况下，资源销毁是通过对std::unique_ptr内的原生指针使用delete来完成的 一个例子是工厂函数。假设有一个基类和三个派生类，通过一个工厂函数来返回某个派生类的std::unique_ptr，这样调用方就不需要费心什么时候销毁返回的对象了：std::unique_ptr会负责这件事。 class Investment {...}; class Stock: public Investment {...}; class Bond: public Investment {...}; class RealEstate: public Investment {...}; template \u003ctypename... Ts\u003e std::unique_ptr\u003cInvestment\u003e makeInvestment(Ts\u0026\u0026... params); auto pInvestment = makeInvestment(args); // 注意这里实际上有个所有权的转移：工厂函数通过std::unique_ptr将Investment对象的所有权转移给了调用者 std::unique_ptr可以传入自定义的销毁器 在构造std::unique_ptr时，我们还可以传入一个自定义的销毁器，它会在std::unique_ptr析构时被调用，来销毁对应的资源 比如我们可能不想只是delete obj，还想输出一条日志 auto delInvmt = [](Investment* pInvestment) { makeLogEntry(pInvestment); // make log delete pInvestment; // delete obj }; template \u003ctypename... Ts\u003e std::unique_ptr\u003cInvestment, decltype(delInvmt)\u003e makeInvestment(Ts\u0026\u0026... params) { std::unique_ptr\u003cInvestment, decltype(delInvmt)\u003e pInv(nullptr, delInvmt); if (...) { pInv.reset(new Stock(std::forward\u003cTs\u003e(params)...)); } ... return pInv; } 从调用者的角度，你可以放心的处理std::unique_ptr，你可以相信在调用过程中资源只会销毁一次，且按恰当的方式销毁。理解以下几点能帮助你理解这种实现有多漂亮 delInvmt是自定义的销毁器，在std::unique_ptr析构时，自定义的销毁器会来完成释放资源必需的操作。这里用lambda表达式来实现delInvmt，不仅更方便，性能还更好 自定义的销毁器的类型必须与std::unique_ptr的第二个模板参数相同，因此我们要用decltype(delInvmt)来声明std::unique_ptr makeInvestment的基本策略是创建一个空的std::unique_ptr，再令它指向合适的类型，再返回。其中我们把delInvmt作为第二个构造参数传给std::unique_ptr，从而将销毁器与pInv关联起来 无法将裸指针隐式转换为std::unique_ptr，需要用reset来修改std::unique_ptr持有的裸指针 我们在创建具体的对象时，使用了std::forward将makeInvestment的所有参数完美转发给对应的构造函数 注意delInvmt的参数是Investment*，而它的实际类型可能是派生类，因此需要基类Investment有一个虚的析构函数 class Investment { public: ... virtual ~Investment(); ... }; 前文我们说过在不提供自定义的销毁器时，std::unique_ptr的大小与裸指针相同。但在有了自定义的销毁器后，这个假设不成立了。销毁器的大小取决于它内部保存了多少状态。对于无状态的函数对象（例如捕获列表为空的lambda表达式），销毁器实际不占用任何空间，这就意味着当你需要一个无状态的销毁器时，在lambda表达式和函数间做选择，lambda表达式更好 auto delInvmt1 = [](Investment* pInvestment) { ... }; template \u003ctypename... Ts\u003e std::unique_ptr\u003cInvestment, decltype(delInvmt1)\u003e makeInvestment(Ts\u0026\u0026... args); // return type has size of Investment* void delInvmt2(Investment* pInvestment) { ... } template \u003ctypename... Ts\u003e std::unique_ptr\u003cInvestment, void(*)(Investment*)\u003e makeInvestment(Ts\u0026\u0026... args); // return type has size of Investment* // plus at least size of function pointer std::unique_ptr另一个广泛应用的场景是pImpl模式 std::unique_ptr的两种形式分别是std::unique_ptr\u003cT\u003e和std::unique_ptr\u003cT[]\u003e，其中前者没有定义operator[]，后者在默认析构时会调用delete[]，且没有定义operator*和operator-\u003e。但在用到std::unique_ptr\u003cT[]\u003e的地方，你可能需要想一下是不是std::vector、std::array、std::string更合适。唯一一个用std::unique_ptr\u003cT[]\u003e更好的场合就是当你需要与C API交互时 std::unique_ptr另一个吸引人的地方在于，它可以作为std::shared_ptr的构造参数，因此上面的工厂函数返回std::unique_ptr就再正确不过了：调用者可以根据自己对所有权的需求来决定用std::unique_ptr还是std::shared_ptr，反正都支持 在C++11中，std::unique_ptr是表达独占所有权的方式，但它最吸引人的一个特性是它能即简单又高效地转化为std::shared_ptr std::shared_ptr\u003cInvestment\u003e sp = // 把 std::unique_ptr转换为 makeInvestment(argument); // std::shared_ptr 这是为什么std::unique_ptr如此适合做工厂函数的关键原因，工厂函数不会知道：独占所有权语义和共享所有权语义哪个更适合调用者。通过返回一个std::unique_ptr，工厂提供给调用者的是最高效的智能指针，但它不妨碍调用者用std::shared_ptr来替换它 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:2:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"Summary std::unique_ptr是一个具有开销小，速度快，只可移动的智能指针，使用独占所有权语义管理资源 默认情况下，释放资源由delete来完成，也可以指定自定义的析构函数来替代，但是具有丰富状态的deleters和以函数指针作为deleters增大了std::unique_ptr的存储开销 很容易将一个std::unique_ptr转化为std::shared_ptr ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:2:1","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款19 需要共享所有权的资源管理，用shared_ptr 什么是std::shared_ptr 使用std::shared_ptr管理的对象的所有权是共享的，没有哪个std::shared_ptr特别拥有这个对象，而是最后一个std::shared_ptr析构时，销毁这个对象 与垃圾回收类似，调用者不需要手动管理std::shared_ptr管理的对象 与析构函数类似，对象的析构时间是确定的 std::shared_ptr的特点 std::shared_ptr内部有引用计数，被复制时，引用计数+1，有std::shared_ptr析构时，引用计数-1，当引用计数为0时，析构持有的对象 引用计数的存在有以下性能影响 *std::shared_ptr的大小是裸指针的两倍：一个指针指向持有的对象，一个指针指向引用计数。* 引用计数使用的内存必须动态分配，原因是std::shared_ptr的引用计数是非侵入式的，必须要独立在对象外面。用std::make_shared能避免这次单独的内存分配 引用计数的加减必须是原子的，因此你必须假设读写引用计数是有成本的 注意，不是所有std::shared_ptr的构造都会增加引用计数，移动构造就不会。因此移动构造一个std::shared_ptr要比复制一个更快 与std::unique_ptr类似，std::shared_ptr的默认销毁动作也是delete，且也可以接受自定义的销毁器 但与std::unique_ptr不同的是，std::shared_ptr的销毁器类型不必作为它的模板参数之一 auto loggingDel = [](Widget* pw) { makeLogEntry(pw); delete pw; }; std::unique_ptr\u003cWidget, decltype(loggingDel)\u003e upw(new Widget, loggingDel); std::shared_ptr\u003cWidget\u003e spw(new Widget, loggingDel); 因此std::shared_ptr要比std::unique_ptr使用更灵活，比如不同销毁器的std::shared_ptr可以放到同一个容器中，而std::unique_ptr则不可以 另外，不同的销毁器不会改变std::shared_ptr的大小。std::shared_ptr内部需要为引用计数单独开辟一块内存，那么这块内存中再放一个销毁器也没什么额外开销。实际上这块内存被称为”控制块”，它里面包含以下元素 引用计数 弱引用计数 其它数据，包括 自定义销毁器 内存分配器 等等 控制块的创建规则为 std::make_shared总会创建一个控制块 通过一个独享所有权的指针（如std::unique_ptr或std::auto_ptr）创建出的std::shared_ptr总会创建一个控制块 通过裸指针创建的std::shared_ptr会创建控制块 一个推论就是：通过一个裸指针创建两个std::shared_ptr，会创建两个控制块，进而导致这个裸指针会被析构两次 从中我们可以得到两个教训 不要直接用裸指针构造std::shared_ptr，尽量用std::make_shared。当然在需要自定义的销毁器时不能用std::make_shared 非要用裸指针构造std::shared_ptr的话，尽量直接new，不要传入已有的裸指针变量 控制块会带来哪些开销呢？一个控制块通常只有几个word大，但其中会用到继承，甚至还有虚函数。这也意味着使用std::shared_ptr也会有调用虚函数的开销 但通常来说std::shared_ptr的额外开销是很小的。对于std::make_shared创建的std::shared_ptr，它的控制块只有3个word大，且内存分配上无额外成本。解引用一个std::shared_ptr也不会比解引用一个裸指针开销大。操作引用计数会带来一两次原子操作的开销，但通常也不大 std::shared_ptr的一个缺点是它不支持数组，但在C++11已经提供了std::array、std::vector、std::string这些容器类的前提下，还要用std::shared_ptr去管理一个数组，本身就是不好设计的信号 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:3:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"Summary std::shared_ptr为了管理任意资源的共享式内存管理，提供了自动垃圾回收的便利 std::shared_ptr是原生指针的两倍大小，因为他们内部除了包含一个原生指针以外，还包含了一个引用计数 std::shared_ptr 是 std::unique_ptr 的两倍大，除了控制块，还有需要原子引用计数操作引起的开销 避免从原生指针类型变量创建 std::shared_ptr 引用计数的内存必须被动态分配，当然用make_shared来创建shared_ptr会避免动态内存的开销 引用计数的递增和递减必须是原子操作 资源的默认析构一般通过delete来进行，但是自定义的deleter也是支持的。deleter的类型对于 std::shared_ptr 的类型不会产生影响 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:3:1","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款20 在需要共享语义且可能空悬的地方用weak_ptr 有时候我们需要一种类似std::shared_ptr，但又不参与这个共享对象的所有权的智能指针。这样它就需要能知道共享对象是否已经销毁了。这就是`std::weak_ptr`` ``std::weak_ptr不是单独存在的，它不能解引用，也不能检测是否为空，它就是配合std::shared_ptr`使用的 通常std::weak_ptr都是通过std::shared_ptr构造的，但它不会影响std::shared_ptr的引用计数 auto spw = std::make_shared\u003cWidget\u003e(); // ref count is 1 ... std::weap_ptr\u003cWidget\u003e wpw(spw); // ref count remains 1 ... spw = nullptr; 可以用expired()来检测std::weak_ptr指向的对象是否有效 if (wpw.expired()) ... 另一个常用的操作是lock()，它能原子地检测对象是否有效，以及返回这个对象的std::shared_ptr std::shared_ptr\u003cWidget\u003e spw = wpw.lock(); // if wpw's expired, spw is null 与之类似的操作是用std::weak_ptr构造一个std::shared_ptr std::shared_ptr\u003cWidget\u003e spw(wpw); 区别在于，如果wpw已经失效了，这次构造会抛std::bad_weak_ptr的异常 下面我们用几个例子来说明std::weak_ptr的必要性 想象我们要实现一个cache，希望其中的元素在无人使用后被销毁。这里我们用std::unique_ptr并不合适，因为cache天然需要共享的语义。这样每个调用者都可以获得一个cache中元素的std::shared_ptr，它的生命期由调用者控制。cache内还需要保存一份元素的指针，且有能力检测它是不是失效了。这里我们需要的就是std::weak_ptr std::shared_ptr\u003cconst Widget\u003e fastLoadWidget(WidgetID id) { static std::unordered_map\u003cWidgetID, std::weak_ptr\u003cconst Widget\u003e\u003e cache; auto objPtr = cache[id].lock(); if (!objPtr) { objPtr = loadWidget(id); cache[id] = objPtr; } return objPtr; } // 请不用在意上面的static，这只是个示意 第二个例子是设计模式中的“观察者模式”。它的一种典型实现是每个主题对象持有一组观察者的指针，每当主题对象有状态变化时依次通知每个观察者。这里主题对象不需要控制观察者的生命期，但需要知道观察者的指针是否还有效。用std::weak_ptr就可以非常自然的实现出这样的特性 第三个例子是，当A和C都持有B的std::shared_ptr时，如果B也需要持有A的某种指针，该持有什么？ 裸指针：如果A析构了，但C还在，B也就还在，此时B持有的A的裸指针就成了空悬指针，不好 std::shared_ptr：这样A与B就形成了循环依赖，永远不可能析构了 std::weak_ptr：唯一的好选择 但要注意的是，用std::weak_ptr来解std::shared_ptr可能造成的循环依赖，这种特性本身并没有价值。设计良好的数据结构，比如树，父节点控制子节点的生命期，但子节点也需要持有父节点的指针，这里最好的方案是父节点用std::unique_ptr来持有子节点，而子节点直接持有父节点的裸指针。即，严格层次结构，明确生命期的场景，不需要使用std::weak_ptr。std::weak_ptr的价值在于：在生命期不明确的场景，可以知道对象是否还有效 在效率方面，std::weak_ptr的大小与std::shared_ptr是相同的，它们使用相同的控制块，区别在于std::weak_ptr不会影响控制块中的引用计数，只会影响其中的弱引用计数 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:4:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"Summary std::weak_ptr 用来模仿类似std::shared_ptr的可悬挂指针 潜在的使用 std::weak_ptr的场景包括缓存，观察者列表，以及阻止 std::shared_ptr 形成的环 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:4:1","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款21 优先用make_unique和make_shared而不是直接new 前言 先做一下介绍，std::make_shared是在C++11中增加的，但std::make_unique却是在C++14中增加的。如果你想在C++11中就用上std::make_unique，自己写一个简单版的也不难 template \u003ctypename T, typename... Ts\u003e std::unique_ptr\u003cT\u003e make_unique(Ts\u0026\u0026... params) { return std::unique_ptr\u003cT\u003e(new T(std::forward\u003cTs\u003e(params)...)); } 这个版本不支持数组，不支持自定义的销毁器，但这些都不重要，它足够用了。但要记住的是，不要把它放到namespace std下面 优先用这两个make的好处 这两个make函数的功能就不解释了，和它们类似的还有一个std::allocate_shared auto upw1(std::make_unique\u003cWidget\u003e()); std::unique_ptr\u003cWidget\u003e upw2(new Widget); auto spw1(std::make_shared\u003cWidget\u003e()); std::shared_ptr\u003cWidget\u003e spw2(new Widget); 上面这个例子说明了用make函数的第一个好处：不需要重复写一遍类型。所有程序员都知道：不要重复代码。代码越少，bug越少 异常安全性。想象我们有两个函数 void processWidget(std::shared_ptr\u003cWidget\u003e spw, int priority); int computePriority(); 调用代码很可能长成这个样子 processWidget(std::shared_ptr\u003cWidget\u003e(new Widget), computePriority()); // potential resource leak! 上面这行代码有内存泄漏的风险，为什么？根据C++标准，在processWidget的参数求值过程中，我们只能确定下面几点： new Widget一定会执行，即一定会有一个Widget对象在堆上被创建。 std::shared_ptr\u003cWidget\u003e的构造函数一定会执行。 computePriority一定会执行。 new Widget的结果是std::shared_ptr\u003cWidget\u003e构造函数的参数，因此前者一定早于后者执行。除此之外，编译器不保证其它操作的顺序，即有可能执行顺序为： new Widget 执行computePriority 构造std::shared_ptr\u003cWidget\u003e 如果第2步抛异常，第1步创建的对象还没有被std::shared_ptr\u003cWidget\u003e管理，就会发生内存泄漏。 如果这里我们用std::make_shared，就能保证new Widget和std::shared_ptr\u003cWidget\u003e是一起完成的，中间不会有其它操作插进来，即不会有不受智能指针保护的裸指针出现： processWidget(std::make_shared\u003cWidget\u003e(), computePriority()); // no potential resource leak 更高效 std:shared_ptr\u003cWidget\u003e spw(new Widget); 这行代码中，我们以为只有一次内存分配，实际发生了两次，第二次是在分配std::shared_ptr控制块。如果用std::make_shared，它会把Widget对象和控制块合并为一次内存分配 但是make函数也有一些缺点。 第一个缺点：无法传入自定义的销毁器。 第二个缺点：make函数初始化时使用了括号初始化，而不是花括号初始化，比如std::make_unique\u003cstd::vector\u003cint\u003e\u003e(10, 20)创建了一个有着20个值为10的元素的vector，而不是创建了{10, 20}这么两个元素的vector(参见Item7)。 第三个缺点：对象和控制块分配在一块内存上，减少了内存分配的次数，但也导致对象和控制块占用的内存也要一次回收掉。即，如果还有std::weak_ptr存在，控制块就要在，对象占用的内存也没办法回收。如果对象比较大，且std::weak_ptr在对象析构后还可能长期存在，那么这种开销是不可忽视的。 如果我们因为前面这三个缺点而不能使用std::make_shared，那么我们要保证，智能指针的构造一定要单独一个语句。回到之前processWidget的例子中，假设我们有个自定义的销毁器void cusDel(Widget* ptr);，因此不能使用std::make_shared，那么我们要这么写来保证异常安全性： std::shared_ptr\u003cWidget\u003e spw(new Widget, cusDel); processWidget(spw, computePriority()); 但这么写还不够高效，这里我们明确知道spw就是给processWidget用的，那么可以使用std::move，将其转为右值，来避免对引用计数的修改： std::shared_ptr\u003cWidget\u003e spw(new Widget, cusDel); processWidget(std::move(spw), computePriority()); ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:5:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"Summary 和直接使用new相比，使用make函数减少了代码的重复量，提升了异常安全度，并且，对于std::make_shared以及std::allocate_shared来说，产生的代码更加简洁快速 也会存在使用make函数不合适的场景：包含指定自定义的deleter,以及传递大括号initializer的需要 对于std::shared_ptr来说，使用make函数的额外的不使用场景还包含 带有自定义内存管理的class 内存非常紧俏的系统，非常大的对象以及比对应的std::shared_ptr活的还要长的std::weak_ptr ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:5:1","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款22 在用到PImpl惯用法时，在实现文件中定义特殊成员函数 我们经常用名为PImpl的方法来实现接口与实现分离，进而大大降低程序构建的时间 PImpl是指把类A中的所有数据成员都移到一个impl类中，A中只留下一个impl类型的指针 举一个例子 class Widget { public: Widget(); ... private: std::string name; std::vector\u003cdouble\u003e data; Gadget g1, g2, g3; // Gadget is some user-defined type }; Widget的数据成员的类型为std::string、std::vector\u003cdouble\u003e、Gadget，这样就至少要include三个头文件，这也意味着每个需要include了这个包含Widget定义的头文件的地方，都被动引入了三个头文件。如果有一天我们修改了Widget的实现，比如增加或删除了一个成员，即使它们都是private的，即使接口完全没有变化，所有include它的用户文件都要重新编译。我们不想污染用户文件，也不想用户文件因为我们的实现修改而重新编译，我们就可以用PImpl class Widget { public: Widget(); ~Widget(); ... private: struct Impl; Impl* pImpl; }; 注意这里出现的Impl类型只是声明，没有定义，称为“不完整类型”，这样的类型只支持很少的操作，其中包括了我们需要的：声明一个不完整类型的指针 对应的实现文件内容为 struct Widget::Impl { std::string name; std::vector\u003cdouble\u003e data; Gadget g1, g2, g3; }; Widget::Widget() : pImpl(new Impl) {} Widget::~Widget() { delete pImpl; } 有了智能指针后，我们觉得直接new和delete不好，需要用std::unique_ptr class Widget { public: Widget(); ... private: struct Impl std::unique_ptr\u003cImpl\u003e pImpl; }; 因为不需要手动的delete，我们没有自己实现Widget的析构函数 看起来都很美好，编译也没问题，但在用户要用时，出事了 Widget w; // error!!! 究其原因，是因为我们没有给Widget实现自定义的析构函数，因此编译器为Widget准备了一个。这个析构函数会被放到Widget的定义体内，默认是内联的，因此会有一份实现在用户文件中。~Widget中只做一件事：析构pImpl，即析构一个std::unique_ptr\u003cImpl\u003e。注意，我们隐藏了Impl的实现，在析构std::unique_ptr\u003cImpl\u003e时编译器发现Impl还是个不完整类型，此时对它调用delete是危险的，因此编译器用static_cast禁止了这种行为 解决方案很简单：自己实现Widget的析构函数 // widget.h class Widget { public: Widget(); ~Widget(); ... private: struct Impl std::unique_ptr\u003cImpl\u003e pImpl; }; // widget.cpp ... Widget::Widget() : pImpl(std::make_unique\u003cImpl\u003e()) {} Widget::~Widget() {} 参考条款17，更好的方法是将析构函数定义为= default Widget::~Widget() = default; 根据条款17，自定义的析构函数会阻止编译器生成移动构造函数和移动赋值函数，因此如果你想要Widget有移动的能力，就要自己实现 class Widget { public: Widget(); ~Widget(); Widget(Widget\u0026\u0026 rhs) = default; // right idea, wrong code! Widget\u0026 operator=(Widget\u0026\u0026 rhs) = default; ... }; 注意不要在这些特殊成员函数的声明后面加= default，这样会重复上面析构函数的问题：会被内联，因此在用户代码中有一份实现，遇到不完整类型，game over。我们要做的就是在.cpp中将它们的实现定义为= default 接下来就是复制构造函数和复制赋值函数了。我们用std::unique_ptr是为了更好的实现PImpl方法，这也导致了Widget无法自动生成复制函数（std::unique_ptr不支持），但这并不意味着Widget就不能支持复制了，我们还可以自己定义两个复制函数 // widget.h class Widget { public: ... Widget(const Widget\u0026 rhs); Widget\u0026 operator=(const Widget\u0026 rhs); ... }; // widget.cpp Widget::Widget(const Widget\u0026 rhs) : pImpl(nullptr) { if (rhs.pImpl) { pImpl = std::make_unique\u003cImpl\u003e(*rhs.pImpl); } } Widget\u0026 Widget::operator=(const Widget\u0026 rhs) { if (!rhs.pImpl) { pImpl.reset(); } else if (!pImpl) { pImpl = std::make_unique\u003cImpl\u003e(*rhs.pImpl); } else { *pImpl = *rhs.pImpl; } } 有意思的是，如果你把pImpl的类型改为std::shared_ptr\u003cImpl\u003e，你会发现上面所有这些注意事项，都不见了。你不需要手动实现析构函数、移动函数、构造函数，程序编译仍然是好的。 这种差异来自于std::unique_ptr和std::shared_ptr对自定义销毁器的支持方式不同。std::unique_ptr的目标是从体积到性能上尽可能与裸指针相同，因此它将销毁器类型作为模板参数的一部分，这样实现起来更高效，代价是各种特殊函数在编译时就要知道元素的完整类型。而std::shared_ptr没有这种性能上的要求，因此它的销毁器不是模板参数的一部分，性能会有一点点影响，但好处是不需要在编译特殊函数时知道元素的完整类型 std::shared_ptr在构造时就把销毁器保存在了控制块中，之后即使传递到了不知道元素完整类型的地方，它仍然能调用正确的销毁器来销毁元素指针。而std::unique_ptr是依靠模板参数提供的类型信息来进行销毁，因此必须要知道元素的完整类型 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:6:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["缘起 在人群中 我看见你"],"content":"RTTI","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"c++ RTTI ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:0:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"什么是RTTI RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法 ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:1:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"typeid 对于c++的内置数据类型以及自己创建的类对象，typeid可以方便的输出他们的数据类型 使用这个运算符，会返回一个 type_info 对象的引用，这个对象的结构大致如下 class type_info { // data public: virtual ~type_info(); // is polymorphic bool operator==(const type_info\u0026) const noexcept; // can be compared bool operator!=(const type_info\u0026) const noexcept; bool before(const type_info\u0026) const noexcept; // ordering size_t hash_code() const noexcept; // for use by unordered_map and the like const char* name() const noexcept; // name of type type_info(const type_info\u0026) = delete; // prevent copying type_info\u0026 operator=(const type_info\u0026) = delete; // prevent copying }; 这个对象包含了一个对象的类型信息，也就是c++中的 RTTI 有趣的是，当typeid作用于指针时，会返回指针自身的类型，但当作用于派生类（有虚函数）的对象或引用时，则会返回这个对象实际的类型 下面是测试代码 现在有基类SceneEntry 和派生类SceneUser class SceneEntry { public: SceneEntry(unsigned long long id, const std::string\u0026 name); virtual ~SceneEntry() = default; }; class SceneUser : public SceneEntry { public: SceneUser(unsigned long long id, const std::string\u0026 name); virtual ~SceneUser() = default; }; ... int main() { SceneEntry* entry = new SceneUser(1, \"xiaoming\"); SceneUser user(1,\"\"); SceneEntry\u0026 entry2 = user; std::cout \u003c\u003c typeid(entry).name() \u003c\u003c std::endl; std::cout \u003c\u003c typeid(*entry).name() \u003c\u003c std::endl; std::cout \u003c\u003c typeid(entry2).name() \u003c\u003c std::endl; return 0; } 以上代码可以得到以下输出 \u003e ./test P10SceneEntry 9SceneUser 9SceneUser 可以看到对于指针类型，他返回的就是指针声明时的类型，上面的P就表示指针，而引用和类返回的则是他们实际对应的派生类。不过这种获取实际派生类时依赖的时虚函数表，因此没有虚函数的时候也就无从知晓了 当去掉虚函数以后，输出就变为了 P10SceneEntry 10SceneEntry 10SceneEntry 最终输出的都是基类 ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:2:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"dynamic_cast dynamic_cast原理 通过了解type_info，也就基本知道dynamic_cast的原理了，其实他就是利用RTTI去判断一个指针所指的类实际是什么的，不过这也依赖于虚函数表，所以当你dunamic_cast一个没有虚函数类的时候就会报错，但是static_cast并不会哦~ error: 'SceneEntry' is not polymorphic ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:3:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"RTTI原理 所以最终，要研究 typeid 和 dynamic_cast 这两个运算符的原理，本质其实是研究 RTTI 的原理 我们可以通过以下代码来进行试验 class X { public: X() { mX = 101; } virtual void vfunc() { cout \u003c\u003c \"X::vfunc()\" \u003c\u003c endl; } private: int mX; }; class XX : public X { public: XX(): X() { mXX = 1001; } virtual void vfunc() { cout \u003c\u003c \"XX::vfunc()\" \u003c\u003c endl; } private: int mXX; }; 首先定义两个有继承关系的类，并且定义一个虚函数，然后通过以下代码来验证一个对象的布局 typedef void (*FuncPtr)(); int main() { XX xx; FuncPtr func; char* p = (char*)\u0026xx;// 此处声明为 char * 的原因主要是为了 + sizeof (xx) 时加对应 n 个字节，从而方便获取 n 个字节后的地址 // 获得虚函数表的地址 void** vtbl = (void**)*(void**)p; // 此处声明成二级指针也是为了在下面 [] 运算时按指针的步长取 // 输出虚函数表的地址，即 vptr 的值 cout \u003c\u003c vtbl \u003c\u003c endl; // 获得 type_info 对象的指针，并调用其 name 成员函数 cout \u003c\u003c \"\\t[-1]: \" \u003c\u003c (vtbl[-1]) \u003c\u003c \" -\u003e \" \u003c\u003c ((type_info*)(vtbl[-1]))-\u003ename() \u003c\u003c endl; // 调用第一个 virtual 函数 cout \u003c\u003c \"\\t[0]: \" \u003c\u003c vtbl[0] \u003c\u003c \" -\u003e \"; func = (FuncPtr)vtbl[0]; func(); // 输出基类的成员变量的值 p += sizeof(int**); cout \u003c\u003c *(int*)p \u003c\u003c endl; // 输出派生类的成员变量的值 p += sizeof(int); cout \u003c\u003c *(int*)p \u003c\u003c endl; return 0; } 运行得到以下输出 \u003e ./classStructTest 0x105127110 [-1]: 0x105127130 -\u003e 2XX [0]: 0x1051261d0 -\u003e XX::vfunc() 101 1001 由此可以得到 c++ 中的一个包含虚函数的 XX 对象的大致布局： 一个对象的内存第一段会保存一个类的虚函数表的指针，指针指向了虚函数表，即一个函数指针数组，而在这个虚函数表指针指向的地址前一个位置保存了一个 type_info 的指针。而虚函数表指针后面跟着的分别是父类的成员变量和自身的成员变量。 但当我们把虚函数去掉以后，再运行代码就会报错： 因此这种没有多态性质的类内存结构是不同的。这种类的 RTTI 信息在编译后便可以确定，所以猜想可能编译时就带入地址了（不过没查到相关资料，待考证）。因此不需要动态的通过类的虚函数表中的 type_info 去确定 ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:4:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"Summary 通过 RTTI 可以让 c++ 在运行时去确定一个对象的实际类型，从而我们可以利用 dynamic_cast 去正确地转换。看到大佬代码用了这么多指针的转换，越来越觉得它是个很自由的语言，它应该是高级语言中最接近底层，最容易操作内存的语言了，不过这也对使用者有较高的要求，学习之路漫漫呀～ ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:5:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["Effective C++"],"content":"条款41~48 模板与泛型编程","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款41~48 模板与泛型编程 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:0:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款41 隐式接口和编译器多态 什么是显式接口和运行期多态 在面向对象编程世界里总是以显式接口和运行期多态解决问题，举个例子 // 无意义的类 class Widget{ public: Widget(); virtual Widget(); virtual std::size_t size() const; virtual void normalize(); void swap(Widget\u0026 other); } // 无意义的函数 void doProcessing(Widget\u0026 w){ if(w.size()\u003e10 \u0026\u0026 w!= somNastyWidget){ Widget temp(w); temp.normalize(); temp.swap(w); } } 在上述代码中，可知 由于w的类型被声明为Widget，所以w必须支持Widget接口。我们可以在源码中找出这个接口，看看它是什么样子，所以我们称此为一个显式接口，也就是他在源码中明确可见 由于Widget的某些成员是 virtual，w对那些函数的调用将表现出运行时多态，也就是说将于运行期根据w的动态类型（条款37）决定究竟调用哪一个函数 Template及泛型编程 Template及泛型编程与面向对象有根本不同。implicit interface 和 compile-time polymorphism移到前头。 还是用上一个例子，一探究竟，我们将doProcessing函数变成function template时看看发生咩事 template\u003ctypename T\u003e void doProcessing\u003cT\u0026 w\u003e { if (w.size() \u003e 10 \u0026\u0026 w != someNastyWidget) { T temp(w); temp.normalize(); temp.swap(w); } } 这里的doProcessing内的的w是如何操作的呢 w必须支持的哪一种接口，由template中执行于w身上的操作来决定 本例w的类型T必须支持size，normalize和swap成员函数，copy构造函数、不等比较!=，并非完全正确。这一组表达式便是T必须支持的一组隐式接口 凡设计w的任何函数调用，例如operator\u003e和operator!=，有可能造成template具现化，是这些调用得以成功。这样的具现行为发生在编译器。“以不同的template参数具现化会导致调用不同的函数，这便是所谓的编译器多态” 现在我们再来细看下述代码 template\u003ctypename T\u003e void doProcessing(T\u0026 w) { if (w.size() \u003e 10 \u0026\u0026 w != someNastyWidget) { ... } } T(w的type)的隐式接口看来好像有这些约束 必须提供一个名为size的成员函数，该函数返回一个整体值 必须支持一个operator!=函数，用来比较两个T对象 真要感谢操作符重载带来的可能性，这两个约束都不需要满足 是的，T必须支持size成员函数，然而这个函数也可能从base class继承而得。这个成员函数不需要返回一个整数值，甚至不需要返回一个数值类型。就此而言，他甚至不需要返回一个定义有operator\u003e的类型，他唯一需要做的就是返回一个类型为x的对象，而x对象加上一个int(10的类型)必须能够调用一个operator\u003e。这个operator\u003e不需要非得取得一个类型为x的参数不可，因为他可以取得类型Y的参数，只要存在一个隐式转换能够将类型x转换为类型y的对象 加诸于template参数身上的隐式接口，就像加诸于class对象身上的显式接口一样真实，而且两者都在编译期完成检查。就像你无法以一种\"与class提供之显式接口接口矛盾\"的方式来使用对象（代码无法通过编译），你也无法在template中使用\"不支持template所要求之隐式接口\"的对象（代码一样无法通过编译） ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:1:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary classes 和 template都支持接口和多态 对于classes而言接口是显式的，以函数签名为中心，多态则是通过virtual function发生于运行期 对template参数而言，接口是隐式的，基于有效表达式，多态则是通过template具现化和函数重载解析发生于编译期 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:1:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款42 了解typename 我们看以下代码 template\u003ctypename C\u003e void print2nd(const C\u0026 container) { if (container.size() \u003e= 2) { C::const_iterator iter(container.begin()); ... } } 现在应该很清楚为什么这不是有效的c++代码了吧。iter声明式只有在C::const_iterator是个类型时才合理，但我们并没有告诉c++说他是，于是c++假设他不是 若要矫正这个，我们必须告诉c++说C::const_iterator是个类型。只要紧临它之前放置关键字typename即可 template\u003ctypename C\u003e void print2nd(const C\u0026 container) { if (container.size() \u003e= 2) { typename C::const_iterator iter(container.begin()); ... } } 再次强调一下，任何时候当你想要在template中指一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename typename知识用来言明嵌套从属类型名称，其他名称不该有他的存在。例如下面这个function template，接收一个容器和一个指向该容器的迭代器 template\u003ctypename C\u003e // 允许使用 \"typename\" (或 class) void f(const C\u0026 container, // 不允许使用 \"typename\" typename C::iterator iter); // 一定要使用 typename 上述的c并不是嵌套从属类型名称（他并非嵌套于任何 取决于template参数 的东西内），所以声明container时并不需要以typename为前导，但C::iterator是个嵌套从属类型名称，所以必须以typename为辅导 typename必须作为嵌套从属类型名称的前缀词，这一规则的例外是，typename不可以出现在 base classed list内的嵌套从属类型名称之前，也不可在 member initialization list（成员初始列）中作为 base class 修饰符。例如 template\u003ctypename T\u003e class Derived : public Base\u003cT\u003e::Nested { // base class list中不允许 typename public: explicit Dervied(int x) : Base\u003cT\u003e::Nested(x) { // mem.init.list中 不允许 typename typename Base\u003cT\u003e::Nested temp; // 不再上述的两个特殊情况内，作为一个 base class 修饰符 需加上 typename } } ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:2:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 声明 template 参数时，前缀关键字 class 和 typename 可互换 请使用关键字 typename 标识嵌套从属类型名称，但不得在 基类列 或者 成员初始列 内以他作为 base class 修饰符 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:2:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款43 调用基类模板成员 模板中，派生类不可调用模板基类的成员函数 在模板类中，如果一个派生类在其方法中调用了基类的方法，那么这段代码可能无法编译通过 备注（重点）： ​ 这一现象是与编译器有关的，Effective C++的作者编译的时候出错，本人使用VS编译的时候没有出错，因此这个问题是与编译器有关 假设现在有这样一个类体系： 我们有若干公司类，其包含两个成员函数可以用来将信息发送到公司（一个为发送加密信息，一个为发送不加密信息） 有一个MsgSender类，其中有两个成员函数，函数中可以定义若干公司，然后调用公司的成员方法向公司发送信息 有一个MsgInfo类，用来封装消息（这个类不重要） //公司类 class CompanyA { public: void sendCleartext(const std::string\u0026 msg); //向公司发送未加密信息 void sendEncrypted(const std::string\u0026 msg); //向公司发送加密信息 }; class MsgInfo {}; //封装信息的类 //发送信息类 template\u003ctypename Company\u003e class MsgSender { public: //在其中定义公司A，并调用公司A的sendCleartext()函数向公司A发送信息 void sendClear(const MsgInfo\u0026 info) { std::string msg; CompanyA a; a.sendCleartext(msg); } //同上，只是发送加密信息 void sendSecret(const MsgInfo\u0026 info) { std::string msg; CompanyA a; a.sendEncrypted(msg); } }; 现在我们为MsgSender类添加了一个派生类，我们希望每次在发送信息的时候记录一下日志。因此定义如下： template\u003ctypename Company\u003e class LoggingMsgSender:public MsgSender\u003cCompany\u003e{ public: void sendClearMsg(const MsgInfo\u0026 info) { //记录一下日志 sendClear(info); //调用基类的方法发送消息，这段代码可能无法编译通过 //记录一下日志 } void sendSecretMsg(const MsgInfo\u0026 info) { //记录一下日志 sendSecret(msg); //调用基类的方法发送消息，这段代码可能无法编译通过 //记录一下日志 } }; 上面代码对于某些编译器会出错的原因在于： 编译期出错：当类遇到LoggingMsgSender类模板定义式时，其并不知道LoggingMsgSender继承的class属于什么类型，因为还没有具体被实例化 因此在编译到LoggingMsgSender的成员函数时，其并不知道其基类是否有一个sendClear()函数* 解决上面错误的3种方法 使用this指针：使用this指针调用这些函数，实现先告诉编译器这些函数是属于自身类的（在编译之后它们会从基类中继承而来） template\u003ctypename Company\u003e class LoggingMsgSender:public MsgSender\u003cCompany\u003e{ public: void sendClearMsg(const MsgInfo\u0026 info) { //记录一下日志 this-\u003esendClear(info); //记录一下日志 } void sendSecretMsg(const MsgInfo\u0026 info) { //记录一下日志 this-\u003esendSecret(info); //记录一下日志 } }; 使用using声明式 注意这种using声明式与非模板类的不同 在非模板类中，使用using是为了防止派生类隐藏继承的方法，而使基类中的方法在派生类中可见 在模板类中，使用using是为了让编译器去基类中查找这个函数 template\u003ctypename Company\u003e class LoggingMsgSender:public MsgSender\u003cCompany\u003e{ public: using MsgSender\u003cCompany\u003e::sendClearMsg; using MsgSender\u003cCompany\u003e::sendSecretMsg; void sendClearMsg(const MsgInfo\u0026 info) { //记录一下日志 sendClear(info); //记录一下日志 } void sendSecretMsg(const MsgInfo\u0026 info) { //记录一下日志 sendSecret(info); //记录一下日志 } }; 明确指出被调用的函数位于base class中 这种方法不太建议，因为：被调用的函数可能是virtual函数，这种修饰符会关闭“virtual绑定行为” template\u003ctypename Company\u003e class LoggingMsgSender:public MsgSender\u003cCompany\u003e{ public: void sendClearMsg(const MsgInfo\u0026 info) { //记录一下日志 sgSender\u003cCompany\u003e::sendClear(info); //记录一下日志 } void sendSecretMsg(const MsgInfo\u0026 info) { //记录一下日志 sgSender\u003cCompany\u003e::sendSecret(info); //记录一下日志 } }; ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:3:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 当一个类的基类包含模板参数时，需要通过this-\u003e的方式调用基类内的函数，例如 class F: public S\u003cC\u003e，在F中的成员函数中调用S中的成员函数this-\u003etest()，而直接写test()无法通过编译，原因是因为C是个模板没有办法确定类S的具体长相，或者说无法确定S中一定有test函数，即使你写的所有C都包含test函数，但是在编译器看来它是不确定这个问题的，因此无法通过编译 解决办法是： 使用this-\u003etest，这样做告诉编译器假设这个test已经被继承了 使用using声明式：using S\u003cC\u003e::test告诉编译期这个test位于S内。相当于必须手动通知编译器这个函数是存在的 直接指明 但是不推荐 因为丧失多态特性 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:3:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款44 将与参数无关的代码抽离template Templates能够节省时间和避免代码反复。对于相似的classes或functions。能够写一个class template或function template，让编译器来做剩余的事。这样做，有时候会导致代码膨胀（code bloat）：其二进制码带着反复（或差点儿反复）的代码、数据。或者两者。 但这时候源代码看起来可能非常整齐。 先来学习一个名词：共性与变性分析（commonality and variability analysis）。 还是比较容易理解的。比如，你在编写几个函数，会用到同样作用的代码。这时候你往往将同样代码搬到一个新函数中。给其它几个函数调用。同理，假设编写某个class。当中某些部分和另外几个class同样，这时候你不会反复编写这些同样部分，仅仅需把共同部分搬到新class中去就可以，去使用继承或复合（Item32 Item38 Item39），让原先的classes取用这些共同特性，原classes的互异部分（变异部分）仍然留在原位置不动。 编写templates时，也要做同样分析，避免反复。non-template代码中反复十分明白：你能够看到两个函数或classes之间有所反复。可是在template代码中，反复是隐晦的。由于仅仅有一份template源代码。 比如。你打算在为尺寸固定的正方矩阵编写一个template，该矩阵有个支持逆矩阵运算的函数 template\u003ctypename T, std::size_t n\u003e // T为数据类型。n为矩阵大小 class SquareMatrix{ public: …… void invert();// 求逆运算 }; SquareMatrix\u003cdouble,5\u003e sm1; sm1.invert(); // 调用SquareMatrix\u003cdouble,5\u003e::invert SquareMatrix\u003cdouble,10\u003e sm2; sm2.invert(); // 调用SquareMatrix\u003cdouble,10\u003e::invert 上面会详细化两份invert。 这两份函数差点儿全然同样（除了一个操作55矩阵。一个操作1010）。这就是代码膨胀的一个典型样例。 上面两个函数除了操作矩阵大小不同外。其它同样。这时能够为其建立一个带数值的函数，而不是反复代码。于是有了对SquareMatrix的第一份改动 template\u003ctypename T\u003e class SquareMatrixBase{ protected: void invert(std::size_t matrixSize); …… }; template\u003ctypename T, std::size_t n\u003e class SquareMatrix : private SquareMatrixBase\u003cT\u003e{ private: using SquareMatrixBase\u003cT\u003e::invert(); // 编码遮掩base中的invert，条款33有说到 public: …… void invert() { // 求逆运算 this-\u003einvsert(n); // 稍后解释为什么用this } }; SquareMatrixBase::invert仅仅是企图避免derived classes代码反复，所以它以protected替换public。这个函数使用this-\u003e，由于模板化基类内的函数名称会被derived classes掩盖（条款43） 注意，SquareMatrixBase和SquareMatrix之间继承关系是private。这说明base class是为了帮助derived classes实现，两者不是is-a关系 如今另一个问题，SquareMatrixBase::invert操作的数据在哪？它在參数中直到矩阵大小，可是矩阵数据derived class才知道。derived class和base class怎样联络？一个做法是能够为SquareMatrixBase::invert加入一个參数（比如一个指针）。 这个行得通，可是考虑到其它因素（比如，SquareMatrixBase内还有其它函数。也要操作这些数据），能够把这个指针加入到SquareMatrixBase类中 template\u003ctypename T\u003e class SquareMatrixBase{ protected: SquareMatirxBase(std::size_t n, T* pMem) : size(n), pData(pMem) { } void setDataPtr(T* ptr) { pData=ptr; } …… private: std::size_t size; T* pData; }; template\u003ctypename T, std::size_t n\u003e class SquareMatrix : private SquareMatrixBase\u003cT\u003e{ public: SquareMatrix() : SquareMatrixBase\u003cT\u003e(n, data) { } …… private: T data[n*n]; }; 这样的类型的对象不须要动态分配内存。可是对象自身可能非常大。另一个做法是把矩阵数据放到heap template\u003ctypename T, std::size_t n\u003e class SquareMatrix : private SquareMatrixBase\u003cT\u003e{ public: SquareMatrix() : SquareMatrixBase\u003cT\u003e (n, 0), pData(new T[n*n]) { this-\u003esetDataPtr(pData.get()); } …… private: boost::scoped_array\u003cT\u003e pData; }; 这样以来。类型同样的derived classes会共享base class。比如。SquareMatrix ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:4:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 原因是模板会根据具体类型具象化不同的代码，如果将与模板无关的代码也放入模板函数或者类中，那么就会生成重复的代码，就会导致代码膨胀的问题，函数模板中与参数无关的代码可以包装成单独的函数。类模板中与参数无关的模板可以放到父类中 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:4:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款45 运用成员函数模板接受全部兼容类型 隐式转化（前言） 该条款作者阐述自己的观点是通过智能指针的样例 所以我们复习一下隐式转化的问题，例如以下代码 #include\u003ciostream\u003e using namespace std; class A { public: explicit A(int i) : a(i) {}; A(const A\u0026 obj) : a(obj.a) {} private: int a; }; int main() { int value =0; A a = value; // 编译不通过。由于构造函数中有explicit限定符 return 0; } *我们知道由于explicit限定符的存在编译不通过* 2. *问题抛出* *既然复习完了，我们来看看书上另一段代码* ```cpp template\u003ctypename T\u003e class SmartPtr { public: explicit SmartPtr(T* realPtr); ... }; SmartPtr\u003cTop\u003e pt1 = SmartPtr\u003cMiddle\u003e(new Middle); SmartPrt\u003cTop\u003e pt2 = SmartPrt\u003cBottom\u003e(new Bottom); SmartPrt\u003cconst Top\u003e pt2=pt1; 我们能够知道，由于SmartPtr\u003cTop\u003e类型和SmartPtr\u003cMiddle\u003e类型不同，再加上explicit SmartPtr\u003cMiddle\u003e中的explicit限定符，SmartPtr\u003cTop\u003e pt1=SmartPtr\u003cMiddle\u003e(new Middle);这句代码编译不通过。 并且编译器并不觉得SmartPtr\u003cTop\u003e类型和SmartPtr\u003cMiddle\u003e类型存在继承关系 为了能够实现相互转化。能够加入本节的主旨技术去解决上面出现的问题 解决方法 template\u003ctypaname T\u003e class SmartPtr{ public: template\u003ctypename U\u003e SmartPrt(const SmartPrt\u003cU\u003e\u0026 other) : heldPrt(other.get()) { }; T* get() const{ return heldPrt; } …… private: T* heldPrt; }; SmartPtr\u003cTop\u003e pt1 = SmartPtr\u003cMiddle\u003e(new Middle); SmartPrt\u003cTop\u003e pt2 = SmartPrt\u003cBottom\u003e(new Bottom); SmartPrt\u003cconst Top\u003e pct2 = pt1; 我们加入了一个member function template函数。由于typename T和typename U 是两种类型，并且构造函数中没有explicit关键字，不会阻止heldPrt(other.get())的隐式转换 所以，以上代码能够通过编译 TR1规范中关于tr1::shared_ptr的一份摘录 template\u003cclass T\u003e class shared_ptr{ public: template\u003cclass Y\u003e explicit shared_ptr(Y* p); template\u003cclass Y\u003e shared_ptr(shared_ptr\u003cY\u003e const\u0026 r); template\u003cclass Y\u003e explicit shared_ptr(weak_ptr\u003cY\u003e const\u0026 r); template\u003cclass Y\u003e explicit shared_ptr(auto_ptr\u003cY\u003e const\u0026 r); template\u003cclass Y\u003e shared_ptr\u0026 operator=(shared_ptr\u003cY\u003e const\u0026 r); template\u003cclass Y\u003e shared_ptr\u0026 operator=(auto_ptr\u003cY\u003e const\u0026 r); …… }; 我们能够发现上面仅仅有泛化copy构造函数不是explicit，表示shared_ptr 的隐式转化被同意，而其它的智能指针转化不被同意 这里另一个须要注意的地方，在class类声明泛化copy构造函数（member template）。并不会阻止编译器生成它们自己的copy构造函数（non-template），换言之。假设程序中仅仅写了泛化的copy构造函数，那么编译器还是会自己主动生成一个非泛化的版本号出来，假设不想要这个缺省版本号，那一定不能偷懒。要两个版本号的copy构造函数都要写 template\u003ctypaname T\u003e class SmartPtr{ public: template\u003ctypename U\u003e SmartPrt(const SmartPrt\u003cU\u003e\u0026 other) : heldPrt(other.get()) {}; SmartPtr() {} // 假设不写自己的非泛化构造函数，编译器会自己主动生成自己的默认非泛化构造函数。 T* get() const{ return heldPrt; } …… private: T* heldPrt; }; ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:5:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 请使用member function templates（成员函数模板）生成“可接受全部兼容类型”的函数 假设你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是须要声明正常的copy构造函数和copy assignment操作符 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:5:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款46 需要类型转换时请为模板定义非成员函数 这个条款是在《Item24》的基础上，讲述有关非成员函数在模板类中的作用，所以忘了的要去复习下 想要在template实现Item24的功能，还得考虑其他问题 template\u003ctypename T\u003e class Rational{ public: Rational(const T\u0026 numerator=0,const T\u0026 denominator=1); const T numerator() const; const T denominator() const; …… }; template\u003ctypename T\u003e const Rational\u003cT\u003e operator*(const Rational\u003cT\u003e\u0026 lhs,const Rational\u003cT\u003e\u0026 rhs) { …… }; Rational\u003cint\u003e oneHalf(1,2); Rational\u003cint\u003e result = oneHalf*2; // 错误 无法通过编译 大家思考一下为什么oneHalf*2这句话不能通过编译 事实上，operator模板函数中參数有两个，所以它会分别对这两个参数进行匹配来确定函数模板类型，试想一下，函数模板在没有实例化之前是不存在的，不存在的函数怎么会实现參数的隐式转换？我们来判断一般模板函数的运行过程。首先，模板函数通过自身參数实例化，实例化之后才会被调用运行。然而。对于本例来说，两个參数的类型一个是Rational\u003cint\u003e，还有一个是2，在编译期间前者能够被判断出来类型是int的rational，后者却判断不出来。由于在template实參推导过程中从不将隐式类型转换考虑在内 为了能让编译通过，我们能够进行例如以下改变 template\u003ctypename T\u003e class Rational { public: …… friend const Rational operator*(const Rational\u0026 lhs,const Rational\u0026 rhs); { return Rational（lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } }; 将operator变成Rational类的友元函数。这样在定义一个Rational\u003cint\u003e对象的时候，operator模板函数事实上已经被实例化了，这时候再调用oneHalf*2这句话的时候，就是直接调用已经实例化的operator函数了，所以，此时，它支持隐式转换。将2转换为Rational\u003cint\u003e对象* 值得一提的是以上代码也可写成例如以下形式 template\u003ctypename T\u003e class Rational { public: …… friend const Rational\u003cT\u003e operator*(const Rational\u003cT\u003e\u0026 lhs,const Rational\u003cT\u003e\u0026 rhs); { return Rational\u003cT\u003e（lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } }; 也就是说Rational\u003cT\u003e和Rational的形式是一个意思，为了简化，我们能够用Rational的形式 由于这样将友元函数定义在Rational类中，也就默认是内联函数inline了，为了避免复杂的friend函数影响代码体积，我们利用另外的一种形式实现* *例如以下代码 template\u003ctypename T\u003e class Rational;//forward decelarion template\u003ctypename T\u003e const Rational\u003cT\u003e doMultiply(const Rational\u003cT\u003e\u0026 lhs,const Rational\u003cT\u003e\u0026 rhs); template\u003ctypename T\u003e class Rational{ public: …… friend const Rational operator*(const Rational\u0026 lhs,const Rational\u0026 rhs);//声明+定义 { return doMultiply(lhs,rhs); } }; template\u003ctypename T\u003e const Rational\u003cT\u003e doMultiply(const Rational\u003cT\u003e\u0026 lhs,const Rational\u003cT\u003e\u0026 rhs) { return Rational\u003cT\u003e（lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } 我们又又一次定义了一个非类成员函数non-member，将此函数的声明和定义都放在类的外部，这样就能避免代码膨胀问题 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:6:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 当编写一个class template时，它所提供之“与此template相关的”函数支持“全部參数之隐式类型转换”时，请将那些函数定义为class template内部的friend函数 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:6:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款47 请使用traits classes表现类型信息 STL迭代器分类 input迭代器 只能一次一步向前移动,客户只可读取(不能涂写)且只能读取一次它们所指的东西,模仿指向输入文件的阅读指针.例如istream_iterators output迭代器 与input迭代器类似,但\"一切只为输出\",只能一次一步向前移动,客户只可涂写(不能读取)且只能涂写一次它们所指向的东西,模仿指向输出文件的涂写指针.例如ostream_iterators forward迭代器 具有input迭代器和output迭代器的所有功能:只能一次一步向前移动,可以读或写其所指物一次以上.STL并未提供单向linked list,但某些程序库有(通常名为slist),这种容器的迭代器就是forward迭代器 bidirectional迭代器 它除了可以向前移动,还可以向后移动,一步只能一次,并可以读或写所指物一次以上.STL的list,set,multiset,map和multimap的迭代器就属于这一类 random迭代器 除了bidirectional迭代器的所有功能以外,还可以执行\"迭代器算数\",即在常量时间内向前或向后移动任意距离.例如vector,deque和string的迭代器 针对这五种分类,C++标准库分别提供专属的 struct 加以区分 struct input_iterator_tag {}; struct output_iterator_tag {}; struct forward_iterator_tag : public input_iterator_tag {}; struct bidirectional_iterator_tag : public forward_iterator_tag {}; struct random_access_iterator_tag : public bidirectional_iterator_tag {}; traits STL主要由\"用以表现容器,迭代器和算法\"的templates组成,单也覆盖若干工具性templates,例如用于将迭代器移动到某个给定距离的advance函数模板.正如1所言,不同迭代器具有不同接口,因而advance需要根据不同迭代器所能进行的操作确定不同实现,例如对于random迭代器,advance可以直接进行+=操作,而对于其他迭代器,则可能反复使用++或–,因此advance的实现可能像这样 template\u003ctypename IterT,typename DisT\u003e void advance(Iter\u0026 iter,Dist d){ if(iter is a random access iterator) //伪代码 iter+=d; else if(d\u003e=0) while(d--) ++iter; else while(d++) --iter; } 这种做法必须首先判断iter是否为random迭代器,因此需要取得类型的有关信息,traits技术就是用来使STL的某些泛型算法能够在编译期取得某些类型信息. “Traits并不是C++关键字或一个预先定义好的构件;它们是一种技术,也是一个C++程序员共同遵守的协议.““这个技术的要求之一是,它对内置类型和用户自定义类型的表现必须一样好” “Traits能够施行于内置类型\"意味着通过在类型内嵌套信息实现类型判断不可行,因此类型的traits信息必须位于类型自身之外.标准技术是把它置入一个template及一个或多个特化版本中.“这样的templates在标准程序库中有若干个,其中针对迭代器的被被命名为iterator_traits” template\u003ctypename IterT\u003e struct iterator_traits; iterator_traits的运作方式是:针对每一个类型IterT,在struct iterator_traits内一定声明某个typedef名为iterator_catagory,这个typedef用于确定Iter的迭代器分类: 对于自定义类型,它要求每一个用户\"自定义的iterator类型\"必须嵌套一个typedef,名为iterator_catagory(实际上,要使自定义的iterator支持更多的STL泛型算法,还需要其他typedef,见第3条),这个typedef用来确认Iter的分类 ,因此针对一个的确迭代器设计的class可能回想这样 template\u003c...\u003e class deque{ public: class iterator{ public: typedef random_access_iterator_tag iterator_category; ... }; ... } list的迭代器可能像这样: template\u003c...\u003e class list{ public: class Iterator{ public: typedef bidirectional_iterator_tag iterator_category; ... }; ... }; 至于iterator_traits,只是用来表现iterator class的嵌套式typedef template\u003ctypename IterT\u003e struct iterator_traits{ typedef typename IterT::iterator_category iterator_category; ... }; 对于指针迭代器,由于指针不可能嵌套typedef,iterator_traits特别针对指针类型提供一个偏特化版本: template\u003ctypename Iter\u003e struct iterator_traits\u003cIterT*\u003e{ typedef random_access_iterator_tag iterator_category; ... }; 由以上实例,trait classes的设计与实现过程大体如下: ​ 1). 确认若干想取得的类型相关信息.(对于迭代器,包括其category) ​ 2). 为该信息选择一个名称(对于迭代器的category,名称为iterator_category) ​ 3). 提供一个template和一组特化版本(例如iterator_traits),内含希望支持的类型信息. 因此,最开始的伪代码可以实行 template\u003ctypename IterT,typename DisT\u003e void advance(Iter\u0026 iter,Dist d){ if(typeid(typename::std::iterator_traits\u003cIterT\u003e::iterator_category ==typeid(typename::std::random_access_iterator_tag)) ... } 此时还未结束,因为以上代码会存在编译问题:假设对advance作以下调用 std::list\u003cint\u003e::iterator iter; advance(iter,10); 那么advance将被特化为以下形式: void advance(std::list\u003cint\u003e::iterator iter,int d){ if(typeid(typename::std::iterator_traits\u003cstd::list\u003cint\u003e::iterator\u003e:iterator_category==typeid(typename::std::random_access_iterator_tag)) iter+=d; //错误,编译时不通过! else if(d\u003e=0) while(d--) ++iter; else while(d++) --iter; } 尽管测试typeid的那一行总会因为list::iterator而失败,因而iter+=d永远不会执行,但在此之前编译器必须确保所有的源码有效,纵使是不会执行的代码! 此外,由于iterator_traits::category在编译期即可确定,但if语句的判断却要在运行期核定,这不仅浪费时间,也会造成可执行文件膨胀. 实际上,C++提供了完成在编译期进行核定的方法:函数重载.合成两种重载函数,但接受不同的iterator_category对象,由它们完成advance的实际功能,因此advance的最终实现版本如下: template\u003ctypename IterT,typename DistT\u003e void doAdvance(IterT\u0026 iter,Dist d,std::random_access_iterator_tag){ iter+=d; } template\u003ctypename IterT,typename DistT\u003e void doAdvance(IterT\u0026 iter,Dist d,std::bidirectional_iterator_tag){ if(d\u003e=0) while(d--) ++iter; else while(d++) --iter; } template\u003ctypename IterT,typename DistT\u003e void doAdvance(IterT\u0026 iter,Dist d,std::input_iterator_tag){ if(d\u003c0) throw out_of_range(\"Negative distance\"); while(d--) ++iter; } template\u003ctypename ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:7:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款48 模板元编程 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:8:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 什么是模板元编程 模板元编程(template mataprogramming,TMP)是编写C++程序并执行于编译期的过程,“所谓template mataprogram(模板元程序),是以C++写成,执行于C++编译器内的程序.一旦TMP程序结束执行,其输出,也就是从templates具现出来的若干C++源码,便会一如往常地被编译 模板元编程的优点 它让某些事情变得更容易 template program执行于C++编译期的特性使得工作可以从编译期转移至执行期,这使得错误可以被提前检测,并产出具有较小可执行文件,较短运行期,较少内存需求的文件,代价就是编译时间变长了. Item47中的traits解法就是TMP，因为traits引发编译期发生于类型身上的if…else运算：用编译期的重载模板函数参数匹配行为代替执行期发生的if…else运算功能 TMP已经被证明是\"图灵完全\"的,使用TMP可以声明变量,执行循环,编写及调用函数……针对TMP设计的程序库(例如Boost’s MPL)提供更高层次的语法.“但这般构件相对于正常的C++对应物看起来很是不同,例如Item47展示的TMP if-else条件句是藉由templates及其特化体表现出来”,另外一个例子是循环,TMP是的循环是藉由递归完成 用TMP实现一个计算阶乘的函如下 template\u003cunsigned n\u003e struct Factorial{ enum{value=n*Factiroal\u003cn-1\u003e::value;}; } template\u003c\u003e struct Factorial\u003c0\u003e{ enum{ value=1}; } TMP的重要应用 确保量度单位正确 优化矩阵运算 生成客户定制之设计模式实现品(如Strategy，Observer，Visitor等) TMP的缺点 语法不直观 编译时间长 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:8:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款32~40 继承与面向对象设计","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款32~40 继承与面向对象设计 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:0:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"前言 这一大章条款 主要是说的继承与面向对象设计，说实话我觉得没有看这一大章的必要，去看本博客的《设计模式》章节 设计模式这个名字太高大上，其实他就是可复用的面向对象设计，没错，你在学设计模式其实就是相当于学面向对象 设计模式也是基于面向对象设计原则的，所以你不懂设计模式，不懂面向对象设计原则，我觉得你看完这一章作用也不大 懂设计模式的希望你看本章节会有一些新的体会，其实每个条款都是对应着面向对象设计原则，同时也有很多设计模式可以解决这些条款的问题 没有错，在本大章节，我就是设计模式吹!!! ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:1:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款32 确保public继承是is-a关系 “is-a\"的概念 以 C++进行面向对象编程，最重要的一个规则是：public inheritance（公开继承）意味 “is-a”（是一种）的关系 如果你令 class D以 public 形式继承 class B，你便是告诉编译器： 每一个类型为D的对象同时也是一个类型为B的对象，反之不是 B对象可使用的地方，D对象一样可以使用，反之不是 下面的Student类 public 继承 Person类 class Person {}; class Student :public Person {}; 任何获得类型为Person（pointer-to-Person或reference-to-Person）的实参，都可以接受一个Student（pointer-to-Student或reference-to-Student）对象 void eat(const Person\u0026 p); void study(const Student\u0026 s); int main() { Person p; Student s; eat(p); //正确 eat(s); //正确 study(s); //正确 study(p); //错误 return 0; } 上面的规则只对\"public\"继承才成立哦～，“private\"“protected\"不成立 设计正确的继承模型 鸟可以飞，企鹅也是一种鸟。于是我们可能设计下面错误的继承模型 企鹅虽然属于鸟类，但是企鹅不会飞 设计中，我们错误的将鸟类中的fly()虚函数派生给了Penguin类 //鸟类 class Bird { public: virtual void fly(); }; //企鹅，也继承了fly()虚函数 class Penguin : public Bird {}; 我们应该修改上面的代码，下面才是合适的模型，学过设计模式知道抽象思想的，其实就是基于抽象类再抽象了一层 //鸟类 class Bird { //无fly()函数 }; //会飞的鸟类 class FlyingBird :public Bird { public: virtual void fly(); }; //企鹅不会飞 class Penguin :public Bird { }; 以“编译期”确认关系代替“运行期”确认关系 还是基于上述 鸟和企鹅的例子 企鹅不会飞，但是我们仍然让Bird定义fly()函数，然后让Penguin继承于Bird，与上面不同的是，我们让Penguin在执行fly()函数的时候报出一个错误（运行期执行） class Bird { public: virtual void fly(); }; void error(const std::string\u0026 msg); class Penguin :public Bird { public: virtual void fly() { error(\"Attempt to make a penguin fly!\"); } }; 上面的代码是在运行期检查这种错误的，下面我们设计让编译器在编译的时候检查出企鹅不会飞这种错误 class Bird { //无fly()函数 }; class Penguin :public Bird { //… }; Penguin p; p.fly(); *这个问题的关键是：并不是所有的鸟都会飞，因此Bird不应该暴露Fly接口* *所以还是再抽象一个会飞的鸟类接口，我觉得是可以的，但是也随之暴露一个问题了，面向对象设计原则有一个**类应该是单一职责**，如果不是单一职责，那么子类的数目就会急剧膨胀了* *其实知道装饰模式和桥模式，这里就可以利用 **组合**去优化，但是那是设计模式的知识点了，大家可以看《[装饰模式](https://vlicecream.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/)》《[桥模式](https://vlicecream.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/)》* 再考虑矩形和正方形，从几何角度讲，正方形是一种矩形。从软件设计角度讲，正方形是矩形吗？应该使用public继承吗？ 思考：对矩形可以单独设置宽度，而不影响高度。但是对于正方形，设置宽度，要求高度随之变化，否者就不是正方形了。因此不能使用public继承 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:2:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"Summary public继承意味is-a 适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个bass class 对象 在类的设计上 其实要蛮下一番心思的（这其实就是题外话了，推荐本博客《设计模式》专题） ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:2:1","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款33 避免遮掩继承而来的名称 C++基类和派生类的作用域为嵌套关系,同时存在作用域屏蔽规则,例如: class Base{ public: void fun(); ... private: int a; ... } class Derived:public Base{ ... } 那么Derived和Base之间的作用域关系就像这样 如果Derived中没有定义a和fun,那么对在Derived作用域内对a的fun的使用将会由内而外直至全局作用域逐层查找; 如果Derived中定义了a和fun,那么会使用Derived中的a和fun,但是如果Derived中a和fun的定义如果像这样: class Derived:public Base{ public: void fun(int); string a; ... private: ... } 此时如果在Derived内存在如下语句: a=1; fun(); 都会编译不通过,因为由于名字屏蔽,Base的a和fun在Derived中将不可见,这就是作用域屏蔽规则.因此派生类对基类函数的重写将不是overload \u0026 override,而是隐藏 在采用public继承时,如果派生类重写基类函数,名字屏蔽会使得基类中同名函数在派生类中不可见 如果使基类的同名函数在派生类中仍然可见,可以使用using声明式 class Derived:public Base{ public: using Base::fun; void fun(int); ... private: string a; ... } 如果并不想继承Base类所有的fun函数(private继承中可能出现),则可以使用\"转交函数”(forwarding function)的方法 class Derived:private Base{ public: void fun(){ Base::fun(); } void fun(int); ... private: string a; ... } 此条款主要讲的也是违反了面向对象原则之一（里氏替换原则-我们应该去重写，而不是隐藏） ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:3:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"Summary 我们要小心谨慎 不能隐藏了父类函数 可以使用类名作用域决定调用父类还是子类的函数 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:3:1","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款34 接口继承与实现继承 说实话 这个思想我是真觉得你应该去看设计模式，光看这一个条款你可能不理解接口继承与实现继承，说到底其实就是一个抽象接口的思想，但是实现起来可是有一番难度的 本条款其实就是介绍了三种虚函数的好坏而已，同时看到这里大家有没有想起来《条款31》呀~ 好，进入主题 继承中接口的处理方式 作为类的设计者，对于基类的成员函数可以大致做下面三种方式的处理： ​ ① 纯虚函数：基类定义一个纯虚函数，然后让派生类去实现 ​ ② 非纯虚的virtual虚函数：基类定义一个非纯虚的virtual虚函数，然后让派生类去重写覆盖(override) ​ ③ 普通的成员函数：基类定义一个普通的成员函数，并且不希望派生类去隐藏 本文依次介绍上面这三种设计的原理。下面定义一个类，作为本文讲解的基础： - class Shape { public: virtual void draw()const = 0; //纯虚函数 virtual void error(const std::string\u0026 msg); //非纯虚函数 int objectID()const; //普通成员函数 }; class Rectangle :public Shape {}; class Ellipse :public Shape {}; 纯虚函数 这是文章开始提到的第一种情况：派生类只继承基类的成员函数的接口（纯虚函数），派生类自己实现纯虚函数 纯虚函数的一些特征： ① 拥有纯虚函数的类不能实例化 ② 拥有纯虚函数的类，其派生类必须实现该纯虚函数 class Shape { public: virtual void draw()const = 0; //纯虚函数 }; class Rectangle :public Shape {}; class Ellipse :public Shape {}; 其中涉及纯虚函数的目的为： Shape是所有图形类的基类，其提供一个draw()的画图函数，但是由于其派生类（矩形、圆等）的画图方式都是不一样的，因此无法为draw()函数提供一种默认缺省行为，因此Shape将draw()定义为纯虚函数， 让其派生类去自动实现 class Shape { public: virtual void draw()const = 0; }; class Rectangle :public Shape { public: virtual void draw()const { std::cout \u003c\u003c \"Rectangle\" \u003c\u003c std::endl; } }; class Ellipse :public Shape { public: virtual void draw()const { std::cout \u003c\u003c \"Ellipse\" \u003c\u003c std::endl; } }; int main() { //Shape *ps = new Shape; //错误，不能实例化 Shape *ps1 = new Rectangle; Shape *ps2 = new Ellipse; ps1-\u003edraw(); //调用Rectangle::draw() ps2-\u003edraw(); //调用Ellipse::draw() return 0; } 非纯虚的virtual虚函数 先来看一个virtual函数的演示案例 假设某航天公司设计一个飞机继承体系，该公司现在只有A型和B型两种飞机，代码如下 class Airport {}; //机场 class Airplane { //飞机的基类 public: virtual void fly(const Airport\u0026 destination) { //飞机飞往指定的目的地(默认行为) } }; //A、B两个派生类 class ModelA :public Airplane {}; class ModelB :public Airplane {}; // ModelB 哈哈哈 让我想起最近的一个新车啥车型 主持人说 - \"ma de b\" 笑死 fly()函数被声明为virtual函数，因为A和B两个飞机具有相同的默认飞行行为，因此在Airplane类的fly()函数中定义这种默认飞行行为，然后让A和B继承。这样的好处是： ​ ① 将所有性质搬到到base class中，然后让两个class继承 ​ ② 避免代码重复，并提升未来的强化能力，减缓长期维护所需的成本 但是万一有一个ModelC，不使用这个fly()呢，吃瘪了吧，所以要把虚函数改成纯虚函数 ① 展示第一种修改方法 class Airport {}; //机场 class Airplane { public: virtual void fly(const Airport\u0026 destination) = 0; protected: void defaultFly(const Airport\u0026 destination) { //飞机飞往指定的目的地(默认行为) } }; class ModelA :public Airplane { public: virtual void fly(const Airport\u0026 destination) { defaultFly(destination); } }; class ModelB :public Airplane { public: virtual void fly(const Airport\u0026 destination) { defaultFly(destination); } }; class ModelC :public Airplane { public: virtual void fly(const Airport\u0026 destination) { //C型飞机不可以使用默认飞行行为，因此定义自己的飞行方式 } }; 现在C型飞机，或者别的添加的飞机就不会意外继承默认的飞行行为了（因为我们将默认的飞行行为封装到一个defualtFly函数中了），自己可以在fly()中定义飞行行为了 注意，在A和B的类的fly()函数中，对defaultFly()做了一个inline调用（见条款30，inline和virtual函数之间的交互关系） ② 第二种修改方法 上面我们将fly()接口和实现（defaultFly()函数）分开来实现，有些人可能会反对这样做，因为这样会因过度雷同的函数名称而引起class命名空间污染 如果不想将上述两个行为分开，那么可以为纯虚函数进行定义，在其中给出defaultFly()函数的相关内容。例如： class Airport {}; //机场 class Airplane { public: //实现纯虚函数 virtual void fly(const Airport\u0026 destination) = 0 { //飞机飞往指定的目的地(默认行为) } }; class ModelA :public Airplane { public: virtual void fly(const Airport\u0026 destination) { Airplane::fly(destination); } }; class ModelB :public Airplane { public: virtual void fly(const Airport\u0026 destination) { Airplane::fly(destination); } }; class ModelC :public Airplane { public: virtual void fly(const Airport\u0026 destination) { //定义自己的飞行方式 } }; 这个设计实现的功能和上面的演示案例是一样的，只不过在派生类的fly()函数中用纯虚函数Airplane::fly替换了独立函数Airplane::defaultFly 这种合并行为丧失了“让两个函数享有不同保护级别”的机会：例如上面的defaultFly()函数从protected变为了public 普通的成员函数 最后来看看Airplane的普通成员函数 class Shape { public: int objectID()const; //普通成员函数，不希望派生类隐藏 }; class Rectangle :public Shape {}; class Ellipse :public Shape {}; 设置普通的成员函数的目的： 意味着基类不希望派生类去隐藏这个成员函数 实际上一个普通的成员函数所表现的不变性凌驾其特异性，因为它表示不论派生类变得多特特异化，它的行为都不可以改变 在上面的代码中： 每个Shape对象都有一个用来产生对象识别码的函数 此识别码总是采用相同计算方法，该方法有Shape::objectID的定义式决定，任何派生类都不应该尝试改变其行为 由于普通成员函数代表的意义是不变性凌驾特异性，所以它绝不该在派生类中被重新定义（这也是条款36所讨论的一个重点） ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:4:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"Summery 接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口 pure virtual函数只具体hiding接口继承 impure virtaul函数具体指定接口继承及缺省实现继承 non-virtual函数具体指定接口继承以及强制性实现继承 题外话，是不是光看这个条款还是不懂接口继承和实现继承到底是啥，对吧 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:4:1","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款35 考虑virtual函数以外的选择 一般做法 我们都玩过游戏，在砍杀游戏中，我们假定使用成员函数healthValue，它会返回一个整数，表示人物的健康程度。将其设置为virtual似乎是再明白不过的做法 class GameCharacter { public: virtual int healthValue() const; ... } Non-Virtual Interface手法 实现 Template Method模式 这里是不是不懂Teamplate Method模式，这可不是c++的 template 哦，不懂就去看《设计模式-模板方法》 有一种流派，它主张virtual函数应该几乎总是private。这个流派的拥护者建议，较好的设计是保留healthValue为public成员函数，但让它成为non-virtual，并调用一个private virtual函数 class GameCharacter { public: int healthValue() const { ... int retValue = doHealthValue; ... return retValue; } ... private: virtual int doHealthValue() const { // derived classes 可重新定义它 ... // 缺省算法，计算健康指数 } } Function Pointers实现 Strategy 模式 这里是不是不懂Strategy模式，不懂就去看《设计模式-策略模式》 另一种流派设计主张”人物健康指数的计算与人物类型无关“，这样计算完全不需要”人物“这个成分 例如我们可能会要求每个人物的构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算 class Gamecharacter; // 前置声明 // 以下函数就是计算健康指数的缺省算法 int defaultHealthCalc(const GameCharacter\u0026 gc); class GameCharacter { public: typedef int (*HealthCalcFunc) (const GameCharacter\u0026); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) { } int healthValue() const { return healthFunc(*this); } ... private: HealthCalcFunc healthFunc; } 相比于之前做法，该Strategy设计模式的简单应用，它提供了某些有趣弹性 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:5:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款26～31 实现","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款26～31 实现 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:0:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款26 尽可能延后变量定义得时间 因为变量（对类而言）的定义，需要承担一次构造函数的时间，在函数结束后还可能承担一次析构函数的时间，假如该变量未被使用，那么构造函数和析构函数的时间就白白浪费了，尤其是在可能发生异常的函数中，假如你过早的定义变量，然后在你使用这个变量之前抛出了异常，那么这个变量的构造函数就没有意义而且降低效率。所以应该尽可能延后变量定义得时间，只有真正使用这个变量的时候才定义它 条款4讲过，copy construction的效率 \u003e default construction +assign function，所以最好的做法是直接调用copy construction函数对变量直接进行初始化，而不是先定义，再赋值 std::string encryptPassword(const std::string\u0026 password) { ... string encrypted; encrypted = password; ... } std::string encryptPassword(const std::string\u0026 password) { ... string encrypted(password) ... } 对于有循环的情况，假设一个n次的循环，如代码所示 方法A-定义于循环之外 此方法的代价 - 1次构造，1次析构，n次赋值 Widget w; for (int i = 0; i \u003c n; ++i) { w = \u003c取决于i的某个值\u003e; ... } 方法B-定义于循环内 此方法的代价 - n次构造，n次析构 for (int i = 0; i \u003c n; ++i) { Widget w(\u003c取决于i的某个值\u003e); ... } 如果n较大，那么应该选择方法A / 如果n较小，可以选择方法B ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:1:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary 尽可能延后变量定义得时间，只有真正使用这个变量的时候才定义它 直接调用copy construction函数对变量直接进行初始化，而不是先定义，再赋值 对于有循环的情况，如果n较大，那么应该选择方法A / 如果n较小，可以选择方法B ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:1:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款27 正确使用类型转换 const_cast：4个类型转换中唯一一个可以对const进行转换的类型转换符 static_cast：算是用的最多的一个类型转换符，明确指出类型转换，一般建议都将隐式转换都替换为显示转换，因为没有动态 类型检查，static_cast上行转换也就是 派生类-\u003e基类 安全，但是下行转换不安全，所以主要执行非多态的转换操作，其实基本上除了常量和非多态也就都用static_cast了 既然是最常用的，那我们来看看static_cast static_cast使用例子 class Widget { public: explicit Widget(int size); ... }; void doSomeWork(const Widget\u0026 w); doSomeWork(Widget(15)); // create Widget from int with function-style cast doSomeWork(static_cast\u003cWidget\u003e(15)); // create Widget from int with c++-style cast // 关于 function-style 大家可以看这个网址 // url: https://en.cppreference.com/w/cpp/language/explicit_cast static_cast转型分析 #include \u003cstdio.h\u003e class Base { public: int a; }; class Dervied : public Base { public: double c{}; virtual void bar() }; int main() { Dervied d; Base* base = static_cast\u003cBase*\u003e(\u0026d); } static_cast\u003cxxx\u003e(zzz)其实是一个临时对象 如下述代码，如果Window::onResize()中有修改成员变量的操作，那么在SpecialWindow中是修改不了的，因为转换后只是一个临时对象 class Window { public: virtual void onResize() { ... }; }; class SpecialWindow : public Window { public: virtual void onResize() { static_cast\u003cWindow\u003e(*this).onResize(); } } // 正确写法 class SpecialWindow : public Window { public: virtual void onResize() { Window::onResize(); } } dynamic_cast：专⻔用于派生类之间的转换，type-id 必须是类指针，类引用或 void，对于下行转换是安全的，当类型不一致时，转换过来的是空指针，而static_cast，当类型不一致时，转换过来的是错误意义的指针，可能造成非法访问等问题* 他的代价也比较高，因为其他的都是在编译时，这个是在运行时 dynamic_cast的开销有点大，所以能避免就避免 此解决方法1 很鸡肋 因为原本想用基类指针，这样方便扩展类 针对上述问题，我们可以这么改 reinterpret_cast：不到万不得已，不要使用这个转换符，高危操作 使用特点: 从底层 对数据进行重新解释，依赖具体的平台，可移植性差 可以将整形转换为指针，也可以把指针转换为数组; 可以在指针和引用之间进行肆无忌惮的转换 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:2:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary 最好使用C++4个新式的类型转换函数，因为这很容易辨识，代码可读性提高 尽量避免使用dynamic_cast，因为这种转换效率很低，一般用虚函数的方式来避免转型 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:2:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款28 避免返回一个指针、引用或者迭代器指向类内的成员 如果返回了成员的引用或者指针，就可以通过这个引用或者指针修改雷内的private成员，这样是不合理的（这样的话成员就相当于public的了），这一点可以通过给函数的返回类型加const修饰符来防止内部成员变量被修改 但是还有一种情况是，如果获得的类内的一个成员的引用或指针，但是在使用之前，对象被释放了，那么这个引用或指针就变成了野指针了，必然会导致core dump错误。所以应该避免返回类内成员的指针或引用 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:3:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款29 努力写一个异常安全的代码 这个条款的核心思路就是 发生异常时的处理主要分一下几类：资源不泄漏、数据不丢失、不抛出异常。反正就是考虑程序的各种可能的情况，如果异常了要尽可能保证你的程序某些功能或数据不丢失 RAII，不清楚RAII，可以去看《RAII是什么》 class PrettyMenu { public: void changeBackground(std::istream\u0026 imgSrc); private: Mutex mutex; Image *bgImage; int imageChanges; }; void PrettyMenu::changeBackground(std::istream\u0026 imgSrc) { lock(\u0026mutex); delete bgImage; ++imageChanges; bgImage = new Image(imgSrc); // 可能出现异常 unlock(\u0026mutex) } 如果在 bgImage = new Image(imgSrc);出现异常 那么你就会发现，数据已经出现修改并且锁也没有释放，我们称这种代码就是异常不安全代码 我们可以利用 RAII 这么修改 void PrettyMenu::changeBackground(std::istream\u0026 imgSrc) { lock_guard(\u0026mutex); // lock_guard就是c++11之后的一个RAII对象 delete bgImage; ++imageChanges; bgImage = new Image(imgSrc); // 可能出现异常 } 我们利用RAII能够成功的把锁给释放了，但是数据破坏还没有解决 智能指针 class PrettyMenu { ... std::shared_ptr\u003cImage\u003e bgImage; ... } void PrettyMenu::changeBackground(std::istream\u0026 imgSrc) { lock_guard(\u0026mutex); // lock_guard就是c++11之后的一个RAII对象 bgImage.reset(new Image(imgSrc)); ++imageChanges; } 这样这段代码就是一个基本异常安全的代码 异常安全也是分等级的，异常安全代码只需保证下面其一就可以说是异常安全代码 basic guarantee 基本异常安全，就如上述例子一样，不会数据破坏，资源泄漏 strong guarantee 强力异常安全，如果函数失败，此时状态还是执行函数之前的状态 nothrow guarantee 不会抛出异常的 怎么能做到强力异常安全 copy and swap 该策略是《Pimpl》的一种使用实现 struct PMImpl { std::shared_ptr\u003cImage\u003e bgImage; int imageChanges; } class PrettyMenu { ... private: Mutex mutex; std::shared_ptr\u003cPMImpl\u003e pImpl; } void PrettyMenu::changeBackground(std::istream\u0026 imgSrc) { using std::swap; Lock ml(\u0026mutex); std::shared_ptr\u003cPMImpl\u003e; pNew-\u003ebgImage.reset(new Image(imgSrc)); ++pNew-\u003eimageChanges; swap(pImpl, pNew); } 实现强异常安全还是比较有困难的，所以我们要保证一个基本的异常安全，但是如果能实现强力异常安全，那也还要去实现的 看下述代码，如果f1() f2()只是基本异常安全，然而我们想要把someFunc()实现为强异常安全，那代价将是非常高的 因为，我们要捕捉f1() 的所有异常，然后在f1()执行之前将函数目前状态都保存下来，如果异常了就要恢复，所以代价会很高 如果f1() f2()都是强力异常安全，那么行不行呢，也是不行的，因为f1执行成功，但是f2异常了，这时候f1该做的操作也都做了 void someFunc() { ... // make copy of local state f1(); f2(); ... // swap modified state into place } ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:4:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary 发生异常时的处理主要分一下几类：资源不泄漏、数据不丢失、不抛出异常。反正就是考虑程序的各种可能的情况，如果异常了要尽可能保证你的程序某些功能或数据不丢失 实现异常安全可以依靠下述办法，但不仅依靠下述办法 RAII 智能指针 PImpl - 这个是实现强力异常安全的思路 我们要做到基本异常安全，强力异常安全就佛系，但是能做到也最好 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:4:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款30 理解inline function inline function 会在符号表中以\"weak\"中存在 下述代码在链接的时候会报错，你这个全局其实有两个foo()函数 我们来看看上述代码的符号表，在符号表中其实foo(int)符号绑定类型是GLOBAL 我们用inline function来试试 c++17 之后静态成员直接类内inline就可以省去类外初始化的麻烦 inline static uint8_t selectone = 0; c++11之后inline可以修饰命名空间 下述代码 在libfoo_2022命名空间中会有一个模板foo，然后再libfoo命名空间中想来个模板特化，这样是会报错的 namespace libfoo { namespace libfoo_2022 { template \u003ctypename T\u003e T\u0026 foo(T\u0026); } using namespace libfoo_2022; } namespace libfoo { template \u003c\u003e float\u0026 foo\u003cfloat\u003e(float\u0026); } 可以在namespace中加入inline namespace libfoo { inline namespace libfoo_2022 { void foo1(Bar1); class Bar2 {}; template \u003ctypename T\u003e T\u0026 foo(T\u0026); } using namespace libfoo_2022; } namespace libfoo { template \u003c\u003e float\u0026 foo\u003cfloat\u003e(float\u0026); } 隐式 inline 下述场景是一个隐式inline class Person { public: ... int age() const { return theAge; } // 隐式inline ... private: int theAge; }; inline也可以修饰模板对吧，在符号表中，其实模板也是weak符号类型 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:5:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary inline function 会在符号表中以\"weak\"中存在 c++11之后inline可以修饰命名空间 c++17 之后静态成员直接类内inline就可以省去类外初始化的麻烦 隐式 inline，对于模板来说都是inline ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:5:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款31 最小化文件依赖 我们在项目里只修改了一个私有成员，然后编译就发现全部重新编译了，我们就需要构建一个\"编译防火墙\"，编译防火墙就是最小化文件依赖 我们来看看c++的一个特点，在下述代码中，如果我们修改了Date.h或者Address.h，那么只要包含了Person.h的文件就会重新编译 #include \u003cstring\u003e #include \"Date.h\" #include \"Address.h\" class Person { public: Person(const std::string\u0026 name, const Date\u0026 birthday, const Address\u0026 addr); std::string name const; Date birthDate() const; Address address() const; private: std::string theName; Date theBirthDate; Address theAddress; } 然后我们继续基于上述代码来看main() int main() { int x; Person p(params); ... } 在执行到Person p(params);这一行 编译器就必须看清楚Person是啥，特别是私有成员变量里的Date Address 但是我们如果定义成一个指针，编译器就不会去看清楚 int main() { int x; Person* p; ... } 还是《Pimpl》的设计，我们可以通过\"PImpl\"来最小化文件依赖 我们采用了PImpl设计，并且前置声明，但是有几个点一定要注意 如下述代码，Person::~Persion() = default;一定要写出来，如果不写，编译器默认会加，于是所有包含该头文件的编译单元都会inline编译这几个函数，然而又找不到数据类的实现，于是出现编译错误 Person构造函数如下述代码用智能指针写 除了\"PImpl\"，我们还可以用 抽象类接口 最小化文件依赖 类中全部都是pure virtual函数，这样的类在使用的时候只能是以指针的形式出现，这样就同样达到了减少编译依赖的效果 但是希望的能明白，这两种方式都可以最小化依赖，没有什么好与不好。因为PImpl他多出来指针，而且每次访问都是间接访问。虚函数也是靠虚表和虚指针，所以都会带来一定的开销，写的时候任意选一个熟悉的即可，本人是习惯抽象类接口 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:6:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary 我们可以通过\"PImpl\"来最小化文件依赖 要注意析构函数必须显示的写出来 我们还可以用 抽象类接口 最小化文件依赖 PImpl他多出来指针，而且每次访问都是间接访问。虚函数也是靠虚表和虚指针，所以都会带来一定的开销 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:6:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["缘起 在人群中 我看见你"],"content":"RAII","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"啥是RAII? ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:0:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"什么是RAII RAII是指C++语言中的一个惯用法（idiom），它是“Resource Acquisition Is Initialization”的首字母缩写。中文可将其翻译为“资源获取就是初始化” 虽然从某种程度上说这个名称并没有体现出该惯性法的本质精神，但是作为标准C++资源管理的关键技术，RAII早已在C++社群中深入人心 ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:1:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"思路推导 如果你有写过C++或者RUST，你也许听过Resource Acquisition Is Initialisation (RAII), 但是并不了解这名字的含义是什么，或者不知道这个机制有什么用处。在这篇文章中，笔者将详细阐述RAII的原理以及它在资源管理方面巨大的威力 RAII是一种使用在面向对象语言中的资源（内存，互斥锁，或者文件描述符）管理机制，使用RAII的语言中，最出名的当属c++ and rust，正是因为强制RAII机制使得rust拥有了绝对的内存安全 Resource Acquisition Is Initialisation, 顾名思义，意味着任何资源的获取都应该发生在类的构造函数中，但我个人认为这个名字不太完备，有另一半的意思没有解释到，那就是资源的释放应发生在析构函数中，这意味着所有资源的 life cycle都与一个 object紧紧绑定在一起 我将用几段代码来具体阐述RAII的应用场景 互斥锁 std::mutex mut; int write_to_a_file_descriptor(std::string content) { mut.lock(); // critical area below (might throw exception) // Writing content to a file descriptor... // Critical areas above mut.unlock(); } 以上代码展示了一个将字符串写进某个文件描述符的函数，并且这个函数会被很多线程并行调用（这种情况在高并发线上服务的logger中非常常见），因此这个共用的文件描述符必须用一个互斥锁保护起来，否则不同线程的字符串会混在一起 这段代码看起来仿佛没有问题，但是如果当写IO时是抛出异常，call stack会被直接释放，也就意味着unlock不会执行，造成永久的死锁，这个问题可以像java一样用一个try-catch语句来避免但是也会让代码变得臃肿和难看。并且在复杂的逻辑中，往往很可能会忘了解锁，或者花很多精力来管理锁的获得和释放(如果在一个函数调用中有多处返回，每个return statement之前都需要 unlock)。这就是RAII发挥其威力的时候了，下面一段代码将展示如何用 lock_guard来使我们的代码异常安全并且整洁 std::mutex mut; int write_to_a_file_descriptor(std::string content) { std::lock_guard\u003cstd::mutex\u003e lock(mut); // critical area below (might throw exception) // Writing content to a file descriptor... // Critical areas above } lock_guard保证在函数返回之后释放互斥锁，因此使得开发人员不需要为抛出异常的情况担心且不需手动释放锁。但是 lock_guard是如何做到的呢？笔者将尝试自己手动实现一个 lock_guard template \u003ctypename T\u003e class lock_guard { private: T _mutex; public: explicit lock_guard(T \u0026mutex) : _mutex(mutex) { _mutex.lock(); } ~lock_guard() { _mutex.unlock(); } }; 从实现上可以看出，lock_guard在构造函数中锁住了引用传入的mutext，并且在析构函数中释放锁。其异常安全的保障就是析构函数一定会在对象归属的scope退出时自动被调用 如果你用过golang的话会知道golang的defer机制，这与C++的析构函数十分相似，但是golang的defer只能保证在函数返回前执行，而C++的析构函数可以保证在当前scope退出前执行（个人感觉golang的defer相比之下比较鸡肋） ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:2:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"智能指针 C++中一个非常常见的应用场景就是调用一个函数来产生一个对象，然后消费这个对象，最后手动释放指针。如以下代码所示 class my_struct { public: my_struct() = default; }; template \u003ctypename T\u003e T* get_object() { return new T(); } int main() { auto obj = get_object\u003cmy_struct\u003e(); // consume the object // ... // consume finish delete obj; } 然而，在大型应用程序中，指针的产生和消费错综复杂，写到后面程序员根本不记得自己有没有释放指针，或者某处地方读取一个已经释放的指针直接导致segmentation fault程序崩溃。而这就是C/C++各种内存泄漏的万恶之源 而自从C++11推出智能指针后，其极大地减轻了C++开发者们内存管理的压力。通过在裸指针上包一层智能指针，再也不用通过手动 delete来释放内存了。下面的代码将展示如何用 std::unique_ptr来管理指针 class my_struct { public: my_struct() = default; }; template \u003ctypename T\u003e std::unique_ptr\u003cT\u003e get_object() { return std::unique_ptr\u003cT\u003e(new T()); } int main() { auto obj = get_object\u003cmy_struct\u003e(); // consume the object // ... // consume finish } 智能指针的方便之处在于它会在自己的析构函数中执行 delete操作而不需程序员手动释放 在上述代码中，当main函数退出时， std::unique_ptr在自己的析构函数中释放指针，而为了防止有别的 std::unique_ptr指向自己管理的对象而导致的提早释放与空指针访问， std::unique_ptr禁止了 copy constructor与 copy assignment。有人可能会疑惑，为什么 get_object函数创建的 unique_ptr为什么没有在函数返回前释放指针？这是因为 std::unique_ptr实现了 move constructor（一种可以将资源从另一个对象“偷”过来的构造函数）并在返回时将指针传给了main函数中 obj变量 如果不太理解发生了什么，可以看一下以下我自己尝试实现的 unique_ptr. template \u003ctypename T\u003e class unique_ptr { private: T* _ptr; public: // Construct from plain pointer explicit unique_ptr(T* ptr) : _ptr(ptr) { std::cout \u003c\u003c \"unique_ptr constructed\" \u003c\u003c std::endl; }; // Move constructor unique_ptr(unique_ptr \u0026\u0026ptr) noexcept : _ptr(ptr._ptr) { ptr._ptr = nullptr; std::cout \u003c\u003c \"unique_ptr move constructed\" \u003c\u003c std::endl; } // Copy constructor is forbidden unique_ptr(unique_ptr \u0026ptr) = delete; // Move assignment unique_ptr\u0026 operator=(unique_ptr \u0026\u0026ptr) noexcept { if (this == \u0026ptr) { return *this; } _ptr = ptr._ptr; ptr._ptr = nullptr; return *this; } // Copy assignment is forbidden unique_ptr\u0026 operator=(unique_ptr \u0026ptr) = delete; ~unique_ptr() { delete _ptr; std::cout \u003c\u003c \"unique_ptr destructed\" \u003c\u003c std::endl; } T* operator-\u003e() { return _ptr; } }; 代码看上去比较复杂，不过我将一个方法一个方法地和大家分析 第8行代码实现了最基本的构造函数：从一个裸指针开始构造 第13行实现了 move constructor，这个方法会用一个已有的 unique_ptr来构造一个新的对象，它将旧 unique_ptr的指针替换为 nullptr来防止多个指针指向相同对象 第19行禁止了 copy constructor的使用，因为不允许多个指针指向同一对象 第22行实现了 move assignment，原理与 move constructor相同 第32行禁止了 copy assignment，原理与 copy constructor相同 第34行是析构函数，将最终释放指针 第39行实现了 operatoroverload，使得我们可以像访问普通指针一样访问 unique_ptr 我们来用我们自己定义的 unique_ptr运行一下看会发生什么 class my_struct { public: std::string _name = \"name\"; my_struct() = default; explicit my_struct(std::string name) : _name(std::move(name)) { std::cout \u003c\u003c \"my_struct constructed\" \u003c\u003c std::endl; } ~my_struct() { std::cout \u003c\u003c \"my_struct destructed\" \u003c\u003c std::endl; } }; template\u003ctypename T\u003e unique_ptr\u003cT\u003eget_object() { return unique_ptr\u003cT\u003e(new T(\"struct name\")); } int main() { unique_ptr\u003cmy_struct\u003e obj = get_object\u003cmy_struct\u003e(); std::cout \u003c\u003c obj-\u003e_name \u003c\u003c std::endl; } // console output my_struct constructed unique_ptr constructed struct name my_struct destructed unique_ptr destructed 首先， my_struct被构造，然后 unique_ptr被构造，并且可以发现， my_struct的析构函数会在 unique_ptr的析构函数返回前执行，这意味着我们成功地将指针的life cycle绑定到了 unique_ptr上！不过，细心的同学可能发现了，全程 unique_ptr的 move constructor都没有被call过，但是我之前明确说了，main函数中的 obj是用 get_object函数中构造的 unique_ptr通过 move constructor构造的。可是为什么我们没有抓到 move constructor打印出来的东西呢？这是因为C++编译器做了一个叫做 copy elision的优化，来避免不必要的构造和析构，例如本例中，两个函数中的 unique_ptr对象其实是一个东西，因此他们之间的转换和赋值被优化掉了。如果我们通过 std::move来强制 move constructor发生，如下所示： 我们将看到这样的信息： my_struct constructed unique_ptr constructed unique_ptr move constructed unique_ptr destructed struct name my_struct destructed unique_ptr destructed 此时我们可以清晰地看到，main函数中的 obj是通过 move constructor构造的，并且在其构造完成之后， get_object函数中构造的 unique_ptr对象被析构了，因为我们已经提早将其内部指针替换成了 nullptr, 其析构函数什么都不会释放 智能指针中，除了 std::unique_ptr，还有其他类型，比如允许多个指针指向同一变量的 std::shared_ptr，其内存管理逻辑会复杂许多 ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:3:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"技术总结 通过这篇文章，相信大家都体会到了RAII的威力，其将资源绑定到轻量级对象(比如智能指针，内存占用很少，可以像普通指针一样随意传递)的方法使得我们再也不需要关心在获取资源之后对资源的释放 ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:4:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["Effective C++"],"content":"条款18～25 设计与生命","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款18～25 设计与生命 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:0:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款18 让接口容易被正确使用，不易被误用 对class的参数类型进行抽象 我们普通的定义一个接口会有啥问题，如下述代码 class Date{ public: Date(int month, int day, int year); ... }; Date d(2, 30, 2021); // 传参容易出错 所以我们可以对class的参数类型进行抽象，如下述代码 struct Day{ int val; explicit Day(int d) : val(d) {} }; ... class Date{ public: Date(const Month\u0026 m, const Day\u0026 d, const Year\u0026 y); ... }; Date d(Month(3), Day(31), Year(2021)); // 传参可靠 尽量让自定义type行为与内置type一致 这边如果a和b是自定义类型，这边编译器就不会报错，如果a和b是内置类型，那么ab是临时对象-右值，所以编译器就会报错* 所以我们这边需要统一，行为与内置type一致，在前面的条款3也说了，直接加const即可 if (a * b = c) factory 函数返回智能指针* 了解设计模式的童鞋们就会知道有一个设计模式叫工厂模式，在这里推荐工厂函数返回一个智能指针，因为用裸指针就会增加用户的心智开销，避免忘记delete Investment* createInvestment(); -\u003e std::shared_ptr\u003cInvestment\u003e createInvestment(); shared_ptr\u003cInvestment\u003e createInvestment(){ shared_ptr\u003cInvestment\u003e retVal( static_cast\u003cInvestment*\u003e(0), // 初始化一个null shared_ptr指针， getRidOfInvestment); // 指定getRidOfInvestment函数为删除器， retVal = ...; // 令retVal指向正确的对象 return retVal; } ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:1:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 好的接口容易被正确使用，不容易被误用 “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容 “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任 shared_ptr 支持定制型删除器。可防范 DLL 问题，可被用来自动解除互斥锁（mutex）等 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:1:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款19 设计class犹如设计type ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:2:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 这个条款有12问帮你设计好一个class，当然class由于需求是会多变的，但是这个12问能够起到很好的辅助作用 自定义 type 的对象应该如何被创建和销毁 也就是他的构造和析构应该是怎么去写 对象的初始化和对象的赋值应该有什么样的差别？（不要混淆“初始化”和“赋值”） 新 type 的对象如果被 pass by value，意味着什么？（copy 构造函数定义） 什么是新 type 的“合法值”？（构造函数、赋值操作、setter 函数） 新 type 需要配合某个继承图系吗？（virtual 函数、virtual 析构函数） 新 type 需要什么样的转换？（条款15：显式转换：explicit 构造，隐式转换：operator Type、-\u003e） 什么样的操作符和函数对此新 type 而言是合理的？ 什么样的标准函数应该驳回？（条款06：明确拒绝copy 构造、copy assignment 操作符等） 谁该取用新 type 的成员？（访问规则：数据成员的封装，成员函数 API 的开放，是否友元） 什么是新 type 的“未声明接口”？ 你的新 type 有多么一般化？（class template） 你真的需要一个新 type 吗？（多个 non-member 函数或 template 是否可以达到目的） ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:2:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款20 以 pass by reference to const 替换 pass by value pass-by-reference-to-const 作为函数参数 效率高（没有构造和析构函数被调用），还能避免slicing（对象切割）问题 class Window{ public: ... string name() const; // 返回窗口名称 virtual void display() const; // 显示窗口和内容 }; class WindowWithScrollBars : public Window{ public: ... virtual void display() const; }; void printNameAndDisplay(Window w){ // 不正确！参数可能被切割。value是没有多态的特性的 cout \u003c\u003c w.name(); w.display(); } WindowWithScrollBars wwsb; printNameAndDisplay(wwsb); // 总是调用Window的display() void printNameAndDisplay(const Windows\u0026 w) { // 正确！引用本质上就是一个漂亮的指针 也具有多态特性 cout « w.name(); w.display(); } pass-by-value 经常适用于内置类型、STL迭代器和函数对象 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:3:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary pass-by-reference-to-const 作为函数参数，效率高（没有构造和析构函数被调用），还能避免slicing（对象切割）问题 pass-by-value 经常适用于内置类型、STL迭代器和函数对象 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:3:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款21 不要错误的返回对象的引用 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:4:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 不要返回一个临时对象的引用 不要返回在堆上分配的对象的引用，因为这违背了new和delete成对出现的原则，这样的方式是很不合理的，稍加不注意就会导致内存泄漏问题 也不要返回一个static对象的引用，因为static可能同时被很多地方需要，这样的话共享就存在问题 所以对于这种问题，最好的解决方法就是不返回引用就OK了 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:4:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款22 将成员变量声明为private ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:5:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 其实声明为private 带来的最大的好处就是 - 成员变量有更精细的访问控制 考虑一个 public 成员变量变更或消失时对用户代码的影响 考虑一个 protected 成员变量变更或消失时对 derived class 代码的影响 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:5:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款23 将non member \u0026 non friend 替换 member func 封装使我们能够改变事物而只影响有限客户 导致较大封装性的是 non-member、non-friend 函数（因为不增加“能够访问 class 内 private 成分”的函数数量） class WebBrowser{ public: ... void clearCache(); void clearHistory(); void removeCookies(); ... }; // non-member“便利函数” void clearBrowser(WebBrowser\u0026 wb){ wb.clearCache(); wb.clearHistory(); wb.removeCookies(); } 将所有便利函数放在多个头文件但隶属于同一个命名空间，意味客户可以轻松扩展这一组便利函数 // 头文件“webbrowser.h” namespace WebBrowserStuff{ class WebBrowser{...}; ... // 核心机能，几乎所有客户需要的non-member函数 } // 头文件“webbrowserbookmarks.h” namespace WebBrowserStuff{ ... // 与书签相关的便利函数 } // 头文件“webbrowsercookies.h” namespace WebBrowserStuff{ ... // 与cookie相关的便利函数 } ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:6:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 封装使我们能够改变事物而只影响有限客户 导致较大封装性的是 non-member、non-friend 函数（因为不增加“能够访问 class 内 private 成分”的函数数量） ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:6:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款24 若所有参数皆需类型转换，请为此采用 non-member 函数 隐式转换与 member 函数 class Rational{ private: ... public: Rational(int numerator = 0, // non-explicit int denominator = 1); // 允许int-to-Rational隐式转换 int numerator() const; // 分子访问函数 int denominator() const; // 分母访问函数 ... const Rantional operator*(const Rational\u0026 rhs) const; }; Rational result; Rational oneHalf(1, 2); result = oneHalf * 2; // 正确，oneHalf.operator*( 2 /* 隐式转换 */); result = 2 * oneHalf; // 错误，2.operator*(oneHalf); 隐式转换与 non-member 函数 class Rational{ private: ... public: Rational(int numerator = 0, // non-explicit int denominator = 1); // 允许int-to-Rational隐式转换 int numerator() const; // 分子访问函数 int denominator() const; // 分母访问函数 ... }; const Rantional operator*(const Rational\u0026 lhs, const Rational\u0026 rhs){ return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } Rational result; Rational oneHalf(1, 2); result = oneHalf * 2; // 正确，operator*(oneHalf, 2 /* 隐式转换 */); result = 2 * oneHalf; // 正确，operator*(2, oneHalf); ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:7:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 若所有参数皆需类型转换，请为此采用 non-member 函数 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:7:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款25 考虑写出一个不抛异常的 swap 函数 我们标准库里面的swap函数是这么写的，无非就是一个中间值过渡，只要T支持copying(通过copy构造函数和assignment操作符完成)，默认的swap会实现代码就会将类型为T的对象进行置换 namespace std { template\u003ctypename T\u003e void swap(T\u0026 a, T\u0026 b) { T temp(a); a = b; b = temp; } } 这种方法对于内置类型没任何问题，内置类型上的赋值绝对不会抛出异常，并且效率很高。但是如果a,b不是内置类型，就会调用类的copy构造函数和assign函数，并且必须是深拷贝。这样如果类的成员较多就会造成交换的效率很低，特别是针对pimpl实现方法，即成员中包含指针（即资源）时。更好的做法就是直接交换指针就可以了，相当于交换了两个int(指针都是4字节的)，这就比拷贝这个指针指向的资源要快得多 关于pimpl可以查看本博客《C++ Pimpl》 如何实现呢？我们先用pimpl手法将Widget的数据成员封装到WidgetImpl中 class WidgetImpl {// class for Widget data; public:// details are unimportant... private: int a, b, c;// possibly lots of data — std::vector\u003cdouble\u003e v;// expensive to copy!... }; class Widget {// class using the pimpl idiom public: Widget(const Widget\u0026 rhs); Widget\u0026 operator=(const Widget\u0026 rhs)// to copy a Widget, copy its { // WidgetImpl object. For ...// details on implementing *pImpl = *(rhs.pImpl);// operator= in general, ...// see Items 10, 11, and 12. } ... private: WidgetImpl *pImpl;// ptr to object with this };// Widget’s data 设计问题 置换两个Widget对象过于复杂，浪费空间和效率(对于置换Widget对象值，我们只需要做的是置换impl指针，但默认的swap要交换Widget类更需要交换WidgetImpl) 可以直接交换指针的地址，改变指针指向的内存 我们可以置换其impl指针 namespace std{ template\u003c\u003e void swap\u003cWidget\u003e(Widget\u0026 a,Widget\u0026 b)//std::swap的全特化版本只能对 //\u003cWidget\u003e表示这一特例化版本只是针对指针交换而设计 { swap(a.pImpl,b.pImpl); } } 这个有个问题 pImpl是属于Widget的private成员因此此函数肯定是无法编译通过的，我们可以将其声明为friend函数但其封装性较弱，可以将swap声明为member函数如下 class Widget { // same as above, except for the public:// addition of the swap mem func ... void swap( Widget\u0026 other){ using std::swap;// the need for this declaration // is explained later in this Item swap(pImpl, other.pImpl);// to swap Widgets, swap their } // pImpl pointers ... }; namespace std { template\u003c\u003e// revised specialization of void swap\u003cWidget\u003e(Widget\u0026 a,// std::swap Widget\u0026 b) { a.swap(b);// to swap Widgets, call their }// swap member function } 这一段代码能够通过编译，并且具有STL容器的一致性，以为std::swap也提供了有pulic swap成员函数的和std::swap的特化版本 但是对于Widget class templates而非classes 将数据类型加以参数化 template\u003ctypename T\u003e class WidgetImpl { ... }; template\u003ctypename T\u003e class Widget { ... }; namespace std { template\u003ctypename T\u003e void swap\u003cWidget\u003cT\u003e \u003e(Widget\u003cT\u003e\u0026 a,// error! illegal code! Widget\u003cT\u003e\u0026 b) { a.swap(b); } } // 企图偏特化一个function template(std::swap)，但C++只能对class templates偏特化 // 在function templates身上时不能偏特化的。因此无法编译 所以我们得偏特化 function template namespace std {template\u003ctypename T\u003e// an overloading of std::swap void swap(Widget\u003cT\u003e\u0026 a,// (note the lack of “\u003c...\u003e” after Widget\u003cT\u003e\u0026 b)// “swap”), but see below for { a.swap(b); }// why this isn’t valid code} 这时候还是有个问题，重载function templates是没问题的，但std是一个特殊的命名空间 可以全特化std内的templates 不可以添加新的templates(class或function)到std里面 所以真正高效正确的做法就是 non member swap \u0026 member swap相结合 namespace WidgetStuff { ...// templatized WidgetImpl, etc. template\u003ctypename T\u003e// as before, including the swapclass Widget { ... };// member function ... template\u003ctypename T\u003e// non-member swap function; void swap(Widget\u003cT\u003e\u0026 a,// not part of the std namespace Widget\u003cT\u003e\u0026 b) { a.swap(b); } } swap实现效率不足的解决(class或template运用了pimpl手法) 提供一个public的swap函数，让它高效地置换你的类型的两个对象值，而其不能抛出异常 在你的class或template所在的命名空间提供一个non-member swap，并令他调用上述swap成员函数 如果编写一个class(而非class template)，为你的class特化一个std::swap，并令他调用你的swap的成员函数 必须使用using std::swap,以便其能够在函数类曝光可见，然后报价namspace修饰符 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:8:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 当std::swap对你的类型无效时，提供一个swap成员函数。确保交换不会抛出异常 如果你提供了一个成员交换，也要提供一个调用成员的非成员交换。对于类(不是模板)，也要专门化std::swap 当调用swap时，对std::swap使用using声明，然后不带命名空间限定的调用swap 完全专门化用户定义类型的std模板是可以的，但永远不要尝试向std添加全新的东西 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:8:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了动态规划的概念，思路，及例题","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"动态规划 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"动态规划 动态规划 跟 “分治、递归、回溯”没有太大的区别，我们来看看动态规划的具体定义 simplifying a complicated problem by breaking it down into simpler sub-problems 这个是 wiki百科 对动态规划的解释，同时我感觉这是最好的解释 动态规划，个人觉得翻译成 “动态递推/动态推导” 是最好的，动态规划其实有点不直白 然后上述英文的意思则是 “把一个复杂的问题分解为更简单的子问题” 其实就是分治的思想，但是分治和动态规划只有小小的不一样，那就是第二点 动态规划 = 分治 + 最优子结构 一般来说 动态规划 会让你求 最优解 最大值 最小值，这也就是动态规划的应用场景 正因为，他有所谓的最优子结构，所以，你就不需要，将中间所有的状态都保存下来，只需要存最优的状态 重点总结 动态规划和 递归 分治 没有根本上的区别（关键是看有无最优子结构） 他们之间的共性就是 找到重复子问题 他们之间的差别就在于 动态规划有最优子结构，中途可以淘汰最优解 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"斐波那契数列 斐波那契额数列 我们都知道是可以用递归去解决，但是面试的时候，千万不能说用递归，傻递归的效率是极慢的 时间复杂度为指数级，也就是 O(2^n) 所以我们就得想办法来优化啦，我们可以加一个缓存，这个缓存可以用数组，这种叫做 “记忆化搜索” func fib(n int, memo []int) { // resursion terminator(递归终止条件) if (n \u003c= 1) { return 0 } if (memo[n] == 0) { memo[n] = fib(n - 1) + fib(n - 2) } return memo[n] } 在上述代码中我们通过增加数组实现的缓存，使得只要在数组出现的值就直接return，不让他参与遍历，把重复的节点直接砍掉，所以O(2^n) 变成了 O(n) 是不是贼棒，其实这个也是分治的思想，只不过加了个记忆化搜索 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"思想 - 自顶向下 我们在面对斐波那契时，当然可以用上述讲的 分治 + 记忆化搜索 来实现，其实这个思想就是 “自顶向下” 的思想 什么叫自顶向下呢？就是上述图片，我们一直从上面也就是fib(6)找到最下面的叶子结点 我要算 fib(6) 就得算fib(5) 和 fib(4) 我要算fib(5) 就得算fib(4) 和 fib(3) … 就如上述一直下去，中间算过的结果，我们可以用记忆化搜索，这种符合人脑的习惯，也是分治的思想 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:3:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"思想 - 自底向上 我们学习了自顶向下的方法，emmm，是不是感觉很不错，但是后来当我们遇到更难得dp也就是动态规划时，高手一般会直接用“自底向上”的思想 那么什么是自底向上呢 我们想算fib(6) 从fib(0) fib(1) 开始 然后一直用循环去递推 所以我们只需要了解自底向下思想即可，所以动态规划翻译成动态递推是不是很有道理 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:4:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"状态转移方程 状态转移方程也叫 dp方程 这个其实是要在例题1 例题2 后来讲的 这里为了工整性 提前说了 大家可以先看一下例题1 和例题2 的分析再来看 dp方程 和 关键点 思考步骤 两道例题 其实都有一个核心的关键方程 例题1 是 v[i] = v[i-1] + v[i-2] 例题2 是 v[i][j] = v[i-1][j] + v[i][j-1] 这类方程 我们叫状态转移方程 也叫dp方程 但是又回到 咬文嚼字上 这其实就是一个递推方程 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:5:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"dp 思考点 化繁为简，将复杂的问题 变成子问题，其实就是 找重复性（分治思想） 定义好状态空间 定义dp数组 \u0026\u0026 初始化dp数组 注意这里定义和初始化数组的长度一定要注意 有时候会是 “\u003e=” 或者其他的，如果定义错误，则会数组越界，或者答案错误 写好dp方程 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:6:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 爬楼梯 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:7:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"方法1 - 动态规划 URL 70. 爬楼梯 - 力扣（LeetCode） 代码示例 class Solution { public: int climbStairs(int n) { /* 定义dp数组 */ vector\u003cint\u003e dp(n+1); /* 初始化dp数组 */ dp[0] = 1; dp[1] = 1; /* dp方程 自底向上 */ for (int i = 2; i \u003c dp.size(); i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } }; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:7:1","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["Effective C++"],"content":"条款13～17 资源管理","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款13～17 资源管理 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:0:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"知识点 RAII对象 本大章节-资源管理，需要弄懂什么是RAII，在本博客《什么是RAII》中有详解 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:1:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款13 以对象管理资源 前言 其实在本文中的auto_ptr已经被弃用了，建议去看《Effective Modern c++ Item18 ~ Item22》 但是在这里还是说一下该条款的一些思路点 思路点 在构造中获得资源并在析构函数中释放资源 两个常用的自动管理资源的类是shared_ptr和auto_ptr，其中auto_ptr的复制动作，会导致复制对象变为null，容易造成意外的错误，一般推荐使用shared_ptr，其使用引用计数的原理实现对象共享的目的，并且在计数为0时自动释放对象 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:2:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"Summary 已过时，建议去看《Effective Modern c++ Item18 ~ Item22》 思路点其实就是RAII原则 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:2:1","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款14 在资源管理类中小心copying行为 引言 上节是对资源的管理说明。有时候我们不能依赖于shared_ptr或者auto_ptr,所以我们须要自己建立一个资源管理类来管理自己的资源 假设我们使用C API函数处理Mutex互斥器对象： void lock(Mutex* pm); //锁定pm所指的互斥器 void unlock(Mutex* pm); //解除锁定 为了忘记释放锁，我们想要建立一个class来进行资源管理，这里class应该满足RAII守则，即\"资源在构造期间获得，在析构期间释放\" class Lock{ public: explicit Lock(Mutex* pm):mutexPtr(pm){ lock(mutexPtr);//获得资源 } ~Lock(){ unlock(mutexPtr); // 释放资源 } private: Mutex* mutexPtr; }; copying行为 上述例子写的这很不错，但是如果此时Lock对象被复制，会发生什么？ Lock ml1(\u0026m); // 锁定m Lock ml2(ml1); // 将ml1复制到ml2身上 这样做绝对不行，我们不能确定什么时候m2和m1会被析构，一旦被析构就会导致mutex解锁，mutex一旦解锁就会被别的进程所调用，程序将出现巨大的混乱 其实，这不是说一个特定例子，一般的情况是：当一个RAII对象被复制时，应该如何选择，有以下两种做法 禁止复制 如条款06所言：将copying操作声明为private，或者利用c++11新特性 = delete 引用计数 对底层资源使用”reference-count“ 有时候希望保有资源，直到它的最后一个使用者（某对象）被销毁。对Lock打算使用reference counting它可以改变mutexPtr类型，将Mutex*改为tr1::shared_ptr\u003cMutex\u003e，当然这不是我们想要的，我们只是想释放锁，而不是删除锁 幸运的是tr1::shared_ptr运行指定所谓的删除器，那是一个函数或对象，引用次数为0才被调用。删除器对tr1::shared_ptr构造函数而言是可有可无的第二参数，所以代码看起来像这样 class Lock { public: explicit Lock(mutex* pm) : mutexPtr(pm, unlock) { lock(mutexPtr.get()); } private: std::trl::shared_ptr\u003cMutex\u003e mutexPtr; } ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:3:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"Summary 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为 普遍常见的RAII class copying 行为是：禁止复制、施行引用计数法 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:3:1","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款15 资源管理类中提供对原始资源的访问 这里想要将RAIIclass对象进行转换为其内含之原始资源，有两种转换 示例代码 FontHandle getFont(); void releaseFont(FontHandle fh); class Font { public: explicit Font(FontHandle fh) : f(fh) { } ~Font() { releaseFont(f); } FontHanle get() const { return f; } // 显示转换 operator FontHandle() const { return f; } // 隐式转换 private: FontHandle f; }; Font f1(getFont()); FontHanle f2 = f1; 显示转换 提供get()函数得到原始指针 显示调用 很不错 没有啥问题 隐式转换 允许隐式转换，但是会有问题，在客户FontHanle f2 = f1;的时候，并不知道这还有一层隐式转换的逻辑，所以会增加错误率 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:4:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"Summary APIs往往要求访问原始资源，所以每一个RAII class应该提供一个”取得其所管理之资源“的方法 对原始资源的方法可能会经由显式转换或隐式转换 相对而言显式转换比较安全，但是频繁get()很烦人 但隐式转换对用户比较方便 个人觉得是显示调用要好，频繁调用get()又不会死，隐式调用用户如果不告诉他，或者他自己发现，也不会察觉到有一次隐式调用，会增加报错的几率 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:4:1","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款16 new和delete 要使用相同形式 在使用new delete需要使用一致的形势使用，否则会导致内存泄漏 std::string* stringPtr1 = new std::string; std::string* stringPtr2 = new std::string[100]; ... delete stringPtr1; delete[] stringPtr2; 要注意typedef自定义类型 typedef std::string AddressLines[4]; std::string* pal = new AddressLines; // new string[4] delete pal; // undefined!!! delete[] pal; // fine 这个规则对于使用typedef的程序员来说十分重要，因为它意味着typedef的作者必须说清楚：当程序员以new创建该种typedef类型对象是，该以哪一种delete形式删除之，考虑一下这个typedef: 为避免诸如此类错误，尽量不是对数组形式使用typedef操作。这容易达成，因为C++标准程序库含有string vector等templates,可以将数组的需求下降到0 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:5:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"Summary 在使用new delete需要使用一致的形势使用，否则会导致内存泄漏 在typedef自定义类型的时候，一定要注释写着哪一种delete形式删除 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:5:1","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款17 以独立语句将newed对象置入智能指针 有些智能指针类(比如shared_ptr\u003cT\u003e)不支持隐式类型转换,假设存在这样两个函数 void fun(shared_ptr\u003cint\u003e lhs,int rhs); int foo(); 那么对于以下函数调用 fun(new int,foo()); 将不能通过编译,解决方法之一: fun(shared_ptr\u003cint\u003e(new int),foo()); 它共有三个步骤 执行new int 构造shared_ptr\u003cint\u003e 调用foo() 但是由于编译器对于同一语句的各项操作具有重新排列的自由,因此除了执行new int肯定在构造shared_ptr\u003cint\u003e之前外,调用foo(),可以发生在任何阶段,可能在最前,中间,最后,如果是按:执行new int→调用foo()→构造shared_ptr\u003cint\u003e的顺序执行,那么如果foo()发生异常,就会在shared_ptr\u003cint\u003e构造之前造成内存泄露. 对于1出现的问题,可以利用编译器对于\"跨越语句的各项操作\"没有重新排列的权力,以独立语句将newed对象置入智能指针,如下 shared_ptr\u003cint\u003e ptr(new int); fun(ptr,foo); 这样可以防止由于foo在new出的int被放入shared_ptr\u003cint\u003e之前抛出异常而导致内存泄露,但要注意: ptr不是临时对象,也就是说调用fun后ptr管理的内存没有被释放,而ptr的存在并不是为了要访问底层资源,而是为了防止出现异常而造成内存泄露存在的,所以如果不需要ptr所指向的内存,最好调用reset()将它释放.(个人认为这个条款有些鸡肋) ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:6:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了位运算的一些场景","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"位运算 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:0:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"前言 本文分三个部分 有趣的位运算 算法比较常用的 n \u0026 (n - 1) 算法例题 位运算的基本概念 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"位运算符 左移 \u003c\u003c 0011 -\u003e 0110 右移 \u003e\u003e 0110 -\u003e 0011 按位或 | 0011 -----\u003e 1011 1011 按位与 \u0026 0011 -----\u003e 0011 1011 按位取反 ~ 0011 -\u003e 1100 按位异或 ^ 0011 -----\u003e 1000 1011 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"XOR 异或 异或: 相同为0 不同为1 也可用 \"不进位加法\" 来理解 异或操作的一些特点: x ^ 0 = x x ^ 1s = ~x // 注意 1s = ~0 x ^ (~x) = 1s x ^ x = 0 c = a ^ b =\u003e a ^ c = b, b ^ c = a // 交换两个数 a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative 有趣的位运算(一直更新补充) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将x最右边的n位清零 x \u0026 (~0 \u003c\u003c n) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"获取x的第n位值 (0 或者 1) (x \u003e\u003e n) \u0026 1 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:5:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"获取x的第n位的幂值 x \u0026 (1 \u003c\u003c (n - 1)) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:6:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"仅将第n位置为1 x | (1 \u003c\u003c n) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:7:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"仅见第n位置为0 x \u0026 (~(1 \u003c\u003c n)) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:8:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将x最高位至第n位 (含)清零 x \u0026 ((1 \u003c\u003c n) -1) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:9:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将第n位至第0位 x \u0026 (~((1 \u003c\u003c (n-1))-1)) ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:10:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"判断奇偶 x % 2 == 1 ---\u003e (x \u0026 1) == 1 x % 2 == 0 ---\u003e (x \u0026 1) == 0 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:11:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"x » 1 —\u003e x / 2 即 x = x/2; ---\u003e x = x \u003e\u003e 1; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:12:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"得到最低位的1 X \u0026 -X ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:13:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"X \u0026 ~X -\u003e 0 X \u0026 ~X -\u003e 0 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:14:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将英文字符串转为大小写 大写变小写、小写变大写 : 字符 ^= 32; 大写变小写、小写变小写 : 字符 |= 32; 小写变大写、大写变大写 : 字符 \u0026= -33; /* 以上操作能够产生奇特效果的原因在于 ASCII 编码 字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了 */ ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:15:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"判断两个数是否异号 int x = -1, y = 2; bool f = ((x ^ y) \u003c 0); // true int x = 3, y = 2; bool f = ((x ^ y) \u003c 0); // false ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:16:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"交换两个数 int a = 1, b = 2;a ^= b;b ^= a;a ^= b; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:17:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"加1 int n = 1;n = -~n; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:18:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"减1 int n = 2;n = ~-n; // 现在 n = 1 算法常用操作 n\u0026(n-1) 这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:19:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 二进制中的1的个数 LCR 133. 位 1 的个数 - 力扣（LeetCode） 思路详解： `就是让你返回 n 的二进制表示中有几个 1 因为 n \u0026 (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止 int hammingWeight(uint32_t n) { int res = 0; while (n != 0) { n = n \u0026 (n - 1); res++; } return res; } 题目推荐 ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:20:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 插入 题目url 面试题 05.01. 插入 - 力扣（LeetCode） 解题思路 先将N的第i ~ j位全部置零； 在将M左移i位，使之对其上一步中N置零的位，直接相加即可。 示例代码 class Solution { public: int insertBits(int N, int M, int i, int j) { for (int k = i; k \u003c= j; ++ k) { //举例说明： (1 \u003c\u003c 3) 表示 00001000，取反后得 11110111 // N \u0026= (11110111) 表示将 N 的第3位置零了 N \u0026= ~(1 \u003c\u003c k); } return N + (M \u003c\u003c i); } }; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:21:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题2 - 翻转数位 题目url 面试题 05.03. 翻转数位 - 力扣（LeetCode） 方法1 - 位运算 /* 在遍历num每一位时，追踪当前1序列的长度和上一段1序列的长度； 当遇到比特位为0时，分两种情况讨论： 1、若下一个比特位为1，那么preLen = curLen； 2、若下一个比特位为0，那么preLen = 0，我们不能合并这两个1序列 */ class Solution { public: int reverseBits(int num) { if (~num == 0) return 32; //全是1的情况，若不特判会输出33 int curLen = 0, preLen = 0； int maxLen = 1; //最少也能翻转1位 for (int i = 0; i \u003c 32; ++ i) { if ((num \u0026 1) == 1) { curLen ++ ; } else { preLen = ((num \u0026 2) == 0) ? 0 : curLen; //判断下一比特位是否为0 curLen = 0; } maxLen = max(maxLen, preLen + curLen + 1); num \u003e\u003e= 1; } return maxLen; } }; ","date":"2023-03-05","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:22:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了二分查找的概念，思路，及例题","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的思想-减而治之 二分查找通过不断缩小区间的范围来查找目标元素，这种\"不断缩小区间\"就是减而治之的思想 减而治之听起来高大上，其实就是排除法，我们每一次查找就排除掉一些元素，每一次重复此操作，自然就找到了我们的目标元素 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的应用范围 在有序数组中寻找一个目标值，有序和数组是重点 在整数范围内寻找一个目标值，也就是不一定是有序数组，旋转数组和山脉数组都可以用到二分法 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的算法思路 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"在循环体中查找元素 简介 此思路很简单，就是直接在数组中查找到目标元素 时间复杂度 O(log N)，这里的N是指数组的长度 空间复杂度：由于二分查找算法在执行的过程中只使用到常数个临时变量，因此空间复杂度是 O(1)。 代码模板 int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } } ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:1","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"在循环体中排除目标元素一定不存在的区间 简介 这种思路就是一直排除元素不存在的区间，然后剩下来最后一个数 也就是left = right的数，因为这里的循环条件就是while (left \u003c right) {}，最后进行这个数的判断是不是我们的目标数 时间复杂度 O(log N)，这里的N是指数组的长度 空间复杂度：由于二分查找算法在执行的过程中只使用到常数个临时变量，因此空间复杂度是 O(1)。 代码模板 int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } } ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:2","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的重点 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"循环条件 循环条件是一个很重要的东西，我们到底需要用left \u003c= right 还是使用left \u003c right，其实这就是跟思路有关了 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:1","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"取中间数的代码 一般来说我们取中间数都是用(left + right) / 2这么使用如果两个数特别大的时候会造成溢出的，所以我们不能这么用 最好的我们是使用left + (right - left) / 2，这个计算方法很好的避免了溢出这个问题，故二分法要这么去写 其实还有一个利用位运算很帅的一个方法，int mid = (left + right) \u003e\u003e 1; 比如这个代码，大家做个了解即可这是因为整数右移 1 位和除以 2（向下取整）是等价的，这样写的原因是因为位运算比整除运算要快一点。但事实上，高级的编程语言，对于 / 2 和除以 2 的方幂的时候，在底层都会转化成为位运算，我们作为程序员在编码的时候没有必要这么做，就写我们这个逻辑本来要表达的意思即可，这种位运算的写法，在 C++ 代码里可能还需要注意优先级的问题 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:2","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"中间数的代码要不要向上取整 int mid = left + (right - left) / 2中/ 2表示的含义其实是向下取整，如果最后区间位于中间的有两位数，那么只能取到左边的数，那么上取整和下取整有没有啥区别呢，其实是有的，这种区别我们可以在具体的题目中去感悟，哪一个 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:3","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"案例一 - 二分查找 在循环体中查找元素 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c= right) { int mid = (left + right) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } return -1; } }; 在循环体中排除目标元素一定不存在区间 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c right) { int mid = (left + right) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } if (nums[left] == target) { return left; } return -1; } }; ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:5:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"案例二 - 猜数字大小 在循环体中查找元素 class Solution { public: int guessNumber(int n) { int left = 1, right = n; while (left \u003c= right) { int mid = left + (right - left) / 2; if (0 == guess(mid)) { return mid; } if (-1 == guess(mid)) { right = mid - 1; } if (1 == guess(mid)) { left = mid + 1; } } return -1; } }; 在循环体中排除目标元素一定不存在区间 class Solution { public: int guessNumber(int n) { int left = 1, right = n; while (left \u003c right) { int mid = left + (right - left) / 2; if (1 == guess(mid)) { left = mid + 1; } else { right = mid; } } return left; } }; 课后习题 搜索插入位置 在排序数组中查找元素的第一个和最后一个位置 寻找旋转排序数组中的最小值 寻找旋转排序数组中的最小值 II 搜索旋转排序数组 搜索旋转排序数组 II 第一个错误的版本 山脉数组的峰顶索引 山脉数组中查找目标值 寻找两个正序数组的中位数 x 的平方根 寻找重复数 转变数组后最接近目标值的数组和 爱吃香蕉的珂珂 分割数组的最大值 在 D 天内送达包裹的能力 制作 m 束花所需的最少天数 小张刷题计划 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:6:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了双指针的概念及场景和例题","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"双指针 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:0:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"引言 对于数组和链表 来说 “双指针\"其实是一个常用的解法了 双指针也是有很多种类的 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"普通双指针 什么是双指针 双指针模式指使用两个一前一后的指针遍历数据结构，直到某个指针触发停止条件 使用双指针的好处 单指针原本需要平方的时间复杂度，用了双指针便可优化到线性时间复杂度 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"快慢指针 什么是快慢指针 两个速度不同的指针 比如 “fast指针” 跑两格 “slow指针” 跑一格 可以拿龟兔赛跑去想象，在一个圆形赛道，“兔子 -\u003e 快指针” 肯定会追上 “乌龟 -\u003e 慢指针”，龟兔赛跑也经常用在判断链表是否成环上面 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:3:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"左右指针 来讲一讲题外话 其实 快慢指针 也有被说成 左右指针，但是本人认为这么说，其实是相当不合理，在此之上，我便有了一丝 朱光潜老先生的 “咬文嚼字” 的感觉，我始终认为 你给一个方法取名 其实就是代表了 你对这个方法的理解 比如了解什么是左右指针后 你把它叫做 “对撞指针” 也可以 这就是 “1000个读者有1000个哈姆雷特” 所以我也很推荐你们能拥有自己的想法 不要在意别人的命名 就好比 leetcode 题解 就有把快慢指针说为左右指针，你能说他错吗 其实快慢指针 也确实就是一个指针左 一个指针右 什么是左右指针 其实就是一个left指针从最左边向右跑，一个right指针从最右边向左跑 左右指针的代码模板 int left = 0, right = vector.size()-1; while (left \u003c= right) { ... } left, right := 0, len(array)-1 for left \u003c= right { ... } ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:4:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"滑动窗口 什么是滑动窗口 滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口 其实可以把它当成一个队列 如果 窗口要向后滑动 直接把开头去掉即可~ 这只是其中一个实现思想 滑动窗口的应用场景 滑动窗口可解决一系列字符串匹配问题 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:5:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"双指针的应用场景 涉及 数组或链表，成对元素的集合、甚至是子数组 匹配一个「目标」值或是去除重复 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"趣谈 - KMP 另起了一个专题 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:7:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 数组 - 移动零 - 快慢指针 题目url 283. 移动零 - 力扣（LeetCode） 其他例题 26. 删除有序数组中的重复项 - 力扣（LeetCode） 88. 合并两个有序数组 - 力扣（LeetCode） ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:8:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题2 - 数组 - 盛最多水的容器 - 左右指针 题目url 11. 盛最多水的容器 - 力扣（LeetCode） 解题思路 这道题是 “求最优解”, 其实求最优解是 “贪心算法” 和 “动态规划\"的场景, 但是这里也可以用双指针 其他例题 189. 轮转数组 - 力扣（LeetCode） ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:9:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题3 - 链表 - 成环链表 - 快慢指针 题目url 141. 环形链表 - 力扣（LeetCode） 解题思路 成环链表 用 “快慢指针” 真的人人皆知 所以也要留个心眼 学个其他的解法 面试的时候 也是个亮点哦 其他例题 142. 环形链表 II - 力扣（LeetCode） ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:10:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题4 - 链表 - 反转链表 - 双指针 题目url 206. 反转链表 - 力扣（LeetCode） 解题思路 这道题我们可以这么看 1 -\u003e 2 -\u003e null 然后变成 null \u003c- 2 \u003c- 1 在遍历链表时，将当前节点的 next 指针改为指向前一个节点，由于节点没有引用其前一个节点，因此必须事先存储其前一个节点，在更改引用之前，还需要存储后一个节点。最后返回新的头引用 ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:11:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题5 - 字符串 - 无重复字符的最长字串 题目url 3. 无重复字符的最长子串 - 力扣（LeetCode） ","date":"2023-03-04","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:12:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["Effective C++"],"content":"条款5～12 构造/析构/赋值运算","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款5～12 构造/析构/赋值运算 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:0:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款5-了解c++默认生成的函数 前言 这本书其实有点老，该条款有很多东西过时了，所以该条款被 “Effective Modern C++” 条款17 特种成员函数的生成机制 替换 So? 直接去看这个条款吧 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:1:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款6-不想要的特种成员函数，明确禁止编译器自动生成 前言 该条款解决方法 分为两种，一个为\"c++11\"以后的解决方法，一个为\"c++98\" c++11 直接在不想要的特种成员函数 后面 加上 = delete 即可 class HomeForSale { public: HomeForSale(const HomeForSale\u0026) = delete; HomeForSale\u0026 operator=(const HomeForSale\u0026) = delete; } c++98 可以通过私有化 并且 只声明，而不去定义，具体如下述代码 class Uncopyable { protected: Uncopyable() { }; ~Uncopyable() { }; private: Uncopyable(const Uncopyable\u0026); Uncopyable\u0026 operator=(const Uncopyable\u0026); } class HomeForSale : private Uncopyable { ... }; ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:2:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 我们在不想要的特种成员函数，可以通过以下方法来禁止编译器自动生成 c++11 - 在成员函数后面 = delete c++98 - 放在私有数据里，只声明，不定义 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:2:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款7-为多态基类声明virtual析构函数 为多态基类声明virtual析构函数 如果不为多态基类声明virtual析构函数，那么在实例化派生类的时候，则会只调用基类的析构函数，就会造成内存泄漏 class TimeKeeper { public: TimeKeeper(); ~TimeKeeper(); // non-virtual }; class AtomicClock : public TimeKeeper { }; // getTimeKeeper(); 工厂函数，有可能实例化了AtomicClock，所以这时候一个父类的指针指向了子类 TimeKeeper* ptk = getTimeKeeper(); ... // use it delete ptk; // 这个就会出现问题，因为TimeKeeper的析构函数不是虚函数，所以只会用了TimeKeeper基类的析构函数 不是为了多态特性，不要随意声明virtual析构函数 如果不需要多态特性，还会析构函数声明了virtual，那么析构函数会变大，多了虚指针和虚表 类继承时小心父类析构函数不具有多态特性 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:3:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 为多态基类声明virtual析构函数 类继承时小心父类析构函数不具有多态特性 不是为了多态特性，不要随意声明virtual析构函数 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:3:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款8-析构函数不要抛出异常 析构函数不要抛出异常 析构函数抛出异常就代表这个析构函数并没有执行完，可能会造成内存泄漏 避免异常从析构函数抛出的方法 场景描述： class DBConnection { public: static DBConnection FactoryCreate(); // 工厂函数 void close(); // 抛出异常 }; class DBConn { public: ~DBConn() { db.close(); // 这样的话 其实close方法是可能会抛出异常的 } private: DBConnection db; } 发生异常直接终止程序（程序：你清高） DBConn::~DBConn() { try { db.Close(); } catch (...) { // 打印日志 std::abort(); //终止程序 } } 或者就是不终止程序了，直接把错误吞掉，打印好日志 DBConn::~DBConn() { try { db.Close(); } catch (...) { // 打印日志 } } 前两者都无法对\"抛出异常\"做出什么反应,另一个方法是避免异常函数在析构函数内执行,由客户来调用func函数,为避免客户忘记执行,需设立flag标记客户是否调用,如果客户没有调用,在析构函数内调用该函数 class DBConn { public: void close() { db.close(); closed = true; // 如果成功close 就设一个标识符 } ~DBConn() { if (!closed) { try { db.close(); } catch (...) { // make log } } } private: DBConnection db; } ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:4:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 析构函数不要抛出异常，因为抛出异常后，接下来的代码无法运行，就等于说析构没有全部执行，会造成内存泄漏 如果真的抛出异常了，有以下解决方法 记录log，并直接中止程序（想都不用想，其实不太可能） 记录log，直接无视错误，继续执行（其实有点不太好） 增加标志符，将抛出异常的函数交给用户去调用，如果用户没有调用，则在析构中调用，并记录log ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:4:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款9-不要再构造和析构函数中调用virtual函数 不要再构造和析构函数中调用virtual函数 如果在构造函数中调用了virtual函数，在实例化了派生类的时候，构造函数的执行顺序是从内到外，所以他会先调用父类的构造函数，但是父类的构造函数又调用了virtual函数，这时候派生类还没有初始化，所以调用的也只是父类的virtual函数 如果在析构函数中调用了virtual函数，在销毁派生类的时候，析构函数的执行顺序是从外到内的，所以他会先销毁子类，再是父类，但是父类的析构函数又调用了virtual函数，这时候派生类已经被干掉了，所以调用的也只是父类的virtual函数 class Base{ public: Base() { sayHello(); } virtual void sayHello() { std::cout \u003c\u003c \"Hello Base!\" \u003c\u003c std::endl; } virtual void sayBye() { std::cout \u003c\u003c \"Bye Base!\" \u003c\u003c std::endl; } virtual ~Base() { sayBye(); } } class Derived : public Base { Derived() { } void sayHello() override { std::cout \u003c\u003c \"Hello Derived\" \u003c\u003c std::endl; } void sayBye() override { std::cout \u003c\u003c \"Bye Derived\" \u003c\u003c std::endl; } } Derived derived; // 实例化派生类 // 结果 Hello Base! Bye Base! ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:5:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 不要再构造和析构函数中调用virtual函数 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:5:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款10 - operator=返回自身引用 如果不返回自身引用，那么在某些特殊场景 比如下述代码就会出现问题 class Widget { public: void operator=(const Widget\u0026 rhs) { } // return void } Widget w1(1), w2(2), w3(3); w2 = w1 // success w3 = w2 = w1 // 等同于 w3 = (w2 = w1) w3 = w2 = w1 这行先执行了 w2 = w1 然后 就会失败，因为传回来的是一个void 没有办法继续 w3 = 了 所以需要修改为返回自身引用，=要返回 其他的类似+= 也是同理 class Widget { public: Widget\u0026 operator=(const Widget\u0026 ths) { return *this; } Widget\u0026 operator=(int rhs) { return *this; } Widget\u0026 operator+=(const Widget\u0026 ths) { return *this; } } 这么做的目的就是因为要做一个统一的约定，因为w3 = w2 = w1确实是可以的，所以我要做成他们一样 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:6:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 要在 operator = 以及类似操作符 要返回自身引用 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:6:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款11-安全实现赋值运算符 潜在的自我赋值* 自我赋值一个bug：如果类里面有动态内存分配，那么在赋值的时候，需要先delete掉原来的，再new一个新的，最后赋值。但如果是自我赋值，那么在delete掉原来的内存的同时，需要赋的值也被delete了（因为都是同一块内存） 下面是个例子，假设我们有一个Bitmap类，一个Widget类。其中Widget有一个Bitmap的指针 class Bitmap{}; class Widget { public: Widget\u0026 operator=(const Widget\u0026 rhs); private: Bitmap* pb; }; // 防止自我赋值的 Widget\u0026 Widget::operator=(const Widget\u0026 rhs){ delete pb; pb = new Bitmap(*rhs.pb); return *this } 解决这个问题的方法就是在前面加个判断 class Bitmap{}; class Widget { public: Widget\u0026 operator=(const Widget\u0026 rhs); private: Bitmap* pb; }; // 防止自我赋值的 Widget\u0026 Widget::operator=(const Widget\u0026 rhs){ if (this == *rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this } 除此之外还有个问题。如果赋值的时候，new一块新的空间失败了，那么pb会指向一块被delete掉的空间。这样的指针是有害的 Widget\u0026 Widget::operator=(const Widget\u0026 rhs) { Bitmap *tmp = pb; pb = new Bitmap(*rhs.pb); delete tmp; return *this; } 首先上面这个版本申请了一个临时变量保存原始的对象。然后new一个Bitmap并赋值。如果这里出错了，还没到delete，其他的所有东西都保持原样。如果没有出错，则再将原始的空间，通过这个临时变量delete。这就解决了上面的问题 然后它还取消了自我赋值的检测。但是他依然可以处理自我检测问题，假如两个指针指向同一个对象，它也会先创建一个新的副本，赋值以后再删除原来的版本 copy and swap技术 这个技术需要保证swap函数是异常安全的 swap具体实现《条款25》会解释，这里只做了解 异常安全这个概念请去《条款29》深入理解 Widget\u0026 Widget::operator=(const Widget\u0026 rhs) { Widget tmp(rhs); swap(tmp); return this; } ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:7:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 我们在实现赋值运算符的时候 一定要去注意自我赋值 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:7:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款12-复制对象时勿忘其每一个成分 引言* 在深拷贝和浅拷贝的理解中，我们知道了\"拷贝构造函数\"，并且也了解了他的构成 因此，在pass by value的应用场景中，我们可以写出以下的拷贝构造函数 #include \u003ciostream\u003e #include\u003cstring\u003e using namespace std; class A { public: A(int i) : count(i) {}; A(const A\u0026 r) { // 拷贝构造函数 count = r.count; } ~A() {}; void out() { cout \u003c\u003c \"count:\" \u003c\u003c count \u003c\u003c endl; } private: int count; }; int main() { A a(1); A a1(a); // 将a的临时变量传递进去 a1.out(); return 0; } 不要忘记复制每一个成员 在引言的例子里，我们完整将count通过拷贝构造函数复制了过来。如果我们此时有了新需求，需要给类A增加一个成员x，那么在拷贝构造函数中，一定不要忘记拷贝x! #include \u003ciostream\u003e using namespace std; class A { public: A(int i, int j) : count(i),x(j) {}; A(const A\u0026 r) { count = r.count; x = r.x; // 不要忘记赋值成员x! } ~A() {}; void out() { cout \u003c\u003c \"count:\" \u003c\u003c count \u003c\u003c endl; cout \u003c\u003c \"x:\" \u003c\u003c x \u003c\u003c endl; } private: int count; int x; }; int main() { A a(1, 1); A a1(a); a1.out(); return 0; } 值得注意的是：如果我们遗漏了第9行代码，编译器是不会报错的，甚至也能正常运行，但是不会得出想要的结果1 拥有\"显示\"拷贝构造函数发生继承 在上面的A类中， 我们已经针对A写出了显示的拷贝构造函数。但是如果此时发生了继承会怎么样呢？ class B: public A { public: B(int x, int y) : b1(x),b2(y){}; B(const B\u0026 r){ b1 = r.b1; b2 = r.b2; }; ~B() {}; void out() { cout \u003c\u003c \"b1:\" \u003c\u003c b1 \u003c\u003c endl; cout \u003c\u003c \"b2:\" \u003c\u003c b2 \u003c\u003c endl; } private: int b1, b2; }; 简直跟class A一样有木有 于是我们开始编译 B b(2,2); B b1(b); ,会出现以下错误：error C2512: 'CPS' : no appropriate default constructor available 这是为什么呢 在类B的拷贝函数中看起来好像赋值了B中的每一个东西，但是它们复制的只是B声明的成员变量b1,b2;B继承A的成员变量附件完全木有得到复制啊 在创建对象时，会首先调用A类的构造函数。而在B的初始化列表中，并没有显示的对基类的构造函数进行调用。那么，系统会默认调用A的无参构造函数，但是你的A类并没有定义无参构造函数，所以出错了 改法如下 class B: public A { public: B(int x, int y) : b1(x),b2(y), A(x, y) {}; // 调用A的构造函数 B(const B\u0026 r) : A(r.b1, r.b2){ // 调用A的构造函数 b1 = r.b1; b2 = r.b2; }; ~B() {}; void out() { cout \u003c\u003c \"b1:\" \u003c\u003c b1 \u003c\u003c endl; cout \u003c\u003c \"b2:\" \u003c\u003c b2 \u003c\u003c endl; } private: int b1, b2; }; ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:8:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 拷贝函数应该确保复制对象内的所有成员变量及所有的基类成分 不要尝试以某个拷贝函数实现另一个拷贝函数。应该将共同机能放进第三个函数中，并由两个拷贝函数共同调用 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:8:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了时间\u0026空间复杂度的概念及计算","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"时间复杂度 \u0026 空间复杂度 时间复杂度 O(1) 常数复杂度 O(log n) 对数复杂度 O(n) 线性时间复杂度 O(nlogn) 线性对数时间复杂度 O(n ^ 2) 平方 O(n ^ 3) 立方 O(2 ^ n) 指数 O(n!) 阶乘 O(1) \u003c O(logn) \u003c O(n) \u003c O(nlogn) \u003c O(n ^ 2) \u003c O(n ^ 3) \u003c O(2 ^ n) \u003c O(n!) ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:0:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(1) n := 1000 fmt.Println(n) ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(logn) 时间复杂度 O(logn) —对数阶，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标 代码 for i := 1; i \u003c n; i = i * 2 { fmt.Println(i) } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n) for i := 0; i \u003c n; i++ { fmt.Println(i) } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n + m) for i := 0; i \u003c n; i++ { fmt.Println(i) } for j := 0; j \u003c m; j++ { } // O(n + m) ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:4:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(nlogn) 线性对数阶O(nlogn)其实非常容易理解，将对数阶O(logn)的代码循环n遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)，归并排序的复杂度就是O(nlogn) for (int m = 1; m \u003c= n; m++) { int i = 1; while (i \u003c n) { i = i * 2; } } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:5:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n ^ 2) for i := 0; i \u003c n; i++ { for j := 0; j \u003c n; j++ { fmt.Println(i) fmt.Println(j) } } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:6:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(nm) for i := 0; i \u003c n; i++ { for j := 0; j \u003c m; j++ { fmt.Println(i) fmt.Println(j) } } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:7:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(k ^ n) func fib(n int) int { if n \u003c= 0 { return 1 } return n * fib(n - 1) } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:8:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"时间复杂度减少 计算: 1 + 2+ 3 + 4 + 5 + .. + n 方法1: y = 0 for i = 1; i \u003c= n; i++ { y += i } 方法2 求和公式: y = n * (n+1)/2 ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:9:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"图示总结 空间复杂度 ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:10:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"leetcode 常争论的一个点 func test(n int) []int { res := make([]int, 0) res = append(res, n) return res } ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:11:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(1) int i; ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:12:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n) int[] arr; ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:13:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n ^ 2) int[][] arr; ","date":"2023-03-03","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:14:0","tags":["时间/空间复杂度"],"title":"时间/空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"数组-链表-跳表","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"数组-链表-跳表 ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:0:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"数组 数组的特点 当我们申请数组的时候，计算机会在内存开辟一段连续的内存地址，内存管理器可以直接访问每个内存地址，所以我们可以通过\" [ ] “去取值 数组的时间复杂度 select： O(1) insert： O(n) append： O(1) delete： O(n) 数组时间复杂度图示 ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:1:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"链表 引出 研究数据结构的科学家们 看到数组的 “insert” “delete” 就会去想优化这个时间复杂度 随后 链表诞生了 何为链表 非连续的内存空间 有一个个的 节点（node） 组成 node 又是由 value next 组成 value 可以为int string 对象 … 等类型 next 则就是一个指针 指向下一个node 时间复杂度 select: O(n) Append: O(1) insert: O(1) delete: O(1) ps: 不结合实际场景的计算时间复杂度都是耍流氓 图示 ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:2:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"单向链表 时间复杂度 select: O(n) 查询需要从head节点遍历 所以 O(n) insert: O(n) 插入需要从head节点遍历到 插入的前驱节点 所以O(n) delete: O(n) 删除跟插入同理 golang 实现单向链表 type Object interface{} type Node struct { Data Object next *Node } type List struct { size uint64 head *Node tail *Node } func (list *List) Init() { (*list).size = 0 (*list).head = nil (*list).tail = nil } // 向链表追加节点 func (list *List) Append(node *Node) bool { if node == nil { return false } (*node).next = nil // 新加节点在末尾，没有next if (*list).size == 0 { (*list).head = node } else { oldTail := (*list).tail // 取尾结点 (*oldTail).next = node // 尾结点的next指向新加节点 } (*list).tail = node // 新节点是尾结点 (*list).size++ return true } // 向第i个节点处插入节点 func (list *List) Insert(i uint64, node *Node) bool { if node == nil || i \u003e (*list).size || (*list).size == 0 { return false } if i == 0 { (*node).next = (*list).head (*list).head = node } else { preNode := (*list).head for j := uint64(1); j \u003c i; j++ { preNode = (*preNode).next } (*node).next = (*preNode).next // 新节点指向旧节点原来所指的next (*preNode).next = node // 原节点的next指向新节点 } (*list).size++ return true } // 移除指定位置的节点 func (list *List) Remove(i uint64) bool { if i \u003e= (*list).size { return false } if i == 0 { preHead := (*list).head // 取出旧的链表头 (*list).head = preHead.next // 旧链表头的next变为新的头 // 如果仅有一个节点，则头尾节点清空 if (*list).size == 1 { (*list).head = nil (*list).tail = nil } } else { preNode := (*list).head for j := uint64(1); j \u003c i; j++ { preNode = (*preNode).next } node := (*preNode).next // 找到当前要删除的节点 (*preNode).next = node.next // 把当前要删除节点的next赋给其父节点的next,完成后代转移 // 若删除的尾部，尾部指针需要调整 if i == ((*list).size - 1) { (*list).tail = preNode } } (*list).size-- return true } // 移除所有节点 func (list *List) RemoveAll() bool { (*list).Init() return true } // 获取指定位置的节点 func (list *List) Get(i uint64) *Node { if i \u003e= (*list).size { return nil } node := (*list).head for j := uint64(0); j \u003c i; j++ { node = (*node).next } return node } // 搜索某个数据的节点位置 func (list *List) IndexOf(data Object) int64 { pos := int64(-1) node := (*list).head if node.Data == data { return 0 } for j := uint64(1); j \u003c (*list).size; j++ { if node != nil { node = (*node).next if node != nil \u0026\u0026 node.Data == data { pos = int64(j) break } } } return pos } // 取得链表长度 func (list *List) GetSize() uint64 { return (*list).size } // 取得链表头 func (list *List) GetHead() *Node { return (*list).head } // 取得链表尾 func (list *List) GetTail() *Node { return (*list).tail } ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:3:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"双向链表 时间复杂度 select: O(n) 查询需要从head节点遍历 所以 O(n) insert: O(n) 跟单项链表一样 都需要知道前驱node delete: O(n) 同上 append: O(1) golang 实现代码 // 节点数据 type DoubleObject interface{} // 双链表节点 type DoubleNode struct { Data DoubleObject Prev *DoubleNode Next *DoubleNode } // 双链表 type DoubleList struct{ mutex *sync.RWMutex Size uint Head *DoubleNode Tail *DoubleNode } // 双链表初始化 func (list *DoubleList)Init() { list.mutex = new(sync.RWMutex) list.Size = 0 list.Head = nil list.Tail = nil } // Get 获取指定位置的节点 func (list *DoubleList)Get(index uint) *DoubleNode { if list.Size == 0 || index \u003e list.Size - 1 { return nil } if index == 0{ return list.Head } node := list.Head var i uint for i = 1; i \u003c= index; i ++{ node = node.Next } return node } // Append 向双链表后面追加节点 func (list *DoubleList)Append(node *DoubleNode) bool { if node == nil{ return false } list.mutex.Lock() defer list.mutex.Unlock() if list.Size == 0 { list.Head = node list.Tail = node node.Next = nil node.Prev = nil } else { node.Prev = list.Tail node.Next = nil list.Tail.Next = node list.Tail = node } list.Size++ return true } // Insert 向双链表指定位置插入节点 func (list *DoubleList)Insert(index uint, node *DoubleNode) bool { if index \u003e list.Size || node == nil{ return false } if index == list.Size{ return list.Append(node) } list.mutex.Lock() defer list.mutex.Unlock() if index == 0{ node.Next = list.Head list.Head = node list.Head.Prev = nil list.Size++ return true } nextNode := list.Get(index) node.Prev = nextNode.Prev node.Next = nextNode nextNode.Prev.Next = node nextNode.Prev = node list.Size++ return true } // Delete 删除指定位置的节点 func (list *DoubleList) Delete (index uint) bool { if index \u003e list.Size - 1 { return false } list.mutex.Lock() defer list.mutex.Unlock() if index == 0 { if list.Size == 1{ list.Head = nil list.Tail = nil } else { list.Head.Next.Prev = nil list.Head = list.Head.Next } list.Size-- return true } if index == list.Size - 1{ list.Tail.Prev.Next = nil list.Tail = list.Tail.Prev list.Size-- return true } node := list.Get(index) node.Prev.Next = node.Next node.Next.Prev = node.Prev list.Size-- return true } ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:4:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"跳表 引出 对于一组有序数据，我们想要在其中查找某个数，如果数据使用数组存储，显然二分法是再适合不过了，但是如果数据是用链表存储的呢？难道我们用从头遍历吗？这样时间复杂度会达到O（n）级别，相比二分法O（logn）级别简直天壤地别。那么如何提高效率呢 跳表 算法有两个很重要的思想 空间换时间 升维 跳表其实就是链表采用了升维的思想 如下图，对初始链表做一层“索引”，每两个节点提取一个节点到上一层，然后用down指针连接到下一层。 现在我们查询16这个节点。从第一级索引开始，找到13，并且下一个为17，显然16在这两个节点之间，利用down指针下降一层，这次我们遍历2次即可。利用索引后，遍历了5+2=7次，而原始链表需要10次，这里加一层索引遍历次数减少了，效率提高了一点，但还不够，我们继续往上添加索引层 ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:5:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["Effective C++"],"content":"条款1～4 让自己习惯c++","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款1～4 让自己习惯c++ ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:0:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款1-视c++为一个语言联邦 视c++为一个语言联邦 C Object-Oriented C++ Template C++ The STL ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:1:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"Summary 我们想要学习c++，一定就得学这4个，分别是c，c++的面向对象等特性，c++模板编程/泛型编程，STL ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:1:1","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款2-尽量不使用#define #define定义常量 #define定义常量的缺点 #define ASPECT_RATIO 1.653，#define是不会添加到符号表的，所以当跟ASPECT_RATIO有关报错的时候，不会提示ASPECT_RATIO出了问题，不利于报错排查 替换手段 可以拿const double AspectRatio = 1.653;来进行替换#define 在类中也可以拿static来定义\"常量\" class GamePlayer { private: static const int NumTurns = 5; int scores[NumTurns]; } 但是要注意 在编译的时候这个是通过的，但是如果你在后面对他有取地址之类的操作，链接就会报错，因为这里只是声明，并没有给他分配内存空间，所以还需要在cpp处理一下即可 const int GamePlayer::NumTurns; #define定义宏 #define定义宏的缺点 其实在inline专题有提到，#define定义宏，太麻烦了，只因他是直接替换的效果，最经典就是计算平方问题 #define CALL_WITH_MAX(a, b) f((a) \u003e (b) ? (a) : (b)) 替换手段 可以拿inline函数去进行替换 template\u003ctypename T\u003e inline void callWithMax(const T\u0026 a, const T\u0026 b) { f(a \u003e b ? a : b); } ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:2:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"Summary #define由于各个的因素，比如安全性，使用性，不太咋滴，所以尽量不使用#define 常量可以由const或者static替换 复杂的宏计算表达式就用inline替换 ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:2:1","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款3-尽量使用const 修饰指针 修饰指针一定要区分好，const pointer and const data char greeting[] = \"Hello\"; char* p = greeting; // non-const pointer, non-const data const char* p = greeting; // non-const pointer, const data char* const p = greeting; // const pointer, non-const data const char* const p = greeting; // const pointer, const data void f1(const Widget *pw); // f1 takes a pointer to a constant Widget object void f2(Widget const *pw); // so does f2 修饰 STL-iterator 修饰STL-iterator所带来的好处就是可以控制 iterator指向的值或者iterator本身是否被修改，同时这也是红黑树，map，set控制修改iterator指向的值的秘诀 std::vector\u003cint\u003e vec; // ... const auto iter = vec.begin(); // iter acts like a T* const *iter = 10; // OK, changes what iter pointer to ++iter; // error! iter is const auto cIter = vec.cbegin(); // cIter acts like a const T* *cIter = 10; // error! cIter is const ++cIter; // fine, changes cIter 将某些东西声明为const可以帮助编译器侦测出错误用法 在函数返回值修饰的好处就是可以保证一些低级的错误，如下述代码 class Rational { ... } const Rational operator * (const Rational\u0026 lhs, const Rational\u0026 rhs); Ration a, b, c; // ... (a * b) = c; // 这是没有错的，但是我们这么写很少 几乎没有 我们一般会把这个(a * b) = c; 加个 if判断，变成if (a * b == c) {...}，但是如果我们手抖，写成了if (a * b = c) 这个就是赋值了，但是编译器不会报错，但是我们在返回参数加了一个 const，就能够报错 将#define定义常量 修改为const也是可以帮助编译器侦测出错误类型 bitwise constness \u0026\u0026 logical constness 编译器强制实行bitwise constness(又称physical constness,物理上的常量性,即成员函数不更改对象的任何一个bit时才可以说是const),例如 class TextBlock{ public: ... char\u0026 operator [](std::size_t position) const{ return pText[position]; } private: char* pText; } 编译器认定它是bitwise constness的,但是它却允许以下代码的存在 const TextBlock cctb(\"Hello\"); char* pc=\u0026cctb[0]; *pc='J'; 这是由于只有pText是cctb的一部分,其指向的内存并不属于cctb 程序员编写程序时应该使用conceptual constness(概念上的常量性或logical constness,逻辑上的常量性,即一个const成员函数可以处理它所修改的对象的某些bits,但只有在客户端侦测不出的情况下才得如此) 例如对于某些特殊类,其中的某些成员的值注定是要改变的,因此可以用mutable关键字修饰,从而实现即使对象被设定为const,其特定成员的值仍然可以改变的效果.此时该类符合conceptual constness而不符合bitwise constness. 下述代码即就是上一句话的代码解释，在客户端的角度来说，他这个值是不修改的 class CTextBlock { public: std::size_t length() const; private: char* pText; mutable std::size_t textLength; mutable bool lengthThisVaild; }; std::size_t CTextBlock::length() const { if (!lengthThisVaild) { textLength = std::strlen(pText); lengthThisVaild = true; } return textLength; } 函数重载 如果参数是引用,可以基于参数是否为const实现函数重载(也可以基于指针是否为const实现函数重载),特殊的,对于成员函数,因为它存在一个隐含的this指针参数,因而可以基于函数是否为const实现重载 class TextBlock { public: const char\u0026 operator[](std::size_t position) const { return text[position]; } char\u0026 operator[](std::size_t position) { return text[position]; } private: std::string text; } TextBlock tb(\"hello\"); std:cout \u003c\u003c tb[0]; // calls non-const TextBlock::operator[] const TextBlock ctb(\"hello\"); std:cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[] 避免const和非const成员函数中的重复 class TextBlock { public: const char\u0026 operator[](std::size_t position) const { ... // 检查 ... // 打印日志 return text[position]; } char\u0026 operator[](std::size_t position) { ... // 检查 ... // 打印日志 return text[position]; } } 看上述代码 很明显 他们有重复代码，所以我们要抽出来，因为这样更好维护，代码如下 class TextBlock{ public: ... const char\u0026 operator[](std::size_t position) const{ ... return text[position]; } char operator[](std::size_t position){ return const_cast\u003cchar\u0026\u003e(static_cast\u003cconst TextBlock\u0026\u003e(*this)[position]); } ... }; 可以看出,经过了两次类型转换 第一次通过static_cast将*this转为const TextBlock\u0026，以确保调用的是operator[]的const版本，否则会调用非const版本导致递归调用造成栈溢出 第二次通过const_cast去掉const版本的opsrator[]返回的const char\u0026的const特性以与函数的返回类型相匹配 对于const_cast的行为之前存在一些误解,对于以下代码 #include\u003ciostream\u003e using std::cout; using std::endl; int main(){ const int a = 5; int\u0026 rta = const_cast \u003c int\u0026\u003e(a) ; rta = 6; cout \u003c\u003c \"a: \" \u003c\u003c a \u003c\u003c \" rtr: \" \u003c\u003c rta \u003c\u003c endl; cout \u003c\u003c \"\u0026a: \" \u003c\u003c \u0026a \u003c\u003c \" \u0026rta: \" \u003c\u003c \u0026rta; system(\"pause\"); return 0; } 输出结果如下 可见虽然const_cast表面上改变了变量的const性质,但a的值实际上还是没有改变(编译器仍然背着我们干了不少事),所以const_cast的实际用途并不是改变const对象的值,而是\"暂时\"去除对象的const属性使其可以作为参数传入非const函数,企图通过const_cast改变const对象的值可能会导致未预料的结果.因此个人认为5中的第二段代码(出自Effective C++ “条款3 尽可能用const”)存在一些错误,如有错误欢迎批评指正！ ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:3:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"Summary const可以修饰指针，要注意区分修饰指针 const int* i = 1; non-const-pointer / const-data int* const i = 1; const pointer / non-const-data const int* const i = 1; const pointer / const-data const可以用来修饰STL中的iterator 一定要知道红黑树下的map，set的key不可修改就是因为 const iterator const安全性比某些东西更高 没错 某些东西说的就是#define bitwise constness \u0026\u0026 logical constness 关于这个你只需要记住程序员编写程序时应该使用logical constness（概念上的常量性，逻辑上的常量性） 即一个const成员函数可以处理它所修改的对象的某些bits,但只有在客户端侦测不出的情况下才得如此 说简单点，就是在客户的角度上看，不需要修改其任何值，我们就必须使用const进行标注，但是在内部其实是修改了值的 如果参数是引用,可以基于参数是否为const实现函数重载(也可以基于指针是否为const实现函数重载),特殊的,对于成员函数,因为它存在一个隐含的this指针参数,因而可以基于函数是否为const实现重载 实现const重载时，我们可以利用static_cast const_cast来去除冗余代码 ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:3:1","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款4-对象使用前应该被初始化 class的成员变量总是以其声明的次序被初始化 在下述代码中，我们虽然在构造函数的初始化列表中先初始化了b_，再是a_，但是实际上是以声明的次序被初始化，也就是先初始化 a_，在初始化b_ class C { public: C(std::string aName, int bValue) : b_(bValue), a_(aName, b_.v_) { } private: A a_; // 不展示A class了 B b_; // 不展示B class了 } 类类型的构造函数对于成员按:基类成员→派生类类类型成员(按声明顺序)→派生类内置类型成员(按声明顺序)的顺序进行初始化. 构造函数成员初始化列表优于函数体赋值 Foo函数如下 随后我们来看看 不用构造函数的初始化列是什么情况 class Test { public: explicit Test(const Foo\u0026 foo) { foo_ = foo; } private: Foo foo_; } int main() { Foo foo(1, \"foo1\"); Test test(foo); return 0; } 我们来看看不用构造函数的初始化列 到底做了什么 最后我们再来看看用了构造函数的初始化列，形成一个对比 class Test { public: explicit Test(const Foo\u0026 foo) : foo_(foo) { } private: Foo foo_; } 我们也是很明显的发现 使用初始化列 明显性能要高于 不使用初始化列，不使用初始化列要先两次构造函数了，然后一步调用拷贝赋值，而使用初始化列只做了一个构造函数和一次拷贝构造函数 非局部变量的初始化顺序替换为函数运用结合 既然被替换了，那么肯定被替换者有什么问题，那我们来好好瞧瞧 接下来场景为多文件场景，有两个文件，分别是 “init_before_user.cpp”, “init_before_user1.cpp” // init_before_user.cpp #include \"foo.h\" Foo globalFoo(123, \"globalFoo\") int main() { printf(\"===main===\\n\"); } // init_before_user1.cpp #include \"foo.h\" extern Foo globalFoo; class Bar { public: explicit Bar(Foo \u0026foo) { printf(\"Bar(const Foo\u0026)foo.a=%d\\n\", foo.a); } }; Bar bar(globalFoo); 如果我们使用cmake add_executable(init_before_use init_before_use.cpp init_befor_user1.cpp ) 就会发现Bar的foo.a的值是不对的，这是因为初始化文件的顺序是会影响初始化的顺序的 add_executable(init_before_use init_befor_user1.cpp init_before_use.cpp ) 这样就正常了，但是这样我们肯定是不愿意看到的，坑非常大 通过函数运用去解决 // init_before_user.cpp #include \"foo.h\" Foo\u0026 globalFoo() { static Foo globalFoo(123, \"globalFoo\"); return globalFoo; } int main() { printf(\"===main===\\n\"); } // init_before_user1.cpp #include \"foo.h\" extern Foo\u0026 globalFoo(); class Bar { public: explicit Bar(Foo\u0026 foo) { printf(\"Bar(const Foo\u0026)foo.a=%d\\n\", foo.a); } }; Bar bar(globalFoo); 这样解决就不存在之前说的初始化的问题 ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:4:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"Summery 类的成员变量的初始化顺序不是取决于初始化列表的顺序，而是声明的顺序 我们要尽量使用构造函数的初始化列表 因为这里才是真正的初始化，在函数体中那叫赋值 对于类类型,降低了程序效率，对于内置类型在初始化列表还是在函数体内初始化对于效率没有影响 在某些特殊情况(例如const变量和引用)必须在初始化列表进行初始化 非局部变量，比如全局变量，他会存在cmake的文件顺序来决定初始化顺序 所以使用函数来解决此问题 ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:4:1","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["算法 \u0026 数据结构"],"content":"栈\u0026队列","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"栈/队列/双端队列/优先队列 什么是队列 队列是一个 先进先出 的数据结构 先进来的元素 先被消费使用 好比排队 第一个排队的人肯定第一个出来 这就是先进先出 队列有两种重要的方法 - push（往队列的尾部塞入元素）/ pop（往队列的头部删除元素） 什么是栈 栈是一个 先进后出 的数据结构 先进来的元素 最后一个被消费使用 / 最后进来的元素 第一个被消费使用 好比一个箱子 你往里面放书 第一个书本在最下面 你只能第一时间拿出最上面的书 也就是最后放进去的书 栈有两种重要的方法 - push（往栈的尾部塞入元素）/ pop（往栈的尾部删除元素） 什么是双端队列 是一种具有队列和栈性质的数据类型 双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行 什么是优先级队列 依靠每个元素的优先级 来决定哪一个最先被消费使用 golang 如何实现队列 及其 他的时间复杂度是多少 insert：O(1) delete: O(1) // A FIFO queue. type Queue []int // 往队列的尾部塞入元素 func (q *Queue) Push(v int) { *q = append(*q, v) } // pop（往队列的头部删除元素） func (q *Queue) Pop() int { head := (*q)[0] *q = (*q)[1:] return head } // Returns if the queue is empty or not. func (q *Queue) IsEmpty() bool { return len(*q) == 0 } golang 如何实现栈 及其 他的时间复杂度是多少 insert: O(1) delete: O(1) type Stack []interfice{} func (stack Stack) Len() int { return len(stack) } func (stack Stack) Cap() int { return cap(stack) } func (stack *Stack) Push(value interface{}) { *stack = append(*stack, value) } func (stack Stack) Top() (interface{}, error) { if len(stack) == 0 { return nil, errors.New(\"Out of index, len is 0\") } return stack[len(stack) - 1], nil } func (stack *Stack) Pop() (interface{}, error) { theStack := *stack if len(theStack) == 0 { return nil, errors.New(\"Out of index, len is 0\") } value := theStack[len(theStack) - 1] *stack = theStack[:len(theStack) - 1] return value, nil } func (stack Stack) IsEmpty() bool { return len(stack) == 0 } 不要仅限于固定思想 实现栈 和 队列的方式千千万万 用两个栈实现队列 https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/ ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:0:0","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"布隆过滤器","date":"2023-03-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/","tags":["布隆过滤器"],"title":"布隆过滤器","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"categories":["算法 \u0026 数据结构"],"content":"布隆过滤器 ","date":"2023-03-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/:0:0","tags":["布隆过滤器"],"title":"布隆过滤器","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"categories":["算法 \u0026 数据结构"],"content":"布隆过滤器 引出 对于hashtable，我们存放一个数据，会先进行哈希取模，然后决定放在哪一个桶，随后就会把这个数据放进🪣中，对于哈希表来说，存放的数据是准备完整的 我们再来想一个场景，如果我们不需要完整的数据，我们只是想判断一个这个数据到底存不存在，这个时候哈希表其实不太适合，其实可以做到的，但是终归不是完美适合这个场景 所以我们需要一个更高效的数据结构 布隆过滤器 他lei了 什么是布隆过滤器 他是一个很长的 二进制向量 和 一系列随机映射函数 布隆过滤器可以用于检索一个元素是否在一个集合中 布隆过滤器的优点 空间效率和时间效率是远远超过一般的数据结构 布隆过滤器的缺点 有一定的误别率和删除困难 布隆过滤器的图示 布隆过滤器的误别 布隆过滤器的 golang实现 package main import ( \"fmt\" \"github.com/bits-and-blooms/bitset\" ) //设置哈希数组默认大小为16 const DefaultSize = 16 //设置种子，保证不同哈希函数有不同的计算方式 var seeds = []uint{7, 11, 13, 31, 37, 61} //布隆过滤器结构，包括二进制数组和多个哈希函数 type BloomFilter struct { // 使用第三方库 set *bitset.BitSet // 指定长度为6 hashFuncs [6]func(seed uint, value string) uint } //构造一个布隆过滤器，包括数组和哈希函数的初始化 func NewBloomFilter() *BloomFilter { bf := new(BloomFilter) bf.set = bitset.New(DefaultSize) for i := 0; i \u003c len(bf.hashFuncs); i++ { bf.hashFuncs[i] = createHash() } return bf } //构造6个哈希函数，每个哈希函数有参数seed保证计算方式的不同 func createHash() func(seed uint, value string) uint { return func(seed uint, value string) uint { var result uint = 0 for i := 0; i \u003c len(value); i++ { result = result*seed + uint(value[i]) } //length = 2^n 时，X % length = X \u0026 (length - 1) return result \u0026 (DefaultSize - 1) } } //添加元素 func (b *BloomFilter) add(value string) { for i, f := range b.hashFuncs { //将哈希函数计算结果对应的数组位置1 b.set.Set(f(seeds[i], value)) } } //判断元素是否存在 func (b *BloomFilter) contains(value string) bool { //调用每个哈希函数，并且判断数组对应位是否为1 //如果不为1，直接返回false，表明一定不存在 for i, f := range b.hashFuncs { //result = result \u0026\u0026 b.set.Test(f(seeds[i], value)) if !b.set.Test(f(seeds[i], value)) { return false } } return true } func main() { filter := NewBloomFilter() filter.add(\"asd\") fmt.Println(filter.contains(\"asd\")) // true fmt.Println(filter.contains(\"2222\")) // fmt.Println(filter.contains(\"155343\")) } ","date":"2023-03-02","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/:1:0","tags":["布隆过滤器"],"title":"布隆过滤器","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了树的概念及种类","date":"2023-03-02","objectID":"/tree/","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"树 ","date":"2023-03-02","objectID":"/tree/:0:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"树 引出 当我们在刷算法的时候 当中有个思路就是空间换时间，因为在如今科技发达的社会 硬件已经很牛逼了，所以相比较，时间更为重要 还有个思路就是 升维这个思想，链表其实就是一维，跳表就是二维，将链表升维后 时间复杂度也从 O(n) 优化到了 O(logn) 树也是一样的 通过链表升维而诞生的一个数据结构 树的定义 二维数据结构 常见的二维数据结构 - 树 / 图 树和图的差别就是在于有没有环，环就是指 树有一个节点指向其他的节点 形成一个环 链表就是特殊的树，因为有树在极端的情况下 类似链表 树就是特殊的图，没有环的图就是树 树的实现代码 type TreeNode struct { val int left *TreeNode right *TreeNode } class TreeNode: def __init__(self, val): self.val = val self.left, self.right = None, None struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(NULL), right(NULL) } ","date":"2023-03-02","objectID":"/tree/:1:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"二叉树 什么是二叉树 二叉树就是每个节点都只有两个子节点 当然也会有三叉树这样的存在 ","date":"2023-03-02","objectID":"/tree/:2:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"二叉搜索树 什么是二叉搜索树 只需要满足以下特征的就是二叉搜索树 左子树所有节点都小于子树根节点 右子树所有节点大于子树根节点 以此类推，左右子树都分别满足这个性质 ","date":"2023-03-02","objectID":"/tree/:3:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"树的遍历 def preorder(self, root): # 前序遍历 if root: self traverse_path.append(root.val) self preorder(root.left) self preorder(root.right) def inorder(self, root): # 中序遍历 二叉搜索树中序遍历一定升序的 if root: self inorder(root.left) self traverse_path.append(root.val) self inorder(root.right) def postorder(self, root): if root: self postorder(root.left) self postorder(root.right) self traverse_path.append(root.val) func preorderTraversal(root *TreeNode) (res []int) { // 前序遍历 根-左-右 var preorder func(node *TreeNode) preorder = func(node *TreeNode) { if node == nil { return } res = append(res, node.Val) preorder(node.Left) preorder(node.Right) } preorder(root) return res } func inorderTraversal(root *TreeNode) (res []int) { // 中序遍历 左-根-右 var inorder func(node *TreeNode) inorder = func(node *TreeNode) { if node == nil { return } inorder(node.Left) res = append(res, node.Val) inorder(node.Right) } inorder(root) return res } func postorderTraversal(root *TreeNode) (res []int) { // 后序遍历 左-右-根 var postorder func(node *TreeNode) postorder = func(node *TreeNode) { if node == nil { return } postorder(node.Left) postorder(node.Right) res = append(res, node.Val) } postorder(root) return res } class Solution { // 前序遍历 public: void preorder(TreeNode* root, vector\u003cint\u003e \u0026res) { if (root == nullptr) return; res.push_back(root-\u003eval); preorder(root-\u003eleft, res); preorder(root-\u003eright, res); } vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; preorder(root, res); return res; } }; class Solution { // 中序遍历 public: void inorder(TreeNode* root, vector\u003cint\u003e \u0026res) { if (root == nullptr) return; inorder(root-\u003eleft, res); res.push_back(root-\u003eval); inorder(root-\u003eright, res); } vector\u003cint\u003e inorderTraversal(TreeNode* root) { vector\u003cint\u003e res; inorder(root, res); return res; } }; class Solution { // 后序遍历 public: void postorder(TreeNode* root, vector\u003cint\u003e\u0026 res) { if (root == nullptr) return; postorder(root-\u003eleft, res); postorder(root-\u003eright, res); res.push_back(root-\u003eval); } vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e res; postorder(root, res); return res; } }; ","date":"2023-03-02","objectID":"/tree/:4:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"树的遍历 - 题目推荐 /* https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/ 二叉树的前序遍历 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/ 二叉树的中序遍历 https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/ 二叉树的后序遍历 */ /* https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/ 验证二叉搜索树 https://leetcode-cn.com/problems/invert-binary-tree/submissions/ 翻转二叉树 */ ","date":"2023-03-02","objectID":"/tree/:5:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"平衡二叉搜索树 引出 树的时间复杂度经过升维的思想 从链表的O(n) 变成了 O(logn)，这个“n” 就是树的高度 但是在极端的树的情况会变成一个链表，时间复杂度会从O(logn) 退化成 O(n)，如下图 ***所以 维护一个树的平衡是很重要的，所以平衡二叉搜索树它lei了 *** 什么是平衡二叉搜索树 没有过深的左右子树 相对来说他们是平衡的 所以为了平衡 在insert delete操作要去动态的维持平衡 平衡二叉搜索树的种类 AVL / 红黑树 / b-tree / b+ tree ","date":"2023-03-02","objectID":"/tree/:6:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"AVL 什么是AVL树 AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis AVL 有一个概念是平衡因子（balance factor），是他的左子树高度减去右子树的高度（相反亦此） balance factor = { -1, 0, 1 } AVL又可以叫做 高度平衡二叉搜索树 他在insert delete操作时通过旋转来进行平衡 AVL的缺点 他的查询效率很快 但是他每个节点都要存储额外信息，且调整次数频繁 AVL示例图 AVL的四种旋转 ","date":"2023-03-02","objectID":"/tree/:7:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"红黑树 引出 我们已经了解了AVL这个高度平衡二叉搜索树，也已经知道他的缺点，所以红黑树又lei了 什么是红黑树 红黑树是一种近似平衡二叉搜索树 他的特点是保证任何一个节点的左右子树的高度差小于两倍 红黑树的五大特点 每个节点要么是黑色，要么是红色 根节点一定是黑色 每个叶节点（nil节点）是黑色 不能有相邻的两个红色节点 从任意节点出发到其每个叶节点的所有路径都包含相同数目的黑色节点 重点在于 不能有相邻的两个红色节点 从任意节点出发到其每个叶节点的所有路径都包含相同数目的黑色节点 保证了任何一个节点的左右子树的高度差小于两倍 红黑树图示 红黑树与AVL的对比 AVL更适合查询 因为他更平衡 / 红黑树只是近似平衡* 红黑树更适合插入 因为他插入的时候 不需要像avl那样时刻保持平衡 他只需要满足两倍差即可 ","date":"2023-03-02","objectID":"/tree/:8:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"字典树 什么是字典树 字典树 即trie树，又称前缀树，是一种树形结构 典型应用是用于统计和排序大量的字符串(但不仅限于字符串) 所以经常被搜索引擎系统用于文本词频统计 字典树的基本性质 节点本身不存完整的单词 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个节点的所有子节点路径代表的字符都不相同 字典树图示 Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起，比如我们有[\"hello\",\"her\",\"hi\",\"how\",\"see\",\"so\"] 这个字符串集合 golang实现字典树 // Trie 树结构 type Trie struct { root *trieNode // 根节点指针 } // Trie 树节点 type trieNode struct { char string // Unicode 字符 isEnding bool // 是否是单词结尾 children map[rune]*trieNode // 该节点的子节点字典 } // 初始化 Trie 树 func NewTrie() *Trie { // 初始化根节点 trieNode := NewTrieNode(\"/\") return \u0026Trie{trieNode} } // 初始化 Trie 树节点 func NewTrieNode(char string) *trieNode { return \u0026trieNode{ char: char, isEnding: false, children: make(map[rune]*trieNode), } } // 往 Trie 树中插入一个单词 func (t *Trie) Insert(word string) { node := t.root // 获取根节点 for _, code := range word { // 以 Unicode 字符遍历该单词 value, ok := node.children[code] // 获取 code 编码对应子节点 if !ok { // 不存在则初始化该节点 value = NewTrieNode(string(code)) // 然后将其添加到子节点字典 node.children[code] = value } // 当前节点指针指向当前子节点 node = value } node.isEnding = true // 一个单词遍历完所有字符后将结尾字符打上标记 } // 在 Trie 树中查找一个单词 func (t *Trie) Find(word string) bool { node := t.root for _, code := range word { value, ok := node.children[code] // 获取对应子节点 if !ok { // 不存在则直接返回 return false } // 否则继续往后遍历 node = value } if node.isEnding == false { return false // 不能完全匹配，只是前缀 } return true // 找到对应单词 } ","date":"2023-03-02","objectID":"/tree/:9:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了缓存中的一种 LRU","date":"2023-03-01","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/","tags":["LRU-Catch"],"title":"LRU-Catch","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/"},{"categories":["算法 \u0026 数据结构"],"content":"LRU Catch ","date":"2023-03-01","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/:0:0","tags":["LRU-Catch"],"title":"LRU-Catch","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/"},{"categories":["算法 \u0026 数据结构"],"content":"LRU Catch 什么是LRU Catch LRU是最近最少使用策略的缩写，是根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高” 我们可以用 双向链表去实现 LRU Catch LRU Catch 图示 golang 实现 LRU Catch type Node struct { Key int Value int pre *Node next *Node } type LRUCache struct { limit int HashMap map[int]*Node head *Node end *Node } func Constructor(capacity int) LRUCache{ lruCache := LRUCache{limit:capacity} lruCache.HashMap = make(map[int]*Node, capacity) return lruCache } func (l *LRUCache) Get(key int) int { if v,ok:= l.HashMap[key];ok { l.refreshNode(v) return v.Value }else { return -1 } } func (l *LRUCache) Put(key int, value int) { if v,ok := l.HashMap[key];!ok{ if len(l.HashMap) \u003e= l.limit{ oldKey := l.removeNode(l.head) delete(l.HashMap, oldKey) } node := Node{Key:key, Value:value} l.addNode(\u0026node) l.HashMap[key] = \u0026node }else { v.Value = value l.refreshNode(v) } } func (l *LRUCache) refreshNode(node *Node){ if node == l.end { return } l.removeNode(node) l.addNode(node) } func (l *LRUCache) removeNode(node *Node) int{ if node == l.end { l.end = l.end.pre l.end.next = nil }else if node == l.head { l.head = l.head.next l.head.pre = nil }else { node.pre.next = node.next node.next.pre = node.pre } return node.Key } func (l *LRUCache) addNode(node *Node){ if l.end != nil { l.end.next = node node.pre = l.end node.next = nil } l.end = node if l.head == nil { l.head = node } } ","date":"2023-03-01","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/:1:0","tags":["LRU-Catch"],"title":"LRU-Catch","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了哈希表","date":"2023-03-01","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/","tags":["哈希表"],"title":"哈希表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/"},{"categories":["算法 \u0026 数据结构"],"content":"hashtable ","date":"2023-03-01","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/:0:0","tags":["哈希表"],"title":"哈希表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/"},{"categories":["算法 \u0026 数据结构"],"content":"hashtable 什么叫hashtable 哈希表也叫做散列表，是根据关键码值而直接进行访问的数据结构 他通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度 这个映射函数叫做散列函数，存放的记录叫做哈希表 hashtable的时间复杂度 ***search：*O(1) ***Insertion：*O(1) ***Deletion：*O(1) 但是我们如果了解什么是哈希冲突 以及拉链法解决哈希冲突，那么在哈希表很小并且冲突很多的情况下，时间复杂度会退化成链表O(n) hashtable的原理和golang的map实现 图示 ","date":"2023-03-01","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/:1:0","tags":["哈希表"],"title":"哈希表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/"},{"categories":["算法 \u0026 数据结构"],"content":"hashtable例题 // https://leetcode.cn/problems/reverse-linked-list/ // https://leetcode.com/problems/swap-nodes-in-pairs // https://leetcode.com/problems/linked-list-cycle // https://leetcode.com/problems/linked-list-cycle-ii ","date":"2023-03-01","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/:2:0","tags":["哈希表"],"title":"哈希表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/"},{"categories":["缘起 在人群中 我看见你"],"content":"如何理解协程","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"如何理解协程? ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:0:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"普通的函数 我们先来看看普通的函数，从简到繁嘛 def func(): print(\"a\") print(\"b\") print(\"c\") 这是一个简单的函数，当我们调用这个函数的时候会发生啥? 调用func func开始执行，直到return func执行完毕，返回函数A 是不是很简单，函数func执行直到返回，并打印出：“a, b, c” ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:1:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"从普通函数到协程 协程是可以有多个返回点的，这是什么意思呢？ void func() { print(\"a\") 暂停并返回 print(\"b\") 暂停并返回 print(\"c\") } 普通函数下，只有当执行完print(“c”)这句话后函数才会返回，但是在协程下当执行完print(“a”)后func就会因“暂停并返回”这段代码返回到调用函数 有的同学可能会一脸懵逼，这有什么神奇的吗？我写一个return也能返回，就像这样 void func() { print(\"a\") return print(\"b\") 暂停并返回 print(\"c\") } 直接写一个return语句确实也能返回，但这样写的话return后面的代码都不会被执行到了 协程之所以神奇就神奇在当我们从协程返回后还能继续调用该协程，并且是从该协程的上一个返回点后继续执行 这时我们就可以返回到调用函数，当调用函数什么时候想起该协程后可以再次调用该协程，该协程会从上一个返回点继续执行 这个暂停并返回 在编程语言中一般叫做yield(其它语言中可能会有不同的实现，但本质都是一样的) 需要注意的是，当普通函数返回后，进程的地址空间中不会再保存该函数运行时的任何信息，而协程返回后，函数的运行时信息是需要保存下来的，那么函数的运行时状态到底在内存中是什么样子呢，关于这个问题你可以参考这里 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:2:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"Show Me The Code 下面我们采用python来讲解一个例子，不用担心看不懂，在python中，同样使用yield，这样我们的函数就变成了 def func() { print(\"a\") yield print(\"b\") yield print(\"c\") } 注意，这时候这个函数就不再是简简单单的函数了，而是升级成为了协程，然后我们该怎么使用呢 def A(): co = func() # 得到该协程 next(co) # 调用协程 print(\"in function A\") # do something next(co) # 再次调用该协程 我们看到虽然func函数没有return代码，也就是说虽然没有返回任何值，但是我们依然可以写co = func()这样的代码，意思是说co就是我们拿到的协程了 我们来看一看这个代码做的事情 我们调用该协程，使用next(co)，运行A函数看看执行到第三行的结果是什么? a 显然，和我们预期的一样，协程在print(\"a\")后因执行yield而暂停并返回函数A 接下来是第4行，这个毫无疑问，A函数在做一些自己的事情，因此会打印 a in function A 接下来是重点的一行，当执行第5行再次调用协程时该打印什么呢 a in function A b 看到了吧，协程是一个很神奇的函数，它会自己记住之前的执行状态，当再次调用时会从上一次的返回点继续执行 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:3:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"图形化解释 为了让你更加彻底的理解协程，我们使用图形化的方式再看一遍，首先是普通的函数调用 在该图中，方框内表示该函数的指令序列，如果该函数不调用任何其它函数，那么应该从上到下依次执行，但函数中可以调用其它函数，因此其执行并不是简单的从上到下，箭头线表示执行流的方向 从图中我们可以看到，我们首先来到funcA函数，执行一段时间后发现调用了另一个函数funcB，这时控制转移到该函数，执行完成后回到main函数的调用点继续执行 这是普通的函数调用 接下来是协程 在这里，我们依然首先在funcA函数中执行，运行一段时间后调用协程，协程开始执行，直到第一个挂起点，此后就像普通函数一样返回funcA函数，funcA函数执行一些代码后再次调用该协程，注意，协程这时就和普通函数不一样了，协程并不是从第一条指令开始执行而是从上一次的挂起点开始执行，执行一段时间后遇到第二个挂起点，这时协程再次像普通函数一样返回funcA函数，funcA函数执行一段时间后整个程序结束 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:4:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"函数只是协程的一种特例 怎么样，神奇不神奇，和普通函数不同的是，协程能知道自己上一次执行到了哪里。 现在你应该明白了吧，协程会在函数被暂停运行时保存函数的运行状态，并可以从保存的状态中恢复并继续运行。 很熟悉的味道有没有，这不就是操作系统对线程的调度嘛，线程也可以被暂停，操作系统保存线程运行状态然后去调度其它线程，此后该线程再次被分配CPU时还可以继续运行，就像没有被暂停过一样。 只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见 这就是为什么有的人说可以把协程理解为用户态线程的原因 也就是说现在程序员可以扮演操作系统的角色了，你可以自己控制协程在什么时候运行，什么时候暂停，也就是说协程的调度权在你自己手上。 在协程这件事儿上，调度你说了算。 当你在协程中写下yield的时候就是想要暂停该协程，当使用next()时就是要再次运行该协程。 现在你应该理解为什么说函数只是协程的一种特例了吧，函数其实只是没有挂起点的协程而已 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:5:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"协程是如何实现的 让我们从问题的本质出发来思考这个问题，协程的本质是什么 其实就是可以被暂停以及可以被恢复运行的函数 好比NBA比赛被暂停，但是也可以继续比赛，因为比赛状态被记录了下来，这里的状态就是上下文-context 协程之所以可以被暂停也可以继续，那么一定要记录下被暂停时的状态，也就是上下文，当继续运行的时候要恢复其上下文(状态)，那么接下来很自然的一个问题就是，函数运行时的状态是什么？ 这个关键的问题的答案就在《函数运行起来后在内存中是什么样子的》这篇文章中，函数运行时所有的状态信息都位于函数运行时栈中 函数运行时栈就是我们需要保存的状态，也就是所谓的上下文，如图所示： 从图中我们可以看出，该进程中只有一个线程，栈区中有四个栈帧，main函数调用了A，A调用了B，B调用了C，当C函数在运行时整个进程的状态就如图所示 现在我们已经知道了函数的运行时状态就保存在栈区的栈帧中，接下来重点来了哦 既然函数的运行时状态保存在栈区的栈帧中，那么如果我们想暂停协程的运行就必须保存整个栈帧的数据，那么我们该将整个栈帧中的数据保存在哪里呢？ 很显然，这就是堆区啊，heap，我们可以将栈帧保存在堆区中，那么我们该怎么在堆区中保存数据呢？希望你还没有晕，在堆区中开辟空间就是我们常用的C语言中的malloc或者C++中的new 我们需要做的就是在堆区中申请一段空间，让后把协程的整个栈区保存下，当需要恢复协程的运行时再从堆区中copy出来恢复函数运行时状态 再仔细想一想，为什么我们要这么麻烦的来回copy数据呢？ 实际上，我们需要做的是直接把协程的运行需要的栈帧空间直接开辟在堆区中，这样都不用来回copy数据了，如图所示 从图中我们可以看到，该程序中开启了两个协程，这两个协程的栈区都是在堆上分配的，这样我们就可以随时中断或者恢复协程的执行了 有的同学可能会问，那么进程地址空间最上层的栈区现在的作用是什么呢？ 这一区域依然是用来保存函数栈帧的，只不过这些函数并不是运行在协程而是普通线程中的 现在你应该看到了吧，在上图中实际上有3个执行流： 一个普通线程 两个协程 虽然有3个执行流但我们创建了几个线程呢？ 一个线程 现在你应该明白为什么要使用协程了吧，使用协程理论上我们可以开启无数并发执行流，只要堆区空间足够，同时还没有创建线程的开销，所有协程的调度、切换都发生在用户态，这就是为什么协程也被称作用户态线程的原因所在 因此即使你创建了N多协程，但在操作系统看来依然只有一个线程，也就是说协程对操作系统来说是不可见的 现在你应该对协程有一个清晰的认知了吧 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:6:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"函数运行时在内存中是什么样子? ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:0:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"引言 在进入到本章的内容前，我们来思考思考几个问题 void f(int a) { if (a \u003e 10000000) return; int arr[100] = { 0 }; f(a+1); } 你能看出这段代码有啥问题吗 你知道协程的本质吗？有的同学可能会说是用户态线程，那么用户态线程是怎么实现的？ 函数运行起来后在内存中是什么样子？ 这几个问题看起来没什么关联，但是背后都指向一个东西，这就是所谓函数运行栈（run time stack） ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:1:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"从进程、线程到函数调用 举个小例子，汽车在高速上行驶时有很多信息，比如速度、位置，通过这些信息我们可以直观的感受汽车的运行时状态 同样的，程序在运行时也有很多信息，像有哪些程序正在运行、这些程序执行到了哪里等等，通过这些信息我们可以直观的感受系统中程序运行的状态 其中，我们创造了进程、线程这样的概念来记录有哪些程序正在运行 进程和线程的运行体现在函数执行上，函数的执行除了函数内部执行的顺序执行还有子函数调用的控制转移以及子函数执行完毕的返回。其中函数内部的顺序执行乏善可陈，重点是函数的调用 因此接下来我们的视角将从宏观的进程和线程拉近到微观下的函数调用，重点来讨论一下函数调用是怎样实现的 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:2:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"函数执行的活动轨迹：栈 也是一样，举个小例子，玩过游戏的同学应该知道，有时你为了完成一项主线任务不得不去打一些支线的任务，支线任务中可能还有支线任务，当一个支线任务完成后退回到前一个支线任务 主线任务A - 西天取经 支线任务B - 收服🐒 支线任务D - 拿到紧箍咒 支线任务C - 收服🐷 也就是说，我们必须支线任务B和支线任务C完成后，才能继续完成主线任务A 想要完成支线任务B 就必须完成支线任务D-拿到紧箍咒 整个任务的依赖关系如图所示： 然后，我们来模拟模拟任务完成过程 首先，我们来到任务A，执行主线任务 执行任务A的过程中我们发现任务A依赖任务B，这时我们暂停任务A去执行任务B 执行任务B的时候，我们又发现依赖任务D 执行任务D的时候我们发现该任务不再依赖任何其它任务，因此C完成后我们可以会退到前一个任务，也就是B 任务B除了依赖任务C外不再依赖其它任务，这样任务B完成后就可以回到任务A 现在我们回到了主线任务A，依赖的任务B执行完成，接下来是任务C 和任务D一样，C不依赖任何其它其它任务，任务C完成后就可以再次回到任务A，再之后任务A执行完毕，整个任务执行完成 让我们来看一下整个任务的活动轨迹 仔细观察，实际上你会发现这是一个 “First In Last Out” 的顺序，天然适用于栈这种数据结构来处理。 再仔细看一下栈顶的轨迹，也就是A、B、D、B、A、C、A，实际上你会发现这里的轨迹就是任务依赖树的遍历过程，是不是很神奇，这也是为什么树这种数据结构的遍历除了可以用递归也可以用栈来实现的原因。 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:3:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"A Box 函数调用也是同样的道理，你把上面的ABCD换成函数ABCD，本质不变 因此，我们知道了，使用栈这种结构就可以用来保存函数调用信息 和游戏中的每个任务一样，当函数在运行时每个函数也要有自己的一个\"小盒子\"，这个小盒子中保存了函数运行时的各种信息，这写小盒子通过栈这种结构组织起来，这个小盒子就被称为\"栈帧（stack frames）\"，也有的称之为 call stack 不管用什么命名，总之，就是这里所说的小盒子，这个小盒子就是函数运行起来后占用的内存，这些小盒子构成了我们通常所说的栈区 那么问题也就来了，函数调用时都有哪些信息呢 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:4:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"控制转移 我们知道当函数A调用函数B的时候，控制从A转移到了B，所谓控制其实就是指CPU执行属于哪个函数的指令，CPU从开始执行属于函数A的指令切换到执行属于函数B的指令，我们就说控制从函数A转移到了函数B 控制从函数A转移到了函数B，我们需要有这两个信息 我从哪里来（返回） 要到哪里去（跳转） 好比你出去旅游，你需要知道去哪里，还需要记住回家的路（写到这里我想起来 哲学的三大问题 我是谁，我从哪里来，要到哪里去。笑死，其实函数也一样要问自己这三个问题，人的智慧其实就是会仿生，无论什么东西都是充斥的模仿的艺术，好比tree数据结构，不是吗?） 好，回归正题，函数调用也是一样的道理，当函数A调用函数B，我们只要知道 函数A对于的机器指令执行到了哪里（我从哪里来） 函数B第一条机器指令所在的地址（要到哪里去） 那么这些信息是怎么获取并保持的呢，现在我们就可以打开这个小盒子，来看看怎么玩的 假设函数A调用函数B，如图所示 当前，CPU执行函数A的机器指令，该指令的地址为0x400564，接下来CPU将执行下一条机器指令也就是 call 0x400540 这条机器指令对应的就是我们在代码中所写的函数调用，注意call后有一条机器指令地址，注意观察上图你会看到，该地址就是函数B的第一条机器指令，从这条机器指令后CPU将跳转到函数B 现在我们已经解决了控制跳转的“要到哪里去”问题，当函数B执行完毕后怎么跳转回来呢？ 原来，call指令除了给出跳转地址之外还有这样一个作用，也就是把call指令的下一条指令的地址，也就是0x40056a push到函数A的栈帧中，如图所示 现在，函数A的小盒子变大了一些，因为装入了返回地址 现在CPU开始执行函数B对应的机器指令，注意观察，函数B也有一个属于自己的小盒子(栈帧)，可以往里面扔一些必要的信息 如果函数B中又调用了其它函数呢？道理和函数A调用函数B是一样的 让我们来看一下函数B最后一条机器指令ret，这条机器指令的作用是告诉CPU跳转到函数A保存在栈帧上的返回地址，这样当函数B执行完毕后就可以跳转到函数A继续执行了 至此，我们解决了控制转移中“我从哪里来”的问题 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:5:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"传递参数与获取返回值 函数调用与返回使得我们可以编写函数，进行函数调用。但调用函数除了提供函数名称之外还需要传递参数以及获取返回值，那么这又是怎样实现的呢？ 在x86-64中，多数情况下参数的传递与获取返回值是通过寄存器来实现的 假设函数A调用了函数B，函数A将一些参数写入相应的寄存器，当CPU执行函数B时就可以从这些寄存器中获取参数了 同样的，函数B也可以将返回值写入寄存器，当函数B之行结束后函数A从该寄存器中就可以读取到返回值了 但是，我们都知道寄存器的数量是有限的，当传递的参数多于寄存器的数量该怎么办 这时候，小盒子也就是栈帧，又是他发挥作用的时候到了 原来，当参数个数多于寄存器数量时剩下的参数直接放到栈帧中，这样被调函数就可以从前一个函数的栈帧中获取到参数了 现在栈帧的样子又可以进一步丰富了，如图所示： 从图中我们可以看到，调用函数B时有部分参数放到了函数A的栈帧中，同时函数A栈帧的顶部依然保存的是返回地址 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:6:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"局部变量 我们知道在函数内部定义的变量被称为局部变量，这些变量在函数运行时被放在了哪里呢 原来，这些变量同样可以放在寄存器中，但是当局部变量的数量超过寄存器的时候这些变量就必须放到栈帧中了 因此，我们的栈帧内容又一步丰富了 细心的同学可能会有这样的疑问，我们知道寄存器是共享资源可以被所有函数使用，既然可以将函数A的局部变量写入寄存器，那么当函数A调用函数B时，函数B的局部变量也可以写到寄存器，这样的话当函数B执行完毕回到函数A时寄存器的值已经被函数B修改过了，这样会有问题吧 这样的确会有问题，因此我们在向寄存器中写入局部变量之前，一定要先将寄存器中开始的值保存起来，当寄存器使用完毕后再恢复原值就可以了 那么我们要将寄存器中的原始值保存在哪里呢？ 没错 还是栈帧 最终，我们的小盒子就变成了如图所示的样子，当寄存器使用完毕后根据栈帧中保存的初始值恢复其内容就可以了 现在你应该知道函数在运行时到底是什么样子了吧，以上就是问题3的答案 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:7:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"Big Picture 需要再次强调的一点就是，上述讨论的栈帧就位于我们常说的栈区 栈区，属于进程地址空间的一部分，如图所示，我们将栈区放大就是图左边的样子 关于栈区详细的讲解你可以参考《深入理解操作系统：程序员应如何理解内存（未完待续）》这篇。 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:8:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"问题1 最后，让我们回到文章开始的这段简单代码 void func(int a) { if (a \u003e 100000000) return; int arr[100] = {0}; func(a + 1); } void main(){ func(0); } 想一想这段代码会有什么问题？ 原来，栈区是有大小限制的，当超过限制后就会出现著名的栈溢出问题，显然上述代码会导致这一问题的出现 因此我们要注意 不要创建过大的局部变量 函数栈帧，也就是调用层次不能太多 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:9:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"总结 本章我们从几个看似没什么关联的问题出发，详细讲解了函数运行时栈是怎么一回事，为什么我们不能创建过多的局部变量 细心的同学会发现第2个问题我们没有解答，这个问题的讲解可以在《如何理解协程》中理解 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:10:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"线程共享了哪些进程资源","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"线程到底共享了哪些进程资源? ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:0:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"引言 鲁迅经常说这样一句话：“反过来想，总是反过来想”，如果你对线程之间共享了哪些进程资源这个问题想不清楚的话那么也可以反过来思考，那就是有哪些资源是线程私有的 鲁迅：我真的说过这一句话吗? ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:1:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"线程私有资源 线程运行的本质其实就是函数的执行，函数的执行总会有一个源头，这个源头就是所谓的入口函数，CPU从入口函数开始执行从而形成一个执行流，只不过我们人为的给执行流起一个名字，这个名字就叫线程 既然线程运行的本质就是函数的执行，那么函数执行都有哪些信息呢？ 在《函数运行时在内存中是什么样子》这篇文章中我们说过，函数运行时的信息保存在栈帧中，栈帧中保存了函数的返回值、调用其它函数的参数、该函数使用的局部变量以及该函数使用的寄存器信息 如图所示，假设函数A调用函数B 此外，CPU执行指令的信息保存在一个叫做程序计数器的寄存器中，通过这个寄存器我们就知道接下来要执行哪一条指令。由于操作系统随时可以暂停线程的运行，因此我们保存以及恢复程序计数器中的值就能知道线程是从哪里暂停的以及该从哪里继续运行了 由于线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此每个线程都有自己独立的、私有的栈区 同时函数运行时需要额外的寄存器来保存一些信息，像部分局部变量之类，这些寄存器也是线程私有的，一个线程不可能访问到另一个线程的这类寄存器信息 所以我们知道了什么是线程私有资源 栈区 程序计数器 栈指针 函数运行使用的寄存器 以上这些信息有一个统一的名字，就是线程上下文(thread context) 我们也说过操作系统调度线程需要随时中断线程的运行并且需要线程被暂停后可以继续运行，操作系统之所以能实现这一点，依靠的就是线程上下文信息 除此之外，剩下的都是线程间共享资源，我们来看一下剩下的资源 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:2:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"代码区 进程地址空间中的代码区，这里保存的是什么呢？从名字中有的同学可能已经猜到了，没错，这里保存的就是我们写的代码，更准确的是编译后的可执行机器指令 那么这些机器指令又是从哪里来的呢？答案是从可执行文件中加载到内存的，可执行程序中的代码区就是用来初始化进程地址空间中的代码区的 线程之间共享代码区，这就意味着程序中的任何一个函数都可以放到线程中去执行，不存在某个函数只能被特定线程执行的情况 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:3:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"数据区 进程地址空间中的数据区，这里存放的就是所谓的全局变量 char c; // 全局变量 void func() { } 在程序员运行期间，也就是run time，数据区中的全局变量有且仅有一个实例，所有的线程都可以访问到该全局变量 但是要注意，c/c++里面有static void func(){ static int a = 10; } 注意到，虽然变量a定义在函数内部，但变量a依然具有全局变量的特性，也就是说变量a放在了进程地址空间的数据区域，即使函数执行完后该变量依然存在，而普通的局部变量随着函数调用结束和函数栈帧一起被回收掉了，但这里的变量a不会被回收，因为其被放到了数据区 这样的变量对每个线程来说也是可见的，也就是说每个线程都可以访问到该变量 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:4:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"堆区 堆区是程序员比较熟悉的，我们在C/C++中用malloc或者new出来的数据就存放在这个区域，很显然，只要知道变量的地址，也就是指针，任何一个线程都可以访问指针指向的数据，因此堆区也是线程共享的属于进程的资源 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:5:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"栈区 唉，等等！刚不是说栈区是线程私有资源吗，怎么这会儿又说起栈区了？ 确实，从线程这个抽象的概念上来说，栈区是线程私有的，然而从实际的实现上看，栈区属于线程私有这一规则并没有严格遵守，这句话是什么意思？ 通常来说，注意这里的用词是通常，通常来说栈区是线程私有，既然有通常就有不通常的时候 不通常是因为不像进程地址空间之间的严格隔离，线程的栈区没有严格的隔离机制来保护，因此如果一个线程能拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量 这从某种程度上给了程序员极大的便利，但同时，这也会导致极其难以排查到的bug。 试想一下你的程序运行的好好的，结果某个时刻突然出问题，定位到出问题代码行后根本就排查不到原因，你当然是排查不到问题原因的，因为你的程序本来就没有任何问题，是别人的问题导致你的函数栈帧数据被写坏从而产生bug，这样的问题通常很难排查到原因，需要对整体的项目代码非常熟悉，常用的一些debug工具这时可能已经没有多大作用了 说了这么多，那么同学可能会问，一个线程是怎样修改本属于其它线程的数据呢？ 接下来我们用一个代码示例讲解一下 void thread(void* var) { int* p = (int*)var; *p = 2; } int main() { int a = 1; pthread_t tid; pthread_create(\u0026tid, NULL, thread, (void*)\u0026a); return 0; } 这段代码是什么意思呢？ 首先我们在主线程的栈区定义了一个局部变量，也就是 int a= 1这行代码，现在我们已经知道了，局部变量a属于主线程私有数据，但是，接下来我们创建了另外一个线程 在新创建的这个线程中，我们将变量a的地址以参数的形式传给了新创建的线程，然后我来看一下thread函数 在新创建的线程中，我们获取到了变量a的指针，然后将其修改为了2，也就是这行代码，我们在新创建的线程中修改了本属于主线程的私有数据 现在你应该看明白了吧，尽管栈区是线程的私有数据，但由于栈区没有添加任何保护机制，一个线程的栈区对其它线程是可以见的，也就是说我们可以修改属于任何一个线程的栈区 就像我们上文说得到的，这给程序员带来了极大便利的同时也带来了无尽的麻烦，试想上面这段代码，如果确实是项目需要那么这样写代码无可厚非，但如果上述新创建线程是因bug修改了属于其它线程的私有数据的话，那么产生问题就很难定位了，因为bug可能距离问题暴露的这行代码已经很远了，这样的问题通常难以排查 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:6:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"动态链接库 进程地址空间中除了以上讨论的这些实际上还有其它内容，还有什么呢？ 这就要从可执行程序说起了。 什么是可执行程序呢？在Windows中就是我们熟悉的exe文件，在Linux世界中就是ELF文件，这些可以被操作系统直接运行的程序就是我们所说的可执行程序。 那么可执行程序是怎么来的呢？ 有的同学可能会说，废话，不就是编译器生成的吗？ 实际上这个答案只答对了一半。 假设我们的项目比较简单只有几个源码文件，编译器是怎么把这几个源代码文件转换为最终的一个可执行程序呢？ 原来，编译器在将可执行程序翻译成机器指令后，接下来还有一个重要的步骤，这就是链接，链接完成后生成的才是可执行程序。 完成链接这一过程的就是链接器。 其中链接器可以有两种链接方式，这就是静态链接和动态链接。 静态链接的意思是说把所有的机器指令一股脑全部打包到可执行程序中，动态链接的意思是我们不把动态链接的部分打包到可执行程序，而是在可执行程序运行起来后去内存中找动态链接的那部分代码，这就是所谓的静态链接和动态链接。 动态链接一个显而易见的好处就是可执行程序的大小会很小，就像我们在Windows下看一个exe文件可能很小，那么该exe很可能是动态链接的方式生成的。 而动态链接的部分生成的库就是我们熟悉的动态链接库，在Windows下是以DLL结尾的文件，在Linux下是以so结尾的文件。 说了这么多，这和线程共享资源有什么关系呢？ 原来如果一个程序是动态链接生成的，那么其地址空间中有一部分包含的就是动态链接库，否则程序就运行不起来了，这一部分的地址空间也是被所有线程所共享的。 也就是说进程中的所有线程都可以使用动态链接库中的代码 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:7:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"文件 最后，如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:8:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["网络原理"],"content":"TCP\u0026UDP","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP/UDP 传输层 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:0:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"传输层的定义 传输层是第一次在端对端也就是主机对主机的一层 专门负责处理上层的数据 负责可靠不可靠的传输 传输层下层是使用 mac 和 ip 地址来寻找到特定主机 但是光凭 mac ip 可不够,还要需要端口, 也是在这一层 有了端口的概念 这一层的数据单位称为数据段 TCP ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:1:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 概念 \u0026 流控制 TCP是 面向有链接 协议, 因为他是 流控制，也被称作流式协议 流控制： 接收端告诉发送端 我这边可以接收多少数据 发送端也跟接收端确认少数据 取最小值 将数据切割 TCP是可靠协议 他有一系列的方法来实现可靠性 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:2:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 序列号 \u0026 应答机制 引出： TCP是一个可靠协议 所以TCP需要各种方法来保证他的可靠性 解决： 发送端发送数据后 接收端接收成功 会发送一个ACK应答 缺点 万一ACK发送失败 发送端就会一直发送数据 这是一个问题 优化： 引入 序列号 机制 为每一个数据都打上一个序列号 ACK也算一个序列号 接收端收到数据后, 就会分析她下一次应该接收数据的序列号 然后以ACK应答出去 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:3:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 重发超时 RTT 与 RTO RTT 和 RTO的概念 TCP作为一个面向有连接型的协议，需要保证其可靠性 所以其内部实现了一个重传计时器 每发送一个数据包，就给这个数据设置一个重传计时器, 如果在计时器超时之前收到了针对这个数据包的ack，就取消这个计时器。如果没有收到，则开始发起重传。计时器超时的时间被称为RTO，这个时间的确定取决于RTT 关于两者详细的解释 RTT(Round Trip Time): 一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值 RTO(Retransmission Time Out): 重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传 RTT的测量 每发送一个分组 TCP就会对其采样，这个采样只会对同一时间的数据段进行采样, 随后用这个采样记录当作RTT 采样方法一般有两种 采用时间戳： 发送一个数据段时在TCP选项中记录下时间 收到数据段再记录下时间 随后计算出差值 就把这个差值作为RTT 但是需要发送端和接收端都需要支持这个选项 重传队列中数据包的TCP控制块： 每个数据包第一次发送出去后都会放到重传队列中，数据包中的TCP控制块包含着一个变量，tcp_skb_cb-\u003ewhen，记录了该数据包的第一次发送时间。如果没有时间戳选项，那么RTT就等于当前时间和when的差值 RTO的计算 为了避免单次RTT波动，计算RTO时新引入了变量SRTT，表示更加平滑的RTT数值，它的计算方法： SRTT = x(SRTT) + (1 - x)RTT; // x被称为平滑因子，一般建议设置在[0.8, 0.9]，意思是SRTT值百分之八十来自于之前的值，百分之二十来自于当前值。 计算RTO的方法为： RTO = min(ubound, max(lbound, y(SRTT))); // y 是时延离散因子，推荐值为[1.3, 2.0]，ubound是RTO的上边界，lbound是RTO的下边界 算法的缺点 在RTT波动较大时，RTO不能明显适应网络变化 标准方法 标准方法引入了平均偏差的概念，它类似于统计学里面的方差，但是因为方差的计算过程代价较大，对于快速TCP来说不太适合。假设rtt的值为M，RTO的计算方式为： srtt = (1 - g)srtt + g(M); rttval = (1 - h)rttval + h(|M - rttval|); RTO = srtt + 4(rttval); /* 其中`g`设置为1/8，`h`设置为`1/4` 对srtt而言，它有1/8取决于当前值，7/8取决于现有值 当RTT变化时，偏差增量越大，RTO的增量也越大 */ ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:4:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 三次握手 第一次握手 SYN = 1，seq = x 客户端发送一个 SYN标志为1，指明客户端打算连接的服务器端口，以及初始的序列号为随机生成的 x 的一个TCP包 发送完成后，客户端进入 SYN_SEND状态 第二次握手 SYN = 1，ACK = 1，seq = y，ACKNum = x+1 服务端发回 SYN=1 ACK=1，并且ACK也算一个序列号+1 所以ACKNum是 x+1，随后再把自己要发送的数据标上序列号，序列号变成了 y 的一个TCP包 服务端发送完毕后 进入 SYN_RECV状态 第三次握手 ACK = 1，ACKNum = y+1 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕 客户端进入 ESTABLISH状态，服务端接收到这个包后 也进入ESTABLISH状态，TCP握手结束 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:5:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 四次挥手 第一次挥手 FIN = 1, seq = x 假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己像断开连接 没有数据可以发送了，但是仍然可以接收数据 发送完毕后，客户端进入 FIN_WAIT_1 状态 第二次挥手 ACK = 1 ACKNum = x + 1 服务端接受到了客户端想要断开的链接的请求，便发出了一个ACK标志位为1的TCP包，表明自己接收到了请求，但还没有准备好关闭连接 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到了这个确认包之后，进入 FIN_WAIT_2的状态，等待服务端关闭连接 第三次挥手 FIN=1，seq=y 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK 第四次挥手 ACK = 1，ACKNum = y + 1 客户端接收到来自服务器端的关闭请求，发送一个确认包 客户端发送完包并进入 TIME_WAIT 状态，等待可能出现的要求重传的ACK包 服务端接收到这个确认包后，关闭连接，进入CLOSED状态 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:6:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"为什么需要3次握手 挥手需要4次 3次握手目的是要确定客户端和服务端通信也就是两边的“收”“发”功能是否正常 第一次握手: 客户端发送网络包 服务器收到了 这个时候服务端就能确定客户端的\"发\" 和 服务端的 “收” 都没有问题 第二次握手: 服务端发送 这个时候客户端就能确定 客户端的 “发收” 服务端的 “收发” 是没有问题的 但是服务端还没有确定 第三次握手: 客户端发包 这个时候服务端就能确定 服务端的 “发收” 客户端的 “收发” 是没有的问题的 所以综上所述 两次握手是没有办法确定 双方的通信能力是否正常 至少也要三次 4次挥手目的是要数据接收完毕 不能在数据没有接受完全就直接关闭了连接TCP连接是双向传输的对等的模式, 就是说双方都可以同时向对方发送或接受数据 第一次挥手: 当有一方要关闭连接时，会发送指令告知对方 我们要close连接 第二次挥手: 对方回一个ack应答 此时一个方向的连接关闭 但是！另一个方向仍然可以继续传输数据 等到数据发送完 就进行第三次挥手 第三次挥手: 发送FIN段 第四次挥手: 回ACK应答 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:7:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 以段为单位发送数据 什么是段 在三次握手的期间发送端会告诉接受端 我一次性能发送多少数据接受端也会告诉发送端 我一次性能接受多少数据随后发送端就会把全部数据切割为最小值 发送出去 这个最小值为段 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:8:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 窗口控制 引出 当我们以段为单位 一次发送数据 随后又得等待ack 这样包的往返效率很慢 所以tcp采用了滑动窗口来优化 什么是窗口控制 滑动窗口就是我们设置窗口值 在没超够窗口值的前提下 不用等待ack的应答 就可以发送段数据 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:9:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 重发控制 引出 当我们利用窗口来发送数据 如果有数据丢失怎么办 ACK丢失 如有几个ack应答丢失是没有关系的 因为剩下的ack会到达发送端 所以一对比单个段发送的效率 窗口的性能还是蛮高的 段丢失 如果段数据丢失了 接受端会一直返回相对应的序列号的ack应答 如果发送端一直接受同样的ack三次 就会进行重发 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:10:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 拥塞窗口 引出 计算机网络都处在一个共享的环境。 因此也有可能会因为其他主机之间的通信会造成网络拥堵。如果在网络拥堵的时候 发送一个较大量的数据包 会可能导致整个网络的瘫痪 什么是拥塞窗口 TCP在通信一开始的时候会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制 首先，为了在发送端调节要发送数据的量,定义了一个叫做 “拥塞窗口” 的概念 在慢启动的时候，将这个窗口调节为1个数据段发送数据，随后没收到一个ack就进行+=1 在发送数据的时候 也会将其拥塞窗口的大小和接受端的窗口对比 取其最小值 然后发送比这个最小值还小一点的数据 上述解决办法会出现的问题 随着包的往返，拥塞窗口也会以 1 2 4 等指数函数增长，拥堵状况激增甚至导致拥塞的发生 慢启动阈值他也就来了 慢启动阈值 只要拥塞窗口的值超过这个范围，则每一次收到ack，只允许下面这种比例放大拥塞窗口 1个数据段的字节数 / 拥塞窗口(字节) X 1个数据段字节数 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:11:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 连接状态 CLOSED: 初始状态 LISTEN: 服务器处于监听状态 SYN_SEND: 客户端socket执行CONNECT连接，发送syn包 进入此状态 SYN_RECV: 服务端收到SYN包并发送服务端SYN包，进入此状态 ESTABLISH: 表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接 收到ACK包后进入此状态 FIN_WAIT_1: 终止连接的一方发送了FIN报文后进入,等待对方FIN CLOSE_WAIT: 假设服务器)接收到客户机FIN包之后等待关闭的阶段。在接收到 对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本 方是否立即断开连接(发送FIN包)取决于是否还有数据需要发送给客户端，若有， 则在发送FIN包之前均为此状态 FIN_WAIT_2: 此时是半连接状态, 既有一方要求关闭连接，等待另一方关闭，客户端接收到服务端的ACK包，但并没有接收到服务端的FIN包，进入FIN_WAIT_2状态 LAST_ACK: 服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。 TIME_WAIT: 客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之 后的2MSL时间称为TIME_WAIT状态。 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:12:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 首部格式 源端口号 发送方的应用端口 占16位 目标端口号 接受端的应用端口 占16位 序列号 占32位 发送端会在发送数据的每个字节上标上序号 不一定每一个序列号都是0, 1开始的 这个序列号是随机的 会在syn包也就是第一次握手 告诉接受端 syn包 \u0026 fin包 \u0026 ACK 都是一个字节 确认应答号 占32位 收到数据后 会返回下一次应该收到的序列号信息作为确认应答 这个确认应答也就代表着 前面的数据我都收到了的意思 偏移量 tcp首部长度 保留 占4位 主要是为了以后扩展用的 一般都是0 控制位 字段长为8位, 当它们对应位上的值为1 就会有特殊作用 三次握手, 四次挥手 ack 该位为1时, 确认应答的字段变为有效, tcp规定除了最开始的syn包外, 必须为1 syn 该位为1时, 代表希望建立连接, 并且序列号会随机生成 fin 该位为1时, 代表希望断开连接 英语全称(其实一开始作者看错了 以为都是p开头 结果阴差阳错发现了 然后就记住了 哈哈) =-= psh(push) 该位为1时，代表需要直接将数据传给上一层 / 该位为0时 需要先进行缓存在进行传送 rst(reset) 该位为1时，代表tcp连接出现异常 必须强制断开连接 比如对方突然断电 紧急指针相关 URG 该位为1时，代表包中有需要紧急处理的数据 拥塞窗口 cwr 该位为1时，则会通知对方拥塞窗口缩小 ece 该位为1时，通知对方，从对方到这里的网络有拥塞 窗口大小 长为16位 代表发送数据最多不能超过这个窗口大小 如果窗口大小为0 则就是代表可以窗口探测 去寻找最新的窗口大小 校验和 紧急指针 该字段长为16位, 只有在URG控制位为1时有效 数据的首位到紧急指针指向的位置 都是紧急数据 怎么处理紧急数据 就是应用层要实现的事情, 一般在暂停通信 或者中断通信的时候使用 选项 UDP ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:13:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"UDP 概念 \u0026 用途 UDP 是面向无连接协议 爆式协议 他不会去管数据到底有没有到达 所以想啥时候发数据就啥时候发数据经常用于广播 视频 音频等 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:14:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"UDP 首部格式 因为UDP简单 所以首部只有 源端口号 目标端口号 检验和 包长度 四个数据 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:15:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"IP","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP及其相关协议 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:0:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"网络层 网络层介绍 IP(IPv4 IPv6) 相当于OSI7层模型中的第三层-网络层 在这一层 IP和ICMP是主角 网络层的作用 实现点对点通信 在第二层 数据链路层中 我们知道了在同一链路中 是通过\"mac地址\"来确定目标主机 进行包传递 那在不同的链路中 就是通过第三层的\"IP地址\"来实现包传递 IP基础知识 IP总共分为三大作用模块 分别是 “寻址” “路由” “分片与组包” ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:1:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP地址的定义 ipv4由32位正整数来表示 TCP/IP要求将IP地址分配给每一个通讯的主机IP地址在计算机内部由二进制表示 但是人类社会并不习惯二进制 所以每8位分开 隔一个\".\" 将每组数以十进制来表示每一台主机上的每一张网卡都需要设置IP地址 所以IP地址越来越不够用 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:2:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP地址由网络和主机两部分标识组成 IP地址是由网络地址和主机地址两部分组成 实现了唯一性，网络地址在不同的数据链路中也是不相同的，如果网络地址相同则说明在同一个网段中，接下来就是通过主机地址来区分不同的主机 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:3:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP地址的分类 IP地址分为4类 分别为 A类 B类 C类 D类 它根据IP地址中从第1位到第4位的比特对其网络标识和主机标识进行区分 A类地址 A类地址是首位以 “0” 开头的地址，代表着从第1位到第8位是他的网络地址，后24位为主机地址 十进制表示为：0.0.0.0 - 127.0.0.0 是A类的网络地址 B类地址 B类地址是前两位为 “10” 的地址 代表着从第1位到第16位是他的网络地址 后16位为主机地址 十进制表示 128.0.0.0 - 191.255.0.0 是他的网络地址 C类地址 C类地址是前三位为 “110” 的地址 代表着从第1位到第24位是他的网络地址 后8位为主机地址 十进制表示 192.0.0.0 - 223.255.255.0 是他的网络地址 D类地址 D类地址是前4位为 “1110” 的地址 代表着从第1位到第32位是他的网络地址 十进制表示 224.0.0.0 - 239.255.255.255 是他的网络地址 D类地址没有主机标识 常被用于多播 PS：分配IP地址 要用比特位表示主机地址时 不能全为0 或者 全为1 全部为0 代表对应的网络地址或者IP地址不可获知的情况下使用 全部为1的主机地址通常作为广播地址 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:4:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"广播地址 什么是广播地址 广播地址用于在同一个数据链路层中的互相连接的主机之间发送数据包 怎么设置广播地址 将IP地址的主机位全部设置为1 就成了广播地址 比如 172.20.0.0/16 二进制：10101100.00010100.00000000.00000000 -\u003e 10101100.00010100.11111111.11111111 十进制：172.20.255.255 本地广播 在本网络的广播叫做本地广播 比如在172.20.0.0/24的情况下 广播地址为172.20.0.255 因为这个广播地址的IP会被路由器所屏蔽 所以不会到达172.20.0.0/24以外的其他链路上 直接广播 在不同的网络的广播叫做直接广播 但是由于直接广播具有安全性的问题 所以大多数不会采用直接广播 例如网络地址为 192.168.0.0/24的主机向 192.168.1.255/24的目标地址发送IP包 收到这个包的路由器，将数据转发给192.168.1.0/24 从而使得 192.168.1.1 ~ 192.168.1.254的主机都能收得到这个包 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:5:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"多播 什么是多播 多播用于将包发送给特定组的所有主机 因为是直接使用IP协议 所以也不存在可靠传输 为什么不使用广播 而使用多播 广播会将包发送给所有的终端主机 然后由主机的上一层去判断这个包是不是他要的 所以会造成不必要的流量 而且广播无法穿透路由,想给其他的网段发送同样的包 就不得不采取另一种机制 所以多播可以穿透路由器 又可以实现只给那些必要的组发送数据包的技术就成为必选之路了 多播的特点 多播采用D类地址 因此 如果前4位为\"1110\"的就可以认为是多播地址 而剩下的28位可以成为多播的组编号从 224.0.0.0 到 239.255.255.255 都是多播地址的可用范围 其中 224.0.0.0 ~ 224.0.0.255 的范围不需要路由控制 在同一个链路也可以实现多播而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包对于多播，所有的主机(路由器以外的主机和终端主机)必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组利用IP多播实现通信 除了地址之外 还需要IGMP等协议的支持 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:6:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"子网掩码 为什么需要子网掩码 一个IP地址只要确定了其分类 也就确定了他的网络标识和主机标识 网络标识相同肯定就代表着在同一个链路内 所以对于B类地址 允许有6多万台计算机连接 实属浪费 所以一个更为灵活的组合方式 子网掩码诞生了 子网掩码的优点 IP地址的网络地址和主机地址就并不是分的那么严格 而去由子网掩码去通过子网网络地址细分出比原来分类更小粒度的网络所以这种方式其实就是将原来的分类中的主机地址部分用作子网地址 可以讲原网络分为多个多个物理网络的一种机制 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:7:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"CIDR/VLSM ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:8:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"全局地址与私有地址 路由控制 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:9:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"路由控制表 引出 我们已经在前面学习了IP地址，并且知道了靠网络地址和主机地址让每个主机都具有唯一性，那么问题就来了，我们在传递数据的时候，我咋知道目标的IP在哪里，我怎么才能去找到目标IP地址？ 所以我们还需要一个类似于 “车票\"的东西，那就是路由控制表 什么是路由控制表 路由控制表记录者网络地址与下一步应该发送至路由器的地址 维护路由控制表的方法 静态路由控制： 由管理员手动去管理 动态路由控制： 依靠路由器与其他路由器相互交换信息时靠路由协议去自动更新自动去更新这张表(路由协议先不讲述) ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:10:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP地址与路由控制 在发送IP包的时候 首先要确定IP包首部的目标地址 然后在路由控制表中找到相同网络地址的记录 然后转发至下一个路由如果有多个相同 则找一个最相同的 随后转发至下一个路由 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:11:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"默认路由 引出 如果一张路由表存放着包含所有网络及其子网的信息 将会造成无端的浪费，如果只有部分 那么也有可能IP数据包的目的地址找不到 所以当我们找不到目的地址的时候 就会走默认路由 什么是默认路由 默认路由一般标记为 “0.0.0.0/0” 或者 “default” 注意 这里的 “0.0.0.0” 并不是IP地址 因为后面是 “/0” 所以并没有标识IP地址 “0.0.0.0\"的IP地址应该被标记为 “0.0.0.0/32” 而且默认路由的子网掩码也是 “0.0.0.0” ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:12:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"主机路由 “IP地址/32” 也被称为 主机路由，他的意思是整个IP地址的所有位都将参与路由主机路由，多用于不希望通过网络地址路由的情况 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:13:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"环回地址 这个就是老朋友了 127.0.0.1 或者是 localhost，环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址，数据包不会流向网络 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:14:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"路由控制表的聚合 利用网络地址的比特分布可以有效的进行分层配置对内，即使有多个子网掩码，对外呈现出的也是同一个网络地址，所以通过路由信息的聚合可以有效的减少路由表的数目 提升效率 IP分割处理与再构成处理 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:15:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"数据链路不同 MTU则相异 引出 在数据链路层，其实每次传过来的MTU是不一样的（因为每个不同类型的数据链路的使用目的不同），所以IP要为每一个数据链路还专门去适配吗? 所以IP就用了一个分割处理和再构成处理 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:16:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP报文的分片与重组 引出 任何一台主机都需要将IP分片进行相应的处理 要不然在比较大的报文无法一下子发送出去 分片和重组的过程 在路由器上会将IP数据包分成分片发送出去，随后在目标主机而且也只能在目标主机上重组 为何只能在目标主机上重组 这么设计是有理由的：现实中无法保证IP数据报是否经由同一个路径传送，IP数据报拆分后是否会丢失，在当中路径中重组的话 可能在后面的路由器又会拆分，所以只能在目标主机上重组 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:17:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"路径MTU发现 引出 分片拆分是在路由器上面进行拆分 但是随着科技的发展 路由器要求性能越来越高 其次如果拆分的时候 其中一个分片丢失 则所有的数据报会作废 所以诞生了路径MTU发现 UDP 路径MTU发现工作原理 在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1 根据这个标志位, 途中的路由器即使遇到需要分片才能处理的大包也不要分片 而是直接丢弃，随后 通过一个ICMP的不可达消息将数据链路上MTU的值给发送主机 下一次 从发送的同一个目标主机的IP数据报获得ICMP所通知的MTU值以后 将它设置为当前MTU，然后对数据报进行分片处理 如此反复 直到没有收到ICMP 就认为MTU是一个合适的值 ps：MTU最多可以缓存10分钟 如果超过了 就会在去路径MTU发现 TCP 路径MTU发现 根据路径MTU的大小计算出最大段长度 然后再根据这些信息进行数据报的发送，所以在TCP上 IP不需要进行分片 IPv4首部 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:18:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IPv4首部 教你如何通过理解去背诵 首先肯定要记录发送端主机和目标段主机IP地址 源地址 32bit构成，记录者发送端主机的地址 目标地址 32bit构成 记录者接收端主机的地址 IPv4首部长度肯定会有记录 首部长度 4bit构成 表明IP首部的大小 单位是4个字节(32bit) 对于没有可选项的IP包, 首部长度则设置为\"5” 也就是说 没有可选项的IP时 IP首部为20byte 总长度 16bit 标识IP首部与数据部分合起来的总字节数 所以说IP包最大长度 为 65536字节 记录不同的数字来标识一些不同的情况 版本 4bit 构成 标记IP的版本号 /“4 -\u003e ipv4” “5 -\u003e ST” “6 -\u003e ipv6”/ 等等 区分服务 8bit 构成 用来表明服务质量 一般这个值都是应用指定也应该是由应用指定，但是现在一般都无视这个字段 因为在符合质量的要求的情况下按其要求发送本身的功能实现起来非常的难，现在有人提出将这个字段分为两个字段 - DSCP \u0026 ECN 协议 8bit 构成 表示的是IP包传输层的上层协议编号，具体编号可以从特殊网站获取 分片重组相关 标识 由16bit组成，用于分片重组，同一个分片标识相同 不同的分片标识不同 通常 每发送一个IP包 他的值也逐渐递增，此外 即使ID相同 如果目标地址 源地址 协议不同 也会被认为是不同的分片 标志 3bit 组成 表示包被分片的相关信息 第0个bit -\u003e 未使用 现在必须是0 第1个bit -\u003e 表示是否进行分片 “0” 可以分片 / “1” 不能分片 第2个bit 包被分片的情况下 表示是否为最后一个包 “0” 最后一个分片的包 / “1” 分片中段的包 片偏移 由13bit组成 用来表示被分片的每一个分段相对于原始数据的位置 第一个分片对应的值为0 由于片偏移占13bit 所以最多可以表示8192个相对位置 单位为8字节 因此最大可以表示原始数据为 “8 x 8192 = 65536\"字节的位置 IP包的生命周期 生存时间 由8bit构成 他最初的意思是以秒为单位记录当前包在网络上应该生存的期限，然而 在实际中他是指可以中转多少个路由的意思 每经过一个路由 生存时间就会-1 直到变成0则丢弃该包 可以避免IP包在网络内无限传递的问题 校验和 首部校验和 由16bit构成 也就IP首部校验和 该字段不会校验数据部分 只会校验IP数据包不会被破坏 其他 可选项 长度可变 通常只在进行试验或诊断时使用 填充 再有可选项的情况下 首部长度可能不是32比特的整数倍 所以填充就是保证是整数倍的 数据 存入数据 将IP上层协议的首部也作为数据进行处理 ICMP ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:19:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"ICMP是个啥玩意 引出 我们在架构IP网络的时候 最注意两点: 1. 确认网络是否工作 2. 遇到异常时进行问题诊断ICMP正是提供这类功能解决这些问题的一种协议 ICMP的功能 确认IP包是否成功送达目标地址 通知在发送过程当中IP包被废弃的具体原因 改善网络设置 … ICMP所以其实就是一个传递消息的 在IP通信中如果某个IP包因为某种原因未能达到目标地址 那么这个具体的原因将由ICMP负责通知ICMP这种通知消息会使用IP进行发送ICMP的消息 大致可以分为两类 1. 通知出错原因的错误消息 2. 用于诊断的查询消息 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:20:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"主要的ICMP消息 ICMP目标不可达消息 IP路由器无法将IP数据包发送给目标地址时, 会给发送端主机返回一个不可达的ICMP消息 并在这个消息显示具体原因 ICMP重定向消息 如果路由器选择次优路径发送数据, 那么他会返回一个ICMP重定向的消息给这个主机 在这个消息中包含了最适合的路由信息和源数据 ICMP超时消息 在IP包字段中有一个记录着IP的生存周期的字段 如果这个字段为0 则会发送一个ICMP消息给发送端主机 表示该包已经丢弃 ICMP回送消息 用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息 “ping” 命令就是由ICMP实现的 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:21:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"其他的ICMP信息 ICMP原点抑制消息 在使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题 ICMP原点抑制消息可以缓和这种拥堵情况 但是会造成不公平的网络通信 所以一般不使用 ICMP路由器探索消息 主要用于发现与自己相连网络中的路由器 当一台主机发出ICMP路由器请求时 路由器则返回ICMP路由器公告消息给主机 ICMP地址掩码消息 主要用于主机或路由器想要了解子网掩码的情况 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:22:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"ICMPv6 引出 有了ICMP 为啥还要有一个ICMPv6 ICMPv6的作用 IPv4中的ICMP仅作为一个辅助作用支持IPv4 也就是说没有了ICMP 其实也是可以实现IP通信的 在IPv6中 ICMP的作用被扩大 如果没有ICMPv6 IPv6则就无法进行正常通信 ICMPv6的消息 错误消息 信息消息 邻居探索 邻居探索消息在ICMPv6中很重要 用于查询IPv6与MAC地址的关系 并由邻居宣告消息得知MAC地址 邻居探索消息利用IPv6的多播地址实现传播 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:23:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"OSI","date":"2023-01-01","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/","tags":["OSI"],"title":"OSI","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/"},{"categories":["网络原理"],"content":"OSI OSI OSI 模型(Open System Interconnection Model)是一个由 ISO 提出得到概念模 型，试图提供一个使各种不同的的计算机和网络在世界范围内实现互联的标准框架。 虽然OSI参考模型在实际中的应用意义并不是很大，但是它对于理解网络协议内部的 运作很有帮助，为我们学习网络协议提供了一个很好的参考。它将计算机网络体系结 构划分为7层，每层都为上一层提供了良好的接口。以下将具体介绍各层结构及功 能。 ","date":"2023-01-01","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/:0:0","tags":["OSI"],"title":"OSI","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/"},{"categories":["网络原理"],"content":"OSI 7层模型 \u0026 作用 应用层: 这一层为操作系统或网络应用程序提供访问网络服务的接口。 表示层: 这一层主要解决用户信息的语法表示问题 比如发送邮件 可能这个软件是自己的独有的编码, 表示层需要将这个转化为通用编码 然后把这个软件独有和通用的编码格式放到数据首部 会话层: 这一层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话 比如现在有5封邮件, 你是一次建立连接 发送一封邮件 在建立一次连接 再发送一封邮件 还是 建立一次连接吧所有的邮件发送出去 这就是会话层的任务 决定哪一种传输方式 传输层: 首次的端对端,也就是主机对主机的层次 / 专门负责\"上层数据分段并提供到端对端 可靠与不可靠的传输\" / 数据单位称之为 “数据段” 网络层: 负责网路与另一个网络的连接发送数据 / 专门负责\"寻址\" “路由” “分片与组包” / 在这里数据单位称之为 “数据包” 数据链路层: 数据链路层(Data Link Layer)定义了在单个链路上如何传输数据 物理层: 物理层(Physical Layer)确保原始的数据可在各种物理媒体上传输 ","date":"2023-01-01","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/:1:0","tags":["OSI"],"title":"OSI","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/"},{"categories":["网络原理"],"content":"各层传输协议、传输单元、主要功能性设备比较 名称 传输协议 传输单元 主要功能设备/接口 物理层 IEEE 802.1A、IEEE 802.2 bit-flow 比特流 光纤，双绞线，中 继器，集线器，网 线接口 数据链路层 ARP、MAC、 FDDI frame 帧 网桥、二层交换机 网络层 IP、ICMP、ARP、RARP 数据包(packet) 路由器、三层交换 机 传输层 TCP、UDP 数据段 四层交换机 会话层 SMTP、DNS 报文 QoS 表示层 Telnet、SNMP 报文 应用层 FTP、TFTP、Telnet、HTTP、DNS 报文 ","date":"2023-01-01","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/:2:0","tags":["OSI"],"title":"OSI","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/"},{"categories":["操作系统"],"content":"操作系统的IO模型","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"IO模型 5种 IO模型 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:0:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"从TCP发送信息流程开始讲起 要深入的理解各种 I/O 模型，那么必须先了解下产生各种IO的原因是什么，要知道这其中的本质问题那么我们就必须要知道一条消息是如何从一个人发送到另外一个人的 以两个应用程序通讯为例，我们来了解一下当“A”向\"B\" 发送一条消息，简单来说会经过如下流程 应用A将数据发送到TCP发送缓冲区 TCP发送缓冲区再把数据发送出去，经过网络传递后，数据会发送到服务器B的TCP接收缓冲区 B再从TCP接收缓冲区去读取属于自己的数据 这个流程我们了解后 我们就开始来进入主题 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:1:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"阻塞/非阻塞 IO模型 我们先来思考一个问题： 因为发送信息肯定是间断 他不会一直都会有信息，一直在发送，所以如果B的TCP接收缓冲区没有数据，B发送了一个接收数据的读取请求，那么这时候是会直接告诉B没有可读消息，还是让B一直等待直到有可读消息呢 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:2:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"什么是阻塞IO 我们这个问题思考完 其实就已经明白了什么是阻塞IO 所谓阻塞IO就是当应用B发起读取数据申请时，在内核数据没有准备好之前，应用B会一直处于等待数据状态，直到内核把数据准备好了交给应用B才结束 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:2:1","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"什么是非阻塞IO 按照上面的思路，所谓非阻塞IO就是当应用B发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用B，不会让B在这里等待 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:2:2","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"IO复用模型 我们依旧先来思考一个问题： 我们还是从 服务器B 要去从缓冲区读取数据的问题，如果在并发的场景下，可能会有N个人向服务器B发送消息，这种情况一般我们会开多个线程去处理不同的消息，每个线程都会自己调用 recvfrom 去读取数据 并发情况下服务器很可能一瞬间会收到几十上百万的请求，这种情况下应用B就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送recvfrom 请求来读取数据 那么问题来了，这么多的线程不断调用 recvfrom 请求数据，先不说服务器能不能扛得住这么多线程，就算扛得住那么很明显这种方式是不是太浪费资源了，线程是我们操作系统的宝贵资源，大量的线程用来去读取数据了，那么就意味着能做其它事情的线程就会少 有人就提出了一个思路，能不能提供一种方式，可以由一个线程监控多个网络请求（我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路 正如上图，IO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起recvfrom请求去读取数据 进程将一个fd或者多个fd传递给 select，阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据 复用IO的基本思路就是通过select或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:3:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"信号驱动IO模型 我们继续来看一个问题： select会一直轮询 这就代表着绝大多数的轮询都是无意义的 那我们能不能发出请求后 也别去管他了 数据准备好直接来通知我呢? 所以就衍生了信号驱动 IO模型 于是信号驱动IO不是用循环请求询问的方式去监控数据就绪状态，而是在调用sigaction时候建立一个SIGIO的信号联系，当内核数据准备好之后再通过SIGIO信号通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起recvfrom读取数据的请求，因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个fd 首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用recvfrom来读取数据 IO复用模型里面的select虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:4:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"异步IO 还是老样子，我们来看一个问题： 也许你一开始就有一个疑问，为什么我们明明是想读取数据，而却非得要先发起一个select询问数据状态的请求，然后再发起真正的读取数据请求,能不能有一种一劳永逸的方式，我只要发送一个请求我告诉内核我要读取数据，然后我就什么都不管了，然后内核去帮我去完成剩下的所有事情? 当然既然你想得出来，那么就会有人做得到，有人设计了一种方案，应用只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种一劳永逸的模式为异步IO模型 应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成 异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。 IO多路复用机制 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:5:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll V.S select 假想这么一个场景 你朋友来找你较量一场击剑，然后不知道寝室在哪 所以找了宿管 select宿管带着你的朋友挨家挨户找，直到找到你 epoll宿管，她会先记下每位同学的房间号，你的朋友来的时候只要告诉房间号即可 那如果来了10000个人 都要找你击剑，那么select效率更高还是epoll？ select 如一个保姆照顾一群孩子，如果把孩子尿尿这件事必做 IO，那保姆就相当于问每一个孩子需要尿尿不 epoll的机制下 保姆无需挨个询问孩子是否要尿尿，而是每个孩子若自己需要尿尿，主动站到事先约定好的地方，而保姆的职责就是看约定好的地方有无孩子。因此，epoll的这种机制，能够高效的处理成千上万的并发连接，而且性能不会随着连接数增加而下降 select epoll 性能 随着连接数的增加，急剧下降 随着连接数的增加，性能基本不会下降 连接数 连接数有限制-1024如果要处理超过1024，则需要修改FD_SETSIZE宏，并重新编译 连接数无限制 内在处理机制 轮询 回调callback 开发复杂性 低 中 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:6:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"select select 通过设置或检查存放fd标志位的数据结构进行下一步处理 这会带来问题： 单个进程可监控的fd数量被限制, 只允许1024，这些是由 FD_SETSIZE宏去控制的， 当然也可对其修改，然后重新编译内核，但性能可能受影响，这需要进一步测试。一般该数和系统内存关系很大 当 socket 较多的时候，每次select都要遍历FD_SETSIZE的socket，不管是否活跃都很浪费CPU的时间，若能给socket注册某个回调函数，当他们活跃时候，直接完成相关操作 即可避免轮询 这就是 epoll和 kqueue select 缺点 内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户控件和内核空间在传递该结构时复制开销大 每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大 每次调用select，都需在内核遍历传递进来的所有fd select支持的文件描述符数量太小，默认最大支持1024 主动轮询效率很低 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:7:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"poll 和select类似，只是描述fd集合的方式不同，poll使用 pollfd 结构而非select的 fd_set 结构 struct pollfd { int fd; short events; short revents;}; 管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll无最大文件描述符数量的限制 poll和select都有一个缺点 就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，其开销也随着文件描述符数量增大而线性增大 将用户态传入的数组拷贝到内核空间 然后查询每个fd对应设备状态 若设备就绪 在设备等待队列中加入一项继续遍历 若遍历完所有fd后，都没发现就绪的设备，挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义遍历 无最大连接数量限制 基于链表存储 缺点： 大量fd数组被整体复制于用户空间和内核空间中，而不管是否有意义 若报告了fd后，没有被处理，则下次poll时会再次报告该fd 链表查询时间复杂度为 O(n) 所以又有了 epoll ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:8:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理 可理解为event poll，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1) // 事件参数描述链接到文件描述符fd的对象 struct epoll_event { __u32 events; __u64 data;} EPOLL_PACKED; ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll触发模式 LT，默认的模式（水平触发）只要该fd还有数据可读，每次epoll_wait 都会返回他的事件，提醒用户程序去操作 ET，边缘触发 只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以ET模式下，read一个fd时，一定要把它的buffer读完，即读到read返回值小于请求值或遇到EAGAIN错误 epoll使用“事件”就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似回调机制激活该fd，epoll_wait便可收到通知 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:1","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"ET的意义 若用LT，系统中一旦有大量无需读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这大大降低处理程序检索自己关心的就绪文件描述符的效率。 而采用ET，当被监控的文件描述符上有可读写事件发生时，epoll_wait会通知处理程序去读写。若这次没有把数据全部读写完(如读写缓冲区太小)，则下次调用epoll_wait时，它不会通知你，即只会通知你一次，直到该文件描述符上出现第二次可读写事件才通知你。这比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:2","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll的优点 无最大并发连接的限制，能打开的FD上限远大于1024（1G内存能监听约10万个端口） 效率提升，不是轮询，不会随FD数目增加而效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大优点在于它只关心“活跃”连接，而跟连接总数无关，因此实际网络环境中，Epoll效率远高于select、poll 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。 epoll通过内核和用户空间共享一块内存而实现 表面上看epoll的性能最好，但在连接数少且都十分活跃情况下，select/poll性能可能比epoll好，毕竟epoll通知机制需要很多函数回调 epoll跟select都能提供多路I/O复用。在现在的Linux内核里有都能够支持，epoll是Linux所特有，而select则是POSIX所规定，一般os均有实现 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:3","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll提供的函数 epoll_create 创建一个句柄 epoll_ctl 注册要监听的事件类型 对于第一个缺点，epoll的解决方案在epoll_ctl.c，每次注册新事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有fd拷贝进内核，而非在epoll_wait时重复拷贝。epoll保证每个fd在整个过程中只会拷贝一次！ EPOLL_CTL_ADD：在文件描述符epfd所引用的epoll实例上注册目标文件描述符fd，并将事件事件与内部文件链接到fd EPOLL_CTL_MOD：更改与目标文件描述符fd相关联的事件 EPOLL_CTL_DEL：从epfd引用的epoll实例中删除目标文件描述符fd。该事件将被忽略，并且可以为NULL epoll_wait 等待事件的产生 对于第二个缺点，epoll解决方案不像select/poll每次都把current流加入fd对应的设备等待队列，而只在epoll_ctl时把current挂一遍（这一遍必不可少），并为每个fd指定一个回调函数 当设备就绪，唤醒等待队列上的等待者时，就会调用该回调函数，而回调函数会把就绪fd加入一个就绪链表。 epoll_wait实际上就是在该就绪链表中查看有无就绪fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步类似）。 对于第三个缺点，epoll无此限制，其支持FD上限是最大可以打开文件的数目，一般远大于2048。1GB内存机器大约10万左右，具体数目可查看 cat /proc/sys/fs/file-max，这数目和系统内存关系很大 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:4","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"总结 select，poll，epoll都是I/O多路复用机制，即能监视多个fd，一旦某fd就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质都是同步I/O，因为他们都需在读写事件就绪后，自己负责进行读写，即该读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O实现会负责把数据从内核拷贝到用户空间 select，poll需自己主动不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但它是设备就绪时，调用回调函数，把就绪fd放入就绪链表，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但select和poll在“醒着”时要遍历整个fd集合，而epoll在“醒着”的时候只需判断就绪链表是否为空，节省大量CPU时间，这就是回调机制带来的性能提升 select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，且把current往等待队列上挂也只挂一次（在epoll_wait开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少开销。 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:10:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"操作系统的进程管理","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程管理 进程与线程 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:0:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程的概念 进程的概念 指一个应用程序运行了起来, 进程是操作系统分配资源的一个最小单位 进程的结构 控制块（PCB）存放着进程的唯一ID，如果运行了多个微信进程，他们的ID也都是不一样的 数据块存放着进程的原始数据和中间数据 程序块多个进程共享 存放在文本区域 这个的多个进程是指如果开启了多个微信程序 则多个微信程序共享程序块 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:1:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"线程的概念 线程的概念 操作系统最小调度单位, 不能独立运行 被包含于进程, 一个进程可以有一个或多个进程 也被叫做轻量级进程 但是轻量级进程多用于内核级进程 而用户级线程成为线程 内核级线程 线程的控制块在操作系统的内核空间里 被称为内核级线程 但是线程的数据块和程序块还依然在用户控件 实现了真正意义上的线程并行 不需要运行时系统的参与 正因为数据块和程序块在用户空间，所以频繁的切换会导致内核开销大 用户级线程 线程的控制快在操作系统的用户控件里 被称为用户级线程 不依赖于操作系统 调度依赖于用户程序 在操作系统的视角里其实感觉不到用户级线程的存在 线程位于用户控件（不需要模式切换） 独立于操作系统（线程可以在不支持他们的操作系统上运行） 运行时系统可以切换用户控件中的本地阻塞线程（eg：等待另一个线程完成） 系统调用中，对一个线程的阻塞将会导致整个进程的阻塞 非真正意义的线程并行（一个进程安排在单个cpu上） 不存在时钟中断 更多的用户级线程的知识请看《如何理解协程?》 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:2:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程与线程的区别 进程是操作系统分配资源的最小单位 / 线程是操作系统最小调度单位 一个线程只属于一个进程 / 一个进程可以包括多个线程但最少有一个主线程 进程在执行过程中拥有独立的内存单元 / 而多个线程共享进程的内存 进程编程调试简单可靠性高，但是创建销毁开销大 / 线程正相反，开销小，切换速度快，但是编程调试相对复杂 进程间不会相互影响 / 线程一个线程挂掉将导致整个进程挂掉 进程适应于多核、多机分布 / 线程适用于多核 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、IO设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销 / 而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作 / 所以进程切换的开销也远大于线程切换的开销 由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:3:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"线程资源 详细文章请看《线程到底共享了哪些进程资源？》 线程共享的资源 线程私有的资源 堆区 寄存器 打开的文件 栈区 数据区（全局变量和static） 程序计数器 代码区（每一个函数） 栈指针 动态链接库 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:4:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"说一下 fork，wait，exec 函数 父进程产生子进程使用fork拷贝出一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读一块内存的 当有进程写的时候使用写时拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了 fork 从父进程返回子进程的 pid，从子进程返回 0，调用了 wait 的父进程将会发生阻塞，直到 有子进程状态改变，执行成功返回 0，错误返回 -1 exec 执行成功则子进程从新的程序开始运行，无返回值，执行失败返回 -1 fork()函数 #Fork:创建一个和当前进程映像一样的进程可以通过 fork() 系统调用: #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e pid_t fork(void); 成功调用 fork() 会创建一个新的进程，它几乎与调用 fork() 的进程一模一样，这两个进程都会 继续运行 在子进程中，成功的 fork()调用会返回0。在父进程中 fork() 返回子进程的 pid，如果出现错误，fork() 返回一个负值 最常⻅的 fork() 用法是创建一个新的进程，然后使用 exec() 载入二进制映像，替换当前进程的 映像。这种情况下，派生(fork)了新的进程，而这个子进程会执行一个新的二进制可执行文 件的映像。这种“派生加执行”的方式是很常⻅的 在早期的 Unix 系统中，创建进程比较原始。当调用 fork 时，内核会把所有的内部数据结构复 制一份，复制进程的⻚表项，然后把父进程的地址空间中的内容逐⻚的复制到子进程的地址空 间中。但从内核⻆度来说，逐⻚的复制方式是十分耗时的。现代的 Unix 系统采取了更多的优 化，例如 Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:5:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"孤儿进程 V.S 僵尸进程 什么是孤儿进程 一般情况下，子进程是由父进程创建，而子进程和父进程的推出顺序是无序的，两者之间都不知道谁先退出。 正常情况下，父进程会先结束调用wait()或者waitpid()函数等到子进程完成后再退出，而一旦父进程不等待直接退出，则剩下的子进程会被init(pid=1)进程接收，成了孤儿进程（进程树中除了init都会有父进程） 什么是僵尸进程 如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的 状态信息，则子进程残留的状态信息( task_struct 结构和少资源信息)会变成僵尸进程 怎么处理僵尸进程 子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中 调用wait进行处理僵尸进程 原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:6:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"守护进程 什么是守护进程 守护进程(Daemon)是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。 守护进程是一种很有用的进程 守护进程特点 守护进程最重要的特性是后台运行 守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符，控制终端，会话和进程组，工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的父进 程(特别是shell)中继承下来的 守护进程的启动方式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc.d中启 动，可以由作业规划进程crond启动，还可以由用户终端(shell)执行 实现一个守护进程 在父进程中执行fork并exit推出 在子进程中调用setsid函数创建新的会话 在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录 在子进程中调用umask函数，设置进程的umask为0 在子进程中关闭任何不需要的文件描述符 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:7:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程的创建过程，需要哪些函数，需要哪些数据结构 fork函数创造的子进程是父进程的完整副本，复制了父进程的资源，包括内存的内容task_struct内容 vfork创建的子进程与父进程共享数据段，而且由vfork创建的子进程将先于父进程运行 linux 上创建线程一般使用的就是pthead库，实际上linux也给我们提供了创建线程的系统调用，也就是clone ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:8:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程创建子进程，fork 详解 函数原型 pid_t fork(void) 除了0号进程(系统创建的)之外，linux系统中都是由其他进程创建的。创建新进程的进 程，即调用fork函数的进程为父进程，新建的进程为子进程 fork函数不需要任何参数，对于返回值有三种情况 对于父进程，fork函数返回新建子进程的pid; 对于子进程，fork函数返回 0; 如果出错， fork 函数返回 -1 int pid=fork(); if(pid \u003c 0){ //失败，一般是该用户的进程数达到限制或者内存被用光了 ........ } else if(pid == 0){ //子进程执行的代码 ...... } else{ //父进程执行的代码 ......... } 进程运行 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:9:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"五种基本状态 创建： 创建好一个进程 就绪：进程做好了执行的准备 就差分配处理机 运行：该进程正在执行 阻塞：等待某事件发生才能执行，如等待I/O完成 终止：进程被关闭 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:10:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程控制 什么是进程控制 即os对进程实现有效的管理 比如进程的创建、进程切换等动作 os 通过 原语 操作来实现进程控制 什么是原语 由若干条指令组成 具有原子性 原语的特点 原子操作 要么全部执行 要么全部失败 执行过程不会被终止 在管态/系统态/内核态下执行，常驻内存 是内核三大支撑功能之一(中断机制，时钟管理，原语操作) ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:11:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程是怎么运行的 创建原语：create 阻塞原语：block 唤醒原语：wakeup 撤销原语：destroy 挂起原语：suspend 激活原语：active ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:12:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"处理机 什么是处理机 根据一定的算法和原则将处理机资源进行重新分配的过程 前提：作业/进程数目一定远远大于处理机数目 目的：提高资源利用率 减少处理机空闲时间 处理机调度：调度的层次 高级调度/作业调度 把后备作业调入内存 只调入一次 调出一次 中级调度/内存调度 将进程调至外存 条件合适再调入内存 在内存 外存对换区进行进程对换 低级调度/进程调度 从就绪队列选取进程分配给处理机 最基本的调度 频率非常高（相当于一个时间片完成） 调度算法 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:13:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"先来先服务 算法内容：调度作业/就绪队列中最先入队者，等待操作完成和阻塞 算法原则：按作业/进程到达顺序服务 调度方式：非抢占调度 适用场景：作业/进程调度 优缺点 有利于CPU繁忙型作业 充分利用CPU资源 不利于I/O繁忙型作业 操作耗时 其他饥饿 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:14:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"短作业优先 算法内容：所需服务时间最短的作业/进程优先服务 算法原则：追求最小的平均周转时间 调度方式：非抢占式服务（除了服务时间最短 还有另一种方式-最短剩余时间优先） 适用场景：作业/进程调度 优缺点 平均等待/调度时间最少 长作业会增加或者饥饿 估计时间不准确 不能保证紧急任务及时处理 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:15:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"高响应比优先调度 算法内容：结合先来先服务\u0026短作业优先，综合考虑等待时间和服务时间计算响应比 高的响应比优先调度 算法原则：综合考虑作业/进程的等待时间和服务时间 调度方式：非抢占调度 适用场景：作业/进程调度 响应比计算 (等待时间 + 服务时间) / 服务时间 当前进程完成或者阻塞时重新计算所有的进程响应比 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:16:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"优先级调度 算法内容：又叫优先权调度，按作业/进程的优先级（紧迫程度）进行调度 算法原则：优先级最高的作业/进程先调度 调度方式：抢占（高优先级立即执行）/非抢占（高优先级等待当前进程让出后执行） 适用场景：作业/进程调度 优先级设置原则 静态/动态优先级 系统 \u003e 用户 / 交互型 \u003e 非交互型 / I/O型 \u003e 计算型 低优先级进程可能会饥饿 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:17:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"时间片轮转调度 算法内容：按进程到达就绪队列的顺序，轮流分配一个时间片去执行，时间用完则剥夺 算法原则：公平、轮流为每个进程服务，进程在一定时间内都能得到响应 调度方式：抢占式 由时钟中断确定时间 适用场景：进程调度 优缺点 公平，响应快，适用于分时系统 时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力 时间片太大，相当于 先来先服务 / 太小 处理机切换频繁 开销增大 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:18:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"多级反馈队列调度 算法内容 设置多个按优先级排序的就绪队列 优先级从高到低 时间片从小到大 新进程采用队列降级法 （1. 进入第一级队列 按先来后到分时间片 2. 没有执行完，移动到第二级） 前面队列不为空 不执行后续队列进程 算法原则：集中前几种算法的优点 调度方式：抢占式 适用场景：进程调度 优缺点 对各类型相对公平 可以快速响应 也实现了短作业优先 周转时间短 在前几个队列部分执行 进程通信 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:19:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"共享内存 共享内存，指两个或多个进程共享一个给定的存储区 共享内存是最快的一种进程通信方式，因为进程是直接对内存进行存取 因为多个进程可以同时操作 所以需要进行同步 信号量 + 共享内存通常结合在一起使用 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:20:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"管道通信 无名管道 半双工 具有固定的写端以及读端 管道就是一个 队列 是先进先出 无名管道只能用于具有亲属关系的进程之间的通信 管道其实可以看成一个特殊的文件, 对于他的读写也可以使用 read()/write() 但是管道不属于文件系统，他是用于内存中 当一个管道建立时，会创建两个文件文件描述符，要关闭管道只需将这两 个文件描述符关闭即可 Int pipe(int fd[2]); 有名管道（fifo） 有名管道可以用于无关的进程之间通信 有名管道有路径名与之相关联，她以一种特殊设备文件形式存在于文件系统中 Int mkfifo(const char* pathname, mode_t mode); ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:21:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"消息队列 消息队列，是消息的连接表，存放在内核中。一个消息队列有一个标识符来标识 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容不会被删除 消息队列可以实现消息的随机查询 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:22:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"信号量 什么是信号量 信号的数量 举例： 好比一个停车场，里面很多的停车位，停车位是任何车都可以停的，所以可以看成共享资源，那停车位满了，外面肯定就要排队 P/V 操作 P操作： wait原语，进程等待 V操作： signal原语，唤醒等待进程 信号量的工作机制 由一个 剩余资源数量 \u0026 进程等待队列 实现的结构体 如果有一个进程在执行 则剩余资源数量-1 如果剩余资源数量为负数，则让当前申请资源的进程进入等待队列并处于阻塞状态 如果一个进程执行完毕，则剩余资源数量+1，并且从等待队列唤醒一个进程 进程同步 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:23:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程同步 什么是进程同步 协调进程间的 相互制约关系, 使他们按照预期的方式执行的过程 两种相互制约形式 互斥： 进程排他性访问共享资源 同步： 进程间的合作，比如管道通信 互斥的实现 临界区： 比如打印机、音频设备等 通过对多个进程进程串行化来访问公共资源或一段代码 在任意时刻只允许一个进程访问 一个进程成功访问后就会加锁 直到释放锁 也唤醒其他的阻塞进程 互斥对象： 互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的进程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个进程同时访 问。当前拥有互斥对象的进程处理完任务后必须将进程交出，以便其他进程访问该资源 同步的实现 信号量： 上面已经介绍，在此不多赘述 事件对象： 通过通知操作的方式来保持进程的同步，还可以方便实现对多个进程的优先级 比较的操作 死锁 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:24:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"死锁 什么是死锁： 多个进程由于竞争资源而造成的阻塞现象，若无外力干预，这些进程都无法前进 死锁产生的原因 系统资源的竞争 进程推近顺序非法 死锁产生的必要条件 互斥条件： 共享资源的排他性访问 不剥夺条件： 访问时该共享资源不会被剥夺 请求并保持： 保持当前资源请求另一个资源 循环等待条件： 存在共享资源循环等待链 处理死锁的四大方法 预防死锁： 破坏死锁的四大必要条件 避免死锁： 在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生 检测死锁： 允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除 解除死锁： 当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来 预防死锁 与 避免死锁 的区别 预防死锁是破坏死锁的四个必要条件，严格的防止死锁的出现 避免死锁是不破坏死锁的四个必要条件，因为就算4个必要条件也可能不会出现死锁，他的角度是从系统运行中注意避免死锁的产生 死锁的预防 破坏互斥条件 将只能互斥访问的资源改为同时共享访问（可以在中间加一个缓冲队列） 将独占锁改为共享锁 不是所有资源都能改成可共享的 破坏不剥夺/不可抢占条件 请求新资源无法满足时必须释放已有资源 由OS协助强制剥夺某进程持有的资源 实现复杂，代价高 此操作过多导致原进程任务无法推进 破坏请求并保持条件 进程开始时一次性申请所需资源 阶段性请求和释放资源 破坏循环等待条件 对所有资源进行排序 对资源的编号应相对稳定，限制了新设备增加 进程使用资源的顺序可能与系统编号顺序不同 限制了用户编程 死锁的避免 银行家算法 系统预判进程请求是否导致不安全状态 是则拒绝请求，否则答应请求 死锁的检测 需要一种数据结构，保存有关资源的请求和分配信息 提供一种算法，利用这些信息监测是否形成了死锁 死锁的解除 资源剥夺： 挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态 撤销进程： 强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行 进程回退： 让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:25:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"操作系统概述","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"概念 用户空间与内核空间 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:0:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"用户空间与内核空间 什么是内核空间与用户空间 在操作系统分为用户空间和内核空间用户空间里运行着应用程序 用户程序不能直接操作内核 内核空间独立于普通的应用程序 可以访问受保存的内存空间,也可以访问底层硬件设备 为什么要区分内核空间和用户控件 很简单 为了安全 因为用户程序可能会有很多隐患 比如清空内存 清空寄存器 操作系统也分了特权指令和非特权指令，对于非常危险的指令 只允许操作系统及其相关的模块使用 也就是特权指令 用户程序的指令 就是非特权指令 这里要注意 中断指令也是非特权指令 intel的cpu分为4个特权等级 Ring0~Ring3 如果等级是Ring3则说明进程是运行在用户态 Ring0则说明是进程运行在内核态 时钟管理 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:1:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"时钟管理 什么是时钟管理 在操作系统里面有个非常重要的就是时钟 他还是一个硬件 作用 记录着系统时间 时钟中断 (用来进行 进程 or 线程 切换) 中断机制 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:2:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"中断机制 什么是中断 中断 是为了解决外部设备完成某些工作后通知CPU的一种机制(譬如硬盘完成读写操作后通过中断告知CPU已经完成) 中断的分类 中断可以分为同步中断和异步中断 同步中断是当指令执行时由 CPU 控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后 CPU 才会发出中断，而不是发生在代码指令执行期间 — 比如系统调用 异步中断是指由其他硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生 — 例如键盘中断 根据 Intel 官方资料，同步中断称为异常(exception)，异步中断被称为中断(interrupt)。中断可分为 可屏蔽中断(Maskable interrupt)和 非屏蔽中断(Nomaskable interrupt)。异常可分为 故障(fault)、陷阱(trap)、终止(abort)三类 从广义上讲，中断可分为四类：中断、故障、陷阱、终止 中断分类图示 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:3:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"中断的处理过程 关中断 进入不可再次响应中断的状态，由硬件实现 保存断点 为了在[中断处理]结束后能正确返回到中断点。由硬件实现 引出中断服务程序 将[中断服务程序]入口地址送PC，转向[中断服务程序]。可由硬件实现，也可由软件实现 保存现场和屏蔽字 保护现场、置屏蔽字、开中断，即保护CPU中某些寄存器的内容、设置[中断处理]次序、允 许更高级的中断请求得到响应，实现中断嵌套由软件实现 开中断 看 - 4 执行中断服务程序 实际上有效的中断处理工作是在此程序段中实现的。由软件程序实现 退出中断 在退出时，又应进入不可中断状态，即关中断、恢复屏蔽字、恢复现场、开中断、中断返回。由软件实现 流程图示 系统调用 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:4:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"执行一个系统调用时，OS 发生的过程 执行用户程序(如:fork) 根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断 进行地址空间的转换和堆栈的切换，执行SAVE_ALL。(进行内核模式) 进行中断处理，根据系统调用表调用内核函数 执行内核函数 执行 RESTORE_ALL 并返回用户模式 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:5:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"系统调用跟函数调用的区别 原语 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:6:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"原语 什么是原语 有若干条指令组成，是一个程序段, 用来完成某个特定功能 执行过程不会被中断具有原子性的叫做原语 原语运行在内核空间 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:7:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["MySQL"],"content":"MySQL的索引","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"索引 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:0:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"索引的基本种类 Innodb 主键索引在建立主键的时候就会自动帮你创建一个主键索引，在Innodb引擎下主键索引是聚簇索引，可以不唯一 普通索引除主键外，任意一列创建的索引就叫做普通索引 普通索引可以有多个 唯一索引跟主键索引唯一的区别就是 该索引是唯一的，可以为null 联合索引一个索引包含多个列 MyISAM 全文索引全文索引类型为 FULLTEXT, 在定义索引的列上支持值的全文查找, 允许在这些索引列中插入重复值和空值 可以在 char varchar text类型列上创建 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:1:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"索引的优点缺点 优点 能够大大加快索引的查询速度 缺点 索引会占用磁盘空间 维护索引需要消耗数据库的资源 在 insert update delete操作下 会性能下降 因为要维护索引 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:2:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"最左匹配原则 现在有一个联合索引包含了 name age bir 三个列 name bir age 能否利用索引 - yes name age bir 能否利用索引 - yes age bir 能否利用索引 - no bir age name 能否利用索引 - yes age bir 能否利用索引 - no 面对上述问题 有两个要注意 最左匹配原则 也就是 “name” or “name age” or “name age bir” 就可以走索引 mysql 引擎在查询为了更好利用索引 在查询过程中会动态优化查询字段 a = 1 and b = 1 and c \u003e 1 and d = 1 联合索引 走到范围查询就会停止 所以这里d不会走到索引 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:3:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"索引的妙用 SELECT 如果有这样的char列，前10个字符都是唯一的，可以建立短索引（前缀索引）这样能加快查询效率 并且减少磁盘io WHERE != not in这些并不会使用索引，但是\u003c \u003e等 都可以使用索引 如果where子句使用到函数 则不会走索引 如果where子句已经使用过索引 orderby 并不会使用索引 所以真要使用orderby 最好建立联合索引 如果用 like %like% %like 不使用索引 like% 才会使用 如果用 or如果 or 前后的两个条件的列都是索引, 那么查询会使用索引， 如果前后两个条件有一个不是索引 则不会使用索引 JOIN 在需要join的列最好用索引 但是要注意 主键与外键的类型必须是相同的 要不然不走索引 使用索引建议性原则 在 查询中很少使用 或者参考的列不要创建索引。由于这些列很少使用到，增加索引反而会降低系统的维护速度和增大空间需求 只有很少数据值的列 也不应该增加索引，由于这些列的取值很少，区分度太低。例如人事表中的性别,在查询时,需要在表中搜索的数据行的比例很大, 增加索引，并不能明显加快检索速度 定义为 text、image 和 bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少 当 修改性能远远大于检索性能 时，不应该创建索引。这是因为，二者是相互矛盾的，当增加索引时，会提高检索性能，但是会降低修改性能 定义有 外键 的数据列一定要创建索引 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:4:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"B+ Tree B+ Tree导出过程 举个例子 现在有几条数据 在底层存储是这么存储的绿色: 主键 / 红色: 数据 / 蓝色: 指针 下一个数据(node) *但是这样随后问题就来了 数据量少就算了 如果有1000条数据 链表时间复杂度为O(n) 所以mysql采用了 **分页（升维）*的思路每一个数据都会存放着自己的那一页的第一条数据的逐渐 随后指针p指向自己的分页的下一级数据 然后我们把第一层的页目录再次提取一层，最终用了三层的结构 ![b+树 终极形态](/Users/ting/Library/Application Support/typora-user-images/image-20230302174409156.png) b+ tree总结 B+树本质上是一种多叉平衡二叉树，是由多个页组成的多层级结构，每个页16Kb，对于主键索引来说，最末级的叶子结点放行数据，非叶子结点放的则是索引信息(主键id和页号)，用于加速查询 B+树利用了空间换时间、升维的方式(构造了一批非叶子结点用于存放索引信息)，将查询时间复杂度从O(n)优化为O(lg(n)) ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:5:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"B+ Tree 和 跳表的区别 查询 B+树是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，所以扇出很高。三层左右就可以存储2kw左右的数据 / 跳表是链表结构，一条数据一个结点，如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方左右，所以，跳表大概高度在24层左右，所以得出结论 b+Tree的查询效率要比跳表高得多 写 B+树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此跳表的写入性能会比B+树要好 其实，mysql的存储引擎是可以换的，以前是myisam，后来才有的innodb，它们底层索引用的都是B+树。也就是说，你完全可以造一个索引为跳表的存储引擎装到mysql里。事实上，facebook造了个rocksDB的存储引擎，里面就用了跳表。直接说结论，它的写入性能确实是比innodb要好，但读性能确实比innodb要差不少 redis为什么使用跳表而不使用B+树或二叉树呢? 大家知道，redis 是纯纯的内存数据库。进行读写数据都是操作内存，跟磁盘没啥关系，因此也不存在磁盘IO了，所以层高就不再是跳表的劣势了。并且前面也提到B+树是有一系列合并拆分操作的，换成红黑树或者其他AVL树的话也是各种旋转，目的也是为了保持树的平衡。而跳表插入数据时，只需要随机一下，就知道自己要不要往上加索引，根本不用考虑前后结点的感受，也就少了旋转平衡的开销。因此，redis选了跳表，而不是B+树 总结 B+树是多叉平衡搜索树，扇出高，只需要3层左右就能存放2kw左右的数据，同样情况下跳表则需要24层左右，假设层高对应磁盘IO，那么B+树的读性能会比跳表要好，因此mysql选了B+树做索引 redis的读写全在内存里进行操作，不涉及磁盘IO，同时跳表实现简单，相比B+树、AVL树、少了旋转树结构的开销，因此redis使用跳表来实现ZSET，而不是树结构 存储引擎RocksDB内部使用了跳表，对比使用B+树的innodb，虽然写性能更好，但读性能属实差了些。在读多写少的场景下，B+树依旧YYDS ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:6:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"B Tree 与 B+ Tree的区别 B Tree 非叶子结点也会存储数据 这样会导致 树的高度比 b+ tree 高 查询磁盘io次数也会比 b+ tree高 这样会影响查询效率 B+ Tree 只有叶子节点会存储数据 非叶子节点只存储键值信息 注意 不是键值对哦~ 所有叶子节点之间都有一个键指针 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:7:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"聚簇索引 \u0026 非聚簇索引 聚簇索引 将数据与索引存放在一块 索引结构的叶子节点保存了行数据 非聚簇索引 将数据与索引分开存储 索引结构的叶子节点指向了数据对应的位置(注意 不是地址哦~) 注意事项 在Innodb中, 在聚簇索引之上创建的索引称之为辅助索引. 非聚簇索引都是辅助索引 像联合索引 唯一索引 前缀索引叶子节点存储的不再是行的物理位置，而是主键值 辅助索引访问数据总是二次查找 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:8:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"在不同引擎下的索引 Innodb Innodb使用的是聚簇索引，将主键组织到一颗b+树中，而行数据就储存到叶子节点 使用 WHERE id = 14这样的主键条件的查询过程 按照 b+ tree 的检索算法即可找到对应的叶节点，之后获得行数据 使用 非主键 WHERE name = 'Ame' 的条件查询过程 在辅助索引b+ tree中检索name，到达其叶子节点获取对应的主键 使用主键在主索引b+ tree中在执行一次b+ tree检索操作，最终到达叶子节点即可获取整行数据 聚簇索引默认是主键，如果表中没有定义主键，Innodb会选择一个唯一且非空的索引代替，如果还是没有这样的索引，Innodb会隐式定义一个主键来作为聚簇索引 如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可 MyISAM MYISAM使用的是非聚簇索引 非聚簇索引的两颗b+树看上去没什么不同 节点的结构一样 只是存储的内容不同 主键索引b+树的节点存储了主键, 辅助索引b+树存储了辅助键 这两颗b+树的叶子节点都使用一个地址指向真正的表数 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:9:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"使用聚簇索引的优势 引出 每次使用辅助索引都要经过两次 b+树查找, 看上去聚簇索引的效率明显要低于非聚簇索引, 所以使用聚簇索引优势在哪 由于行数据和聚簇索引的叶子节点存储在一起, 同一页会有多条数据, 访问同一数据页不同行记录时, 已经将页加载到了buffer 辅助索引的叶子节点, 存储主键值, 而不是数据的存放地址. 好处是当行数据发生变化时, 索引树的节点也需要变化 或者是我们需要查找的数据, 在上一次io读写的缓存中没有, 需要发生一次新的io操作时, 可以比避免对辅助索引的维护工作， 只需要维护聚簇索引树就好了 还有一个因为辅助索引存放的主键值 还少了辅助索引占用的存储空间大小 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:10:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"mysql的主键类型 mysql不推荐uuid为主键 uuid不适合排序且可能会出现新增加记录的uuid 会插入在索引树中间的位置 导致索引树调整复杂度变大 消耗更多的时间和资源 建议使用int bigint类型, 方便排序并且默认会在索引树的末尾增加主键值 ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:11:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"参考资料 参考资料 《MYSQL内核：INNODB存储引擎 卷1》 《RocksDB和Innodb引擎性能PK胜负难料?》 https://cloud.tencent.com/developer/article/1813695 https://www.51cto.com/article/706701.html ","date":"2017-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:12:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"详述了MySQL的事务","date":"2017-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"事务 ","date":"2017-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:0:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"事务 事务是什么 事务就是要么全部完成 要么全部失败 目的是为了保证数据的一致性 事务的ACID 原子性保证全部完成 要么全部失败 没有中间状态 他是靠 undo日志来实现的 持久性事务修改后的数据会一直存在 他是靠 redo日志来实现的 隔离性多个事务之间不会互相影响，他是靠MVCC也就是undo log来实现的 一致性多个事务修改数据后 数据都是一致的 事务的隔离级别（InnoDB引擎中, 定义了四种隔离级别供我们使用 级别越高性能越低 而隔离性是由mysql的各种锁和MVCC机制来实现的） 读未提交我们可以去读事务未提交的数据，会带来 脏读，不可重复读，幻读的问题 读已提交我们只可以去读事务已经提交的数据，会带来不可重复读，幻读的问题 可重复读一个事务不管读取多少次，读的都是以第一次读的快照为标准，会带来幻读的问题 串行化直接串行，一个事务一个事务来，这样效率就会及其低下 事务当中存在的可能问题 脏读事务A正在修改数据，事务B去读了，随后A发生了问题callback，B读取的数据就会无效 不可重复读事务A正在更新数据，事务B去读数据了，随后事务A更新完毕，事务B再去读取，发现前后数据不一致 幻读事务A正在插入数据，事务B读取全部数据，在事务A插入前后读取数据不一致 发现数据多了一行 事务4大隔离级别实现原理 串行化 排他锁和共享锁来实现的 读锁（共享锁，S锁） select ... lock in share mode; 读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改 写锁（排他锁，X锁） select ... for update; 写锁是排他的，会阻塞其他的写锁和读锁，update、delete、insert都会加锁 可重复读 \u0026 读已提交 他们俩是靠MVCC机制来实现的 ","date":"2017-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:1:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"Copy On Write 什么是COW 写入时复制 当有写入操作时 将原表copy一份 专门供来修改 如果此时有查询操作 则就查询原表，等新表写入完成在替换原表 经常用于 读多写少 高并发的场景下，但是不单单只用于该场景 ","date":"2017-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:2:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"MVCC 什么是MVCC 多版本控制链 他跟COW还是很像的，都是在并发下保证数据安全 并且提高效率 MVCC如何实现的 在我们的undo-log记录的数据表中 其实是有两个字段 一个是记录着事务的唯一ID，一个是回滚指针指向上一个事务 比如我们现在update一个数据 那么这个更新后的数据的回滚指针就会指向之前的数据，后面也是一样的道理 所以就形成了一个多版本控制链 ","date":"2017-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:3:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"小谈阿里面试题 - 查询操作方法需要使用事务吗 这种题其实大部分都要视情况而定, 如果你在查询的时候只有一条sql语句 那肯定是没必要开启事务的 但是如果你在导出的场景下 而且隔离级别是可重复读的情况下 导出的数据肯定是需要同一个时间维度的数据 所以这时候需要开启事务，否则就会导致导出的数据中 数据其实不是同一个时间维度的数据 ","date":"2017-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:4:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"MySQL执行过程与BufferPool缓存机制 mysql为何要如此设计 因为mysql要为其性能考虑，kafka为何吞吐量这么高，因为他的写入数据是顺序写，顺序写的性能是相当高 mysql写入 redo-log的时候就是顺序写，但是通过IO线程写入ibd确实随机写，虽然可以优化，但是性能肯定是比不过顺序写 redo-log 为何可以顺序写，ibd确实随机写 redo-log他是记录日志 记录日志本来就可以直接添加在文件末尾的，不会插入或者写在开头 ibd却不一样 我们有多个ibd 因为表有多个，随后我们写数据可能会插入，开头也插入一个数据，所以这里就必须随机写 ","date":"2017-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:5:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"详述了MySQL的CMD命令","date":"2017-07-21","objectID":"/mysql-cmd/","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"cmd命令 ","date":"2017-07-21","objectID":"/mysql-cmd/:0:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"一、存储数据的演变过程 1.随意的存到一个文件中、数据格式也是千差万别的完全取决于我们自己 \"\"\" # 小李 jason|123|NB # 小王 egon-123-DBJ # 小红 tank~123~hecha \"\"\" 2.软件开发目录规范 限制了存储数据的具体位置 \"\"\" bin conf core db lib readme \"\"\" 3.如何将单机变成连网 \"\"\" 假设上述是一个单机游戏 那么每个人的游戏记录只会在自己的计算机上面保存 注册登录的账号也只能在自己的计算机上有效 这样是不行的 所以我们可以 将数据库保存部分全部统一起来 所有人操作数据都来一个地方操作 \"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:1:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二、数据库的本质 \"\"\"本质其实就是一款基于网络通信的应用程序那其实每个人都可以开发一款数据库软件 因为它仅仅就是一个基于网络通信的应用程序也就意味着数据库软件其实有很多很多 关系型数据库 MySQL、oracle、db2、access、sql server 非关系型数据库 redis、mongodb、memcache\"\"\"# 关系型 1 数据之间彼此有关系或者约束 男生表和前女友表 2 存储数据的表现形式通常是以表格存储 name password hobby jason 123 学习 egon 123 女教练 tank 123 吃生蚝 每个字段还会有存储类型的限制 比如姓名只能存字符串...# 非关系型 存储数据通常都是以k,v键值对的形式 ","date":"2017-07-21","objectID":"/mysql-cmd/:2:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"三、MYSQL \"\"\"任何基于网络通信的应用程序底层用的都是socket-服务端 -基于socket通信 -收发消息 -SQL语句-客户端 -基于socket通信 -收发消息 -SQL语句\"\"\"MySQL不单单支持MySQL自己的客户端app还支持其他编程语言来充当客户端操作 如何解决语言沟通的障碍？ # 1 让服务端兼容所有的语言(一个人精通多国语言) # 2 采用统一的语言(SQL语句) ","date":"2017-07-21","objectID":"/mysql-cmd/:3:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"四、重要概念介绍 \"\"\"库 》》》 文件夹表 》》》 文件记录 》》》 文件内一行行的数据 name password hobby jason 123 学习 egon 123 女教练 tank 123 吃生蚝表头 表格的第一行字段字段 name、password、hobby\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:4:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"五、MYSQL的安装 \"\"在IT界 一般都不会轻易的使用最新版本的软件，因为新版本可能会出现各种问题(你原本项目跑的好好的 非要画蛇添足更新版本 然后项目奔溃)小段子: 更新完没事 那么你还是一个普通员工 更新完出事 那么你就是一名\"烈士\"\"\"\"# MySQL有很多版本(5.6、5.7、8.0) 目前企业里面用的比较多的还是5.6左右参考网站:https://www.mysql.com/下载5.6版本即可，如果你下载了其他版本问题也不大，因为sql语句是一样的学按照教学方式下载，会将服务端和客户端一并下载到本地为了学习方便我们将服务端和客户端都在本地启动，后期到了公司服务端会专门跑在一台服务器上，所有人基于网络连接服务端操作 ","date":"2017-07-21","objectID":"/mysql-cmd/:5:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"六、MYSQL服务端与客户端 # exe文件名 \"\"\" 服务端 mysqld.exe 客户端 mysql.exe \"\"\"# 注意 \"\"\" 在前期配置MySQL的时候 cmd终端尽量以管理员的身份运行 windows+r 输入cmd 进入的是普通用户终端 有一些命令是无法执行的 搜索cmd右键 以管理员身份运行 \"\"\"# 启动 先切换到mysqld所在的bin目录下，然后输入mysqld即可 保留原来的cmd窗口重新打开一个\"\"\"常见软件的默认端口号 MySQL 3306 redis 6379 mongodb 27017 django 8000 flask 5000 ... MySQL第一次以管理员身份进入是没有密码的 直接回车即可客户端连接服务端完整命令 mysql -h 127.0.0.1 -P 3306 -uroot -p\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:6:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"七、MYSQL语句初识 1. MySQL结束是以分号(；)为标志2. 基本命令 show databases # 查看全部的库名3. MySQL连接精简版命令 mysql -uroot -p # 省去了默认ip和端口4. 当你输入的命令不对的时候，不想让他继续执行和报错 输入\\c即可(不用分号)5. 客户端退出 quit exit # 不用加分号6. 当你在连接服务端的时候，直接输入MySQL，就可以登录进去，但是是游客模式，只会给你展示一部分内容 ","date":"2017-07-21","objectID":"/mysql-cmd/:7:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"八、环境变量\u0026系统服务制作 \"\"\" 找到mysql的bin文件夹绝对路径，然后邮件我的电脑，点击属性，再点击高级系统设置，在然后点击环境变量，找到下面的path，双击，在新建一个把文件夹绝对路径输入进去，就可以直接cmd输入mysqld啦，不用切换路径文件夹了 我们环境变量弄好了，直接cmd输入mysqld --install 然后显示Service successfully installed就成功了，这时候我们在打开任务管理器，点击管理，找到mysql，右键点击开始，然后这个时候就被我们设置成系统开机就会自动启动的服务端啦，然后直接cmd 直接连接客户端就好啦\"\"\" ***小知识点补充——–如何查看当前进程\u0026如何杀死当前进程 '''1.如何查看当前进程 tasklist |findstr mysql2.如何杀死进程 taskkill /F /PID PID号''' ","date":"2017-07-21","objectID":"/mysql-cmd/:8:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"九、设置密码 \"\"\"mysqladmin -uroot -p 原密码 password 新密码直接在cmd输入 不用打开mysql例如 mysqladmin -uroot -p 123 password 123456\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:9:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十、重置密码 \"\"\"你可以将mysql获取用户名和密码校验的功能看成是一个装饰器装饰在了客户端请求访问的功能上我们如果将该装饰器移除 那么mysql服务端就不会校验用户名和密码了\"\"\"# 1 先关闭当前mysql服务端 命令行的方式启动(让mysql跳过用户名密码验证功能) mysqld --skip-grant-tables # 2 直接以无密码的方式连接 mysql -uroot -p 直接回车# 3 修改当前用户的密码 update mysql.user set password=password(123456) where user='root' and host='localhost';\"\"\"真正存储用户表的密码字段 存储的肯定是密文 只有用户自己知道明文是什么 其他人都不知道 这样更加的安全密码比对也只能比对密文\"\"\"# 4 立刻将修改数据刷到硬盘 flush privileges;# 5 关闭当前服务端 然后以正常校验授权表的形式启动 ","date":"2017-07-21","objectID":"/mysql-cmd/:10:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十一、MYSQL配置文件修改—–统一编码 \"\"\"我们来打开my-default.ini的文件，ini为结尾的文件一般都是配置文件，程序启动会先加载配置文件在真正启动\"\"\"[mysqld] # 一旦服务端启动立刻加载下面的配置sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [mysql] # 一旦客户端启动立刻加载下面的配置...[client] # 其他客户端...# 我们来新建一个ini文件------my.ini# 我们在这里来写个同意编码的文件，然后我们还可以偷个懒，把用户名和密码也写进去，实现自动登录，代码如下 [mysqld] character-set-server=utf8 collation-server=utf8_general_ci [client] default-character-set=utf8 [mysql] user=\"root\" password=123456 default-character-set=utf8# 我们修改后 要去重启服务端，然后再去登陆 ","date":"2017-07-21","objectID":"/mysql-cmd/:11:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十二、MYSQL的基本语句 ","date":"2017-07-21","objectID":"/mysql-cmd/:12:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"12.1 库的增删改查(文件夹) # 增 create database ame; create database yuki charset='gbk';# 查 show database; show create database yuki;# 改 alter database ame charset='gbk';# 删 drop database ame; ","date":"2017-07-21","objectID":"/mysql-cmd/:12:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"12.2 表的增删改查(文件) # 查看当前库所在 select database();# 切换库 use ame;# 增 create table t1(id int, name char(4)); # 里面4的意思就是最大数据4个# 查 show tables # 查看所有表 show create table t1 # 查看t1表 describe t1; # 查看t1表 简写 desc t1# 改 alter table t1 modify name char(16);# 删 drop table t1;\"\"\"create table ame.t1(id int, name char(16)); 使用绝对路径也是可以增加的，用来操做不同的库\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:12:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"12.3 数据的增删改查 # 增 insert into t1 values(1, 'Ame'); insert into t1 values(2, 'yuki'),(3, 'ori');# 查 select * from t1; # 查看所有 数据特别大不建议用 select name from t1; # 查看name# 改 update t1 set name='DSB' where id \u003e 1;# 删 delete from t1 where id \u003e 1; delete from t1 where name='Ame';# 将表所有的数据清空 delete from t1; ","date":"2017-07-21","objectID":"/mysql-cmd/:12:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十三、存储引擎 \"\"\"MySQL 主要的存储引擎 1.Innodb 是MySQL5.5版本机制后默认的存储引擎 存储数据更加的安全 2. myisam 是MySQL5.5版本之前默认的存储引擎 速度要比Innodb更快 但是我们更加注重的是数据的安全 3.memory 内存引擎(数据全部存放在内存中)断电数据丢失 4.blackhole 无论存什么，都立刻消失(黑洞)\"\"\"\"\"\"# 查看所有的存储引擎 show engines;# 不同的存储引擎在存储表的时候 异同点 create table t1(id int) engine=innodb; create table t2(id int) engine=myisam; create table t3(id int) engine=blackhole; create table t4(id int) engine=memory;# 存数据 insert into t1 values(1); insert into t2 values(1); insert into t3 values(1); insert into t4 values(1);\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:13:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十四、创建表的完整语法 # 语法create table 表名( 字段名1 类型(宽度) 约束条件, 字段名2 类型(宽度) 约束条件, 字段名3 类型(宽度) 约束条件)# 注意1 在同一张表中字段名不能重复2 宽度和约束条件是可选的(可写可不写) 而字段名和字段类型是必须的 约束条件写的话 也支持写多个 字段名1 类型(宽度) 约束条件1 约束条件2..., create table t5(id); 报错3 最后一行不能有逗号 create table t6( id int, name char, ); 报错\"\"\"补充\"\"\"# 宽度 一般情况下指的是对存储数据的限制 create table t7(name char); 默认宽度是1 insert into t7 values('jason'); insert into t7 values(null); 关键字NULL 针对不同的版本会出现不同的效果 5.6版本默认没有开启严格模式 规定只能存一个字符你给了多个字符，那么我会自动帮你截取 5.7版本及以上或者开启了严格模式 那么规定只能存几个 就不能超，一旦超出范围立刻报错 Data too long for ....\"\"\"严格模式到底开不开呢？\"\"\"MySQL5.7之后的版本默认都是开启严格模式的使用数据库的准则: 能尽量少的让数据库干活就尽量少 不要给数据库增加额外的压力# 约束条件 null not null不能插入nullcreate table t8(id int,name char not null);\"\"\"宽度和约束条件到底是什么关系 宽度是用来限制数据的存储 约束条件是在宽度的基础之上增加的额外的约束\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:14:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十五、基本数据类型 ","date":"2017-07-21","objectID":"/mysql-cmd/:15:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"15.1 整形 1.分类 tinyint smallint meduimint int bigint2.作用 存储年龄 等级 id 号码...\"\"\"以tinyint 是否有符号 默认情况下是带符号的 超出会如何 超出限制只存最大可接受值\"\"\"create table t9(id tinyint);insert into t9 values(-129),(256);# 约束条件之unsigned 无符号create table t10(id tinyint unsigned);# int默认也是带符号的# 整形默认情况下都是带有符号的create table t11(id int);# 针对整形 括号内的宽度到底是干嘛的create table t12(id int(8));insert into t12 values(123456789)\"\"\"特例：只有整形括号里面的数字不是表示限制位数id int(8) 如果数字没有超出8位 那么默认用空格填充至8位 如果数字超出了8位 那么有几位就存几位(但是还要是遵守最大范围)\"\"\"create table t13(id int(8) unsigned zerofill);# 用0填充到8位# 总结 针对整形字段 括号内无需指定宽度 因为他默认的宽度以及足够显示所有的数据了 ","date":"2017-07-21","objectID":"/mysql-cmd/:15:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"15.2 严格模式(小插曲) # 如何查看严格模式show variables like \"%mode\";模糊匹配/查询 关键字 like %:匹配任意多个字符 _:匹配任意单个字符# 修改严格模式 set session 只在当前窗口有效 set global 全局有效 set global sql_mode = 'STRICT_TRANS_TABLES'; 修改完之后 重新进入服务端即可 ","date":"2017-07-21","objectID":"/mysql-cmd/:15:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"15.3 浮点型 1.分类 FLOAT、DOUBLE、DECIMAL2.作用 身高、体重、薪资# 存储限制float(255,30) # 总共255位 小数部分占30位double(255,30) # 总共255位 小数部分占30位decimal(65,30) # 总共65位 小数部分占30位# 精确度验证create table t15(id float(255,30));create table t16(id double(255,30));create table t17(id decimal(65,30));\"\"\"你们在前期不要给我用反向键 所有的命令全部手敲！！！增加熟练度\"\"\"insert into t15 values(1.111111111111111111111111111111);insert into t16 values(1.111111111111111111111111111111);insert into t17 values(1.111111111111111111111111111111);float \u003c double \u003c decimal# 要结合实际应用场景 三者都能使用 ","date":"2017-07-21","objectID":"/mysql-cmd/:15:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"15.4 字符类型 1.分类 \"\"\" char 定长 char(4) 数据超过四个字符直接报错 不够四个字符空格补全 varchar 变长 varchar(4) 数据超过四个字符直接报错 不够有几个存几个 \"\"\" create table t18(name char(4)); create table t19(name varchar(4)); insert into t18 values('a'); insert into t19 values('a');# 介绍一个小方法 char_length统计字段长度 select char_length(name) from t18; select char_length(name) from t19; \"\"\" 首先可以肯定的是 char硬盘上存的绝对是真正的数据 带有空格的 但是在显示的时候MySQL会自动将多余的空格剔除 \"\"\"# 再次修改sql_mode 让MySQL不要做自动剔除操作 set global sql_mode = 'STRICT_TRANS_TABLES,PAD_CHAR_TO_FULL_LENGTH'; # char 与 varchar对比 \"\"\" char 缺点:浪费空间 优点:存取都很简单 直接按照固定的字符存取数据即可 jason egon alex wusir tank 存按照五个字符存 取也直接按照五个字符取 varchar 优点:节省空间 缺点:存取较为麻烦 1bytes+jason 1bytes+egon 1bytes+alex 1bytes+tank 存的时候需要制作报头 取的时候也需要先读取报头 之后才能读取真实数据 以前基本上都是用的char 其实现在用varchar的也挺多 \"\"\"补充: 进来公司之后你完全不需要考虑字段类型和字段名 因为产品经理给你发的邮件上已经全部指明了 ","date":"2017-07-21","objectID":"/mysql-cmd/:15:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"15.5 时间类型 1.分类 date:年月日 2020-5-4 datetime:年月日时分秒 2020-5-4 11:11:11 time:时分秒 11:11:11 Year:年 2020 2.具体使用 create table student( id int, name varchar(16), born_year year, birth date, study_time time, reg_time datetime ); insert into student values(1,'egon','1880','1880-11-11','11:11:11','2020-11-11 11:11:11'); ","date":"2017-07-21","objectID":"/mysql-cmd/:15:5","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"15.6 枚举与集合类型 1.分类 \"\"\" 枚举(enum) 多选一 集合(set) 多选多 \"\"\" 2.具体使用 create table user( id int, name char(16), gender enum('male','female','others') ); insert into user values(1,'jason','male'); 正常 insert into user values(2,'egon','xxxxooo'); 报错# 枚举字段 后期在存数据的时候只能从枚举里面选择一个存储 create table teacher( id int, name char(16), gender enum('male','female','others'), hobby set('read','DBJ','hecha') ); insert into teacher values(1,'jason','male','read'); 正常 insert into teacher values(2,'egon','female','DBJ,hecha'); 正常 insert into teacher values(3,'tank','others','生蚝'); 报错# 集合可以只写一个 但是不能写没有列举的 ","date":"2017-07-21","objectID":"/mysql-cmd/:15:6","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十六、约束条件 ","date":"2017-07-21","objectID":"/mysql-cmd/:16:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"16.1 DEFAULT 默认值 default 默认值 补充知识点 插入数据的时候可以指定字段 create table t1( id int, name char(16) ); insert into t1(name,id) values('ame',1) create table t2( id int, name char(16), gender enum('male','female','others')default 'male' ); insert into t2(id, name) values(1,'jason'); insert into t2 values(2, 'egon', 'female'); ","date":"2017-07-21","objectID":"/mysql-cmd/:16:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"16.2 UNIQUE唯一 unique唯一 # 单列唯一 create table t3( id int unique, name char(16) ); insert into t3 values(1,'jason'),(1,'egon'); insert into t3 values(1,'jason'),(2,'egon'); # 联合唯一 \"\"\" ip和port 单个都可以重复 但是加在一起必须是唯一的 \"\"\" create table t4( id int, ip char(16), port int, unique(ip,port) ); insert into t4 values(1,'127.0.0.1',8080); insert into t4 values(2,'127.0.0.1',8081); insert into t4 values(3,'127.0.0.2',8080); insert into t4 values(4,'127.0.0.1',8080); 报错 ","date":"2017-07-21","objectID":"/mysql-cmd/:16:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"16.3 PRIMARY KEY 主键 \"\"\"1.单单从约束效果上来看primary key等价于not null + unique非空且唯一!!!\"\"\" create table t5(id int primary key); insert into t5 values(null); 报错 insert into t5 values(1),(1); 报错 insert into t5 values(1),(2);\"\"\"2.它除了有约束效果之外 他还是Innodb存储引擎组织数据的依据Innodb存储引擎在创建表的时候必须要有primary key因为它类似于书的目录 能够帮助提示查询效率并且也是建表的依据\"\"\" 2.1 一张表中有且只有一个主键 如果你没有设置主键 那么会从上往下搜索直到遇到一个非空且唯一的字段将他自动升级为主键 create table t6( id int, name char(16), age int not null unique, addr char(32) not null unique ); 2.2 如果表中没有主键也没有其他任何和的非空且唯一的字段 那么Innodb会采用自己内部提供的一个隐藏字段作为主键，隐藏意味着你无法使用到它 就无法提示查询速度 3.3 一张表中通常都应该有一个主键字段 并且通常将id/uid/sid字段作为主键 单个字段主键 create table t5( id int primary key name char(16) ); 联合主键(多个字段联合起来作为表的主键 本质还是一个主键) create table t7( ip char(16), port int, primary key(ip, port) ); \"\"\" 也意味着 以后我们在创建表的时候id字段一定要加primary key \"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:16:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"16.4 AUTO_INCREMENT 自增 # 当编号特别多的时候 人为的去维护太麻烦 create table t8( id int primary key auto_increment, name char(16) ); insert into t8(name) values('jason'),('egon'),('kevin');# 注意auto_increment通常都是加在主键上的 不能给普通字段加 create table t9( id int primary key auto_increment, name char(16), cid int auto_increment ); ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key ","date":"2017-07-21","objectID":"/mysql-cmd/:16:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十七、表与表之间建关系 ","date":"2017-07-21","objectID":"/mysql-cmd/:17:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.1 问题引出 \"\"\"定义一张员工表 表中有很多字段id name gender dep_name dep_desc\"\"\"# 1 该表的组织结构不是很清晰(可忽视)# 2 浪费硬盘空间(可忽视)# 3 数据的扩展性极差(无法忽视的)# 如何优化？\"\"\"上述问题就类似于你将所有的代码都写在了一个py文件中\"\"\"将员工表拆分 员工表和部门表 ","date":"2017-07-21","objectID":"/mysql-cmd/:17:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.2 外键 \"\"\"外键就是用来帮助我们建立表与表之间关系的foreign key\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:17:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.3 表关系 \"\"\"表与表之间最多只有四种关系 一对多关系 在MySQL的关系中没有多对一一说 一对多 多对一 都叫一对多！！！ 多对多关系 一对一关系 没有关系\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:17:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.4 一对多关系 \"\"\"判断表与表之间关系的时候 前期不熟悉的情况下 一定要按照我给你的建议换位思考 分别站在两张表的角度考虑员工表与部门表为例 先站在员工表 思考一个员工能否对应多个部门(一条员工数据能否对应多条部门数据) 不能！！！ (不能直接得出结论 一定要两张表都考虑完全) 再站在部门表 思考一个部门能否对应多个员工(一个部门数据能否对应多条员工数据) 能！！！ 得出结论 员工表与部门表示单向的一对多 所以表关系就是一对多\"\"\"foreign key 1 一对多表关系 外键字段建在多的一方 2 在创建表的时候 一定要先建被关联表 3 在录入数据的时候 也必须先录入被关联表# SQL语句建立表关系create table dep( id int primary key auto_increment, dep_name char(16), dep_desc char(32));create table emp( id int primary key auto_increment, name char(16), gender enum('male','female','others') default 'male', dep_id int, foreign key(dep_id) references dep(id));insert into dep(dep_name,dep_desc) values('教学部','教书育人'),('外交部','多人外交'),('nb技术部','技术能力有限部门');insert into emp(name,dep_id) values('jason',2),('egon',1),('tank',1),('kevin',3);# 修改dep表里面的id字段update dep set id=200 where id=2; 不行# 删除dep表里面的数据delete from dep; 不行# 1 先删除教学部对应的员工数据 之后再删除部门 操作太过繁琐 # 2 真正做到数据之间有关系 更新就同步更新 删除就同步删除\"\"\"级联更新 \u003e\u003e\u003e 同步更新级联删除 \u003e\u003e\u003e 同步删除\"\"\"create table dep( id int primary key auto_increment, dep_name char(16), dep_desc char(32));create table emp( id int primary key auto_increment, name char(16), gender enum('male','female','others') default 'male', dep_id int, foreign key(dep_id) references dep(id) on update cascade # 同步更新 on delete cascade # 同步删除);insert into dep(dep_name,dep_desc) values('sb教学部','教书育人'),('外交部','多人外交'),('nb技术部','技术能力有限部门');insert into emp(name,dep_id) values('jason',2),('egon',1),('tank',1),('kevin',3); ","date":"2017-07-21","objectID":"/mysql-cmd/:17:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.5 多对多表关系 \"\"\"图书表和作者表\"\"\"create table book( id int primary key auto_increment, title varchar(32), price int, author_id int, foreign key(author_id) references author(id) on update cascade # 同步更新 on delete cascade # 同步删除);create table author( id int primary key auto_increment, name varchar(32), age int, book_id int, foreign key(book_id) references book(id) on update cascade # 同步更新 on delete cascade # 同步删除);\"\"\"按照上述的方式创建 一个都别想成功！！！其实我们只是想记录书籍和作者的关系针对多对多字段表关系 不能在两张原有的表中创建外键需要你单独再开设一张 专门用来存储两张表数据之间的关系\"\"\"create table book( id int primary key auto_increment, title varchar(32), price int);create table author( id int primary key auto_increment, name varchar(32), age int);create table book2author( id int primary key auto_increment, author_id int, book_id int, foreign key(author_id) references author(id) on update cascade # 同步更新 on delete cascade, # 同步删除 foreign key(book_id) references book(id) on update cascade # 同步更新 on delete cascade # 同步删除); ","date":"2017-07-21","objectID":"/mysql-cmd/:17:5","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.6 一对一 \"\"\"id name age addr phone hobby email........如果一个表的字段特别多 每次查询又不是所有的字段都能用得到将表一分为二 用户表 用户表 id name age 用户详情表 id addr phone hobby email........ 站在用户表 一个用户能否对应多个用户详情 不能！！！ 站在详情表 一个详情能否属于多个用户 不能！！！ 结论:单向的一对多都不成立 那么这个时候两者之间的表关系 就是一对一 或者没有关系(好判断)客户表和学生表 在你们报名之前你们是客户端 报名之后是学生(期间有一些客户不会报名)\"\"\"一对一 外键字段建在任意一方都可以 但是推荐你建在查询频率比较高的表中create table authordetail( id int primary key auto_increment, phone int, addr varchar(64));create table author( id int primary key auto_increment, name varchar(32), age int, authordetail_id int unique, foreign key(authordetail_id) references authordetail(id) on update cascade # 同步更新 on delete cascade # 同步删除) ","date":"2017-07-21","objectID":"/mysql-cmd/:17:6","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.7 总结 \"\"\"表关系的建立需要用到foreign key 一对多 外键字段建在多的一方 多对多 自己开设第三张存储 一对一 建在任意一方都可以 但是推荐你建在查询频率较高的表中判断表之间关系的方式 换位思考！！！ 员工与部门 图书与作者 作者与作者详情\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:17:7","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.8 修改表 # MySQL对大小写是不敏感的\"\"\"1 修改表名 alter table 表名 rename 新表名;2 增加字段 alter table 表名 add 字段名 字段类型(宽度) 约束条件; alter table 表名 add 字段名 字段类型(宽度) 约束条件 first; alter table 表名 add 字段名 字段类型(宽度) 约束条件 after 字段名;3 删除字段 alter table 表名 drop 字段名;4 修改字段 alter table 表名 modify 字段名 字段类型(宽度) 约束条件; alter table 表名 change 旧字段名 新字段名 字段类型(宽度) 约束条件; \"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:17:8","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"17.9 复制表 \"\"\"我们sql语句查询的结果其实也是一张虚拟表\"\"\"create table 表名 select * from 旧表; 不能复制主键 外键 ...create table new_dep2 select * from dep where id\u003e3; ","date":"2017-07-21","objectID":"/mysql-cmd/:17:9","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十八、前期表准备 create table emp( id int not null unique auto_increment, name varchar(20) not null, sex enum('male','female') not null default 'male', #大部分是男的 age int(3) unsigned not null default 28, hire_date date not null, post varchar(50), post_comment varchar(100), salary double(15,2), office int, #一个部门一个屋子 depart_id int);#插入记录#三个部门：教学，销售，运营 insert into emp(name,sex,age,hire_date,post,salary,office,depart_id) values ('jason','male',18,'20170301','张江第一帅形象代言',7300.33,401,1), #以下是教学部 ('tom','male',78,'20150302','teacher',1000000.31,401,1), ('kevin','male',81,'20130305','teacher',8300,401,1), ('tony','male',73,'20140701','teacher',3500,401,1), ('owen','male',28,'20121101','teacher',2100,401,1), ('jack','female',18,'20110211','teacher',9000,401,1), ('jenny','male',18,'19000301','teacher',30000,401,1), ('sank','male',48,'20101111','teacher',10000,401,1), ('哈哈','female',48,'20150311','sale',3000.13,402,2),#以下是销售部门 ('呵呵','female',38,'20101101','sale',2000.35,402,2), ('西西','female',18,'20110312','sale',1000.37,402,2), ('乐乐','female',18,'20160513','sale',3000.29,402,2), ('拉拉','female',28,'20170127','sale',4000.33,402,2), ('僧龙','male',28,'20160311','operation',10000.13,403,3), #以下是运营部门 ('程咬金','male',18,'19970312','operation',20000,403,3), ('程咬银','female',18,'20130311','operation',19000,403,3), ('程咬铜','male',18,'20150411','operation',18000,403,3), ('程咬铁','female',18,'20140512','operation',17000,403,3);# 当表字段特别多 展示的时候错乱 可以使用\\G分行展示 select * from emp\\G;# 个别同学的电脑在插入中文的时候还是会出现乱码或者空白的现象 你可以将字符编码统一设置成GBK ","date":"2017-07-21","objectID":"/mysql-cmd/:18:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"十九、几个重要关键字的执行顺序 # 书写顺序 select id,name from emp where id \u003e 3;# 执行顺序 from where select \"\"\" 虽然执行顺序和书写顺序不一致 你在写sql语句的时候可能不知道怎么写 你就按照书写顺序的方式写sql select * 先用*号占位 之后去补全后面的sql语句 最后将*号替换后你想要的具体字段 这里先理解 \"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:19:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十、WHERE筛选条件 # 作用:是对整体数据的一个筛选操作# 1.查询id大于等于3小于等于6的数据 select id,name,age from emp where id\u003e=3 and id\u003c=6; select id,name from emp where id between 3 and 6; 两者等价# 2.查询薪资是20000或者18000或者17000的数据 select * from emp where salary=20000 or salary=18000 or salary=17000; select * from emp where salary in (20000,18000,17000);# 3.查询员工姓名中包含字母o的员工的姓名和薪资 \"\"\" 模糊查询 like % 匹配任意多个字符 _ 匹配任意单个字符 \"\"\" select name,salary from emp where name like '%o%';# 4.查询员工姓名是由四个字符组成的 姓名和薪资 char_length() _ select name,salary from emp where name like '____'; select name,salary from emp where char_length(name) = 4;# 5.查询id小于3或者id大于6的数据 select * from emp where id not between 3 and 6;# 6.查询薪资不在20000,18000,17000范围的数据 select * from emp where salary not in (20000,18000,17000);# 7.查询岗位描述为空的员工姓名和岗位名 针对null不用等号 用is select name,post from emp where post_comment = NULL; select name,post from emp where post_comment is NULL; ","date":"2017-07-21","objectID":"/mysql-cmd/:20:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十一、GROUP BY分组 # 分组实际应用场景 分组应用场景非常的多 男女比例 部门平均薪资 部门秃头率 国家之间数据统计# 1 按照部门分组 select * from emp group by post; \"\"\" 分组之后 最小可操作单位应该是组 还不再是组内的单个数据 上述命令在你没有设置严格模式的时候是可正常执行的 返回的是分组之后 每个组的第一条数据 但是这不符合分组的规范:分组之后不应该考虑单个数据 而应该以组为操作单位(分组之后 没办法直接获取组内单个数据) 如果设置了严格模式 那么上述命令会直接报错 \"\"\" set global sql_mode = 'strict_trans_tables,only_full_group_by'; 设置严格模式之后 分组 默认只能拿到分组的依据 select post from emp group by post; 按照什么分组就只能拿到分组 其他字段不能直接获取 需要借助于一些方法(聚合函数)\"\"\"什么时候需要分组啊？？？ 关键字 每个 平均 最高 最低 聚合函数 max min sum count avg\"\"\"# 1.获取每个部门的最高薪资 select post,max(salary) from emp group by post; select post as '部门',max(salary) as '最高薪资' from emp group by post; select post '部门',max(salary) '最高薪资' from emp group by post;# as可以给字段起别名 也可以直接省略不写 但是不推荐 因为省略的话语意不明确 容易错乱# 2.获取每个部门的最低薪资 select post,min(salary) from emp group by post;# 3.获取每个部门的平均薪资select post,avg(salary) from emp group by post;# 4.获取每个部门的工资总和 select post,sum(salary) from emp group by post;# 5.获取每个部门的人数 select post,count(id) from emp group by post; # 常用 符合逻辑 select post,count(salary) from emp group by post; select post,count(age) from emp group by post; select post,count(post_comment) from emp group by post; null不行# 6.查询分组之后的部门名称和每个部门下所有的员工姓名 # group_concat不单单可以支持你获取分组之后的其他字段值 还支持拼接操作 select post,group_concat(name) from emp group by post; select post,group_concat(name,'_DSB') from emp group by post; select post,group_concat(name,':',salary) from emp group by post;# concat不分组的时候用 select concat('NAME:',name),concat('SAL:',salary) from emp;# 补充 as语法不单单可以给字段起别名 还可以给表临时起别名 select emp.id,emp.name from emp; select emp.id,emp.name from emp as t1; 报错 select t1.id,t1.name from emp as t1;# 查询每个人的年薪 12薪 select name,salary*12 from emp; ","date":"2017-07-21","objectID":"/mysql-cmd/:21:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十二、分组注意事项 # 关键字where和group by同时出现的时候group by必须在where的后面 where先对整体数据进行过滤之后再分组操作 where筛选条件不能使用聚合函数 select id,name,age from emp where max(salary) \u003e 3000; select max(salary) from emp; # 不分组 默认整体就是一组# 统计各部门年龄在30岁以上的员工平均薪资 1 先求所有年龄大于30岁的员工 select * from emp where age\u003e30; 2 再对结果进行分组 select * from emp where age\u003e30 group by post; select post,avg(salary) from emp where age\u003e30 group by post; ","date":"2017-07-21","objectID":"/mysql-cmd/:22:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十三、HAVING分组之后的筛选条件 \"\"\"having的语法根where是一致的只不过having是在分组之后进行的过滤操作即having是可以直接使用聚合函数的\"\"\"# 统计各部门年龄在30岁以上的员工平均工资并且保留平均薪资大于10000的部门 select post,avg(salary) from emp where age\u003e30 group by post having avg(salary) \u003e 10000 ; ","date":"2017-07-21","objectID":"/mysql-cmd/:23:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十四、DISTINCT去重 \"\"\"一定要注意 必须是完全一样的数据才可以去重！！！一定不要将逐渐忽视了 有逐渐存在的情况下 是不可能去重的[{'id':1,'name':'jason','age':18},{'id':2,'name':'jason','age':18},{'id':3,'name':'egon','age':18}]ORM 对象关系映射 让不懂SQL语句的人也能够非常牛逼的操作数据库表 类一条条的数据 对象字段对应的值 对象的属性你再写类 就意味着在创建表用类生成对象 就意味着再创建数据对象点属性 就是在获取数据字段对应的值目的就是减轻python程序员的压力 只需要会python面向对象的知识点就可以操作MySQL\"\"\"select distinct id,age from emp;select distinct age from emp; ","date":"2017-07-21","objectID":"/mysql-cmd/:24:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十五、ORDER BY排序 select * from emp order by salary;select * from emp order by salary asc;select * from emp order by salary desc;\"\"\"order by默认是升序 asc 该asc可以省略不写也可以修改为降序 desc\"\"\"select * from emp order by age desc,salary asc;# 先按照age降序排 如果碰到age相同 则再按照salary升序排# 统计各部门年龄在10岁以上的员工平均工资并且保留平均薪资大于1000的部门,然后对平均工资降序排序 select post,avg(salary) from emp where age\u003e10 group by post having avg(salary) \u003e 1000 order by avg(salary) desc ; ","date":"2017-07-21","objectID":"/mysql-cmd/:25:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十六、LIMIT限制展示条数 select * from emp;\"\"\"针对数据过多的情况 我们通常都是做分页处理\"\"\" select * from emp limit 3; # 只展示三条数据 select * from emp limit 0,5; select * from emp limit 5,5; 第一个参数是起始位置 第二个参数是展示条数 ","date":"2017-07-21","objectID":"/mysql-cmd/:26:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十七、正则 select * from emp where name regexp '^j.*(n|y)$'; ","date":"2017-07-21","objectID":"/mysql-cmd/:27:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"二十八、多表操作 ","date":"2017-07-21","objectID":"/mysql-cmd/:28:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"28.1 前期表准备 #建表 create table dep( id int, name varchar(20) ); create table emp( id int primary key auto_increment, name varchar(20), sex enum('male','female') not null default 'male', age int, dep_id int );#插入数据 insert into dep values (200,'技术'), (201,'人力资源'), (202,'销售'), (203,'运营'); insert into emp(name,sex,age,dep_id) values ('jason','male',18,200), ('egon','female',48,201), ('kevin','male',18,201), ('nick','male',28,202), ('owen','male',18,203), ('jerry','female',18,204); ","date":"2017-07-21","objectID":"/mysql-cmd/:28:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"28.2表查询 select * from dep,emp; # 结果 笛卡尔积\"\"\"了解即可 不知道也没关系\"\"\" select * from emp,dep where emp.dep_id = dep.id;\"\"\"MySQL也知道 你在后面查询数据过程中 肯定会经常用到拼表操作 所以特地给你开设了对应的方法 inner join 内连接 left join 左连接 right join 右连接 union 全连接\"\"\"# inner join 内连接 select * from emp inner join dep on emp.dep_id = dep.id;# 只拼接两张表中公有的数据部分# left join 左连接 select * from emp left join dep on emp.dep_id = dep.id;# 左表所有的数据都展示出来 没有对应的项就用NULL# right join 右连接 select * from emp right join dep on emp.dep_id = dep.id;# 右表所有的数据都展示出来 没有对应的项就用NULL# union 全连接 左右两表所有的数据都展示出来 select * from emp left join dep on emp.dep_id = dep.id union select * from emp right join dep on emp.dep_id = dep.id; ","date":"2017-07-21","objectID":"/mysql-cmd/:28:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"28.3 子查询 \"\"\"子查询就是我们平时解决问题的思路 分步骤解决问题 第一步 第二步 ...将一个查询语句的结果当做另外一个查询语句的条件去用\"\"\"# 查询部门是技术或者人力资源的员工信息 1 先获取部门的id号 2 再去员工表里面筛选出对应的员工 select id from dep where name='技术' or name = '人力资源'; select name from emp where dep_id in (200,201); select * from emp where dep_id in (select id from dep where name='技术' or name = '人力资源'); ","date":"2017-07-21","objectID":"/mysql-cmd/:28:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"28.4 总结 表的查询结果可以作为其他表的查询条件也可以通过起别名的方式把它作为一个张虚拟表根其他表关联\"\"\"多表查询就两种方式 先拼接表再查询 子查询 一步一步来\"\"\" ","date":"2017-07-21","objectID":"/mysql-cmd/:28:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"小知识：mysql-arm 安装 安装mysql：brew install mysql@5.7安装brew服务：brew tap homebrew/services加载和启动MySQL服务：brew services start mysql@5.7检查mysql服务是否已加载：brew services list创建软链接: ln -s /opt/homebrew/Cellar/mysql@5.7/5.7.38/bin/mysql /usr/local/bin/mysql验证安装mysql是否成功： mysql -v进入brew安装目录: cd /opt/homebrew/Cellar/mysql@5.7/5.7.38/bin初始化密码，更改你自己的密码： ./mysqladmin -u root password 'yourpassword' ","date":"2017-07-21","objectID":"/mysql-cmd/:29:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"}]