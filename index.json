[{"categories":["Unreal"],"content":"Unreal - 传统输入 与 增强输入","date":"2026-01-26","objectID":"/unreal-input/","tags":["Unreal","Input"],"title":"Unreal - 传统输入 与 增强输入","uri":"/unreal-input/"},{"categories":["Unreal"],"content":"传统输入 想象一下你在做一个《GTA》类的游戏。 “上车”后的逻辑地狱 在传统输入里，你定义了一个“空格键”叫 Jump。 步行时：按空格是跳跃。 开车时：你想让空格变成手刹。 潜水时：你想让空格变成向上浮。 结果： 你的角色代码里会充斥着这种“逻辑毛线团”： 如果 (在车里) { 执行手刹 } 否则如果 (在水里) { w执行上浮 } 否则 { 执行跳跃 } 这就像老式街机，如果你想把“发射”键改成“确认”键，你得拿烙铁去后台重新接线。线越多，你就越容易把自己绕晕。 ","date":"2026-01-26","objectID":"/unreal-input/:1:0","tags":["Unreal","Input"],"title":"Unreal - 传统输入 与 增强输入","uri":"/unreal-input/"},{"categories":["Unreal"],"content":"增强输入 增强输入把“按键”和“动作”彻底分开了。 Input Action (IA) —— “功能按钮” Input Action* 就是技能表里的“轻攻击”、“交互”、“翻滚”。* 它不关心你是按了鼠标左键还是手柄的 R1，它只代表一个动作意图。 例子：你定义一个 IA_Attack。 好处：无论玩家是在用键盘、PS5 手柄还是方向盘开黑，你的 C++ 代码里只需要监听 IA_Attack 触发了没，而不需要去管玩家到底按了哪个键。 Input Mapping Context (IMC) —— “技能卡带” 同一个“空格键”，在不同模式下的功能完全不同： 步行模式：空格键 = 跳跃 (IA_Jump) 驾驶模式：空格键 = 手刹 (IA_Handbrake) 跳伞模式：空格键 = 开伞 (IA_OpenParachute) 怎么玩？ 当玩家拉开车门那一刻，你只需要代码里一行 Add Mapping Context (驾驶模式)。 神奇的事发生了：系统会自动把“步行模式”的按键屏蔽掉，同样的物理空格键，现在输出的指令自动变成了“手刹”。 这就是增强输入的魅力： 你再也不用在代码里写 if (是在车里) { 手刹 } else { 跳跃 } 这种又臭又长的代码了。 ","date":"2026-01-26","objectID":"/unreal-input/:2:0","tags":["Unreal","Input"],"title":"Unreal - 传统输入 与 增强输入","uri":"/unreal-input/"},{"categories":["Unreal"],"content":"总结 特性 传统输入 (Legacy) 增强输入 (Enhanced) 逻辑存储 项目配置文件（全局唯一） 独立的 UAsset（可复用、可动态加载） 状态切换 靠大量的布尔判断（Boolean Overload） 靠 Context 的叠加与移除（Layering） 数据处理 在 Tick 或事件中手动计算数学逻辑 资产内置 Modifiers（死区、缩放、反转） 手感调节 需要改动功能代码 在资产配置中调整 Triggers 参数 ","date":"2026-01-26","objectID":"/unreal-input/:3:0","tags":["Unreal","Input"],"title":"Unreal - 传统输入 与 增强输入","uri":"/unreal-input/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 UI","date":"2026-01-06","objectID":"/lyra-commonui/","tags":["Unreal","Lyra","CommonUI","UI"],"title":"Lyra - CommonUI","uri":"/lyra-commonui/"},{"categories":["Unreal-Lyra"],"content":"CommonUI 文档 https://dev.epicgames.com/documentation/zh-cn/unreal-engine/overview-of-advanced-multiplatform-user-interfaces-with-common-ui-for-unreal-engine ","date":"2026-01-06","objectID":"/lyra-commonui/:1:0","tags":["Unreal","Lyra","CommonUI","UI"],"title":"Lyra - CommonUI","uri":"/lyra-commonui/"},{"categories":["Unreal-Lyra"],"content":"CommonUI的作用 Common UI 被设计来解决上述的难题。有了Common UI，你便可以： 选择性的实现控件的可互动性，使创建丰富的多层UI变得更加轻松。 主机和PC端的多平台支持。 在主机端： 管理方向选择选项，包括选择轨迹和选择历史。 管理不同主机上的UI元素 ","date":"2026-01-06","objectID":"/lyra-commonui/:2:0","tags":["Unreal","Lyra","CommonUI","UI"],"title":"Lyra - CommonUI","uri":"/lyra-commonui/"},{"categories":["Unreal-Lyra"],"content":"CommonUI的使用场景 虽然CommonUI有许多有益功能，但它使用两个主要用例构建而成： 复杂的多层界面。 跨平台支持。 如果你预期你的项目不会使用其中任一用例，可能没有必要使用CommonUI。 除了这些用例之外，我们推荐你考虑你使用CommonUI是为了获得哪些好处，以及这些好处是否值得花时间精力学习UI创建和交互的新范例。 例如，设计仅限PC的实时策略（RTS）游戏时，CommonUI可能不适用，因为此类型的游戏通常使用不需要复杂基本浏览的单层UI，因此使用CommonUI的输入路由或绑定操作系统不大可能获益。 此外，不推荐将CommonUI用于使用WidgetComponents放置的控件。由于CommonUI依赖光标焦点浏览、激活顺序和绘制顺序/层ID，CommonUI仍可以处理你的2D游戏HUD，但不适用于游戏世界中放置的控件。 如果你有现有UI，可以考虑迁移到CommonUI。做出此决定时，考虑你的UI是否接近完成，以及未来是否有可以从使用CommonUI中获益的UI开发计划。 此外，考虑是否可以使用CommonUI创建新控件，同时与旧UI交互，或者是否需要刷新整个UI以迁移到CommonUI。 ","date":"2026-01-06","objectID":"/lyra-commonui/:3:0","tags":["Unreal","Lyra","CommonUI","UI"],"title":"Lyra - CommonUI","uri":"/lyra-commonui/"},{"categories":["Unreal-Lyra"],"content":"Lyra里的UI ","date":"2026-01-06","objectID":"/lyra-commonui/:4:0","tags":["Unreal","Lyra","CommonUI","UI"],"title":"Lyra - CommonUI","uri":"/lyra-commonui/"},{"categories":["Unreal-Lyra"],"content":"第一切入点：CommonGame插件 UCommonLocalPlayer：该类继承于 ULocalPlayer，抛出了三个事件，同时提供了一个主要游戏布局查询，也就是当前游戏主要Widget /** Called when the local player is assigned a player controller */ DECLARE_MULTICAST_DELEGATE_TwoParams(FPlayerControllerSetDelegate, UCommonLocalPlayer* LocalPlayer, APlayerController* PlayerController); FPlayerControllerSetDelegate OnPlayerControllerSet; /** Called when the local player is assigned a player state */ DECLARE_MULTICAST_DELEGATE_TwoParams(FPlayerStateSetDelegate, UCommonLocalPlayer* LocalPlayer, APlayerState* PlayerState); FPlayerStateSetDelegate OnPlayerStateSet; /** Called when the local player is assigned a player pawn */ DECLARE_MULTICAST_DELEGATE_TwoParams(FPlayerPawnSetDelegate, UCommonLocalPlayer* LocalPlayer, APawn* Pawn); FPlayerPawnSetDelegate OnPlayerPawnSet; ACommonPlayerController：该类最终继承于 APlayerController 他重写virtual void ReceivedPlayer()，这个函数的作用就是成功将 LocalPlayer 跟 PlayerController 成功匹配。也就是在这个函数他将触发 OnPlayerControllerSet 事件 UCommonGameInstance：该类继承于GameInstance 它重写了virtual int32 AddLocalPlayer(ULocalPlayer* NewPlayer, FPlatformUserId UserId) override;，此函数是在添加本地玩家的时候调用。 这个函数中Get到了Lyra自己写的一个UGameUIManagerSubsystem，并且调用了这个Subsystem的NotifyPlayerAdded函数 UGameUIManagerSubsystem：该类继承于 UGameInstanceSubsystem 顾名思义，他是游戏UI管理子系统，其核心主要是管理和存放 UGameUIPolicy UGameUIPolicy：该类就继承于一个 UObject，单纯的数据类。 这个类就是游戏UI策略，比如多个本地玩家一块玩，就需要分屏，以及每一个LocalPlayer的UI信息 等等 如果 OnPlayerControllerSet 事件触发。那么他就会给这个本地玩家去分配UI 它里面就存放着一个 UPrimaryGameLayout，直接创建这个UI UPrimaryGameLayout：游戏的主要游戏 UI 布局，这个小部件类代表如何布局、推送和显示所有图层单人游戏的用户界面。分屏游戏中的每个玩家都会收到自己的主要游戏布局。 内部通过 TMap\u003cFGameplayTag, UCommonActivatableWidgetContainerBase*\u003e 维护了多个图层。 HUD: 游戏内的玩家信息 比如血条 小地图 不需要跟玩家交互 GameMenu：跟游戏玩法相关的UI，比如 Shop Menu：主菜单或者设置菜单之类的 Model：模态化UI，比如二次确认弹窗 UCommonUIExtensions：UI的BlueprintFunctionLibrary，提供一些给蓝图或者c++使用的接口，比如呼出 UI ， 查看用户当然输入设备是不是手柄 ","date":"2026-01-06","objectID":"/lyra-commonui/:4:1","tags":["Unreal","Lyra","CommonUI","UI"],"title":"Lyra - CommonUI","uri":"/lyra-commonui/"},{"categories":["Unreal-Lyra"],"content":"第二切入点：大厅 Frontend 大厅 Frontend 地图是 /Script/Engine.World'/Game/System/FrontEnd/Maps/L_LyraFrontEnd.L_LyraFrontEnd'，在这张地图的 World Setting中的 Default Gameplay Experience指定的就是大厅的游戏体验资产。 打开此资产，随后会发现有UGameFeatureAction 是AddComponents，这个AddComponent会将LyraGameState中加入 B_LyraFrontendStateComponent。这个组件就包含着进入大厅的逻辑 ULyraFrontendStateComponent：该类继承了 UGameStateComponent，并且还继承了 ILoadingPRocessInterface 的接口，这说明了该组件有显示进度的功能 ULyraFrontendStateComponent::OnExperienceLoaded：该函数会起FControlFlow（记得在项目中启动这个插件），创建了4个流程： FlowStep_WaitForUserInitialization： 清除用户的所有房间连接，并且判断用户是否是断线重连，如果是则重置用户状态。 FlowStep_TryShowPressStartScreen：判断是否需要添加开始加载UI FlowStep_TryJoinRequestedSession：判断是否是因为好友邀请而进来的，是的话则不需要到主菜单大厅，直接加入游戏即可 FlowStep_TryShowMainScreen：显示主菜单 就这样主菜单就可以显示出来了，主菜单和开始加载页面都是通过第一切入点写的UPrimaryGameLayout中的方法来直接加入显示的 ","date":"2026-01-06","objectID":"/lyra-commonui/:4:2","tags":["Unreal","Lyra","CommonUI","UI"],"title":"Lyra - CommonUI","uri":"/lyra-commonui/"},{"categories":["Unreal-Lyra"],"content":"第三切入点：ULyraActivatableWidget 该类继承于 UCommonActivatableWidget，其实就是做了一个InputMode的功能，再打开GameMenu之类的，我们就不用去手动的SetInputMode，在关闭的时候也不用手动的设置，这些就都可以自动的去帮我们做了 ","date":"2026-01-06","objectID":"/lyra-commonui/:4:3","tags":["Unreal","Lyra","CommonUI","UI"],"title":"Lyra - CommonUI","uri":"/lyra-commonui/"},{"categories":["渲染"],"content":"如何渲染出一个水体效果","date":"2026-01-05","objectID":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/","tags":["Unreal","水体渲染"],"title":"渲染 - 水体模拟","uri":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/"},{"categories":["渲染"],"content":"基础 ","date":"2026-01-05","objectID":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/:1:0","tags":["Unreal","水体渲染"],"title":"渲染 - 水体模拟","uri":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/"},{"categories":["渲染"],"content":"波动方程 $$ F(x) = A \\cdot \\sin(\\frac{2\\pi}{T}x + p) $$ 参数介绍： 参数 作用 T 波长。数值越大，波越平缓（宽）；数值越小，波越密集（窄）。 A 振幅。数值越大，波浪起伏越高；设为 0 则变回平面。 p 相位。改变它会让波浪产生位移，通常用来做动画。 ","date":"2026-01-05","objectID":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/:1:1","tags":["Unreal","水体渲染"],"title":"渲染 - 水体模拟","uri":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/"},{"categories":["渲染"],"content":"平移和方向 平移 如果让水波要看起来匀速水平无限的循环移动，只要让 p 相位的数据不断地取波浪一个周期的数值就好了 具体的做法就是要知道每移动一个波长需要的时间： 根据 时间 = 路程 / 速度 可以得到： $$ SpeedCycle = \\frac{T}{Speed} $$ T 就是波长，Speed就是自定义的变量速度，SpeedCycle 其实就是周期 我们来看这个公式，这个公式告诉了我们：自 time = 0 开始，我们跑了多少周期 $$ \\frac{Time}{SpeedCycle} $$ 我们可以直接取他们的小数点，因为我们不在乎他跑了多少周期，只在乎他在当前周期跑了多少，小数点就是当前周期跑了多少百分比 $$ frac(\\frac{Time}{SpeedCycle}) $$ 最后我们映射到弧度，因为 $ \\sin{x} = \\sin{x + 2\\pi} $ 方向 看图 我们目前 想要水波朝着U向量前进，就得首先将U进行归一化，使其变成单位向量。 随后我们必须将sin波垂直于U向量，也就是将屏幕上的像素点都要通过点积算出在U向量的投影长度（只要投影长度相同的点，它们都处于同一条垂直于U向量 的直线上），并将它作为sin波的输入，这样就可以了。 形象的比喻：一把梳子，U向量是梳子的梳柄，然后梳子的齿就是一排排的波浪，点积的作用就是确定每一个像素点落在了哪一根“梳子齿”上，因为梳子齿永远和手柄是垂直的，所以你通过点积算出来的波浪也永远是垂直于方向的 点积公式： $$ \\mathbf{u} \\cdot \\mathbf{v} = \\vert u \\vert \\vert v \\vert \\cos(\\theta) $$ 由于U是一个单位向量，所以$ \\vert v \\vert \\cos(\\theta) $就是 v向量在u向量上的投影 随后我们将这个放入我们的sin波方程： $$ F(x) = A \\cdot \\sin(\\frac{2\\pi}{T}x + p) \\\\ \\\\ F(x) = A \\cdot \\sin(\\frac{2\\pi}{T} (\\mathbf{u} \\cdot \\mathbf{v}) + p) $$ ","date":"2026-01-05","objectID":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/:1:2","tags":["Unreal","水体渲染"],"title":"渲染 - 水体模拟","uri":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/"},{"categories":["渲染"],"content":"法线的矫正 法线 什么是法线：在曲面上某一点，垂直于该点切平面（Tangent Plane）的向量，就是该点的法线（Normal）。 切平面：比如你有一个足球，随便找一个点，然后你有一个硬纸板，你贴在这个点上，那么这张硬纸板在数学上就叫 切平面 法线：你往这个硬纸板上插一根直立的吸管，那么这个吸管就是法线 我们怎么计算出法线：那么就是微积分中的偏导数了 偏导数 简单介绍：导数是求曲线的某一点斜率，偏导数则求曲面上某一点在特定方向（如 x 或 y）上的斜率。这两个斜率都是一个数。 / 切平面则是由两个偏导数（x 方向斜率和 y方向斜率）共同确定的一个平面 偏导数符号：$ \\partial{z} $ 对 x 求偏导： $$ f_x(x, y) = \\frac{\\partial{z}}{\\partial{x}} = \\lim_{\\Delta{x} \\to 0} \\frac{f(x + \\Delta{x}, y) - f(x , y)}{\\Delta{x}} $$ 对 y 求偏导： $$ f_y(x, y) = \\frac{\\partial{z}}{\\partial{y}} = \\lim_{\\Delta{y} \\to 0} \\frac{f(x, y + \\Delta{y}) - f(x , y)}{\\Delta{y}} $$ 求出法线：两个方向的切向量叉乘就是垂直于他们的法线 $$ \\vec{Normal} = \\vec{T} \\times \\vec{B} $$ 简化后的终极公式：这里就不展示过程了，大家可以推导一下 $$ \\vec{Normal} = (-\\frac{\\partial{z}}{\\partial{x}}, -\\frac{\\partial{z}}{\\partial{y}}, 1) $$ 别忘记归一化，让法线变成单位向量哦~ ","date":"2026-01-05","objectID":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/:1:3","tags":["Unreal","水体渲染"],"title":"渲染 - 水体模拟","uri":"/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/"},{"categories":["Unreal"],"content":"Unreal - GAS 架构","date":"2025-12-26","objectID":"/unreal-gas/","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"什么是GAS GAS 全称 Gameplay Ability System，是虚幻引擎提供的一套高度模块化、且原生支持网络同步的玩法逻辑框架。它将“技能逻辑”、“数值计算”和“表现效果”彻底解耦，是构建大型 RPG 或动作游戏的工业级标准。 GAS 的核心组成部分： 1. Ability System Component (ASC) —— 心脏与中枢 它是 GAS 的核心组件，所有需要使用 GAS 的对象都必须挂载它。它负责持有和管理所有的能力、效果和标签，并且是网络同步的权威中心。 2. Gameplay Abilities (GA) —— 技能逻辑 它定义了技能“具体要做什么”。包含技能的释放顺序、激活条件、消耗以及冷却。它是一段逻辑代码块，比如“闪避”、“火球术”或“打开宝箱”。 3. Attribute Set —— 属性仓库 它是专门存放数值的地方。比如 Health、Mana、Strength。它不仅存储浮点数，还负责处理属性变动时的限制逻辑，比如血量不能超过最大上限。 4. Gameplay Effects (GE) —— 技能效果 它是改变属性的载体。它不包含代码逻辑，只包含数据。比如“每秒扣 10 点血”、“永久增加 5 点力量”或者“给目标附加一个眩晕状态”。 5. Gameplay Tags —— 标签 它是层级化的字符串标签。它是 GAS 系统判断逻辑的灵魂，比如通过检查角色是否有“State.Dead”标签来决定是否允许释放技能。 6. Gameplay Cues (GC) —— 表现层 它专门处理非数值的表现效果，比如粒子特效、音效、震动。它将视觉反馈从复杂的逻辑计算中剥离出来，从而大幅提升性能和网络带宽利用率。 7. Ability Tasks —— 异步处理机 因为技能通常是持续的过程，它允许技能在运行中“等待”特定事件。比如“等待动画播放到某个节点”、“等待玩家再次输入”或“等待 2 秒钟”。 总结： 你可以把 GAS 想象成一个自动化的流程：一般来说玩家按下按键触发“能力(GA)”，能力检查“标签(Tags)”确认状态，通过“任务(Tasks)”执行异步过程，产生“效果(GE)”去修改“属性集(Attribute Set)”中的数值，最后触发“提示(GC)”播放华丽的特效。 ","date":"2025-12-26","objectID":"/unreal-gas/:1:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"IAbilitySystemInterface 一个契约。确保引擎和 GAS 内部（如 GameplayCue）无论在哪个 Actor 身上，都能通过一个统一的接口 GetAbilitySystemComponent() 找到它的心脏。 ","date":"2025-12-26","objectID":"/unreal-gas/:2:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UAbilitySystemGlobals 存储能力系统（GAS）的全局数据。 可以通过“项目设置”（Project Settings）中的“游戏玩法能力设置”（Game -\u003e Gameplay Abilities Settings）进行配置。 （注意，如果Unreal版本低于5.5，则 ProjectSetting 找不到，只能去 DefaultGame.ini 里面手动配置） ","date":"2025-12-26","objectID":"/unreal-gas/:3:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"元数据与逻辑 ","date":"2025-12-26","objectID":"/unreal-gas/:4:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FGameplayTag / FGameplayTagContainer GAS 的 “神经递质”。 GAS 几乎所有的判断（能不能放技能、能不能吃 Buff、触发什么特效）全部依赖 Tag。没有标签，GAS 只是普通的属性库；有了标签，它才真正拥有了“逻辑”。 ","date":"2025-12-26","objectID":"/unreal-gas/:4:1","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UAbilitySystemBlueprintLibrary GAS 的“万能工具箱”。 提供了一系列静态函数，让你在蓝图中能轻松地获取 ASC、应用 GE、判断 Tag。它是 C++ 底层与蓝图表现层之间的快速通道。 ","date":"2025-12-26","objectID":"/unreal-gas/:4:2","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"GAS调试 showdebug abilitysystem 在控制台输入 showdebug abilitysystem。这个命令显示的界面，本质上就是把上面提到的所有 Spec、ActiveGE、Tags 的实时状态可视化给你看。 ","date":"2025-12-26","objectID":"/unreal-gas/:5:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"AbilitySystemComponent GAS 的心脏。用于与玩法能力系统 (GameplayAbilities System) 对接的核心 Actor 组件。 更加通俗的理解就是：它是连接你的角色（Actor）与技能系统（GAS）的桥梁/核心入口 它负责所有 Gameplay Ability 的赋予与激活，管理 Attribute 的聚合修改，处理 Gameplay Effect 的生命周期，并作为 Gameplay Tags 的宿主来驱动状态逻辑，同时在底层处理所有相关数据的网络同步与动作预测。 ","date":"2025-12-26","objectID":"/unreal-gas/:6:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"一些重要接口 virtual void InitAbilityActorInfo(AActor* InOwnerActor, AActor* InAvatarActor); 翻译：设置该 ASC 的“主人”（Owner）和“化身”（Avatar）。 入参： OwnerActor：逻辑上的所有者（通常是 PlayerState 或 Pawn）。 AvatarActor：表现上的物理实体（通常是 Character）。 核心逻辑：这是 ASC 的启动开关。如果不调用它，技能放不出来、属性同步不了、UI 也会报错。 /* FGameplayAbilitySpec AbilitySpec(AbilityCDO, AbilityLevel); AbilitySpec.SourceObject = SourceObject; AbilitySpec.DynamicAbilityTags.AddTag(InputTag); */ FGameplayAbilitySpecHandle GiveAbility(const FGameplayAbilitySpec\u0026 AbilitySpec); 让角色拥有一项技能 UFUNCTION(BlueprintCallable, Category = \"Abilities\") bool TryActivateAbility(FGameplayAbilitySpecHandle AbilityToActivate, bool bAllowRemoteActivation = true); 尝试去激活一个技能。为什么说尝试？因为它里面会触发 CanActivateAbility等一系列检查 bAllowRemoteActivation： （True）当你在客户端调用此函数时，如果该技能被配置为“在服务器上运行”，客户端会自动向服务器发送一个 RPC 请求，告诉服务器：“我要放这个技能了 （False）激活请求只会留在本地。如果该技能需要服务器确认，而你禁用了远程激活，那么激活就会失败。 virtual FGameplayEffectContextHandle MakeEffectContext() const; 翻译：创建效果上下文句柄。 核心逻辑：这个函数用于生成一个空的、但已经初始化了基础信息的容器。它会自动把当前的 OwnerActor（所有者，如 PlayerState）和 AvatarActor（表现肉体，如 Character）填进去。这个上下文（Context）就像是一张空白的身份证，记录了这一发效果到底是谁发出来的。 开发提示：这是一个虚函数，你可以重写它来携带更多自定义数据。比如在射击游戏中，你可以在重写的 Context 里加入是否爆头、子弹飞行距离等信息。这个生成的句柄随后会被传入 MakeOutgoingSpec，确保这些背景数据能一路跟随 GE 传递到目标的伤害计算（ExecCalc）逻辑中，让目标知道自己是被谁、从哪、用什么方式打中的。 virtual FGameplayEffectSpecHandle MakeOutgoingSpec(TSubclassOf\u003cUGameplayEffect\u003e GameplayEffectClass, float Level, FGameplayEffectContextHandle Context) const; 翻译：创建一个待发送的 GE 规范句柄。 入参： GameplayEffectClass：你想使用的 GE 类。 Level：等级。 Context：施法上下文。 核心逻辑：这是配合下一个函数使用的前提。它就像是先填好一张“发货单”但还没发货。你会拿到一个 Handle，通过这个 Handle 你可以调用 SetSetByCallerMagnitude 等函数来修改这批货的“重量”或“属性”，改完后再用 Apply 接口发出去。 virtual FActiveGameplayEffectHandle ApplyGameplayEffectSpecToTarget(const FGameplayEffectSpec\u0026 GameplayEffect, UAbilitySystemComponent *Target, FPredictionKey PredictionKey=FPredictionKey()); virtual FActiveGameplayEffectHandle ApplyGameplayEffectSpecToSelf(const FGameplayEffectSpec\u0026 GameplayEffect, FPredictionKey PredictionKey = FPredictionKey()); 翻译：应用已经配置好的 GE 规范（Spec）至目标或自身。 入参： Spec：这是一个已经填好了所有数据的“全家桶”对象（可以通过 FGameplayEffectSpecHandle 获取）。它里面已经包含了等级、上下文、甚至你手动设置的动态数值（SetByCaller）。 Target：仅在 ToTarget 中使用，指定效果的接收方。 PredictionKey：网络预测键，用于消除客户端的操作延迟感。 核心逻辑：这是 GAS 中最高级的应用方式。与之前直接传 UClass 不同，这种方式允许你在效果真正发出去之前，对它进行最后的修改。 FActiveGameplayEffectHandle ApplyGameplayEffectToTarget(UGameplayEffect *GameplayEffect, UAbilitySystemComponent *Target, float Level = UGameplayEffect::INVALID_LEVEL, FGameplayEffectContextHandle Context = FGameplayEffectContextHandle(), FPredictionKey PredictionKey = FPredictionKey()); FActiveGameplayEffectHandle ApplyGameplayEffectToSelf(const UGameplayEffect *GameplayEffect, float Level, const FGameplayEffectContextHandle\u0026 EffectContext, FPredictionKey PredictionKey = FPredictionKey()); 翻译：将状态效果（GE）应用至目标或自身。 入参（综合介绍）： GameplayEffect：想要施加的 GE 类（UClass）。它决定了效果的类型，比如是回血、扣血还是增加防御。 Target：仅在 ToTarget 中使用。指定谁来接收这个效果。如果是 ToSelf，则默认接收者就是调用者自己。 Level：效果的等级。用于缩放 GE 内部的数值。比如 1 级技能伤害是 100，2 级可能是 200，就靠这个参数传递。 Context / EffectContext：上下文句柄。它记录了这次施法的完整背景，比如谁发起的、通过哪个技能发的、命中了哪个点。它是追溯伤害来源（KillCam 或战斗日志）的关键数据。 PredictionKey：网络预测键。用于处理客户端延迟。它能让玩家在点击技能的瞬间，本地先看到血条变动或 Buff 出现，而不需要等待服务器的往返确认，保证了游戏手感的流畅。 核心逻辑：这是 GAS 修改属性的终极入口。无论技能逻辑多么复杂，最后一步通常都是通过这两个函数把效果实实在在地挂到角色身上。调用后会返回一个 FActiveGameplayEffectHandle，你可以拿着这个句柄来查询该 Buff 的剩余时间或手动将其移除。 float GetNumericAttribute(const FGameplayAttribute\u0026 Attribute) const; 翻译：获取属性的当前最终数值。 入参： Attribute：目标属性，通常通过 AttributeSet 的宏获取。 核心逻辑：它返回的是经过所有 Buff 修正后的最终数字。比如基础血量 100，身上有加 20 血的 Buff，这里就会返回 120。 virtual int32 HandleGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload); 翻译：发送/触发一个游戏事件。 入参： EventTag：触发事件的标签，比如 Event.OnHit。 Payload：携带的数据包，包含受击者、攻击者、位置等丰富信息。 核心逻辑：用于触发那些不需要按键、而是由特定行为激发的技能（例如受击反击、暴击回血）。 FOnGameplayAttributeValueChange\u0026 GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute); 翻译：获取属性值变化的监听委托。 入参： Attribute：想要监听的属性。 核心逻辑：这是做 UI 界面联动最核心的接口。当血量或能量变化时，它会自动广播，让你的 UI 及时更新。 void CancelAbility(UGameplayAbility* Ability); void CancelAbilityHandle(const FGamepl","date":"2025-12-26","objectID":"/unreal-gas/:6:1","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FPredictionKey FPredictionKey 是 GameplayAbility 系统中支持“客户端预测”的一种通用方式。它本质上是一个 ID，用于标识客户端所执行的预测动作及其产生的“副作用”（Side Effects）。UAbilitySystemComponent（ASC）负责在客户端和服务器之间同步这个预测键及其关联的副作用。 本质上，任何行为都可以与一个预测键关联，例如“激活技能”。 流程开始：客户端生成一个全新的预测键，并在调用 ServerTryActivateAbility 时将其发送给服务器。 服务器响应：服务器会确认或拒绝该请求（触发 ClientActivateAbilitySucceed 或 Failed）。 本地预测阶段：在客户端预测技能运行期间，它会产生各种副作用*（如应用 GameplayEffects、触发事件、播放动画等）。每产生一个副作用，客户端都会将其与启动时生成的那个预测键关联起来。* 结果处理： 如果激活被拒绝：客户端可以立即回滚（撤销）这些关联的副作用。 如果激活被接受：客户端必须等待服务器同步真实的副作用数据。 （ClientActivatbleAbilitySucceed 远程调用会立即发送，但属性同步可能晚几帧到达）。 一旦服务器版本的副作用同步完成，客户端就会撤销本地预测的临时副作用（并以服务器同步过来的权威数据为准）。 一般并不会将伤害数值客户端会预测，只会预测技能特效这些表现效果 FPredictionKey 本身主要提供以下功能： 唯一 ID 系统：支持“当前”和“基础”整数构成的依赖链系统。 特殊的网络序列化（NetSerialize）实现：该预测键只会序列化给发起预测的那个客户端。 这一点至关重要：它允许我们将预测键存在同步状态中，但只有给服务器发送过该键的客户端才能真正看到它（其他客户端不会收到多余的预测数据） ","date":"2025-12-26","objectID":"/unreal-gas/:6:2","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"能力系统 ","date":"2025-12-26","objectID":"/unreal-gas/:7:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UGameplayAbility(GA) 能力 (Abilities) 定义了自定义的玩法逻辑，这些逻辑可以由玩家或外部游戏逻辑激活。 它包含技能的释放逻辑、CD、消耗、标签要求。 ","date":"2025-12-26","objectID":"/unreal-gas/:7:1","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"GA蓝图属性 Tags 标签属性组 Ability Tags 用于标识技能本身的标签 能够让其他逻辑或系统识别出此技能的类别 Cancel Abilities With Tag 当此技能激活时 会自动寻找并取消掉当前角色身上正在运行且带有这些标签的其他技能 Block Abilities With Tag 当此技能处于激活状态时 会阻止任何带有这些标签的新技能被触发激活 Activation Owned Tags 技能在激活期间 技能持有者（ASC）会自动获得这些标签 技能结束时标签随之移除 Activation Required Tags 激活的前提条件 只有当技能持有者（ASC）已经具备了这些标签时 技能才允许被开启 Activation Blocked Tags 激活的排除条件 如果技能持有者（ASC）身上带有这些标签 那么该技能将被锁定无法激活 Source Required Tags 检查技能的发起者 只有当发起者（Source Object）具备这些标签时 技能才能成功触发 Source Blocked Tags 检查技能的发起者 如果发起者（Source Object）具备这些标签 技能将无法被成功激活 Target Required Tags 检查技能的目标 只有当目标对象具备这些标签时 技能才会对该目标产生效果 Target Blocked Tags 检查技能的目标 如果目标对象具备这些标签 技能将无法对该目标产生任何效果 Input 输入属性组 Replicate Input Directly 勾选后会将玩家的原始按键输入直接同步给服务器 而不是通过常规的技能指令流 Advanced 高级属性组 Replication Policy 决定了技能的状态和变量是否在网络上进行同步的策略枚举 Do Not Replicate 技能不进行网络同步 仅在各自触发的那一端运行 Replicate 技能的内部状态和变量会从服务器同步给所有相关的客户端 Instancing Policy 决定了技能在内存中如何创建实例对象的策略枚举 Non Instanced 技能不产生实例 所有角色共享一个类定义 内存效率最高但不能存储个体状态 Instanced Per Actor 每个角色在首次使用该技能时创建一个持久实例 适合存储角色的连招段数等 Instanced Per Execution 每次按下技能都会创建一个全新的独立实例 适合处理复杂的独立逻辑 Server Respects Remote Ability Cancellation 决定了当客户端尝试主动取消技能时 服务器是否听从该请求 Retrigger Instanced Ability 对于实例化技能 如果在运行中再次触发 是否停止当前运行并从头重新开始 Net Execution Policy 决定了技能在客户端和服务器之间执行顺序和同步关系的策略枚举 Local Predicted 本地预测模式 客户端立即执行并在服务器端进行验证 这种模式下的操作感最流畅 Local Only 仅本地模式 技能只在本地客户端运行 不会与服务器进行任何通信 Server Only 仅服务器模式 技能只在服务器运行 客户端不运行任何逻辑 适合安全性高的数值逻辑 Server Initiated 服务器启动模式 必须由服务器决定何时启动技能并通知客户端同步执行 Net Security Policy 决定了技能激活权限等级以防止客户端作弊的策略枚举 Client Or Server 客户端或服务器模式 允许客户端请求激活 灵活但安全性一般 Server Only Execution 即使客户端请求 也要等服务器确认指令传回后才允许开始执行 Server Only Termination 客户端无权主动停止技能 必须由服务器判定结束后发送指令 Server Only 技能的启动和停止完全由服务器掌控 具有最高的防作弊安全性 Costs 消耗属性组 Cost Gameplay Effect Class 指定一个 Gameplay Effect 类 用于定义释放技能需要消耗的属性如法力或体力 Triggers 触发属性组 Ability Triggers 定义了触发技能的各种外部条件数组 包含触发源类型和对应的触发标签 Trigger Source 决定了技能响应何种外部逻辑变化来尝试自动激活的策略枚举 Gameplay Event 监听并响应特定的游戏事件标签 通常由其他逻辑发送事件及其数据载荷来精准触发 Owned Tag Added 当技能持有者（ASC）获得并新增了匹配的标签时 立即触发技能尝试自动激活 Owned Tag Present 状态检查触发 只要技能持有者（ASC）当前正持有匹配的标签 技能便满足自动激活前提 Cooldowns 冷却属性组 Cooldown Gameplay Effect Class 指定一个 Gameplay Effect 类 用于通过标签和持续时间定义技能的冷却逻辑 ","date":"2025-12-26","objectID":"/unreal-gas/:7:2","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UAbilityTask 异步处理机。技能是瞬时启动的，Task 允许技能“等待”某事发生（如：等待动画结束、等待一个碰撞、等待一段时间） ","date":"2025-12-26","objectID":"/unreal-gas/:7:3","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"重要接口 virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const; UFUNCTION(BlueprintImplementableEvent, Category = Ability, DisplayName=\"CanActivateAbility\", meta=(ScriptName=\"CanActivateAbility\")) bool K2_CanActivateAbility(FGameplayAbilityActorInfo ActorInfo, const FGameplayAbilitySpecHandle Handle, FGameplayTagContainer\u0026 RelevantTags) const; K2_CanActivateAbility：K2_ 是 Kismet 2 的缩写（虚幻蓝图系统的代号）。带有 K2_ 前缀的函数通常是 C++ 内部使用的“蓝图版本”。 在 CanActivateAbility 的逻辑中就会调用 K2_CanActivateAbility，K2_CanActivateAbility就是在蓝图里面专门写的函数 翻译：判断技能当前能否激活。 入参： SourceTags/TargetTags：来源方和目标方的标签容器。 核心逻辑：系统在调用 TryActivateAbility 时会先运行这个函数。它会检查技能配置里的各种标签要求（比如：处于晕眩状态不能放技能）。你也可以重写它来增加自定义的限制条件。 virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData); 翻译：激活技能。 入参： Handle：技能的唯一识别句柄。 ActorInfo：技能持有者的环境信息（如谁释放的技能）。 ActivationInfo：有关此次激活的网络同步信息。 TriggerEventData：如果是通过事件触发的技能，这里包含了触发时的详细数据。 核心逻辑：这是技能逻辑的总入口。所有的播放动画、产生特效、发射子弹等逻辑都从这里开始编写。 老司机提醒：此为技能逻辑，如果想释放一个技能，还得调用 TryActivateAbility virtual bool CommitAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr); 翻译：提交技能。 入参： 与激活函数的入参基本一致。 OptionalRelevantTags：如果提交失败，可以用来返回失败的具体原因标签。 核心逻辑：这个函数会自动去检查技能的消耗（Cost）和冷却（Cooldown）。只有这两个检查都通过了，它才会扣除资源并开始计算冷却。如果返回 false，说明资源不足或冷却没好。 virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled); 翻译：结束技能。 入参： bReplicateEndAbility：是否需要将结束信号同步给其他端。 bWasCancelled：技能是正常播放完结束的，还是被外部逻辑强行打断的。 核心逻辑：这是最重要的清理接口。如果你不调用它，技能会永远处于“运行中”状态，导致角色可能无法再次释放技能，或者标签一直挂在身上不消失。 FGameplayAbilityActorInfo GetActorInfo() const; 翻译：获取技能相关的 Actor 信息。 核心逻辑：在技能内部使用。通过它可以直接获取到 AvatarActor（当前的肉体小人）、OwnerActor（逻辑上的所有者）以及 ASC 组件。这是技能内部寻找“我是谁”的最快方式。 void SendGameplayEvent(FGameplayTag EventTag, FGameplayEventData Payload); 翻译：发送游戏事件。 入参： EventTag：标识事件的标签。 Payload：携带的各种数据包。 核心逻辑：用于技能内部的主动通信。比如你的技能在某一时刻达成了一个特殊条件，可以发送一个事件来触发角色身上的其他被动技能或特定的特效表现。 virtual void CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility); 翻译：取消/打断当前技能。 入参： bReplicateCancelAbility：是否需要将取消信号同步到其他端。 核心逻辑：这是技能响应“被强行中止”时的处理函数。它的内部实现通常会自动调用 EndAbility，并显式地将 bWasCancelled 参数设为 true。 开发提示：它与 EndAbility 的区别在于，CancelAbility 专门用于非自愿的打断（比如被敌人眩晕、被沉默或玩家按了另一个会互斥掉当前技能的操作）。当你需要针对“被动中断”写一些特殊逻辑（比如中断施法后进入更长的冷却）时，会关注这个流程。 ","date":"2025-12-26","objectID":"/unreal-gas/:7:4","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"重要接口里面的参数 FGameplayAbilitySpec 技能的“说明书实例”。 当你调用 GiveAbility 时，系统会把 GA 类封装成一个 Spec。它存储了技能的等级、输入绑定 ID、以及谁是这个技能的原始所有者。它是技能在内存中真实存在的“户口本”。 FGameplayAbilitySpecHandle 技能在内存中的“唯一身份证”。 定义：一个全局唯一的整数标识符，指向 ASC 中的 FGameplayAbilitySpec。 作用：在 C++ 中，你不应该*保存 UGameplayAbility 的指针，而是应该保存这个 Handle。* 应用场景：当你需要手动结束技能（EndAbility）或者取消特定技能（CancelAbilityHandle）时，系统只认这个 ID。 FGameplayAbilityTargetData 这是一个用于处理目标数据的通用结构体。目标是让通用的函数能够生成这些数据，并由其他通用函数来消费/处理这些数据。 该结构能够同时持有特定的 Actor/对象引用，以及通用的位置（Location）/ 方向（Direction）/ 源点（Origin）信息。 生成者（Producers）示例： 碰撞事件：重叠（Overlap）或命中（Hit）碰撞事件生成关于近战攻击中“谁被击中”的目标数据。 准星射线检测：鼠标输入触发射线检测（Hit Trace），将准星前方的 Actor 转换为目标数据。 视角信息：鼠标输入导致目标数据直接从所有者的准星视角源点或方向生成。 AOE/光环：范围伤害或光环发生脉冲，将施法者周围半径内的所有 Actor 添加到目标数据中。 “涂抹”锁定模式：类似于《铁甲飞龙》（Panzer Dragoon）风格的滑动涂抹锁定模式。 MMORPG 地面 AOE：典型的地面范围技能瞄准方式（可能同时包含一个地面坐标位置和在该区域内的 Actor 列表）。 消费者（Consumers）示例： 应用效果：向目标数据中的所有 Actor 应用一个 GameplayEffect。 寻找最近目标：从目标数据包含的所有对象中找到距离最近的 Actor。 逻辑调用：对目标数据中的所有 Actor 调用某个特定的函数。 数据操作：过滤（Filter）或合并（Merge）多个目标数据。 生成对象：在目标数据指定的位置生成（Spawn）一个新的 Actor。 FGameplayAbilityTargetDataHandle 用来包装 FGameplayAbilityTargetData 的句柄 它的存在主要有以下两个核心目的： 性能优化：避免我们在蓝图中不得不频繁地拷贝整个完整的目标数据结构体。 支持多态性：允许我们在目标数据结构中使用多态特性（即一个句柄可以指向不同类型的具体子类数据）。 网络同步支持：允许我们实现 NetSerialize（网络序列化），从而在客户端和服务器之间实现“按值同步（Replication by value）”。 FGameplayAbilityActivationInfo 技能的“网络状态快照”。 定义：存储在技能实例中的结构体，记录了当前技能是如何启动的。 作用：它是处理网络同步（Replication）和预测（Prediction）时的重要依据。 核心状态： ActivationMode：标识当前是“本地预测（Predicting）”、“服务器权威（Authority）”还是“远程非权威（Non-Authoritative）”。 价值：在技能内部逻辑中，你可以通过它判断：“我现在是在客户端先行播放特效吗？”或者是“我现在是在服务器做最后的数值结算吗？” FGameplayAbilityActorInfo 技能的“环境快照”。 记录了技能相关的 Owner、Avatar（化身）、SkeletalMesh、甚至 MovementComponent。它能让技能内部快速获取这些组件，避免频繁调用 GetComponent 造成的性能损耗。 ","date":"2025-12-26","objectID":"/unreal-gas/:7:5","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"一些其他的杂项 AGameplayAbilityTargetActor 3D 世界的“选择器”。 用于在场景中生成视觉辅助（如圆形范围、直线射线）。它负责捕捉玩家选中的目标，并将其打包成 TargetData 发送给服务器。 警告： 这些角色在每次能力激活时都会生成一次，并且在默认形式下效率不高 对于大多数游戏，您需要子类化并大量修改此 actor，或者您需要在特定于游戏的 actor 或蓝图中实现类似的功能，以避免 actor 生成成本 这个类没有经过内部游戏的充分测试，但它是一个有用的类，可以用来了解目标复制是如何发生的 UGameplayAbilityWorldReticle 目标的“反馈准心”。 专门用于显示目标确认的反馈效果，比如选中的敌人脚下的红圈，或者技能预判的虚影。 ","date":"2025-12-26","objectID":"/unreal-gas/:7:6","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"效果系统 ","date":"2025-12-26","objectID":"/unreal-gas/:8:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UGameplayEffect 数据容器。它不包含逻辑代码，只包含“修改什么属性、持续多久、有什么标签”。 GE 表达了 GAS 架构中一个极其重要的原则：数据与逻辑的彻底分离。 “驱动一切”的数据资产： 在 GAS 中，UGameplayEffect 本质上是一个“复杂的结构体”。它就像一张处方单，上面写着：加多少血、持续多久、带什么标签。所有的属性改变（Attributes）和状态切换（Tags）都必须通过它来驱动。 为什么不让写蓝图逻辑（No Graphs）？ 性能开销：GE 在游戏中会被高频触发、叠加和同步。如果每个 GE 内部都有复杂的蓝图逻辑，性能会迅速崩溃。 可预测性：GE 的作用应该是确定的。逻辑应该写在 Ability (GA) 里，或者写在 Execution Calculation（重型计算器）里，而不是写在 GE 这个“数据包”里。 网络优化：纯数据的同步比同步一段逻辑要高效得多。 所谓的“模板（Templating）”： 你在编辑器里右键创建 Gameplay Effect 蓝图时，你其实只是在利用蓝图的界面来填表（设置数值）。这被称为“模板化”。你只是在给这个资产设置初始值，而不是在给它写程序。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:1","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FAttributeBasedFloat 1. BackingAttribute（支撑属性捕获定义） 数据类型：FGameplayEffectAttributeCaptureDefinition 介绍：这是整个计算的“传感器”。它决定了我们要去抓取谁的属性。 它的数据包含： AttributeToCapture：具体的属性指针（比如攻击力、蓝量）。 Source / Target：是从施法者身上抓，还是从受击者身上抓。 bSnapshot：是否快照。如果设为 true，则记录放技能那一刻的属性；如果为 false，则在效果结算那一刻读取实时属性。 2. Coefficient（系数） 数据类型：FScalableFloat 介绍：公式里的乘数。注意，源码里显示它是一个 FScalableFloat。 深度含义：这意味着你的“系数”本身也可以随着 GE 的等级（Level）而变化。 游戏场景：比如“法力加成”。1 级 GE 时，伤害是蓝量的 1.0 倍；到了 5 级 GE，伤害可能变成蓝量的 1.5 倍。这就是靠这个系数的 FScalableFloat 曲线来实现的。 3. PreMultiplyAdditiveValue（预加值） 数据类型：FScalableFloat 介绍：在乘法执行前，先给捕获到的属性值加上的底数。 逻辑顺序：计算器会先执行 (属性值 + 预加值)。 游戏场景：比如“保底计算”。即便你的蓝量（属性）是 0，你可以设预加值为 10，保证后面乘以系数时不会算出 0。 4. PostMultiplyAdditiveValue（后加值） 数据类型：FScalableFloat 介绍：在乘法执行完毕后，最后加上的一个固定偏移量。 逻辑顺序：(系数 * 前面的结果) + 这个值。 游戏场景：比如“基于蓝量的额外固伤”。你的一招基础伤害是 100（后加值），然后再额外加上蓝量的 20%。 5. AttributeCurve（属性曲线表） 数据类型：FCurveTableRowHandle 介绍：这是源码里最精彩的部分。如果这里填了数据，系统就不直接使用属性数值了，而是把属性数值当做 X 轴坐标，去这张表里查对应的 Y 轴结果。 游戏场景：比如“非线性属性收益”。你的力量达到 100 之后，每点力量带来的伤害提升会越来越少（边际递减），这种复杂的数学曲线不需要写代码，直接把这张表填上就行。 6. AttributeCalculationType（属性计算策略） 数据类型：EAttributeBasedFloatCalculationType 介绍：它决定了计算器怎么看待抓到的那个属性。 常用选项： AttributeMagnitude：直接拿属性的当前值（算完 Buff 的结果）。 AttributeBaseValue：只看属性的基础值（不看任何临时 Buff）。 AttributeEvaluatedUpToChannel：这是一个很深的功能，允许你计算属性时只计算到特定的“层级/通道”，比如无视某些高级别的 Buff。 7. SourceTagFilter / TargetTagFilter（标签过滤器） 数据类型：FGameplayTagContainer 介绍：这是给计算过程加的“前置滤网”。 作用：只有当来源（Source）或目标（Target）拥有这些特定的标签时，这个属性修改才会生效。如果标签不匹配，这一整套公式可能会直接返回 0。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:2","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FGameplayEffectSpec 这个结构体他告诉了我们 使用了哪个 UGameplayEffect（引用的是不可变的常量数据资产）。 等级是多少（Level）。 谁发起的（Instigator）。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:3","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FGameplayEffectSpecHandle 允许蓝图仅生成一次 GameplayEffectSpec，随后通过句柄对其进行引用，从而实现将其多次应用或应用给多个不同的目标。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:4","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FActiveGameplayEffect 正在运行的“效果快照”。 存储在 ASC 内部的结构体。它代表了一个正在生效的持续性（Duration）或永久性（Infinite）的 GE。你想知道自己身上有多少层 Buff，看的就是它。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:5","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FActiveGameplayEffectHandle 效果的“遥控器”。 一个唯一的 ID。当你应用一个 Buff 后，系统返回这个句柄。你想手动移除某个 Buff（比如驱散效果），必须通过这个句柄来操作。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:6","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FGameplayEffectContext 这是一个用于存储 “发起者”及相关数据（例如位置和目标）的数据结构。 开发者可以派生（子类化）该结构，以添加特定于游戏的自定义信息。 由于该结构贯穿于整个效果执行的全过程，因此它是追踪单次执行过程中“瞬态信息（Transient Information）”的绝佳位置。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:7","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FGameplayEffectContextHandle 包装 FGameplayEffectContext 或子类的句柄，以允许其具有多态性并正确复制 ","date":"2025-12-26","objectID":"/unreal-gas/:8:8","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UGameplayModMagnitudeCalculation 该类用于通过蓝图或原生代码（C++）执行自定义的玩法效果（Gameplay Effect）修饰符计算。 MMC 的核心定位是：为 Gameplay Effect (GE) 里的某一个属性修改提供动态数值。 单一属性修改：如果你只需要算出一个数值（比如“伤害值”或“加血量”），并填入 GE 的某一个 Modifier 里。 需要客户端预测 (Prediction)：这是最关键的一点。MMC 在客户端和服务器都会运行。如果你希望玩家按下按键，UI 上的数值（如蓝条、体力）立即顺滑减少，必须用 MMC。 公式相对独立：公式只涉及基础的数学运算。例如： 加血量 = 等级 * 20 + 基础值 技能消耗 = 基础消耗 * (1 - 冷却缩减属性) 逻辑简单：它只能返回一个 float，不能直接修改标签（Tags）或执行复杂的逻辑分支。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:9","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UGameplayEffectExecutionCalculation 重型计算器。用于处理最复杂的伤害公式（涉及多属性对比，如：攻击者的破甲 vs 目标的护甲）。 ExecCalc 的核心定位是：处理涉及多个属性交互、复杂逻辑的最终结算。 多属性交互（经典伤害公式）：如果你的计算需要同时读取来源（Source）和目标（Target）的大量属性。例如： 最终伤害 = (攻击者攻击力 * 暴击倍率 - 目标防御力) * (1 - 目标的免伤率) * 属性克制系数。 修改多个属性：ExecCalc 一次执行可以同时修改多个属性。例如： 一个“吸血”效果：同时减少目标的 Health，增加来源的 Health。 一个“破甲攻击”：同时扣除目标的 Shield 和 Health。 复杂逻辑判断：内部可以写 if-else。例如： “如果目标生命值低于 20%，则触发斩杀，伤害翻倍”。 “如果目标有‘护盾’标签，则伤害先扣除护盾”。 不需要/不建议预测：ExecCalc 通常只在服务器运行。因为伤害结算涉及跨对象的数据交换，客户端预测极易产生“血条回跳”现象。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:10","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UGameplayEffectContextPayloadBase 它是存储在 FGameplayEffectContext 中的自定义动态数据载体。 你可以写一个 UHeadshotPayload 继承自这个 Base，里面存一个 float HeadshotMultiplier。在应用 GE 前，把这个 Payload 塞进 Context，后续的伤害计算类（ExecCalc）就能精准地把它取出来。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:11","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UGameplayEffectComponent UE5.3 引入的模块化设计。将以前杂乱的 GE 设置（如持续时间、几率等）解耦成组件，提高性能。 ","date":"2025-12-26","objectID":"/unreal-gas/:8:12","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"表现层 ","date":"2025-12-26","objectID":"/unreal-gas/:9:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UGameplayCue 处理非数值的表现（特效、音效、震动）。 通过 GameplayTag 触发。它的优点是“火后即焚”，不参与服务器的回滚，只在客户端执行。 ","date":"2025-12-26","objectID":"/unreal-gas/:9:1","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UGameplayCueManager GC 的分发中心。它负责扫描项目中的 GC 路径，并将 Tag 路由到对应的 Notify 或 Actor 上。 ","date":"2025-12-26","objectID":"/unreal-gas/:9:2","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"AGameplayCueNotify_Static “火后即焚”的表现。 专门处理瞬间触发的特效（如爆炸、打击感）。它性能极高，因为它不需要在场景中生成长久存在的 Actor。 ","date":"2025-12-26","objectID":"/unreal-gas/:9:3","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"AGameplayCueNotify_Actor “持续存在”的表现。 用于处理持续性的效果表现（如身上一直冒火、护盾光圈）。它会创建一个真实的 Actor 挂在目标身上，支持复杂的开启和关闭逻辑。 ","date":"2025-12-26","objectID":"/unreal-gas/:9:4","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FGameplayCueParameters 表现层的“情报包”。 当一个 Cue 触发时（比如一次大爆炸），这个结构体负责传递所有的细节。它就像是一个公文包，里面装载了： Location / Normal：爆炸发生的精确坐标和法线方向。 RawMagnitude：一个原始的浮点数值（比如用来缩放爆炸特效的大小）。 EffectContext：溯源信息，让你知道是哪个技能、哪把武器触发了这个特效。 没有它，你的特效只能呆板地播放，有了它，特效才能实现“哪里被打哪喷血”的精准反馈。 ","date":"2025-12-26","objectID":"/unreal-gas/:9:5","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"UAttributeSet 属性仓库。存储 Health, Mana, Attack 等浮点数。 ","date":"2025-12-26","objectID":"/unreal-gas/:10:0","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FGameplayAttribute 属性的“门牌号”。 它不仅仅是一个名字，而是一个结构体，包装了对 UAttributeSet 中特定字段的反射引用。你在代码中指定“修改生命值”时，传的就是这个。 ","date":"2025-12-26","objectID":"/unreal-gas/:10:1","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FGameplayAttributeData 属性的“保险箱”。 这是你在 AttributeSet 中定义的每一个属性的真实数据类型。它不像普通的 float，它内部包含两个核心数值： BaseValue（基础值）：你的永久属性。 CurrentValue（当前值）：算上所有临时 Buff/Debuff 后的最终数值。 理解这两者的区别，是解决“为什么我 Buff 消失后血量回不到上限”等问题的关键。 ","date":"2025-12-26","objectID":"/unreal-gas/:10:2","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["Unreal"],"content":"FAttributeDefaultsWidget 属性的“初始化模板”。 用于在 DataAsset 中方便地批量配置属性初始值，通常用于 NPC 或不同等级职业的属性初始化。 ","date":"2025-12-26","objectID":"/unreal-gas/:10:3","tags":["Unreal","GAS"],"title":"Unreal - GAS","uri":"/unreal-gas/"},{"categories":["3D图形学"],"content":"复数与四元数","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"复数 ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:1:0","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"复数的定义 任意复数 $z \\in \\mathbb{C}$都可以表示为 $z = a + bi$ 的形式，其中 $a, b \\in \\mathbb{R}$ 而且 $i^2 = 1$。我们将 a 称之为这个复数的实部，b 称之为这个复数的虚部 因为 $z = a + bi$ 其实就是对于 { 1, i } 这个基的线性组合，我们也可以用向量来表示一个复数： $$ z = \\begin{bmatrix} a \\\\ \\\\ b \\end{bmatrix} $$ 因为这个向量有两个元素，我们可以使用复平面上的一个点来表示一个复数。复平面的横坐标 Re 代表他的实部，纵坐标 Im 代表他的虚部 ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:1:1","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"复数的性质 复数加减法 如果我们有两个复数 $z_1 = a + bi，z_2 = c + di$，他们的和就是分量相加的结果 $$ z_1 + z_2 = (a + c) + (b + d)i $$ 同理，如果要对他们相减，直接将分量相减就可以了 $$ z_1 - z_2 = (a - c) + (b - d)i $$ 复数乘法 如果我们有两个复数 $z_1 = a + bi，z_2 = c + di$，我们可以用分配律来计算他们的乘积 $$ \\begin{align*} z_1 z_2 \u0026= (a + bi)(c + di) \\\\ \\\\ \u0026= ac + adi + bci + bdi^2 \\end{align*} $$ 因为 i^2 = -1，这可以进一步简化为： $$ \\begin{align*} z_1 z_2 \u0026= ac - bd + adi + bci \\\\ \\\\ \u0026= ac - bd + (bc + ad)i \\end{align*} $$ 如果仔细观察你就能法线，复数相乘的结果其实也是一个矩阵与向量相乘的结果，也就是说： $$ \\begin{align*} z_1 z_2 \u0026= ac - bd + (bc + ad)i \\\\ \\\\ \u0026= \\begin{bmatrix} a \u0026 -b \\\\ \\\\ b \u0026 a \\end{bmatrix} \\begin{bmatrix} c \\\\ \\\\ d \\end{bmatrix} \\end{align*} $$ 右侧的 $\\begin{bmatrix} c \\\\ \\\\ d \\end{bmatrix}$ 是用向量的实行来表示的 $z_2$，而左侧的$ \\begin{bmatrix} a \u0026 -b \\\\ \\\\ b \u0026 a \\end{bmatrix} $ 则是 $z_1$ 的矩阵形式。 那么，在矩阵形式下，复数与复数的相乘也可以表示为矩阵的相乘，如果我们有两个复数 $z_1 = a + bi，z_2 = c + di$，那么与 $z_1 z_2$所代表的变换则可以表示为： $$ \\begin{align*} z_1 z_2 \u0026= \\begin{bmatrix} a \u0026 -b \\\\ \\\\ b \u0026 a \\end{bmatrix} \\begin{bmatrix} c \u0026 -d \\\\ \\\\ d \u0026 c \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} ac - bd \u0026 -(bc + ad) \\\\ \\\\ bc + ad \u0026 ac - bd \\end{bmatrix} \\end{align*} $$ 注意，复数的相乘是满足交换律的，如果你自己尝试一下，就会发现 $z_1 z_2$与$z_2 z_1$是等价的： $$ \\begin{align*} z_2 z_1 \u0026= \\begin{bmatrix} c \u0026 -d \\\\ \\\\ d \u0026 c \\end{bmatrix} \\begin{bmatrix} a \u0026 -b \\\\ \\\\ b \u0026 a \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} ac - bd \u0026 -(bc + ad) \\\\ \\\\ bc + ad \u0026 ac - bd \\end{bmatrix} = z_1 z_2 \\end{align*} $$ 除此之外，我们来看一下一些特殊复数的矩阵形式： $$ 1 = \\begin{bmatrix} 1 \u0026 0 \\\\ \\\\ 0 \u0026 1 \\end{bmatrix} = I \\quad \\quad \\quad \\quad \\quad \\quad (a = 1, b = 0) \\\\ \\\\ \\\\ \\\\ i = \\begin{bmatrix} 0 \u0026 -1 \\\\ \\\\ 1 \u0026 0 \\end{bmatrix} \\quad \\quad \\quad \\quad \\quad \\quad (a = 0, b = 1) $$ 可以看到，实数单位 1 与单位矩阵是等价的。而虚数单位 i 则等价与 $\\begin{bmatrix} 0 \u0026 -1 \\\\ \\\\ 1 \u0026 0 \\end{bmatrix}$ 如果我们尝试对他进行平方，可以发现： $$ i^2 = i \\cdot i = \\begin{bmatrix} 0 \u0026 -1 \\\\ \\\\ 1 \u0026 0 \\end{bmatrix} \\begin{bmatrix} 0 \u0026 -1 \\\\ \\\\ 1 \u0026 0 \\end{bmatrix} = \\begin{bmatrix} -1 \u0026 0 \\\\ \\\\ 0 \u0026 -1 \\end{bmatrix} = -I = -1; $$ 复数的模长 如果 $z = a + bi$，那么他的模长为： $$ ||z|| = \\sqrt{a^2 + b^2} $$ 复数的共轭 如果 $z = a + bi$，那么他的共轭为： $$ \\bar{z} = a - bi; $$ 模长与共轭之关系 一个复数的模长又可以通过乘积的方式进行计算： $$ ||z|| = \\sqrt{z \\bar{z}} $$ ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:1:2","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"复数相乘与2D旋转 既然与复数的相乘代表着 $\\begin{bmatrix} a \u0026 -b \\\\ \\\\ b \u0026 a \\end{bmatrix}$ 矩阵所做出的变换，那这种变换代表着什么呢？ 复数的相乘其实是旋转与缩放变换的复合 如果有一个复数 $z = a + bi$，那么 z 与任意一个复数 c 相乘都会将 c 逆时针旋转 $\\theta = atan2(b, a)$度，并将其缩放 $||z|| = \\sqrt{a^2 + b^2}$ 倍 如果我们想让 2D 空间中任意一个向量 v 旋转 $\\theta$ 度，那么我们就可以使用这个矩阵对 v 进行变换： $$ v’ = \\begin{bmatrix} \\cos(\\theta) \u0026 -\\sin(\\theta) \\\\ \\\\ \\sin(\\theta) \u0026 \\cos(\\theta) \\end{bmatrix} v $$ 注意，其实 $\\begin{bmatrix} \\cos(\\theta) \u0026 -\\sin(\\theta) \\\\ \\\\ \\sin(\\theta) \u0026 \\cos(\\theta) \\end{bmatrix}$，这个旋转矩阵如果写成复数形式的话就是 $\\cos(\\theta) + i \\sin(\\theta)$ 如果我们将向量 $v = \\begin{bmatrix} x \\\\ \\\\ y \\end{bmatrix}$看作是一个复数 $v = x + yi$，其中实部为 x，虚部为 y。那么，我们可以构造一个复数 $z = \\cos(\\theta) + i \\sin(\\theta)$，并将它与 $v$ 相乘来进行旋转。旋转 $\\theta$度之后的向量 $v’$ 可以用等价的复数乘法来表示： $$ v’ = zv = (\\cos(\\theta) + i\\sin(\\theta))v $$ 复数的极坐标型 根据欧拉公式： $$ \\cos(\\theta) + i \\sin(\\theta) = e^{i\\theta} $$ 有了这个等式，我们能将复数表示为： $$ \\begin{align*} z \u0026= ||z|| \\begin{bmatrix} \\cos(\\theta) \u0026 -\\sin(\\theta) \\\\ \\\\ \\sin(\\theta) \u0026 \\cos(\\theta) \\end{bmatrix} \\\\ \\\\ \u0026= ||z|| (\\cos(\\theta) + i \\sin(\\theta)) \\\\ \\\\ \u0026= ||z|| e^{i \\theta} \\end{align*} $$ 如果我们定义 $r = ||z||$，我们就得到了复数的极坐标形式： $$ z = r e^{i \\theta} $$ 现在复数的定义就与实部与虚部的两个分量 a，b 无关了，我们可以使用一个缩放因子 r 和旋转角度 $\\theta$的形式来定义任意一个复数，而且她旋转与缩放的性质仍然存在。 如果我们想对 2D 空间中向量 $ v = \\begin{bmatrix} x \\\\ \\\\ y \\end{bmatrix}$进行旋转并缩放，我们可以类似地将这个向量看作是一个复数 $v = x + yi$，那么，经过旋转 $\\theta$ 度，缩放 r 倍之后的向量 v’ 就可以这样计算： $$ v’ = re^{i\\theta}v $$ 如果仅旋转 $\\theta$ 度的话，可以令缩放因子 r = 1，那么变换后的结果就是： $$ v’ = e^{i \\theta}v $$ 这三种 2D 旋转公式其实都是等价的，根据不同的需求我们可以使用旋转的不同形态 ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:1:3","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"总结：三种 2D旋转公式 2D 旋转公式（矩阵型） $$ v’ = \\begin{bmatrix} \\cos(\\theta) \u0026 -\\sin(\\theta) \\\\ \\\\ \\sin(\\theta) \u0026 \\cos(\\theta) \\end{bmatrix} v $$ 2D 旋转公式（复数积型） $$ v’ = zv = (\\cos(\\theta) + i\\sin(\\theta))v $$ 2D 旋转公式（指数型） $$ v’ = e^{i\\theta}v $$ ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:1:4","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"旋转的复合 当我们对两个 2D 旋转进行复合时，所得到的变换 $z_{net}$ 仍是一个旋转，而且与施加的次序无关 这个等效变换的旋转角是 $z_1$ 与 $z_2$旋转角之和 ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:1:5","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"三维空间的旋转 ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:2:0","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"引言 表示三维空间中旋转的方法有很多种，但我们这里关注的是轴角式 (Axisangle) 的旋转。欧拉角的旋转很常用，但是有万向节死锁问题。 使用的坐标系是右手坐标系 在轴角的表示方法中，一个旋转的定义需要使用到四个变量：旋转轴 u 的 x，y，z 坐标，以及一个旋转角 $\\theta$，这咋比欧拉角还多出来一个呢？实际上，任何三维中的旋转只需要三个自由度就可以定义了 在三维空间中定义一个方向只需要用到两个量就可以了（与任意两个坐标轴之间的夹角）。最简单的例子就是地球经纬度，我们可以靠经纬度两个变量就可以定义地球任何一个方位。但是如果我们要表达方位上特定的一个点，就需要加上海拔这个第三个变量 我们通常都在说旋转是绕着一个向量在旋转，其实就是绕着向量的方向在旋转，所以他的大小（长度）我们是不关心的。所以为了消除这个长度变量，我们可以将长度转化成一个单位向量。故我们从4个自由度就变成 3个自由度了 ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:2:1","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"旋转的分解 首先，我们可以将 v 分解为平行于旋转轴 u 以及正交（垂直）于 u 的两个分量。$v_{\\parallel}$ 和 $v_{\\perp}$，即： $$ v = v_{\\parallel} + v_{\\perp} $$ 我们可以分别旋转这两个分向量，再将他们旋转的结果相加获得旋转后的向量 $$ v’ = v’_{\\parallel} + v’_{\\perp} $$ 可以看到，$v_{\\parallel}$ 其实就是 v 在 u 上的正交投影 ，根据正交投影的公式，我们可以得出： $$ \\begin{align*} v_{\\parallel} \u0026= proj_u(v) \\\\ \\\\ \u0026= \\frac{u \\cdot v}{u \\cdot u} u \\\\ \\\\ \u0026= \\frac{u \\cdot v}{||u||^2} u \\quad \\quad \\quad \\quad \\quad \\quad (||u||^2 = u \\cdot u) \\\\ \\\\ \u0026= (u \\cdot v)u \\quad \\quad \\quad \\quad \\quad \\quad (||u|| = 1) \\end{align*} $$ 因为 $v = v_{\\parallel} + v_{perp}$，我们可以得到： $$ v_{\\perp} = v - v_{\\parallel} = v - (u \\cdot v) u $$ $v_{\\parallel}$ 的旋转 首先，我们来看一下 $v_{parallel}$ 的旋转。这种情况其实非常简单，从之前的图示中就可以看到，$v_{\\parallel}$其实根本就没有旋转，仍然与旋转轴重合，所以： 3D旋转公式（向量型，平行情况） $$ v’ = v’_{\\parallel} $$ $v_{\\perp}$ 的旋转 接下来我们需要处理正交于 u 的 $v_{perp}$。因为这两个向量是正交的，这个旋转可以看做是平面内的一个旋转，因为旋转不改变 $v_{perp}$ 的长度，所以路径是一个圆。下面是这个旋转的示意图，右侧的为俯视图 在2D的旋转上我们只有一个向量 $v_{perp}$，用他来表示一个旋转是不够的，所以我们造了一个同时正交于 u 和 $v_{\\perp}$ 的向量 w，这个可以通过叉乘来获得： $$ w = u \\times v_{\\perp} $$ 注意叉乘的顺序，因为叉乘不支持交换律。 因为 $||u|| = 1$（之前说了 向量 u 转化为单位向量），我们可以发现： $$ \\begin{align*} \\Vert v \\Vert \u0026= \\Vert u \\times v_{\\perp} \\Vert \\\\ \\\\ \u0026= \\Vert u \\Vert \\cdot \\Vert v_{\\perp} \\Vert \\cdot \\sin(\\pi / 2) \\quad \\quad \\quad \\quad \\quad \\quad (\\pi / 2 是u与v_{\\perp}的夹角) \\\\ \\\\ \u0026= \\Vert v_{\\perp} \\Vert \\end{align*} $$ 也就是说，w 和 $v_{\\perp}$ 的模长是相同的，所以他们在同一个圆上。我们现在可以把 $v’_{\\perp}$ 投影到 w 和 $v_{\\perp}$，将其分解为 $v’_v$ 和 $v’_w$。使用一点三角学的知识我们就能得到： $$ \\begin{align*} v’_{\\perp} \u0026= v’_v + v’_w \\\\ \\\\ \u0026= \\cos(\\theta)v_{\\perp} + \\sin(\\theta)w \\\\ \\\\ \u0026= \\cos(\\theta)v_{\\perp} + \\sin(\\theta)(u \\times v_{\\perp}) \\end{align*} $$ 这也是完成了旋转第二步，我们可以得到这样一个定理： 当 $v_{\\perp}$ 正交于旋转轴 u 时，旋转 $\\theta$角度之后的 $v’_{\\perp}$ 为： $$ v’_{\\perp} = \\cos(\\theta)v_{\\perp} + \\sin(\\theta)(u \\times v_{\\perp}) $$ v的旋转 将上面两个结果组合就可以获得： $$ \\begin{align*} v’ \u0026= v’_{\\parallel} + v’_{\\perp} \\\\ \\\\ \u0026= v_{\\parallel} + \\cos(\\theta)v_{\\perp} + \\sin(\\theta)(u \\times v_{\\perp}) \\end{align*} $$ 因为叉乘遵守分配律： $$ \\begin{align*} u \\times v_{\\perp} \u0026= u \\times (v - v_{\\parallel}) \\\\ \\\\ \u0026= u \\times v - u \\times v_{\\parallel} \\\\ \\\\ \u0026= u \\times v \\quad \\quad \\quad \\quad \\quad \\quad (u 平行于 v_{\\perp}，所以 u \\times v_{\\perp} = 0) \\end{align*} $$ 最后，将 $v_{\\parallel} = (u \\cdot v)u$ 与 $v_{\\perp} = v - (u \\cdot v)u$ 代入： $$ \\begin{align*} v’ \u0026= (u \\cdot v)u + \\cos(\\theta)(v - (u \\cdot v)u) + \\sin(\\theta)(u \\times v) \\\\ \\\\ \u0026= \\cos(\\theta)v + (1 - \\cos(\\theta))(u \\cdot v) u +\\sin(\\theta)(u \\times v) \\end{align*} $$ 这样我们就得到了一般形式的旋转公式： $$ v’ = \\cos(\\theta)v + (1 - \\cos(\\theta))(u \\cdot v) u +\\sin(\\theta)(u \\times v) $$ 马上就能看到四元数跟上面公式的联系了 ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:2:2","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"总结：轴角式的 3D旋转公式 3D 旋转公式（向量型，正交情况） 当 $v_{\\parallel}$ 平行于旋转轴 u 时，旋转 $\\theta$ 角度之后的 $v’_{\\parallel}$ 为： $$ v’_{\\parallel} = v_{\\parallel} $$ 3D 旋转公式（向量型，正交情况） 当 $v_{\\perp}$正交于旋转轴 u 时，旋转 $\\theta$ 角度之后的 $v’_{\\parallel}$为： $$ v’_{\\perp} = \\cos(\\theta)v_{\\perp} + \\sin(\\theta)(u \\times v_{\\perp}) $$ 3D 旋转公式（向量型，一般情况，也叫做「Rodrigues’ Rotation Formula」 3D空间中任意一个 v 沿着单位向量 u 旋转 $\\theta$ 角度之后的 v’ 为： $$ v’ = \\cos(\\theta)v + (1 - \\cos(\\theta))(u \\cdot v) u +\\sin(\\theta)(u \\times v) $$ ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:2:3","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"四元数 ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:0","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"什么是四元数 四元数的定义和复数非常相似，唯一的区别就是复数只有一个虚数，而四元数有3个虚数。所有的四元数$q \\in \\mathbb{H}$都可以写成下面这种形式： $$ q = a + bi + cj + dk \\quad \\quad \\quad \\quad \\quad \\quad (a, b, c, d \\in \\mathbb{R}) $$ 其中： $$ i^2 = j^2 = k^2 = ijk = -1 $$ 与复数类似，因为四元数其实就是对于基{1, i, j, k}的线性组合，四元数也可以写成向量的形式： $$ q = \\begin{bmatrix} a \\\\ \\\\ b \\\\ \\\\ c \\\\ \\\\ d \\end{bmatrix} $$ 除此之外，我们经常将四元数的实部与虚部分开，并用一个三维的向量来表示虚部，将它表示为标量和向量的有序对形式 $$ q = [s, v] \\quad \\quad \\quad \\quad \\quad \\quad (v = \\begin{bmatrix} x \\\\ \\\\ y \\\\ \\\\ z \\end{bmatrix}, s, x,y, z \\in \\mathbb{R}) $$ ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:1","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"定义与性质 模长（范数） 仿照复数的定义，我们可以暂时将一个四元数 q = a + bi + cj + dk 的模长（或者说范数）定义为： $$ \\Vert q \\Vert = \\sqrt{a^2 + b^2 + c^2 + d^2} $$ 如果用标量向量有序对的形式进行表示的话，$q = [s, v]$的模长为： $$ \\Vert q \\Vert = \\sqrt{s^2 + \\Vert v \\Vert ^2} = \\sqrt{s^2 + v \\cdot v} $$ 显然，四元数的模长很难用几何的方法来进行理解，因为它代表的是一个四维的长度．但是，和高维向量的模长一样，这只是类比复数模长进行衍生定义的结果，你只需要将它理解为一个定义就可以了 四元数加减法 与复数类似，四元数的加法只需要将分量相加就可以了。 如果我们有两个四元数 $q_1 = a + bi + cj + dk，q_2 = e + fi + gi +hk$，那么他们的和为： $$ \\begin{align*} q_1 + q_2 \u0026= a + bi + cj + dk + e + fi + gi + hk \\\\ \\\\ \u0026= (a+e) + (b+f)i + (c+g)j + (d + h)k \\end{align*} $$ 减法也是同理，只要将加号改为减号就可以了 $$ q_1 - q_2 = (a - e) + (b - f)i + (c - g)j + (d - h)k $$ 如果四元数是以标量向量有序对形式定义的，比如说 $q_1 = [s, \\mathbf{v}]，q_2 = [t, \\mathbf{u}]$，那么： $$ q_1 \\pm q_2 = [s \\pm t, \\mathbf{v} \\pm \\mathbf{u}] $$ 标量乘法 如果我们有一个四元数 q = a + bi + cj + dk 和一个标量 s，那么他们的乘积为： $$ \\begin{align*} sq \u0026= s(a + bi + cj + dk) \\\\ \\\\ \u0026= sa + sbi + scj + sdk \\end{align*} $$ 四元数与标量相乘是遵守交换律的，也就是说 sq = qs 四元数乘法 四元数之间的乘法比较特殊，他们是不遵守交换律的，也就是说一般情况下 $q_1q_2 \\neq q_2q_1$。这也就有了左乘右乘的区别。结合律和分配律在四元数中都是成立的 如果有两个四元数 $q_1 = a + bi + cj + dk$ 和 $q_2 = e + fi + gj + hk$，那么他们的乘积为： $$ \\begin{align*} q_1 q_2 = \u0026(a + bi + cj + dk)(e + fi + gj + hk) \\\\ \\\\ = \u0026 ae + afi + agj + ahk + \\\\ \\\\ \u0026 bei + bfi^2 + bgij + bhik + \\\\ \\\\ \u0026 cej + cfji + cgj^2 + chjk + \\\\ \\\\ \u0026 dek + dfki + dgkj + dhk^2 \\end{align*} $$ 这样乘法最终的结果显然非常凌乱，但是我们可以根据 $i^2 = j^2 = k^2 = ijk = -1$这个定义来化简： $$ \\begin{align*} ijk \u0026= -1 \\\\ \\\\ iijk \u0026= -i \\quad \\quad \\quad \\quad \\quad \\quad (等式两边同时左乘以i) \\\\ \\\\ -jk \u0026= -i \\quad \\quad \\quad \\quad \\quad \\quad (ii = i^2 = -1) \\\\ \\\\ jk \u0026= i \\end{align*} $$ 同理： $$ \\begin{align*} ijk \u0026= -1 \\\\ \\\\ ijkk \u0026= -k \\quad \\quad \\quad \\quad \\quad \\quad (等式两边同时右乘以k) \\\\ \\\\ -ij \u0026= -k \\\\ \\\\ ij \u0026= k \\end{align*} $$ 利用 ij = k 这个公式，我们可以继续推导： $$ \\begin{align*} ij \u0026= k \\\\ \\\\ ijj \u0026= kj \\quad \\quad \\quad \\quad \\quad \\quad (等式两边同时右乘以j) \\\\ \\\\ -i \u0026= kj \\\\ \\\\ kj \u0026= -i \\end{align*} $$ ×\r1\ri\rj\rk\r1\r1\ri\rj\rk\ri\ri\r-1\rk\r-j\rj\rj\r-k\r-1\ri\rk\rk\rj\r-i\r-1\r表格最左列中一个元素右乘以顶行中一个元素的结果就位于这两个元素行列 的交叉处．比如说 𝑗𝑖 = −𝑘．用颜色标记的格子代表着乘法交换律不成立． 利用这个表格，我们进一步化简四元数乘积的结果： $$ \\begin{align*} q_1 q_2 = \u0026(a + bi + cj + dk)(e + fi + gj + hk) \\\\ \\\\ = \u0026 ae + afi + agj + ahk + \\\\ \\\\ \u0026 bei + bfi^2 + bgij + bhik + \\\\ \\\\ \u0026 cej + cfji + cgj^2 + chjk + \\\\ \\\\ \u0026 dek + dfki + dgkj + dhk^2 \\\\ \\\\ = \u0026 (ae - bf - cg - dh) + \\\\ \\\\ \u0026 (be + af - dg + ch)i + \\\\ \\\\ \u0026 (ce + df + ag +bh)j + \\\\ \\\\ \u0026 (de - cf + bg + ah)k \\end{align*} $$ 矩阵形式 可以看到，四元数的相乘其实也是一个线性组合，我们同样可以将它写成矩阵的形式 $$ q_1q_2 = \\begin{bmatrix} a \u0026 -b \u0026 -c \u0026 -d \\\\ \\\\ b \u0026 a \u0026 -d \u0026 c \\\\ \\\\ c \u0026 d \u0026 a \u0026 -b \\\\ \\\\ d \u0026 -c \u0026 b \u0026 a \\end{bmatrix} \\begin{bmatrix} e \\\\ \\\\ f \\\\ \\\\ g \\\\ \\\\ h \\end{bmatrix} $$ 因为四元数不符合交换律，所以在下面给出右乘 $q_1$ 的变换矩阵： $$ q_2q_1 = \\begin{bmatrix} a \u0026 -b \u0026 -c \u0026 -d \\\\ \\\\ b \u0026 a \u0026 d \u0026 -c \\\\ \\\\ c \u0026 -d \u0026 a \u0026 b \\\\ \\\\ d \u0026 c \u0026 -b \u0026 a \\end{bmatrix} \\begin{bmatrix} e \\\\ \\\\ f \\\\ \\\\ g \\\\ \\\\ h \\end{bmatrix} $$ Graßmann 积 对任意四元数 $q_1 = [s, \\mathbf{v}]$，$q_2 = [t, \\mathbf{u}]$，$q_1 q_2$的结果是： $$ q_1 q_2 = [st - \\mathbf{v} \\cdot \\mathbf{u}, s\\mathbf{u} + t\\mathbf{v} + \\mathbf{v} \\times \\mathbf{u}] $$ 如果你还记得之前推导 3D 旋转公式时的结果，你应该就能注意到上面这个定理会成为将四元数与旋转联系起来的关键． 纯四元数 如果一个四元数能写成这种形式：$v = [0, \\mathbf{v}]$，那我们则称 v 为一个纯四元数，即仅有虚部的四元数。 因为纯四元数仅由虚部的3D向量决定，我们可以将任意的3D向量转为纯四元数。 纯四元数有一个很重要的特性：如果有两个纯四元数 $v = [0, \\mathbf{v}]，u = [0, \\mathbf{u}]$，那么： $$ \\begin{align*} vu \u0026= [0 - \\mathbf{v} \\cdot \\mathbf{u}, 0 + \\mathbf{v} \\times \\mathbf{u}] \\\\ \\\\ \u0026 = [-\\mathbf{v} \\cdot \\mathbf{u}, \\mathbf{v} \\times \\mathbf{u}] \\end{align*} $$ 逆和共轭 因为四元数是不遵守交换律的，我们通常不会将两个四元数相除写为 $\\frac{p}{q}$ 的 形式．取而代之的是将乘法的逆运算定义为 $𝑝𝑞^{−1}$ 或者 $𝑞^{−1}𝑝$，注意它们的结果一般是不同的． 其中，$q^{-1}$是q的逆，我们规定： $$ q q^{-1} = q^{-1}q = 1 \\quad \\quad \\quad \\quad \\quad \\quad (q \\neq 0) $$ 这也就是说： $$ (pq)q^{-1} = p(qq^{-1}) = p \\cdot 1 = p \\\\ \\\\ q^{-1}(qp) = (q^{-1}q)p = 1 \\cdot p = p $$ 所以，右乘 q 的逆运算为右乘 $q^{-1}$，左乘 q的逆运算为左乘$q^{-1}$，这个与矩阵的性质非常相似。 我们定义，一个四元数 $q = a + bi + cj + dk$的共轭为 $q^* = a - bi - cj - dk$。如果用标量向量有序对的形式来定义的话，$q = [s，\\mathbf{v}]$的共轭为 $q^* = [s, -\\mathbf{v}]$ 共轭四元数一个非常有用的性质就是： $$ \\begin{align*} qq^* \u0026= [s, \\mathbf{v}] \\cdot [s, -\\mathbf{v}] \\","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:2","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"四元数的几个定理 定理1 如果 $q = [\\cos(\\theta), \\sin(\\theta)\\mathbf{u}]$，而且$\\mathbf{u}$ 为单位向量，那么 $q^2 = qq = [\\cos(2\\theta), \\sin(2\\theta)\\mathbf{u}]$ 这个定理的几何意义就是，如果绕着同一个轴 $\\mathbf{u}$ 连续旋转 $\\theta$ 度两次，那么所作出的变换等同于直接绕着 $\\mathbf{u}$ 旋转 20度 定理2 假设 $v_{\\parallel} = [0, v_{\\parallel}]$是一个纯四元数，而 $q = [\\alpha, \\beta\\mathbf{u}]$ ，其中 $\\mathbf{u}$ 是一个单位向量，$\\alpha, \\beta \\in \\mathbb{R}$。在这种条件下，如果 $v_{\\parallel}$平行于 $\\mathbf{u}$，那么 $qv_{\\parallel} = v_{\\parallel}q$ 定理3 假设$p_{\\perp} = [0, \\mathbf{v_{\\perp}]}$是一个纯四元数，而 $q = [\\alpha, \\beta\\mathbf{u}]$，其中 $\\mathbf{u}$ 是一个单位向量，$\\alpha, \\beta \\in \\mathbb{R}$。在这种条件下，如果$v_{\\perp}$正交于 $\\mathbf{u}$，那么 $qv_{\\perp} = v_{\\perp}q*$ 定理4 对任意四元数 $q_1 = [s, \\mathbf{v}], q_2 = [t, \\mathbf{u}]$： $$ q_1^* q_2^* = (q_2q_1^*) $$ ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:3","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"四元数与 3D 旋转 前言 我们需要将一个向量$\\mathbf{v}$沿着一个用单位向量所定义的旋转轴$\\mathbf{u}$旋转$\\theta$度，那么我们可以将这个向量$\\mathbf{v}$拆分为正交于旋转轴的$v_{\\perp}$以及平行于旋转轴的$v_{\\parallel}$。我们可以对这两个分向量分别进行旋转，获得$v’_{\\perp}$和$v’_{\\parallel}$。将他们相加就是 $\\mathbf{v}$ 旋转之后的结果 $v’ = v’_{\\parallel} + v’_{\\perp}$ 我们可以将这些向量定义为纯四元数： $$ \\begin{gather*} v = [0, \\mathbf{v}] \\quad \\quad \\quad \\quad \\quad \\quad v’ = [0, \\mathbf{v’}] \\\\ \\\\ v_{\\perp} = [0, \\mathbf{v_{\\perp}}] \\quad \\quad \\quad \\quad \\quad \\quad v’_{\\perp} = [0, \\mathbf{v’_{\\perp}}] \\\\ \\\\ v_{\\parallel} = [0, \\mathbf{v_{\\parallel}}] \\quad \\quad \\quad \\quad \\quad \\quad v’_{\\parallel} = [0, \\mathbf{v’_{\\parallel}}] \\\\ \\\\ u = [0, \\mathbf{u}] \\end{gather*} $$ 那么我们就能得到： $$ v = v_{\\parallel} + v_{\\perp} \\quad \\quad \\quad \\quad \\quad \\quad v’ = v’_{\\parallel} + v’_{\\perp} $$ $v_{\\perp}$的旋转 推导 我们首先讨论正交于旋转轴的 $v_{\\perp}$。我们之前推导过，如果一个向量 $v_{\\perp}$ 正交于旋转轴 $\\mathbf{u}$，那么： $$ v’_{\\perp} = \\cos(\\theta)v_{\\perp} + \\sin(\\theta)(u \\times v_{\\perp}) $$ 我们可以很容易地将前面的 $\\mathbf{v’_{\\perp}}$ 和 $\\mathbf{v_{\\perp}}$ 替换为 $v’_{\\perp}$ 和 $v_{\\perp}$，但是我们仍遗留下来 $\\mathbf{u} \\times \\mathbf{v_{\\perp}}$。 幸运的是，利用四元数的性质，我们可以将它写成四元数积的形式： 如果有两个纯四元数 $v = [0, \\mathbf{v}]$，$u = [0, \\mathbf{u}]$，那么 $vu = [-\\mathbf{v} \\cdot \\mathbf{u}，\\mathbf{v} \\times \\mathbf{u}]$。类似地： $$ \\begin{align*} vu_{\\perp} \u0026= [-\\mathbf{u} \\cdot \\mathbf{v_{\\perp}}, \\mathbf{u} \\times \\mathbf{v_{\\perp}}] \\\\ \\\\ \u0026= [0, \\mathbf{u} \\times \\mathbf{v_{\\perp}}] \\quad \\quad \\quad \\quad \\quad \\quad 因为 \\mathbf{v_{\\perp}}正交于\\mathbf{u}，所以 \\mathbf{u} \\cdot \\mathbf{v_{\\perp}} \\\\ \\\\ \u0026= \\mathbf{u} \\times \\mathbf{v_{\\perp}} \\end{align*} $$ 注意，$uv_{\\perp}$ 同样是一个纯四元数。将这个等式以及之前定义的纯四元数代入，我们就能获得： $$ \\begin{align*} v’_{\\perp} \u0026= \\cos(\\theta)v_{\\perp} + \\sin(\\theta)(uv_{\\perp}) \\quad \\quad \\quad \\quad \\quad \\quad 通过轴角式v_{\\perp}的旋转公式，再把 vu_{\\perp}代入 \\\\ \\\\ \u0026= (cos(\\theta) + \\sin(\\theta)u)v_{\\perp} \\quad \\quad \\quad \\quad \\quad \\quad 乘法分配律 \\end{align*} $$ 你应该可以注意到，如果我们将$(cos(\\theta) + \\sin(\\theta)u)$ 看作是一个四元数，我们就能将旋转写成四元数的乘积了。如果令 $q = cos(\\theta) + \\sin(\\theta)u$，我们能得到： $$ v’_{\\perp} = qv_{\\perp} $$ 如果能构造一个q，那么我们就能完成这个旋转了，我们可以对 q 继续进行变形： $$ \\begin{align*} q \u0026= \\cos(\\theta) + \\sin(\\theta)u \\\\ \\\\ \u0026= [\\cos(\\theta), 0] + [0, \\sin(\\theta)u] \\\\ \\\\ \u0026= [\\cos(\\theta), \\sin(\\theta)u] \\\\ \\\\ \u0026= \\cos(\\theta) + \\sin(\\theta)u_xi + sin(\\theta)u_yj + \\sin(\\theta)u_zk \\end{align*} $$ 这样我们就完成了对 $v_{\\perp}$的旋转，我们可以得到下面定理 总结：定理 3D 旋转公式（四元数型，正交情况） 当 $v_{\\perp}$ 正交于旋转轴 $\\mathbf{u}$ 时，旋转 $\\theta$ 角度后的 $v’_{\\perp}$ 可以使用四元数乘法来获得获得。 令 $v_{\\perp} = [0, \\mathbf{v_{\\perp}}], q = [\\cos(\\theta), \\sin(\\theta)\\mathbf{u}]$，那么： $$ v’_{\\perp} = qv_{\\perp} $$ q 单位四元数 这个我们构造出来的 q其实还是一个单位四元数。因为 ||q|| = 1，他所代表的变换并不会对原项链进行缩放，是一个纯旋转 $$ \\begin{align*} \\Vert q \\Vert \u0026= \\sqrt{\\cos^2(\\theta) + (\\sin(\\theta)\\mathbf{u} \\cdot \\sin(\\theta)\\mathbf{u})} \\\\ \\\\ \u0026= \\sqrt{\\cos^2(\\theta) + \\sin^2(\\theta)(\\mathbf{u} \\cdot \\mathbf{u})} \\\\ \\\\ \u0026= \\sqrt{\\cos^2(\\theta) + \\sin^2(\\theta)(\\Vert \\mathbf{u} \\Vert^2)} \\quad \\quad \\quad \\quad \\quad \\quad (\\mathbf{u} \\cdot \\mathbf{u} = \\Vert u \\Vert ^2) \\\\ \\\\ \u0026= \\sqrt{\\cos^2(\\theta) + \\sin^2{\\theta}} \\quad \\quad \\quad \\quad \\quad \\quad (\\Vert \\mathbf{u} \\Vert = 1) \\\\ \\\\ \u0026= 1 \\quad \\quad \\quad \\quad \\quad \\quad (三角恒等式) \\end{align*} $$ $v_{\\paraller}$的旋转 我们之前讨论过，如果一个向量 $\\mathbf{v_{\\parallel}}$ 平行于 $\\mathbf{u}$，那么旋转不会对他作出任何变换，也就是说： 3D 旋转公式（四元数型，平行情况） 当 $v_{\\parallel}$ 平行于旋转轴 $\\mathbf{u}$ 时，旋转 $\\theta$角度之后的 $v’_{\\parallel}$用四元数可以写为： $$ v’_{\\parallel} = v_{\\parallel} $$ v的旋转 有了这些知识，我们能够获得一般情况下 𝑣 ′ 的结果了 $$ \\begin{align*} v’ \u0026= v’_{\\parallel} + v’_{\\perp} \\\\ \\\\ \u0026= v_{\\parallel} + q v_{\\perp} \\quad \\quad \\quad \\quad \\quad \\quad (其中 q = [\\cos(\\theta), \\sin(\\theta)u]) \\\\ \\\\ \u0026= 1 \\cdot v_{\\parallel} + qv_{\\perp} \\quad \\quad \\quad \\quad \\quad \\quad (qq^{-1} = 1 ~ 和 ~ 定理1) \\\\ \\\\ \u0026= pp^{-1}v_{\\parallel} + ppv_{\\perp} \\quad \\quad \\quad \\quad \\quad \\quad (令 q = p^2) \\\\ \\\\ \u0026= pp^*v_{\\parallel} + ppv_{\\perp} \\quad \\quad \\quad \\quad \\quad \\quad (p^{-1} = p^*) \\\\ \\\\ \u0026= pv_{\\parallel}p^* + pv_{\\perp}p^* \\\\ \\\\ \u0026= p(v_{\\parallel} + v_{\\perp})p^* \\\\ \\\\ \u0026= pvp^* \\end","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:4","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"3D旋转的矩阵形式 3D 旋转公式（矩阵型） 任意向量 $\\mathbf{v}$ 沿着以单位向量定义的旋转轴 $\\mathbf{u}$ 旋转 $\\theta$ 角度之后的 $v’$ 可以使用矩阵乘法来获得。 令 $a = \\cos(\\frac{1}{2}\\theta), b = \\sin(\\frac{1}{2}\\theta)u_x, c = \\sin(\\frac{1}{2}\\theta)u_y, d = \\sin(\\frac{1}{2}\\theta)u_z$，那么： $$ v’ = \\begin{bmatrix} 1 - 2c^2 - 2d^2 \u0026 2bc - 2ad \u0026 2ac + 2bd \\\\ \\\\ 2bc + 2ad \u0026 1 - 2b^2 - 2d^2 \u0026 2cd - 2ab \\\\ \\\\ 2bd - 2ac \u0026 2ab + 2cd \u0026 1 - 2b^2 - 2c^2 \\end{bmatrix} $$ 虽然 3D 旋转的矩阵形式可能不如四元数形式简单，而且占用更多的空间， 但是对于大批量的变换，使用预计算好的矩阵是比四元数乘法更有效率的． ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:5","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"旋转的复合 假设有两个表示沿着不同轴，不同角度旋转的四元数 $q_1$, $q_2$，我们先对 $v$ 进行 $q_1$ 的变换，再进行 q_2 的变换，变换的结果是什么呢？ 我们分步进行。首先，我们实施 $q_1$的变换，变换之后的 $v’$为： $$ v’ = q_1 v q_1^* $$ 接下来，对 $v’$ 进行 $q_2$的变换，得到 $v’’$ $$ v’’ = q_2v’q_2^* = q_2q_1vq_1^*q_2^* $$ 我们对这两个变换进行复合，写为一个等价交换的形式： $$ v’’ = q_{net}vq_{net}^* $$ 在运用定理4： $$ \\begin{align*} v’’ \u0026= q_2q_1vq_1^*q_2^* \\\\ \\\\ \u0026= (q_2q_1)v(q_2q_1) \\end{align*} $$ 注意四元数乘法的顺序，我们先进行的是 𝑞1 的变 换，再进行 𝑞2 的变换． 比如说我们还需要进行第三个旋转 𝑞3，那么： $$ v’’’ = q_3(q_2q_1)v(q_2q_1)^*q_3^* $$ ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:6","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"双倍覆盖 单位四元数与 3D 旋转有一个「2 对 1 满射同态」(2-1 Surjective Homomorphism) 关系，或者说单位四元数双倍覆盖 (Double Cover) 了 3D 旋转． 通俗来说就是同一个 3D 旋转可以使用两个不同的四元数来表示。 从旋转公式中也能推导出相同的结果： $$ (-q)v(-q)^* = (-1)^2qvq^* = qvq^* $$ ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:7","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["3D图形学"],"content":"指数形式 任意向量 $\\mathbf{v}$ 沿着以单位向量定义的旋转轴 $\\mathbf{u}$ 旋转 $\\theta$ 角度之后的 $\\mathbf{v’}$ 可以使用四元数的指数表示： 令 $v = [0, \\mathbf{v}]$，$u = [0, \\mathbf{u}]$，那么： $$ v’ = e^{u\\frac{\\theta}{2}}ve^{-u\\frac{\\theta}{2}} $$ ","date":"2025-11-14","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/:3:8","tags":["Unreal","3D图形学","复数","四元数"],"title":"复数与四元数","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/"},{"categories":["Real-Time Rendering 4"],"content":"变换","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"引言 变换（transform）是指以点、向量、颜色等实体作为输入，并以某种方式对其进行转换的一种操作。对于计算机图形学从业者而言，熟练掌握变换相关的知识是非常重要的。通过各种变换操作，我们可以对物体、光源和相机进行移动、变形以及设定动 画；我们还可以确保所有的计算都在同一个坐标系下进行，以及使用不同的方式来将物体投影到一个平面上。这里我们只列举了变换所能完成的部分操作，但是足以证明变换在实时图形学中的重要性，或者可以说，在任何领域图形学中的重要性。 线性变换 线性变换是指一种仅保留向量加法个标量乘法的变换，具体来说就是： $$ f(x) + f(y) = f(x+y) \\\\ \\\\ kf(x) = f(kx) $$ 缩放变换 例如：现在有一个变换 $f(x) = 5x$，他代表将输入向量 x 的每个分量都乘以 5。为了证明这个变换是线性的，他必须满足上述两个条件，目前确实也是满足的。 这种函数就叫做缩放变换，因为他改变了一个物理的大小（尺寸） 旋转变换 旋转变换是另一种线性变换，他将一个向量以原点为中心进行旋转。 平移变换 函数 $f(x) = x + (7, 3, 2)$是一个非线性变换，其中的向量x是一个三维向量。对两个不同的向量分别执行这个函数，其结果为每个向量各自加上(7, 3, 2)，这就是平移变换。 也就是说让一个向量加上另一个固定向量，意味着完成了一次平移变换 仿射变换 仿射变换通常存储在一个 4 x 4 的矩阵中 仿射变换是指先进性一次线性变换，然后在进行一次平移操作的变换。 我们使用其次符号来表示这样的四维向量。点和方向也会使用同样的方式来进行表示（小写的粗体字母） 实时渲染中所使用的平移、旋转、缩放、对称和剪切矩阵都是仿射类型的。 仿射变换最主要的特征就是它保证了直线的平行性（即两个平行的直线在变换之后仍然是平行的），但是其长度和角度可能会发生一些变化。一个仿射变换也可以表示为一系列独立仿射变换的组合。 缩放变换和旋转变换以及事实上所有应用三维向量的线性变换，都可以使用一个 3 x 3 矩阵来进行表示；但是，3 x 3的矩阵尺寸通常是不够的 符号 名称 特征描述 $T(\\mathbf{t})$ 平移矩阵 移动一个点；是仿射变换，保持方向和长度不变。 $R_x(\\rho)$ 旋转矩阵 绕 x 轴旋转 $\\rho$ 弧度；绕 y, z 轴是类似的；是正交矩阵 \u0026 仿射变换。 $\\mathbf{R}$ 旋转矩阵 任意的旋转矩阵；是正交矩阵，保持长度和角度不变；是仿射变换。 $S(\\mathbf{s})$ 缩放矩阵 根据传入的向量 $\\mathbf{s}$，沿 x, y, z 轴进行缩放；是仿射变换。如果 $\\mathbf{s}$ 的分量不同，则为非均匀缩放。 $H_{ij}(s)$ 剪切变换 将分量 i 相对于分量 j 进行剪切；例如，$H_{xy}(s)$ 将 x 坐标偏移 $s \\cdot y$；是仿射变换。 $E(h, p, r)$ 欧拉变换 根据给定的欧拉角 (yaw, pitch, roll) 创建一个表示朝向的旋转矩阵；是正交矩阵 \u0026 仿射变换。 $\\mathbf{P}_o(s)$ 正交投影矩阵 平行投影到一个平面或者是规范观察体积（view volume）；是线性变换，但会降低维度。 $\\mathbf{P}_p(s)$ 透视投影矩阵 透视投影到一个平面或者视锥体（frustum）；这不是仿射变换，而是射影变换。 $\\text{slerp}(\\hat{\\mathbf{p}}, \\hat{\\mathbf{r}}, t)$ 球面插值 根据参数 $t$，在两个单位四元数 $\\hat{\\mathbf{p}}$ 和 $\\hat{\\mathbf{r}}$ 之间进行球面线性插值，返回一个插值后的新四元数。 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:1:0","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"基本变换 本小节会介绍最基本的变换操作，例如平移、旋转、缩放、剪切、变换组合、刚体变换、法线变换以及计算逆矩阵等。 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:0","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"平移 平移矩阵 $$ T(t) = T(t_x, t_y, t_z) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 t_x \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 t_y \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 t_z \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 图4.1 展示了平移变换的一个具体效果 很容易看出，点 $p = (p_x, p_y, p_z, 1)$ 在经过$T(x)$变换之后，生成了一个新的顶点$p’ = (p_x + t_x, p_y+t_y, p_z + t_z, 1)$，很显然这是一个平移变换 需要注意的是，一个向量$v = (v_x, v_y, v_z, 0)$和矩阵$T$ 相乘后，是不会收到影响的，因为一个方向向量是无法被平移的 平移矩阵的逆矩阵就是反向平移相同距离的矩阵 DirectX矩阵的表示 DirectX 会把平移向量放在变换矩阵的最下面一行。在这种表示方式中，矩阵元素的顺序被颠倒，即应用程序会以从左往右的方式来读取平移变量； $$ T(t) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ t_x \u0026 t_y \u0026 t_z \u0026 1 \\end{bmatrix} $$ 这种向量和矩阵的表示方法被称作行优先表示法；我们上述例子叫做列优先表示法。使用哪一种表示方法仅仅是符号上的区别。 当我们采用行主序表示法，那么变换矩阵在内存中进行存储时，代表位移的四个分量会位于所有 16 个分量的最后四位，其中前三位代表了具体的位移分量，最后 一位是 1。 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:1","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"旋转 旋转变换可以将一个向量（位置或者方向），绕着一个过原点的旋转轴旋转一定的角度。 与平移变换一样，旋转变换也是一个刚体变换，也就是说，被变换点之间的距离并不会发生改变，并且保持了手性，即他不会导致物体左右两边相互变换 这两个特性对于计算机图形学中调整物体位置和朝向而言非常有用 方向矩阵 方向矩阵是一个与相机视角和物体朝向相关的旋转矩阵，它定义了物体在空间中的朝向，即物体向上和向前的方向 x轴旋转矩阵 $$ R_x(\\phi) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 \\cos\\phi \u0026 -\\sin\\phi \u0026 0 \\\\ \\\\ 0 \u0026 \\sin\\phi \u0026 \\cos\\phi \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ y轴旋转矩阵 $$ R_y(\\phi) = \\begin{bmatrix} \\cos\\phi \u0026 0 \u0026 \\sin\\phi \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ -\\sin\\phi \u0026 0 \u0026 \\cos\\phi \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ z轴旋转矩阵 $$ R_z(\\phi) = \\begin{bmatrix} \\cos\\phi \u0026 -\\sin\\phi \u0026 0 \u0026 0 \\\\ \\\\ \\sin\\phi \u0026 \\cos\\phi \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:2","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"缩放 缩放矩阵 $$ S(s) = \\begin{bmatrix} s_x \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 s_y \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 s_z \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 均匀缩放 / 非均匀缩放 当 $s_x = s_y = s_z$的时候，这个缩放操作被称为均匀缩放，否则会被称作非均匀缩放 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:3","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"剪切 剪切变换是另一种基本变换，它可以用来对整个场景进行扭曲，从而创造一种迷幻的效果，或者是对单个模型的外观进行扭曲。 剪切变换一共包含 6 个基本矩阵 $$ H_{xy}(s) = \\begin{bmatrix} 1 \u0026 s \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad H_{xz}(s) = \\begin{bmatrix} 1 \u0026 0 \u0026 s \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ $$ H_{yx}(s) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ s \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad H_{yz}(s) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 s \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ $$ H_{zx}(s) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ s \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad H_{zy}(s) = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 s \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 其中第一个下标用于表示哪个坐标会被剪切矩阵改变，第二个下标表示将会使用哪个坐标来进行剪切。 我们从 $H_{xz}(s)$ 中发现，剪切矩阵的两个下标可以用来找到参数 s 在矩阵中的位置：下标中的 x（其索引为 0）代表了第0行，下标中的 z （其索引为2）代表了第2列 将这个矩阵和一个顶点相乘，会生成一个新的顶点：$(p_x + sp_z \\quad p_y \\quad p_z)^T$ 下附图生动的展示了一个单位正方形被剪切的过程。通过向相反的方向进行剪切，我们可以获得 $H_{ij}(s)$的逆矩阵，即$ H_{ij}^{-1}(s) = H_{ij}(-s) $ 你还可以使用一种稍微不同的剪切矩阵： $$ H’_{xy}(s,t) = \\begin{bmatrix} 1 \u0026 0 \u0026 s \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 t \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 这里的剪切变换包含两个输入参数，他们代表了这两个坐标（x, y）都会被第三个坐标（z）剪切。这个特殊的剪切矩阵可以通过上面一般的剪切矩阵组合而成，即 $H’_{xy}(s,t) = H_{ik}(s)H_{jk}(t)$，其中的 k 代表了第三个坐标分量的索引。 最后我们需要注意的是，任何剪切矩阵的行列式值都为 $|H| = 1$，这意味着剪切变换是一种体积保持的变换，即变换前后，物体的体积并不会发生改变 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:4","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"变换的连接 由于矩阵之间的乘法不具备交换律（noncommutativity），因此矩阵在乘法式子中的顺序十分重要。变换的连接是与顺序相关的。 举例：我们现在有两个矩阵 $S,R$ 其中矩阵 $S(2, 0.5, 1)$是一个缩放变换，他将坐标的 x分量缩放为原来的的2倍，将 y 分量缩放为原来的 0.5 倍。 $R_z(\\pi / 6)$是一个旋转矩阵，他绕 z 轴（在右手坐标系中，这里的 z 轴指向书页的外面）顺时针旋转了 $\\pi / 6$的角度 这两个矩阵可以用两种不同的方式相乘，他们变换的结果是完全不同的。 将一系列矩阵组合成一个独立矩阵有一个好处，那就是可以获得更高的执行效率。例如：想象我们现在有一个包含几百万顶点的游戏场景，场景中的所有物体都需要进行缩放、旋转和平移变换。这里我们并不会将所有的顶点都与这三个变换矩阵挨个相乘，因为这样做的效率实在是太低了；我们会将这三个矩阵连接成一个独立的矩阵， 然后对所有顶点都应用这个相同的组合变换矩阵。 这个组合矩阵可以写作 $C = TRS$，请注意这里的矩阵顺序，缩放矩阵S应当首先作用于顶点，因此他出现在组合矩阵的最右侧。 这个组合矩阵的顺序意味这 $TRSp = (T(R(Sp)))$，其中p是待变换的顶点。 矩阵的交换律不行，但是矩阵的结合律是可以的。即$(TR)(Sp)$是可以的 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:5","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"刚体变换 只包含平移和旋转的变换叫做刚体变换（rigid-body transform） 任何刚体变换矩阵X， 都可以写成一个平移矩阵 $T(t)$ 和一个旋转矩阵 $R$ 的连接 $$ X = T(t)R = \\begin{bmatrix} r_{00} \u0026 r_{01} \u0026 r_{02} \u0026 t_x \\\\ \\\\ r_{10} \u0026 r_{11} \u0026 r_{12} \u0026 t_y \\\\ \\\\ r_{20} \u0026 r_{21} \u0026 r_{22} \u0026 t_z \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 刚体变换矩阵 $X$ 的逆矩阵可以通过这两种方式来计算： $$ X^{-1} = (T(t)R)^{-1} = R^{-1}T(t^{-1}) = R^TT(-t) $$ $$ \\left.\\mathbf{\\bar{R}}=\\left( \\begin{array} {ccc}\\mathbf{r}_{,0} \u0026 \\mathbf{r}_{,1} \u0026 \\mathbf{r}_{,2} \\end{array}\\right.\\right)= \\begin{pmatrix} \\mathbf{r}_0^T, \\\\ \\\\ \\mathbf{r}_1^T, \\\\ \\mathbf{r}_2^T, \\end{pmatrix}, \\\\ \\mathbf{X}= \\begin{pmatrix} \\mathbf{\\bar{R}} \u0026 \\mathbf{t} \\\\ \\mathbf{0}^T \u0026 1 \\end{pmatrix}, $$ 其中 $r_{,0}$ 代表了旋转矩阵中的第一列（即第一个逗号取值可以是 0-2，而第二个下标的值始终为 0） $r_0^t$ 代表了旋转矩阵中的第一行。 方程中的 0 代表一个 3 x 1 的零向量。 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:6","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"法线变换 矩阵可以用于对点、线、三角形和其他几何物体进行变换，这些矩阵同样也可以对这些线或者三角形表面的切向量进行变换，然而有一个重要的几何属性并不能总是使用这些矩阵直接进行变换，即表面法线（以及顶点的光照法线）。 下图展示了如果使用同样的矩阵同时对几何物体及其发现进行变换的结果 法线变换的正确方式 对法线正确的变换方式是： 使用原始变换矩阵的伴随矩阵的转置矩阵来对其进行变换，而不是使用原始变换矩阵本身。矩阵的伴随矩阵是始终存在的。 在变换后通常还需要对法线进行归一化处理。因为法线在经过变换之后，其长度可能会发生变化 实际上，我们甚至都不需要计算这个伴随矩阵。 在这样的条件下（进行了平移、旋转和均匀缩放操作）， 我们可以直接使用模型的变换矩阵来对法线进行变换； 但是如果模型变换涉及了非均 匀缩放或者投影操作，那么就无法使用这种方法对法线进行变换了。 法线变换的传统方式 计算原始变换矩阵的逆矩阵的转置，即 $(M^{-1})^T$ 缺点： 这个方法现在也是可以使用的。但是我们并不需要完整的求出这个逆矩阵，这样会很浪费性能 并且有时候这个逆矩阵可能并不存在，因为逆矩阵是通过伴随矩阵除以矩阵的行列式获得的，但是行列式可能会为0。行列式为 0 的矩阵被成为奇异矩阵 最后是否归一化法线 如果模型变换只涉及平移或者旋转 的话，那么法线的长度是不会发生改变的，因此也就不需要进行归一化处理。 变换中涉及了非均匀缩放的话，那么这个均匀缩放系数（如果是已知的，或者是已经被提取出来的话），也可以直接用来对法线进行归一化处理（直接按照均匀缩放系数进行反向缩放即可） 我们还可以将这一步放在对法线变换之前，让左上角 3 x 3 子矩阵除以这个缩放系数, 从而构建一个会生成归一化结果的法线变换矩阵 如果表面法线是从变换之后的三角形中计算出来的话（例如使用三角形的边向量进行叉乘，从而获得垂直于三角形表面的法线），那么法线变换的问题就不需要进行考虑了。切向量的本质和法线并不相同，它可以直接使用原始变换矩阵进行变换。 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:7","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"计算逆矩阵 有很多计算都需要使用逆矩阵，例如在不同的坐标系间来回切换的时候。根据一个变换的可用信息不同，我们可以使用以下三种方法来计算一个逆矩阵： 如果某个矩阵是一次很简单的变换，或者是一系列带参简单变换的组合的话，那么我们可以通过反转“参数”和矩阵次序的方式，来获得这个矩阵的逆矩阵，即进行一系列的反向变换。 例如：现在有一个变换矩阵 $M = T(t)R(\\phi)$，则其逆矩阵为 $M^{-1} = R(-\\phi)T(-t)$。这种求取逆矩阵的方式十分简单且准确，这对于渲染一个大世界而言是十分重要的 如果一个矩阵是正交矩阵的话，那么其逆矩阵和转置矩阵是相等的，即$M^{-1} = M^T$。旋转矩阵是一个正交矩阵，并且任意数量的旋转矩阵组合在一起仍然是一个旋转矩阵，因此其结果也是正交的 如果这些信息都不知道的话，那么我们还可以使用伴随矩阵法、Cramer法则、LU分解法、高斯消元法等方法来计算一个矩阵的逆矩阵。伴随矩阵法和Cramer法则通常要更好一些，因为他们所设计的分支操作较少； 在进行性能优化的时候，我们还可以对逆矩阵的计算目的进行考虑。例如：如果这个 逆矩阵仅仅是用来对向量进行变换的话，那么通常我们只需要获得左上角子矩阵的逆矩阵即可 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:2:8","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"特殊的矩阵变换和操作 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:3:0","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"欧拉变换 欧拉变换可以构建一个旋转矩阵，将我们自身（相机）或者其他物体指向一个特定的方向 首先，我们需要有一个默认的观察方向，通常来说都会让这个方向指向 z 轴负半轴，并且头部指向 y 轴正半轴。 欧拉变换是三个旋转矩阵相乘的结果，如下图。 欧拉变换通常会使用 $E$ 来进行表示： $$ E(h,p,r) = R_z(r)R_x(p)R_y(h) $$ 由于矩阵 $E$ 是由一系列旋转矩阵连接组成的，那么矩阵 $E$ 本身自然也是一个正交矩阵，因此该矩阵的逆矩阵可以表示为 $E^{-1} = E^T = (R_z^T R_x^T R_y^t) = R_y^t R_x^T R_z^T$，当然，一般直接使用 $E^T$ 是最方便的 其中欧拉角参数 h, p, r 代表了每个方向（h 头部，pitch 俯仰角，roll 翻滚角），在有些地方 比如飞行模拟，Unreal中 head被叫做偏航角（yaw） 改变 head（yaw）偏航角会让观察者摇头 改变 pitch 俯仰角会让观察者点头 改变 roll 翻滚角会让观察者歪头 欧拉变换不仅仅可以用来调整相机的方向，还可以用来调整任意物体的朝向；同时，欧拉变换不仅可以用于世界空间中，同样也可以用于局部参考坐标系中。 在一些欧拉角的表示中，会让 z 轴指向上方；这虽然会让人感到一些困惑，但是它确实只是一种符号表示上的差异，本质上都是等价的。计算机图形学中，在如何看待和表示世界这个问题上，确实存在着一些分歧，即： y 轴向上（y-up）还是 z 轴向上（z-up）。 优点 欧拉角在小角度变换和调整观察者方向方面十分有用 缺点 我们很难将两组欧拉角组合在一起 在两组欧拉角之间进行插值，并不是简单地对每个分量分别进行插值就可以完成的。事实上，两组表示形式完全不同的欧拉角，可能会给出完全相同的方向，因此对这两组欧拉角进行插值的话，中间生成的任何一组欧拉角，在理想情况下都不应当导致物体发生旋转。这也是使用其他方向表示方法（例如四元数）的原因之一 万向节死锁 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:3:1","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"从欧拉变换中提取参数 在某些情况下，我们需要从一个代表欧拉变换的矩阵中，提取出各个方向上所改变的角度，即欧拉变换的参数 h, p ,r。这个过程如下所示： $$ E(h, p ,r) = \\begin{bmatrix} e_{00} \u0026 e_{01} \u0026 e_{02} \\\\ \\\\ e_{10} \u0026 e_{11} \u0026 e_{12} \\\\ \\\\ e_{20} \u0026 e_{21} \u0026 e_{22} \\end{bmatrix} = R_z(r) R_x(p) r_y(h) $$ 齐次变换矩阵是 4 x 4 的。这里我们只使用了左上角 3 x 3 子矩阵，因为这已经能够提供旋转矩阵的所有必要信息了；也就是说，在完整的 4 x 4 欧拉变换矩阵中，除了最右下角的元素是1之外，其他剩余的元素均为 0 我们将三个旋转矩阵相乘，可以获得以下结果： $$ \\mathbf{E} = \\begin{bmatrix} \\cos r \\cos h - \\sin r \\sin p \\sin h \u0026 -\\sin r \\cos p \u0026 \\cos r \\sin h + \\sin r \\sin p \\cos h \\\\ \\\\ \\sin r \\cos h + \\cos r \\sin p \\sin h \u0026 \\cos r \\cos p \u0026 \\sin r \\sin h - \\cos r \\sin p \\cos h \\\\ \\\\ -\\cos p \\sin h \u0026 \\sin p \u0026 \\cos p \\cos h \\end{bmatrix} $$ 我们可以很明显的看出 $\\sin p = e_{21}$; 此外，我们可以令 $e_{01}$ 除以 $e_{11}$ 来计算 r，令 $e_{20}$除以$e_{22}$来计算 h： $$ \\frac{e_{01}}{e_{11}} = \\frac{-\\sin r}{\\cos r} = -\\tan r \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\frac{e_{20}}{e_{22}} = \\frac{-\\sin h}{\\cos h} = -\\tan h $$ 也就是说，我们可以使用 $atan2(y, x)$（包含两个参数的反正切函数）来从矩阵$E$中提取欧拉角的参数h, p, r。即： $$ h = atan2(-e_{20}, e_{22}) \\\\ \\\\ p = arcsin(e_{21}) \\\\ \\\\ r = atan2(-e_{01}, e_{11}) $$ 当我们使用欧拉变换的时候，有时会发生一种叫做万向节死锁的现象。 即在旋转的过程中失去了一个自由度。例如：假设我们现在按照的顺序 x, y, z 进行变换，然后绕 y 轴旋转了 $\\pi / 2$ 的角度，即执行了第二个旋转；这个旋转操作会使得局部坐标系中的 z 轴与原始的 x 轴重合，最终导致绕 z 轴旋转的操作是多余的。 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:3:2","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"矩阵分解 用途 提取物体的缩放因子。 找到一个指定坐标系中所需要的变换（例如：某些系统和变换不允许使用任意的 4 x 4 矩阵） 确定一个物体是否只经历了刚体变换 在只有物体的变换矩阵可用的情况下，在动画的关键帧之间进行插值 移除一个旋转变换矩阵中的剪切变换 在前文中我们其实已经展示了两个矩阵分解的例子 例如从一个刚体变换中提取出平移矩阵和旋转矩阵； 从一个正交矩阵中提取出欧拉角 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:3:3","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"绕任意轴旋转 矩阵如下： $$ R_{\\mathbf{u}}(\\theta) = \\begin{bmatrix} \\cos\\theta + u_x^2(1-\\cos\\theta) \u0026 u_x u_y(1-\\cos\\theta) - u_z \\sin\\theta \u0026 u_x u_z(1-\\cos\\theta) + u_y \\sin\\theta \u0026 0 \\\\ \\\\ u_y u_x(1-\\cos\\theta) + u_z \\sin\\theta \u0026 \\cos\\theta + u_y^2(1-\\cos\\theta) \u0026 u_y u_z(1-\\cos\\theta) - u_x \\sin\\theta \u0026 0 \\\\ \\\\ u_z u_x(1-\\cos\\theta) - u_y \\sin\\theta \u0026 u_z u_y(1-\\cos\\theta) + u_x \\sin\\theta \u0026 \\cos\\theta + u_z^2(1-\\cos\\theta) \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:3:4","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"四元数 四元数可以用于稳定且恒定速度的方向插值，这是欧拉角很难实现的。 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:4:0","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"四元数的定义 $$ \\hat{\\mathbf{q}} = (\\mathbf{q}_v, \\mathbf{q}_w) = iq_x + jq_y + kq_z + q_w = \\mathbf{q}_v + q_w \\\\ \\\\ \\mathbf{q}_v = iq_x + jq_y + kq_z = (q_x, q_y, q_z) \\\\ \\\\ i^2 = j^2 = k^2 = -1, jk = -kj = i, ki = -ik = j, ok = -ji = k $$ $q_w$ 是四元数 $\\hat{q}$ 中的实数部分（实部） $q_v$ 是四元数 $\\hat{q}$ 中的虚数部分（虚部） i, j, k 叫做虚数单位。 四元数的结构和复数类似，但是复数只有一个虚部，而四元数则包含三个虚部 ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:4:1","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"数学运算 乘法 $$ \\begin{align*} \\hat{q}\\hat{r} \u0026= (iq_x + jq_y + kq_z + q_w)(ir_x + jr_y + kr_z + r_w) \\\\ \\\\ \u0026= i(q_yr_z - q_zr_y + r_wq_x + q_wr_x) \\\\ \\\\ \u0026 \\quad + j(q_zr_x - q_xr_z + r_wq_y + q_wr_y) \\\\ \\\\ \u0026 \\quad + k(q_xr_y - q_yr_x + t_wq_z + q_wr_z) \\\\ \\\\ \u0026 \\quad + q_wr_w - q_xr_x - q_yr_y - q_zr_z \\\\ \\\\ \u0026= (\\mathbf{q}_v \\times \\mathbf{r}_v + r_w\\mathbf{q}_v + q_w\\mathbf{r}_v, q_wr_w - \\mathbf{q}_v \\cdot \\mathbf{r}_v) \\end{align*} $$ 加法 $$ \\hat{\\mathbf{q}} + \\hat{\\mathbf{r}} = (\\mathbf{q}_v, q_w) + (\\mathbf{r}_v, r_w) = (\\mathbf{q}_v + \\mathbf{r}_v, q_w + r_w) $$ 共轭 $$ \\hat{\\mathbf{q}}^* = (\\mathbf{q}_v, q_w)^* = (-\\mathbf{q}_v, q_w) $$ 模长 $$ n(\\hat{\\mathbf{q}}) = \\sqrt{\\hat{\\mathbf{q}} \\hat{\\mathbf{q}}^} = \\sqrt{\\hat{\\mathbf{q}}^ \\hat{\\mathbf{q}}} = \\sqrt{\\mathbf{q}_v \\cdot \\mathbf{q}_v + q^2_w} = \\sqrt{q^2_x + q^2_y + q^2_z + q^2_w} $$ 虚数单位 $$ \\hat{i} = (0, 1) $$ 四元数的逆 $$ \\hat{q}^{-1} = \\frac{1}{n(\\hat{q})^2} \\hat{q}^* $$ 共轭法则 $$ \\begin{align*} (\\hat{\\mathbf{q}}^)^ \u0026= \\hat{\\mathbf{q}} \\\\ \\\\ (\\hat{\\mathbf{q}} + \\hat{\\mathbf{r}})^* \u0026= \\hat{\\mathbf{q}}^* + \\hat{\\mathbf{r}}^* \\\\ \\\\ (\\hat{\\mathbf{q}} \\hat{\\mathbf{r}})^* \u0026= \\hat{\\mathbf{r}}^* \\hat{\\mathbf{q}}^* \\end{align*} $$ 模长法则 $$ \\begin{align*} n(\\hat{\\mathbf{q}}^) \u0026= n(\\hat{\\mathbf{q}}) \\\\ \\\\ n(\\hat{\\mathbf{q}} \\hat{\\mathbf{r}}) \u0026= n(\\hat{\\mathbf{q}})n(\\hat{\\mathbf{r}}) \\end{align} $$ 乘法分配律 $$ \\hat{\\mathbf{p}}(s\\hat{q} + t\\hat{\\mathbf{r}}) = $$ ","date":"2025-11-11","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/:4:2","tags":["Real-Time Rendering","Transform"],"title":"变换","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%8F%98%E6%8D%A2/"},{"categories":["Real-Time Rendering 4"],"content":"图形渲染管线","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"引言 第一个包含硬件顶点处理的消费级芯片（NVIDIA GeForce256）于 1999 年发布。 NVIDIA 创造了图形处理单元 （graphics processing unit，GPU）这个术语，用来区别 GeForce256 和过去所使用的光栅化芯片，并将这个术语沿用了下来 各种可编程的着色器（shader）是控制 GPU 的主要手段。为了获得更高的效率，渲染管线中的有些部分仍然只是可配置的，而并非是可编程的，但是 GPU 的整体发展趋势是可编程性和灵活性。 我们需要知道一点，由于在存储中访问数据需要花费一定时间，因此延迟是所有处理器都会面临的一个问题 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:1:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"数据并行结构 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:2:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"CPU 不同的处理器架构使用了不同的策略来避免停滞。CPU 经过优化，可以处理大量的数据结构和大型代码段，CPU 一般都具有多个处理器，每个处理器都以串行的方式来执行代码。为了最小化延迟所带来的影响，CPU芯片中的大部分面积都是高速的本地缓存，这些缓存中存满了接下来可能会用到的数据。CPU也还会使用一些智能技能来避免停滞，比如 分支预测 等… ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:2:1","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"GPU GPU 采用了不同的策略，GPU 芯片中的很大一片面积都是大量的处理器，也叫做着色器核心，GPU芯片中通常会有数千个着色器核心。 GPU 是一个流处理器，他会依次处理有序的相似数据。由于数据的相似性（例如一组顶点或者像素），因此 GPU 可以通过大规模并行的方式来处理这些数据 GPU 专门对吞吐量（throughput）进行了优化，吞吐量指的是数据能够被处理的最大速度。但是这种快速处理是有代价的，由于用于缓存和控制逻辑的芯片面积较少， 因此每个着色器核心的延迟，通常都会比 CPU 处理器所遇到的延迟要大 SIMD 当遇到令着色处理器停滞的指令时（例如：对于一个给定的表面位置，程序需要知道纹理上对应位置的像素颜色，而这个纹理是一个独立的资源，并不是像素着色程序本地内存中的一部分， 因此可能会涉及到访问纹理的操作），我们通过切换并执行其他片元程序的方式，来让 GPU 时刻保持忙碌，从而避免延迟。 更进一步，GPU 可以将指令执行的逻辑与数据分离开来，这种设计叫做单指令、多数据（single instruction， multiple data，SIMD） 这种设计会在固定数量的着色器程序上，以一个固定的步长来执行完全相同的指令 wrap / wavefronts 每个片元的像素着色器调用都可以被称为一个线程，但是这里所说的线程不同于 CPU 的线程，他还包括用于存储着色其输入数据的存储空间，以及用于着色器执行的任何寄存器空间。这些用相同着色器程序会被打包成组 NVDIA将其称为一个 wrap，AMD是称为一个 wavefront 一个 warp / wavefronts 负责调度一定数量的 GPU 处理核心， 可能是 8 到 64 个，并且都会使用 SIMD 处理。每个线程都会被映射到一个 SIMD 通 道（SIMD lane）。 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:2:2","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"影响 GPU 运行效率的点 如果线程的数量很少，那么就只能创建很少的 warp，这可能就没法有效隐藏延迟 影响执行效率的另一个重要特征是着色器程序的结构，其中最重要的一个因素就是每个线程所使用的寄存器数量。 另一个影响整体运行效率的因素是由if语句和循环语句导致的动态分支（dynamic branching）。 假设现在我们的着色器程序中遇到了一个if语句，如果所有线程都进入了相同的分支，那么这个 warp 可以不用管其他的分支，继续执行进入的那个分支即可。 但是，如果其中有几个线程，甚至是只有一个线程进入了其他的分支，那么 这个 warp 就必须把两个分支都执行一遍，然后再根据每个线程的具体情况，丢弃不需要的结果。这个问题叫做线程发散（thread divergence），它意味着有 一些线程需要去执行一个循环操作，或者是进入了所在 warp 中其他线程都没有进入 的“if”分支，这会导致其他的线程空转。 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:2:3","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"GPU 管线概述 顶点着色器是一个完全可编程的阶段，它用于实现渲染管线中的几何处理阶段。 几何着色器也是一个完全可编程的极端，它可以对图元（点，线，三角形）的顶点进行操作，它也可以用于进行一些逐图元的着色操作，销毁图元或者是创建新图元等 曲面细分阶段和几何着色器都是可选的阶段，但并不是所有的 GPU都支持这两个阶段，尤其是移动设备上的 GPU 裁剪，三角形设置和三角形遍历阶段，都是由固定功能的硬件进行实现。 屏幕映射收到窗口和视口设置的影响，其内部包含了一个简单的缩放和重定位功能。 像素着色器阶段是一个完全可编程的阶段 合并阶段尽管不是可编程的，但是他是高度可配置的，我们可以为其设定各种各样的操作。合并阶段实现了渲染管线中的合并功能，负责修改维护颜色缓冲，Z-Buffer，模板缓冲以及其他任何与输出相关的缓冲区 像素着色器和合并阶段一起，组成了概念化的像素处理阶段 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:3:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"可编程着色器阶段 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:4:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"数据类型 32位精度的浮点标量和浮点向量是最基础的数据类型，现在GPU还会支持 64为浮点数，32位整数。诸如结构体、数组和矩阵等聚合类型，也同样被GPU支持 浮点向量通常用来表示位置(xyzw)，向量，矩阵中的某一行，颜色（rgba），或者纹理坐标（uvwq） 整数通常用来表示计数器、索引或者位掩码等 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:4:1","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"常见操作运算 图形计算中的常见操作和运算都可以在现代 GPU 上高效运行，着色语言通过操作符来暴露最常用的操作。例如： 加法乘法操作符是 + \u0026 * 其余的操作可以通过使用内置函数（intrinsic function）来提供，这些内置函数针对 GPU 进行了专门优化。例如： atan() sqrt() log() … 还有一些函数可以提供更加复杂的操作，例如： 向量的标准化 反射向量 向量的叉乘 … ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:4:2","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"流程控制 流程控制（flow control）这个术语，是指使用分支指令来改变代码执行的流程 例如“if”、“case”以及各种类型的循环 着色器支持两种类型的流程控制，包含静态流程控制（static flow control）以及动态流程控制（dynamic flow control） 静态流程控制 其中静态流程控制的分支情况会基于统一输入的值，这意味着在一次 draw call 中，该代码的流程是恒定不变的。 静态流程控制最主要的好处在于，它可以在各种不同的情况下（例如不同数量的光源）使用相同的着色器，并且在这个过程中没有任何的线程发散，因为所有调用都会进入相同的代码路径。 动态流程控制 动态流程控制则基于可变输入的值，它意味着每个片元都可以执行不同的代码，其功能比静态流程控制更加强大，但是也更消耗性能，尤其是当着色器调用之间，代码流程不规则变化时。 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:4:3","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"可编程着色及其 API 的演变 可编程着色框架的想法可以追溯到 1984 年 Cook 所提出的着色树（shade tree） 3dfx 交互公司于 1996.10.01，首次引入了消费级的图形硬件 2001 年初，NVIDIA 推出了 Geforce3 显卡，这是第一个支持可编程顶点着色器的 GPU ，它通过 DirectX 8.0 来暴露相关接口，并可以扩展到 OpenGL。 这时的着色器不允许包含流程控制（分支），如果着色器中包含分支，那么就需要将 两个分支都执行一次，然后在结果中进行选择或者插值来模拟分支。 DirectX 定义了 着色器模型（Shader Model）的概念来区分具有不同功能的着色器。 2002 年微软推出了包含 Shader Model 2.0 的 DirectX 9.0，它支持真正可编程的顶点着色器和像素着色器。同样的功能也可以在 OpenGL 下使用各种扩展来实现。 Shader Model 3.0 于 2004 年推出，并增加了动态流程控制，这使得着色器更加强大 新世代的游戏主机分别于 2005 年底 （Microsoft Xbox 360）和 2006 年底（Sony 计算机娱乐 PS3）推出，他们都配备了支持 Shader Model 3.0 的 GPU。Nintendo 于 2006 年底推出了 Wii 主机，它是最后一个仅支持固定功能 GPU 的著名主机。 着色器可编程性的下一次跨域也出现在 2006 年底，DirectX 10.0 推出了 Shader Model 4.0 [175]，它引入了几个重要特性，例如几何着色器和流式输出。Shader Model 4.0 包含了一个针对所有着色器（顶点着色器、像素着色器和几何着色器）的 统一编程模型，即我们在前文中描述过的标准着色器设计。并且它进一步扩大了资源 范围，同时支持了整数类型的数据（包括位运算等操作）。在 OpenGL 3.3 中所引入 的 GLSL 3.0，也推出了一个类似的着色器模型。 2009 年发布的 DirectX 11 和 Shader Model 5.0 中，增加了曲面细分着色器和计算着色器，计算着色器也被叫做 DirectCompute。这次发布还关注了如何提高 CPU 多线程处理的效率 图形 API 的下一个重大变化是由 AMD 于 2013 年提出的 Mantle API，它是 AMD 和 电子游戏开发商 DICE 一起合作开发的，其核心想法是去除用于图形驱动程序的大量开销，将控制权直接交给开发者。除此之外，该技术还进一步支持了 CPU 多线程的高效处理，这一类 API 专注于如何减少 CPU 花费在驱动上的时间，以及如何更加高效的利用 CPU 的多个核心 2015 年推出了全新的 DirectX 12.0。这里请注意，DirectX 12 并没有增加更多的 GPU 功能——DirectX 11.3 和 DirectX12 具有完全相同的硬件特性。 Apple 于 2014 年推出了自家叫做 Metal 的低开销 API，Metal 首先用于移动设备， 例如 iPhone 5s 和 iPad Air。 AMD 将自身 Mantle 的工作贡献给了 Khronos 组织，后者于 2016 年推出了新一代 的 API，叫做 Vulkan。与 OpenGL 一样，Vulkan 可以用于多个操作系统。Vulkan 使 用了一种被称为 SPIR-V 的全新高级中间语言，它可以同时用于着色器表示和通用 GPU 计算。 在移动设备上一般会使用 OpenGL ES，其中“ES”代表的是嵌入式系统（embedded system），因为这个 API 是针对移动设备进行开发的； ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:5:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"顶点着色器 在进入这个阶段之前，就已经存在一些数据计算了。这在 DirectX 中叫做输入汇编器，几个数据流被编织在一起，形成了顶点集合和图元集合，并向下发送给管 线。 顶点着色器是处理这些三角形的第一个阶段。正如顶点着色器的字面意思，它只会对传入的顶点进行处理。 顶点着色器提供了一种用于修改、创建或者忽略三角形顶点数据的方法，这些数据可以是颜色、法线、纹理坐标和位置等。 通常顶点着色器程序会将顶点从模型空间变换到齐次裁剪空间中，在最极端的情况下，顶点着色器也必须要输出顶点的位置 一些顶点着色器能够实现的效果： 动画关节的顶点混合以及轮廓渲染（描边） 物体生成：仅创建一次模型，并通过顶点着色器对其进行变形。 使用蒙皮技术和变形技术来设置角色的身体动画和面部动画。 程序化变形：例如旗帜、布料和水面的运动。 粒子创建：通过向流水线发送简并（无面积）网格，并根据需要来设定它们的位置，从而来模拟粒子效果 透镜畸变、热雾、水波纹、书页卷曲以及其他特效，可以通过将整个帧缓冲的内容作为一个纹理，然后将其应用在一个正在经历变形，并且屏幕对齐的网格上进行实现 通过使用顶点纹理来获取并应用地形的高度场 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:6:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"曲面细分阶段 曲面细分阶段允许我们绘制曲面，GPU 的任务就是将每个曲面描述都转换成一组三角形。 曲面细分阶段是一个可选的 GPU 特性，它首次出现在 DirectX 11 中。 使用曲面细分阶段有几个好处： 节省内存 当场景中存在一些不断变化的角色或者物体时，这个功能还可以防止 CPU 与 GPU 之间的总线带宽成为程序的性能瓶颈。 对于一个给定的相机视角，曲面细分可以生成适当的三角形数量，这样的曲面可以被高效渲染。 例如：现在有一个距离相机很远的小球，它仅仅需要使用很少的三角形即可；当这个小球距离相机很近的时候，它也可以用几千个三角形来进行表示。从而获得更好的效果。 曲面细分阶段同样包含三个字阶段。在 DirectX 中，它们分别叫做壳着色器（hull shader）、曲面细分器（tessellator）和域着色器（domain shader）。 曲面细分器是流水线中一个固定功能的阶段，并且只用于曲面细分着色器。它的任务是添加新的顶点，并发送给域着色器进行处理。 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:7:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"几何着色器 几何着色器可以将一种图元转换为另一种图元，这是曲面细分着色器所无法实现的。 例如：我们可以为每个三角形都创建边界线段，从而将一个三角形网格转换成一个线框模型。 几何着色器的输入是一个独立物体和与其相关联的顶点。这些物体通常由一个条状三角形、一个线段或者仅仅是一个点组成，其他扩展的图元也可以在几何着色器中进行定义和处理。 几何着色器的设计目的是对输入的顶点数据进行修改，或者是创建有限数量的副本。 例如：其中一个用途是生成六个变换后的数据副本，从而同时渲染一个立方体的六个面。它也可以用于高效的创建级联阴影贴图（cascaded shadow map，CSM），从而生成高质量的阴影。 几何着色器会保证按照图元的输入顺序来输出图元。这个排序会对执行性能产生影响，因为如果有很多个着色器核心并行执行的话，那么为了保证图元的输出顺序与输入顺序相同，则必须要将所有执行后的结果保存下来并进行排序。这个因素和其他的一些因素一起，不利于几何着色器在一次调用中大量复制或者创建图形 在实践中，几何着色器很少会被使用，因为他和 GPU 并行计算的优势并不相符；在一些移动设备上，几何着色器是使用软件进行实现的，因此在这些设备上也不鼓励使用几何着色器 流式输出 使用 GPU 管线的标准方式是通过顶点着色器向 GPU 发送数据，然后将生成的结果三角形进行光栅化，最后在像素着色器中对这些数据进行处理。 流式输出 （stream output）的想法是在 Shader Model 4.0 中引入的，在顶点被顶点着色器处理完成之后（这里还可以选择曲面细分和几何着色器），这些数据除了被发送到光栅化阶段之外，还可以通过一个流（即一个有序数组）来进行输出。 这些处 过的数据可以通过流式输出从管线中返回，从而允许对其进行迭代处理。这类操作在模拟流动的水体，或者其他粒子特效的时候十分有用。它还可以用于对模型进行蒙皮操作，然后让这些顶点数据可以重复使用。 流式输出只能以浮点数的形式返回数据，因此它可能会占用很多存储空间。流式输出是作用于图元的，而不是直接作用于顶点的。 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:8:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"像素着色器 在顶点着色器、曲面细分和几何着色器完成操作之后，输出的片元将会进行裁剪和设置，从而进行下一步的光栅化。 光栅化是管线中相对固定的处理步骤，它不具备任何可编程性，仅仅是某些地方可以进行自定义配置。 三角形中部分与像素重叠、或者完全与像素重叠的部分被叫做一个片元（fragment） 三角形顶点上的数值，包括 z-buffer 中的值在内，每个被三角形所覆盖的像素都会使用这些数据进行插值。这些插值生成的数据会被发送到像素着色器 在编程中，顶点着色器程序的输出，在经过三角形（或者线段）插值之后，会成为像素着色器程序的输入。 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:9:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"合并阶段 在合并阶段中，我们会将每个独立片元的颜色和深度进行组合，并最终形成帧缓冲。 DirectX 将这个阶段叫做输出合并（output merger）； OpenGL 将其称为逐样本操作（per-sample operation）。 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:10:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["Real-Time Rendering 4"],"content":"计算着色器 GPU 不仅可以用来实现传统的图形渲染管线，还可以用于很多非图形的领域 例如 用于计算股票期权的估计价值，以及用于训练深度学习的神经网络等，这种使用硬件的方式叫做 GPU 计算（GPU computing）。 DirectX 11 引入了计算着色器（compute shader），它是利用 GPU 进行计算的一种方式。计算着色器是一种特殊的着色器，但是它并没有锁定在图形管线中的固定位置。它与渲染的过程密切相关，因为它是通过图形 API 来进行调用的。计算着色器与顶点着色器、像素着色器以及其他着色器可以一起进行使用，它利用了管线中相同的统一着色器处理器池。 ","date":"2025-11-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/:11:0","tags":["Real-Time Rendering"],"title":"图形处理单元","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83/"},{"categories":["HDR"],"content":"HDR","date":"2025-10-13","objectID":"/hdr/","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"HDR介绍 更高的峰值亮度 (Higher Peak Brightness) HDR将亮度上限提升了几个数量级，通常要求达到 1000尼特 (nits) 甚至更高。这使得画面不仅整体更亮，更重要的是能够呈现出惊人的对比度和高光细节。阳光不再是一片死白，而是耀眼且有层次的光源；阴影下的细节也依然清晰可见。 更宽的色域 (Wider Color Gamut - WCG) HDR标准强制要求使用广色域，通常是 DCI-P3 或更广的 Rec. 2020。这意味着HDR内容可以展现出远超sRGB的色彩，画面更生动、更饱和、更接近真实。 更高的色深 (Higher Bit Depth) HDR强制要求至少使用 10-bit 色深，每个颜色通道有1024个色阶，总共能显示超过 10.7亿 种颜色。这使得色彩过渡无比平滑，彻底告别了SDR时代的色彩断层问题。 ","date":"2025-10-13","objectID":"/hdr/:1:0","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"HDR10：开放的入门标准 为了统一HDR内容的制作和显示，行业推出了多种标准，其中最主流的是： 定义： HDR10是目前最常见、最基础的HDR开放标准。你可以把它看作是进入HDR世界的“通行证”。 核心技术栈： 转换函数：采用 PQ (Perceptual Quantizer) 曲线，一种为HDR设计的、更符合人眼感知特性的伽马曲线。 色域： Rec. 2020 色深：10-bit 元数据 (Metadata)：HDR10使用静态元数据。这意味着它会告诉显示器整部影片的亮度信息（例如“这部电影最亮的地方有多亮”）。 MaxCLL (Maximum Content Light Level): 内容的最大亮度，即整个影片中最亮像素的尼特值。 MaxFALL (Maximum Frame-Average Light Level): 最大帧平均亮度，即整部影片中平均亮度最高的那一帧的平均尼特值。 局限性：由于元数据是静态的，显示器只能用一套方案来处理整部电影，这在明暗场景频繁切换时可能不是最优解。 ","date":"2025-10-13","objectID":"/hdr/:1:1","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"Dolby Vision \u0026 HDR10+：更智能的动态标准 为了解决HDR10的局限性，杜比实验室推出了 Dolby Vision，三星等厂商则推出了 HDR10+。它们最大的升级在于引入了动态元数据 (Dynamic Metadata)。 核心优势： 动态元数据可以为电影的每一帧或每一个场景提供独立的优化信息。这意味着显示器可以根据当前画面的具体内容，实时调整亮度和色彩映射，从而在任何场景下都能获得最佳的显示效果。 ","date":"2025-10-13","objectID":"/hdr/:1:2","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"HLG (Hybrid Log-Gamma)：为广播而生 HLG主要由英国BBC和日本NHK联合开发，专为电视广播设计。它最大的特点是向后兼容，同一个HLG信号源既可以在HDR电视上显示出HDR效果，也可以在SDR电视上正常显示为SDR图像，极大地简化了电视广播的流程。 ","date":"2025-10-13","objectID":"/hdr/:1:3","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"SDR介绍 有限的峰值亮度 (Lower Peak Brightness) SDR内容的亮度上限通常被设定在 100尼特 (nits) 左右。这大致相当于一台普通办公显示器的亮度。这意味着它无法再现真实世界中刺眼的强光，比如正午的太阳、水面的波光粼粼或是车灯的炫光。所有高光部分的细节都会被“削平”成一片白色。 受限的色域 (Limited Color Gamut) SDR标准通常绑定 sRGB 色彩空间。正如我们之前讨论的，sRGB的色彩范围相当小，无法显示许多自然界中存在的鲜艳颜色，例如法拉利的深邃红色、热带雨林的翠绿色或是霓虹灯的荧光色。 较低的色深 (Lower Bit Depth) SDR通常使用 8-bit 色深，这意味着每个颜色通道（红、绿、蓝）有256个色阶，总共约 1670万 种颜色。在显示平滑的颜色渐变时（如日落的天空），这往往会导致明显的色彩断层 (Banding)。 ","date":"2025-10-13","objectID":"/hdr/:2:0","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"OETF \u0026 EOTF OETF 指的是光电转换函数。 摄像机利用光电转换器将光信号转换为电信号 EOTF 与 OETF 相反，它指的是“电光传输函数”。 电视显示器通过 EOTF 来计算输出光的功率 名称 方向 作用 常见例子 EOTF (Electro-Optical Transfer Function) 数码值 → 光 显示设备响应 PQ / HLG / Gamma OETF (Opto-Electronic Transfer Function) 光 → 数码值 相机编码 sRGB / Rec.709 线性化 反函数 把非线性编码“解码”回线性光 ","date":"2025-10-13","objectID":"/hdr/:3:0","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"色域 (Wide Color Gamut) 色域范围比传统的 sRGB 更宽的叫做宽色域 ","date":"2025-10-13","objectID":"/hdr/:4:0","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"sRGB sRGB的色域范围很窄 ","date":"2025-10-13","objectID":"/hdr/:4:1","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"Adobe RGB 这是 Adobe RGB 色彩空间。 最流行的宽色域。这种色域仅在绿色方面比 sRGB 更宽。但有很多设备都支持这种色域。所以这种色域将是很好的第一步。 ","date":"2025-10-13","objectID":"/hdr/:4:2","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"BT.2020 (Rec.2020) 这是 BT.2020 色域。 一系列标准的高动态范围电视。 它有不同的名称，比如国际电信联盟无线电通信部门的推荐标准 BT.2020，或者简称为 Rec.2020，但其实意思是一样的。 所有原色都在色谱线上。 这意味着这种效果在实际的显示器上很难实现。 所以到了 2018 年，还没有任何电视显示器能够实现 100% 的这种色域覆盖范围。 ","date":"2025-10-13","objectID":"/hdr/:4:3","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"DCI-P3 广泛用于电影分级，iphone一直在用的色域，现在有些显示器也在用 ","date":"2025-10-13","objectID":"/hdr/:4:4","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"ACEScg ACES是学院色彩编码系统，用于渲染与合成，所以游戏很多会用 ACEScg 又称 ACES AP1 ","date":"2025-10-13","objectID":"/hdr/:4:5","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"ACES2065-1 该色域设计与存储图像 覆盖了整个光谱，所以会存在色彩精度丢失情况 ACES2065-1又称ACES AP0 ","date":"2025-10-13","objectID":"/hdr/:4:6","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"Tone Mapping Variations ","date":"2025-10-13","objectID":"/hdr/:5:0","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"ACES RRT + ODT 他是一个基于富士胶片的胶片特性 RRT 就是 参考渲染变换，他将屏幕线性颜色转换成胶片颜色 ODT 就是 输出设备变换，他将屏幕颜色转换成设备信号 优点 专业设计 缺点 ODT只支持 1000/2000/4000尼特显示设备 ","date":"2025-10-13","objectID":"/hdr/:5:1","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"CIE XYZ CIE（国际照明委员会） CIE XYZ 是一个“设备无关”的“主”色彩空间，它用数学方式定义了普通人眼能看见的所有颜色。 它是所有色彩空间转换的中间人。当你想把一张P3色域的图片转换到sRGB色域时， 标准流程是：P3 -\u003e CIE XYZ -\u003e sRGB ","date":"2025-10-13","objectID":"/hdr/:6:0","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"集中谈论各种\"空间\" ","date":"2025-10-13","objectID":"/hdr/:7:0","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"第一层：基础理论与通用标准 这一层是理解所有色彩管理的基础，它们是规则和度量衡。 CIE 1931 XYZ 空间：色彩世界的“总目录” 核心定义： 这是一个特殊的、设备无关的色彩空间，它使用数学方式定义了标准观察者（模拟普通人眼）能看见的所有颜色。 关键特性： XYZ 空间是所有现代色彩科学的基石。它本身不用于直接显示或创作，而是作为所有其他色彩空间进行转换时的“通用翻译官”或“绝对参考系”。 工作流程： 当你需要精确地从一个色彩空间转换到另一个时（例如 Adobe RGB -\u003e sRGB），标准流程就是通过XYZ作为中间站：Adobe RGB -\u003e XYZ -\u003e sRGB。这确保了转换的最高精度。 线性工作流 (Linear Workflow)：符合物理的计算方式 核心定义： 它不是一个“色彩空间”，而是一种工作方式或数学状态*。在这种状态下，颜色数值与光的物理能量严格成正比*。 关键特性： 数值翻倍，光的物理能量也翻倍。例如，强度为 0.2 的光和强度为 0.5 的光混合，其物理结果就是 0.7。所有需要模拟真实世界光照的计算（如渲染、合成、光照混合）都必须在线性空间下进行，否则结果将是错误的。 与人眼感知的关系： 我们的眼睛和显示器都是非线性的。为了高效地存储和显示图像（用更少的数据记录更多人眼敏感的暗部细节），图像通常会经过“伽马校正(Gamma Correction)”处理。因此，我们可以简单总结： 线性空间：为机器计算而生，追求物理正确。 伽马/感知空间 (非线性)：为人眼观看和数据存储而生，追求视觉效率。 ","date":"2025-10-13","objectID":"/hdr/:7:1","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"第二层：具体的色彩空间“产品” 这些是我们日常工作中实际接触到的“容器”，它们都定义了自己的色域范围和（通常是非线性的）编码方式。 sRGB 家族：互联网的通用语 它们共享相同的色域，但有不同的工作方式。 sRGB (标准) 定义： 一个非线性的色彩空间，是互联网、消费级电子产品（显示器、相机）和操作系统的通用标准。 特性： 它是最古老、最通用、但色域（能显示的颜色范围）也相对最小的标准。几乎所有未经色彩管理的图片和视频都默认为sRGB。 sRGB 线性空间 (sRGB Linear) 定义： 拥有和 sRGB 完全相同的色域，但是移除了伽马校正，使其成为一个线性空间。 用途： 它是进行色彩计算的“预备步骤”。当你需要对一张sRGB图片进行正确的亮度调整或颜色混合时，必须先将它从标准的sRGB转换到sRGB线性空间，计算完成后，再转回标准sRGB进行显示或保存。 scRGB 定义： 可以看作是 sRGB 线性空间的“HDR超级版”。它共享sRGB的色域，本身就是线性的，但最关键的特性是：允许颜色数值超出 [0, 1] 的范围。 用途： 它的设计目标是在操作系统层面（特别是Windows）无缝地混合SDR和HDR内容。 SDR内容(如记事本) 在 scRGB 中值依然在 [0, 1] 范围内。 HDR内容(如HDR视频中的太阳) 在 scRGB 中可以拥有 10.0, 100.0 甚至更高的值。 由于整个环境是线性的，操作系统可以简单地对这些不同亮度的内容进行物理正确的混合与叠加，最后再统一输出到显示器。 广色域家族：更丰富的色彩世界 这些空间的色域都比sRGB更广，能显示更生动、更丰富的颜色。 Adobe RGB 定义： 一个非线性色彩空间，主要扩展了sRGB在绿色和青色方向的范围 用途： 广泛应用于专业摄影和印刷出版领域。 线性版本 (Adobe RGB Linear)： 同样地，在需要对其进行计算时，需要先转换到其线性版本。 DCI-P3 定义： 一个非线性色彩空间，是数字电影行业的标准。相比sRGB，它在红色和绿色方向有显著扩展。 用途： 广泛用于电影院、高端消费电子设备（特别是苹果的iPhone、iPad、Mac）的屏幕。 线性版本 (DCI-P3 Linear)： 在游戏引擎或渲染器中，当目标显示设备是P3屏幕时，常会使用其线性版本进行计算。 Rec.2020 (或 BT.2020) 定义： 为超高清（4K/8K）和HDR视频制定的非线性色彩空间。它通常与 PQ 或 HLG 伽马曲线配合使用。 特性： 拥有极其宽广的色域，是目前消费级显示的终极目标，但绝大多数现有显示器都无法100%覆盖。 线性版本 (Rec.2020 Linear)： 在HDR渲染管线中，当需要处理广色域内容时，其线性版本是进行光照计算的核心工作空间之一。 ACES 家族：工业级标准化流程 ACES不只是一个色彩空间，它是一整套用于影视和游戏行业的色彩管理框架。并且 ACES 本身就是线性空间 例如：Unreal 的色彩空间采用的则是 ACES ACEScg (AP1) 定义： 一个原生线性的色彩空间，拥有非常宽广的色域（AP1原色） 用途： 被设计为CG渲染和视觉特效合成的理想工作空间。它的色域足够大，可以容纳任何摄像机捕捉到的色彩，并为调色和特效处理提供充足的“运算空间”。 ACES2065-1 (AP0) 定义： ACES框架中色域最大的原生线性空间（AP0原色），其色域设计为完全包围人眼可见光谱。 用途： 作为项目的“数字母带”和“数据交换”的标准。当你需要将项目文件长期归档，或在不同公司之间传递时，使用此空间可以确保没有任何色彩信息会因转换而丢失。 ","date":"2025-10-13","objectID":"/hdr/:7:2","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"示例：Rec.2020 -\u003e sRGB Rec.2020 (非线性) → [解码 EOTF] → Linear Rec.2020 → [乘以色域变换矩阵] → Linear XYZ → [乘以色域变换矩阵] → Linear sRGB → [应用 sRGB OETF] → sRGB (非线性) 步骤 说明 1️⃣ 解码 EOTF 把 Rec.2020（可能是 Gamma2.4 / PQ / HLG）反线性化为真实的光强响应值。输出是 Linear Rec.2020。 2️⃣ 转换到 XYZ 使用固定的 3×3 原色矩阵，从 Rec.2020 转换到 CIE 1931 XYZ（标准视觉空间）。 3️⃣ 从 XYZ 到 Linear sRGB 使用另一个 3×3 矩阵，从 XYZ 转成 sRGB 原色定义的线性空间。 4️⃣ 应用 sRGB OETF 对 Linear sRGB 再套上 sRGB 的 gamma（ ≈ 2.2），得到最终非线性 sRGB。 ","date":"2025-10-13","objectID":"/hdr/:8:0","tags":["HDR","Unreal","SDR"],"title":"SDR与HDR","uri":"/hdr/"},{"categories":["HDR"],"content":"Unreal中的HDR","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"源码版本 - UE5.5 ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:0:0","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"HDR 相关命令 r.HDR.EnableHDROutput 控制是否启用 HDR 输出。 它主要控制 DXGI 设置，以更改后台缓冲区格式，并允许将 HDR 格式的后台缓冲区发送到 HDR 显示设备。 r.HDR.Display.OutputDevice 控制使用哪个输出设备的传输函数 TAutoConsoleVariable\u003cint32\u003e CVarDisplayOutputDevice( TEXT(\"r.HDR.Display.OutputDevice\"), 0, TEXT(\"Device format of the output display:\\n\") TEXT(\"0: sRGB (LDR)\\n\") TEXT(\"1: Rec709 (LDR)\\n\") TEXT(\"2: Explicit gamma mapping (LDR)\\n\") TEXT(\"3: ACES 1000 nit ST-2084 (Dolby PQ) (HDR)\\n\") TEXT(\"4: ACES 2000 nit ST-2084 (Dolby PQ) (HDR)\\n\") TEXT(\"5: ACES 1000 nit ScRGB (HDR)\\n\") TEXT(\"6: ACES 2000 nit ScRGB (HDR)\\n\") TEXT(\"7: Linear EXR (HDR)\\n\") TEXT(\"8: Linear final color, no tone curve (HDR)\\n\") TEXT(\"9: Linear final color with tone curve\\n\"), ECVF_Scalability | ECVF_RenderThreadSafe ); r.HDR.Display.ColorGamut 控制用作输出设备的色域范围 TAutoConsoleVariable\u003cint32\u003e CVarDisplayColorGamut( TEXT(\"r.HDR.Display.ColorGamut\"), 0, TEXT(\"Color gamut of the output display:\\n\") TEXT(\"0: Rec709 / sRGB, D65 (default)\\n\") TEXT(\"1: DCI-P3, D65\\n\") TEXT(\"2: Rec2020 / BT2020, D65\\n\") TEXT(\"3: ACES, D60\\n\") TEXT(\"4: ACEScg, D60\\n\"), ECVF_Scalability | ECVF_RenderThreadSafe ); r.HDR.Display.MinLuminanceLog10 所设定的最低显示输出的 Nit 值（以对数形式表示的值） 默认值 -4 r.HDR.Display.MidLuminance 18% 灰度的配置显示输出的亮度水平 默认值 15 r.HDR.Display.MaxLuminance 所配置的显示输出的亮度水平（假设已启用 HDR 输出）。 默认值 0 但是其实代码判断为0 就会显示1000，如果启用 HDR 输出 跟 r.HDR.Display.MidLuminance 配合使用，要不然这个调的太低，场景会灰 r.HDR.UI.CompositeMode 控制UI是否启用HDR合成模式，尝试获得与SDR相同的UI视觉效果。 r.HDR.UI.Level 将用户界面元素合成到高动态范围帧缓冲区时的亮度级别 r.HDR.UI.Luminance 控制 UI HDR 亮度值 在将用户界面元素合成到 HDR 帧缓冲区时，其基亮度值（以尼特为单位）乘以 r.HDR.UI.Level 的结果 除了 r.HDR.EnableHDROutput ，其他的参数都是控制 UE 渲染逻辑的 Shader 参数 ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:1:0","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"HDR 后处理 关于 HDR 的后处理可以分为两个流程，实际里面也有对 SDR 的处理 cLUTs Tonemap ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:2:0","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"生成 cLUTs 首先，生成当前帧的 CLUT。 此逻辑由 PostProcessCombineLUTs.usf 处理。有两个版本可供选择：PS 和 CS，具体取决于当前平台。 此 CLUT 包含以下颜色操作： 依靠UV计算出 2D/3D 的 中性LUTs 白平衡 HDR 调色 输出变换 （RRT + ODT） （1）中性LUTs USE_VOLUME_LUT 这个宏内走的会根据你的 LUTSize（默认值为32）生成 32 x 32 x32 的 3D LUTs 表 如果不走这个宏的话，他就会按照你的 LUTSize（默认值为32） 生成像素长为 32 x 32 = 1024，像素宽为 32 的 2D LUTs 再然后如果发现你的 OutputDevice \u003e= 3 则把 ST 2084/PQ 传输函数将 0-1 范围重新映射到 0-100 尼特的转换 SDR输出设备分支采用对数编码，利用对数函数将0到1的范围重新映射到从0到场景中最大像素值（约50）的转换。 float4 CombineLUTsCommon(float2 InUV, uint InLayerIndex) { #if USE_VOLUME_LUT == 1 // construct the neutral color from a 3d position volume texture float4 Neutral; { float2 UV = InUV - float2(0.5f / LUTSize, 0.5f / LUTSize); Neutral = float4(UV * LUTSize / (LUTSize - 1), InLayerIndex / (LUTSize - 1), 0); } #else // construct the neutral color from a 2d position in 256x16 float4 Neutral; { float2 UV = InUV; // 0.49999f instead of 0.5f to avoid getting into negative values UV -= float2(0.49999f / (LUTSize * LUTSize), 0.49999f / LUTSize); float Scale = LUTSize / (LUTSize - 1); float3 RGB; RGB.r = frac(UV.x * LUTSize); RGB.b = UV.x - RGB.r / LUTSize; RGB.g = UV.y; Neutral = float4(RGB * Scale, 0); } #endif ...... float3 LUTEncodedColor = Neutral.rgb; float3 LinearColor; // Decode texture values as ST-2084 (Dolby PQ) BRANCH if (GetOutputDevice() \u003e= TONEMAPPER_OUTPUT_ACES1000nitST2084) { // Since ST2084 returns linear values in nits, divide by a scale factor to convert // the reference nit result to be 1.0 in linear. // (for efficiency multiply by precomputed inverse) LinearColor = ST2084ToLinear(LUTEncodedColor) * LinearToNitsScaleInverse; } // Decode log values else { LinearColor = LogToLin(LUTEncodedColor) - LogToLin(0); } } float3 LogToLin( float3 LogColor ) { const float LinearRange = 14; const float LinearGrey = 0.18; const float ExposureGrey = 444; // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered. float3 LinearColor = exp2( ( LogColor - ExposureGrey / 1023.0 ) * LinearRange ) * LinearGrey; //float3 LinearColor = 2 * ( pow(10.0, ((LogColor - 0.616596 - 0.03) / 0.432699)) - 0.037584 ); // SLog //float3 LinearColor = ( pow( 10, ( 1023 * LogColor - 685 ) / 300) - .0108 ) / (1 - .0108); // Cineon //LinearColor = max( 0, LinearColor ); return LinearColor; } （2）白平衡 使用上一个步骤计算出来的 LinearColor 计算白平衡 float4 CombineLUTsCommon(float2 InUV, uint InLayerIndex) { ...... float3 BalancedColor = WhiteBalance(LinearColor, WhiteTemp, WhiteTint, bIsTemperatureWhiteBalance, (float3x3)WorkingColorSpace.ToXYZ, (float3x3)WorkingColorSpace.FromXYZ); ...... } float3 WhiteBalance(float3 LinearColor, float WhiteTemp, float WhiteTint, bool bIsTemperatureWhiteBalance, const float3x3 WCS_2_XYZ, const float3x3 XYZ_2_WCS) { float2 SrcWhiteDaylight = D_IlluminantChromaticity(WhiteTemp); float2 SrcWhitePlankian = PlanckianLocusChromaticity(WhiteTemp); float2 SrcWhite = WhiteTemp \u003c 4000 ? SrcWhitePlankian : SrcWhiteDaylight; float2 D65White = float2(0.31270, 0.32900); { // Offset along isotherm float2 Isothermal = PlanckianIsothermal(WhiteTemp, WhiteTint) - SrcWhitePlankian; SrcWhite += Isothermal; } if (!bIsTemperatureWhiteBalance) { float2 Temp = SrcWhite; SrcWhite = D65White; D65White = Temp; } float3x3 WhiteBalanceMat = ChromaticAdaptation(SrcWhite, D65White); WhiteBalanceMat = mul( XYZ_2_WCS, mul( WhiteBalanceMat, WCS_2_XYZ ) ); return mul(WhiteBalanceMat, LinearColor); } 白平衡是利用是色温值来选择是普朗克轨迹还是日光模型来算出白点的色度坐标 如果是 色温值 \u003c 4000则光源更接近于黑体辐射，所以使用普朗克轨迹模型，更通俗点就是人造光源 反之，则光源更接近于日光这种，所以使用标准日光模型 （3）从sRGB 到AP1色彩空间的转换 计算白平衡后，色彩空间从sRGB Linear转换为ACESAP1线性色彩空间。 float4 CombineLUTsCommon(float2 InUV, uint InLayerIndex) { ...... float3 ColorAP1 = mul( (float3x3)WorkingColorSpace.ToAP1, BalancedColor ); ...... } 我们将色域从 sRGB 空间转换到了广色域 AP1，但之前的场景渲染是在 sRGB 线性色彩空间中进行的，因此得到的色域值始终在 sRGB 色域内。 现在 UE 出了一个小技巧：场景看起来像是在广色域空间中进行计算的，其原色介于 P3 和 AP1 之间，它使用 Wide_2_AP1 进行颜色转换，最后将参数与原始的 sRGB_2_AP1 转换结果进行插值。 float4 CombineLUTsCommon(float2 InUV, uint InLayerIndex) { ...... // Expand bright saturated colors outside the sRGB ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:2:1","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"使用 cLUTs (Tonemap) 使用CLUT的逻辑由PostProcessTonemap.usf处理，其主要功能逻辑在TonemapCommonPS函数中 该函数首先计算任何目前尚未完成的后处理，例如Grain、Color Fringe、Sharpen、Bloom、Exposure和Vignette，然后将上述后处理计算得到的最终结果转换为3D LUT的采样坐标来查找颜色： half3 ColorLookupTable( half3 LinearColor ) { float3 LUTEncodedColor; // Encode as ST-2084 (Dolby PQ) values BRANCH if(GetOutputDevice() \u003e= TONEMAPPER_OUTPUT_ACES1000nitST2084) { // ST2084 expects to receive linear values 0-10000 in nits. // So the linear value must be multiplied by a scale factor to convert to nits. // We don't send negative values to LinearToST2084 as it will result in NaN because of pow. LUTEncodedColor = LinearToST2084(max(0, LinearColor) * LinearToNitsScale); } else { LUTEncodedColor = LinToLog( LinearColor + LogToLin( 0 ) ); } float3 UVW = LUTEncodedColor * LUTScale + LUTOffset; #if USE_VOLUME_LUT == 1 half3 OutDeviceColor = Texture3DSample( ColorGradingLUT, ColorGradingLUTSampler, UVW ).rgb; #else half3 OutDeviceColor = UnwrappedTexture3DSample( ColorGradingLUT, ColorGradingLUTSampler, UVW, LUTSize, InvLUTSize ).rgb; #endif return OutDeviceColor * 1.05; } float4 TonemapCommonPS( float3 UV, float2 Vignette, float4 GrainUV, float2 ScreenPos, // [-1, 1]x[-1, 1] float2 FullViewUV, float4 SvPosition, out float OutLuminance ) { ...... half3 OutDeviceColor = ColorLookupTable(FinalLinearColor); ...... } 因为我们 cLUTs 是非线性的 HDR 空间的值，所以我们经历 Bloom 等一些计算出的颜色也要 To ST2084 后才能去 cLUTs 里面寻找 最后，根据 OutputDevice，如果你在编辑器开启了HDR，则会将 ST2084 转成 ScRGB，输出到下一阶段，其他的看分支即可 float4 TonemapCommonPS( float3 UV, float2 Vignette, float4 GrainUV, float2 ScreenPos, // [-1, 1]x[-1, 1] float2 FullViewUV, float4 SvPosition, out float OutLuminance ) { ...... if(GetOutputDevice() == TONEMAPPER_OUTPUT_ACES1000nitScRGB || GetOutputDevice() == TONEMAPPER_OUTPUT_ACES2000nitScRGB) { OutColor.xyz = ST2084ToScRGB(OutColor.xyz, GetOutputDevice(), OutputMaxLuminance); } else if(GetOutputDevice() == TONEMAPPER_OUTPUT_LinearEXR) { OutColor.xyz = ST2084ToLinear(OutColor.xyz); } else { OutColor.xyz = OutDeviceColor; } ...... } ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:2:2","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"UI 中的 HDR UI中使用 HDR 主要是在 CompositeUIPixelShader.usf 中处理的 ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:3:0","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"（1）计算 UI 颜色 在这里会从一个包含UI元素的纹理中采样颜色。随后进行颜色变换，从 sRGB 空间转换到 REC.2020的线性空间，所以这里 Unreal 会默认一切UI颜色都是为 sRGB 在这个步骤，其实就会跟 r.HDR.UI.Luminance计算 void Main( FScreenVertexOutput Input, out float4 OutColor : SV_Target0 ) { ... float4 UIColor = ComputeHDRUIColor(Input.UV); ... } ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:3:1","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"（2）计算场景颜色 这里先从场景纹理采样，随后因为我们在之前 Tonemap 中最终输出的是ST2080，所以在这里如果没开启SCRGB的宏，会将ST2080 转成 Rec.2020 线性空间. 如果开启ScRGB的宏，最终其实也是转为了 Rec.2020 的颜色空间 void Main( FScreenVertexOutput Input, out float4 OutColor : SV_Target0 ) { ... float3 SceneColor = Texture2DSample(SceneTexture, SceneSampler, Input.UV).xyz; SceneColor = ComputeHDRSceneColor(SceneColor); ... } ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:3:2","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"（3）混合 UI 和 场景 颜色 最终会在这个步骤将场景和UI混合到一张 RT 上，这里会如果 UI 为半透明会进行特殊处理，如果为 a通道为0或者不透明，则会乘上 r.HDR.UI.Level 的值，做运算 float3 ComposeUIAndScene(float3 SceneColor, float4 InUIColor, float InUILevel) { BRANCH if (InUIColor.w \u003e 0.f \u0026\u0026 InUIColor.w \u003c 1.f) { // Clamp gamut to sRGB as extended gamut colors bleeding into the UI can look funny SceneColor = max(SceneColor, 0.f); // Tonemap HDR under transparent UI with a simple Reinhard to the max luminance of the UI // This prevents HDR bleed through destroying UI legibility // Rec2020 coefficients to compute luminance float KR = 0.2627, KG = 0.678, KB = 0.0593; float Luminance = dot(SceneColor, half3(KR, KG, KB)) / InUILevel; float OutL = 1.f / (Luminance + 1.f); // Ease out remapping to avoid hard transitions where UI is near zero opacity SceneColor *= lerp(1.f, OutL * InUILevel, InUIColor.w); } // Composite, assuming pre-multiplied alpha return SceneColor * (1.f - InUIColor.w) + InUIColor.xyz * InUILevel; } void Main( FScreenVertexOutput Input, out float4 OutColor : SV_Target0 ) { ... OutColor.xyz = ComposeUIAndScene(SceneColor.xyz, UIColor, UILevel); ... } ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:3:3","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"（4）色盲模式 Unreal 其实对色盲是有过处理的，将合成后的颜色转换成模拟某种色盲（如红绿色盲、蓝黄色盲）所看到的颜色。 void Main( FScreenVertexOutput Input, out float4 OutColor : SV_Target0 ) { OutColor.rgb = ApplyColorDeficiency(OutColor.rgb); } ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:3:4","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["HDR"],"content":"（5）输出到显示器 我们到这个流程的颜色空间为 Rec.2020 线性空间，既然要输出到显示器，肯定必须在转换为 ST 2084（PQ），如果使用 scRGB 编码则就转换为 sRGB色域 void Main( FScreenVertexOutput Input, out float4 OutColor : SV_Target0 ) { #if !SCRGB_ENCODING // Linear -\u003e PQ OutColor.xyz = LinearToST2084(OutColor.xyz); #else const float3x3 Rec2020_2_sRGB = mul(XYZ_2_sRGB_MAT, Rec2020_2_XYZ_MAT); OutColor.xyz = mul(Rec2020_2_sRGB, OutColor.xyz / ScRGBScaleFactor); #endif } ","date":"2025-10-13","objectID":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/:3:5","tags":["HDR","Unreal"],"title":"Unreal中的HDR","uri":"/hdr-unreal%E4%B8%AD%E7%9A%84hdr/"},{"categories":["Real-Time Rendering 4"],"content":"图形渲染管线","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"引言 本博客介绍了实时图形学中的核心组件，它被称为“图形渲染管线（graphics rendering pipeline）”，也被简称为“管线”。 渲染管线的核心功能就是利用给定的虚拟相机、三维物体、光源等信息，来生成或者渲染（render）一张二维图像。因此， 渲染管线是实时渲染中的底层工具 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:1:0","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"渲染管线的架构 一种粗略的划分方法是将渲染管线分为四个阶段——应用阶段（application）、几何处理阶段（geometry processing）、光栅化阶段（rasterization）和像素处理阶段（pixel processing） 渲染速度可以用每秒帧数（FPS）来进行表示，即每秒显示的帧数；也可以用赫兹 （Hz）来进行表示，这个单位代表了 ，即更新的频率。 应用阶段（application）是由应用程序进行驱动的，它在软件中进行实现，运行在通用 CPU 上。这些 CPU 一般都具有多个核心，可以并行处理多个线程 （thread）的任务，这使得 CPU 可以高效执行由应用阶段所负责的各种任务，一般 CPU 会负责碰撞检测，全局加速算法，动画，物理模拟等任务，具体会执行哪些任 务取决于应用程序的类型。 下一个主要阶段是几何处理阶段（geometry processing），它负责处理变换（transform），投影（projection）以及其他所有和 几何处理相关的任务。这个阶段需要计算哪些物体会被绘制，应该如何进行绘制，以 及应当在哪里绘制等问题。几何阶段通常运行在硬件处理单元（GPU）上，它包含一 系列的可编程单元和固定操作硬件。 光栅化阶段（rasterization）通常会将构成一个 三角形的三个顶点作为输入，找到所有位于三角形内部的像素，并将其转发到下一个 阶段中。 最后一个阶段是像素处理阶段（pixel processing），对于每个像素而言， 都会执行一个程序来决定它的颜色；并执行深度测试，来判断这个像素是否可见；这 里还可以执行一些逐像素的操作，例如将新计算的颜色和之前的颜色进行混合。 光栅化阶段和像素处理阶段同样完全运行在 GPU 上 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:2:0","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"应用阶段 由于应用阶段通常都运行在 CPU 上， 因此开发者可以完全控制在应用阶段发生的事情 有一些应用阶段中的任务也可以让 GPU 来进行执行，即通过使用一个叫做计算着色器（compute shader）的独立模式，该模式会将 GPU 视为一个高度并行 的通用处理器，而忽略其专门用于图形渲染的特殊功能 在应用阶段的最后，需要进行渲染的几何物体会被输入到几何处理阶段中，这些几何物体被称作为渲染图元（rendering primitive），即点、线和三角形。 碰撞检测（collision detection）通常会在这个阶段中实现。当检测到两个物体之间的碰撞之后，会产生相应的响应，并返回给碰撞物体，同时也返回给力反馈设备（如果有的话）。 应用阶段同样也是处理其他来源输入的地方，例如键盘、鼠标或者头戴式显示器等，会根据不同的输入，从而采取不同的操作。此外，一些加速算法例如特殊的剔除算法等，以及渲染管线剩余部分无法处理的一切问题，都会在应用阶段中完成。 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:3:0","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"几何处理阶段 运行在 GPU 上的几何处理阶段会负责大部分的逐三角形（per-triangle）和逐顶点 （per-vertex）操作。将几何处理阶段再细分下去，可以划分为以下几个功能性阶段：顶点着色（vertex shading）、投影（projection）、裁剪（clipping）和屏幕映射（screen mapping），如图 2.3 所示. ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:4:0","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"顶点着色 顶点着色（vertex shading）的任务主要有两个 一个是计算顶点的位置 另一个是计算那些开发人员想要作为顶点数据进行输出的任何参数，例如法线（normal）和纹理坐标（texture coordinate）等 顶点着色器如今是一个更加通用的单元，它负责计算并设置与每个顶点都相关的数据。例如顶点着色器可以用来计算物体的动画。 首先我们描述一下顶点位置是如何被计算出来的，它需要一组顶点坐标来作为输入。 在物体最终进入屏幕的过程中，它需要在不同的空间（space）或者坐标系 （coordinate system）下，进行若干次变换 接下来，我们将描述顶点着色的第二类输出。为了创建一个真实的场景，仅仅是渲染物体的位置和形状是不够的，我们还需要对物体的外观信息进行建模，包括物体的材质（material）信息以及光源照射在物体表面上的效果。从最简单的颜色描述到基于物理的详细描述，材质和光源可以通过很多方式进行建模。 确定光照作用于材质上所产生的效果，这个操作被称为着色 顶点着色的结果（可能是颜色、向量、纹理坐标或者其他类型的着色数据）会被发送到光栅化阶段中进行插值，并在像素处理阶段中用于计算表面的着色。 作为顶点着色的一部分，渲染系统还会进行投影操作和裁剪操作，这两个操作会将整个可视空间变换为一个标准立方体，这个标准立方体被称为规范可视空间（canonical view volume） 首先会进行投影操作，这是在 GPU 上的顶点着色器中完成； 有两种常见的投影方法， 一种是正交投影（orthographic），也可以叫做平行投影（parallel）；另一种是透视投影（perspective） ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:4:1","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"可选的顶点管理 每个渲染管线中，都会有刚才所描述的顶点处理阶段，当完成顶点处理之后，还有几个可以在 GPU 上执行的可选操作，它们的执行顺序如下：曲面细分 （tessellation）、几何着色（geometry shading）和流式输出（stream out）。 曲面细分 想象有一个用三角形表示的曲面小球，我们从远看看的就是一个小球，但是离近看就会发现三角形，所以曲面细分就可以帮我们为一个曲面生成数量合适的三角形，这样就可以做到性能与质量兼顾 曲面细分阶段本身也包含了一系列子阶段——壳着色器 （hull shader）、曲面细分器（tessellator）和域着色器（domain shader），它们可以将当前的顶点集合（通常）转换为更大的顶点集合，从而创建出更多的三角形。 几何着色器 这个着色器出现的比曲面细分着色器更早，因此在 GPU 上也更加常见。它和曲面细分着色器的相似点在于，它也将各种类型的图元作为输入，然后生成新的顶点。 这是一个较为简单的阶段，因为它能够创建的范围是有限的，能够输出的图元则更加有限 几何着色器有好几种用途， 其中最流行的一种就是用来生成粒子。想象我们正在模拟一个烟花爆炸的过程，每颗火花都可以表示为一个点，即一个简单的顶点。 流式输出 这阶段我们可以把GPU作为一个几何引擎 说人话就是把数据放在缓冲区，而不是直接输入到渲染管线后面流程并且直接输出到屏幕 这个阶段通常会用于粒子模拟，例如我们刚才所举的烟花案例 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:4:2","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"裁剪 我们只需要可视空间里面的图元，如果在可视空间外，则可以不用显示，如果一个三角形有一部分在可视空间外，就会直接裁剪，抛弃可视空间外的顶点，生成新的顶点 我们使用投影矩阵来将可视空间变成一个立方体，这意味着所有的图元都需要被这个标准立方体所裁剪。使用观察变换和投影变换可以保证裁剪的一致性 这里我们会采用投影变换的四维齐次坐标去完成这个剪切操作 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:4:3","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"屏幕映射 只有位于可视空间的图元我们才会传递到屏幕映射阶段。当这些图元进入到这个阶段的时候，坐标还是三维的，所以需要映射到屏幕的二维坐标 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:4:4","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"光栅化阶段 所有在前一阶段中被保留下来的图元，在这个阶段中都会进行光栅化，即找到所有位于图元内部的像素，然后将其发送管线的像素处理阶段 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:5:0","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"像素处理阶段 这一步的目标是计算出每个可见图元所覆盖像素的颜色值 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:6:0","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"总结 本章节介绍的就是面向实时渲染程序的API以及图形硬件发展而来的结果。 离线渲染中也有一套渲染管线，但是经历了与实时渲染完全不同的有演化路径 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/:7:0","tags":["Real-Time Rendering"],"title":"图形渲染管线","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"categories":["Real-Time Rendering 4"],"content":"微积分的导数","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/","tags":["Real-Time Rendering"],"title":"简介","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/"},{"categories":["Real-Time Rendering 4"],"content":"实时渲染 实时渲染是指在计算机上快速生成图像，它是计算机图形学中互动性最强的领域 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/:1:0","tags":["Real-Time Rendering"],"title":"简介","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/"},{"categories":["Real-Time Rendering 4"],"content":"刷新率 电影放映机（movie projector）会以 24 FPS 的速率来进行显示，但是它会使用一个 快门系统（shutter system）来将每帧重复显示 2-4 次，从而避免画面出现闪烁。这 被称为刷新率（refresh rate），其单位是赫兹（Hz） ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/:2:0","tags":["Real-Time Rendering"],"title":"简介","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/"},{"categories":["Real-Time Rendering 4"],"content":"几何定义 几乎所有图形硬件使用的渲染图元（primitive，也叫做 drawing primitives）都是 点、线和三角形 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/:3:0","tags":["Real-Time Rendering"],"title":"简介","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/"},{"categories":["Real-Time Rendering 4"],"content":"着色 按照约定俗成的计算机图形学惯例，本书中的“着色（shading）”和“着色器 （shader）”以及相关的派生词，常常被用来指向两个相关但是完全不同的概念：一 个是计算机生成的视觉外观，例如：“着色模型（shading model）”，“着色方程 （shading equation）”，“卡通渲染（toon shading）”等；另一个是渲染系统中的 可编程组件，例如：“顶点着色器（vertex shader）”，“着色器语言（shading language）”等。 ","date":"2025-09-09","objectID":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/:4:0","tags":["Real-Time Rendering"],"title":"简介","uri":"/%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93-%E7%AE%80%E4%BB%8B/"},{"categories":["微积分"],"content":"微积分的导数应用","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"函数的极值 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:1:0","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"绝对（全局）极值 定义：绝对极值 设 $f$ 是定义域为 D 的函数，$ c \\in D $，则 $f(c)$ 是： $f$ 是 D 上的绝对最大值，当且仅当对一切 $x \\in D$，有 $ f(x) \\leq f(c)$ $f$ 是 D 上的绝对最小值，当且仅当对一切 $x \\in D$，有 $ f(x) \\neq f(c)$ 定理：连续函数的极值定理 如果 $ f(x) $ 是闭区间 $I$ 上的连续函数，那么 $ f(x) $ 在 $I$ 的某些点处即能取到其绝对最大值 M，也能取到绝对最小值 m ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:1:1","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"局部（相对）极值 定义：局部极值 设 c 是函数 $f(x)$ 定义域的内点，则 $f(c)$是： 在 c 的局部最大值，当且仅当对包含 c 的某个开区间中的一切 x ，有 $ f(x) \\leq f(c) $ 在 c 的局部最小值，当且仅当对包含 c 的某个开区间中的一切 x ，有 $ f(x) \\neq f(c) $ ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:1:2","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"求极值 定理：局部极值 如果函数 $f$ 在其定义域的内点 c 点取到局部最大值或局部最小值，又若在 c 点 $f’$ 存在，那么： $$ f’(c) = 0 $$ 定义：临界点 函数 $f$ 的定义域中的一点称为 $f$ 的临界点，如果在该点处 $ f’ = 0 $ 或者 $f’$ 不存在 怎么求闭区间商连续函数的极值 第一步：计算$f$在所有临界点和端点处的值 第二步：从这些值中取最大和最小值 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:1:3","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"中值定理和微分方程 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:2:0","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"Roller 定理 假设 $ y = f(x) $ 在 [a，b] 的每一点连续，又连续它在（a，b）的每一点可微，如果： $$ f(a) = f(b) = 0 $$ 那么（a，b）中至少有一个数 c，$f’(c)$ = 0 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:2:1","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"中值定理 中值定理就是在斜线上的 Roller 定理 假设 $ y = f(x) $ 在闭区间[a，b]上连续而且在区间（a，b）的内点处可微，那么（a，b）中至少有一点 c ，使下述公式成立 $$ \\frac{f(b) - f(a)}{b - a} = f’(c) $$ ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:2:2","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"物理解释 把数 $(f(b) - f(a)) / (b - a)$ 设想为 $f$ 在 [a，b]上的平均变化率而 $f’(c)$ 是 $f$ 在 x = c 的瞬时变化率. 中值定理是说，在某个内点处的瞬时变化率一定等于整个区间上的平均变化率 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:2:3","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"数学推论 推论：导数为零的函数一定是常数函数 推论：在区间上具有相同导函数的函数互相差一个常数 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:2:4","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"微分方程以及抛射体的高度 微分方程就是把未知函数及其一个或多个导数联系在一起的方程 一个函数称为微分方程的一个解，若该函数的导数满足该微分方程 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:2:5","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"图形的形状 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:3:0","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"增函数和减函数的一阶导数检验法 定义：增函数，减函数 设 $f$ 是定义在区间 I 上的函数，那么： $f$ 在 I 上是增函数，如果对所有 I 中的 $x_1$ 和 $x_2$，$x_1 \u003c x_2 \\Rightarrow f(x_1) \u003c f(x_2)$ $f$ 在 I 上是减函数，如果对所有 I 中的 $x_1$ 和 $x_2$，$x_1 \u003c x_2 \\Rightarrow f(x_1) \u003e f(x_2)$ 推论：增函数和减函数的一阶导数检验法 假设 $f$ 在 [a，b] 上连续并在（a，b）上可微 如果在 （a，b）的每一点处 $f’ \u003e 0$，那么$f$ 在 [a，b] 上是增函数 如果在 （a，b）的每一点处 $f’ \u003c 0$，那么$f$ 在 [a，b] 上是减函数 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:3:1","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"局部极值的一阶导数检验法 在临界点 x = c 处 $f$ 有局部最小值，如果 $f’$ 在 c 从负变到正 $f$ 有局部最大值，如果 $f’$ 在 c 从正变到负 $f$ 没有局部极值，如果 $f’$ 在 c 的两边正负号相同 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:3:2","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"凹性 定义：凹形 可微函数 $y = f(x)$ 的图形是 在开区间 I 上凹向上的，如果 $y’$ 在 I 上递增 在开区间 I 上凹向下的，如果 $y’$ 在 I 上递减 凹形的二阶导数检验法 二次可微函数 $y = f(x)$ 的图形 在 $y’’ \u003e 0$ 的任何区间上是凹向上的 在 $y’’ \u003c 0$ 的任何区间上是凹向下的 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:3:3","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"拐点 一点称为函数的拐点，如果函数在该点有切线而且在该店改变函数的凹形 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:3:4","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"局部极值的二阶导数检验法 如果$f’(c) = 0$ 且 $f’’(c) \u003c 0$，那么 $f$ 在 $x = c$ 取到局部最大值 如果$f’(c) = 0$ 且 $f’’(c) \u003e 0$，那么 $f$ 在 $x = c$ 取到局部最小值 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:3:5","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"用手画 $ y = f(x) $ 的图形的一般步骤 求 $y’$ 和 $y’’$ 求曲线的上升和下降空间 确定曲线的凹形 综合并展示曲线的总的样子 点出特定的点并粗略画出曲线的图形 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:3:6","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"从函数的导数了解函数 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:3:7","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"自治微分方程的图形解 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:4:0","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"平衡点和相直线 自治微分方程 对方称 $y^2 = x + 1$ 隐式的求导数就给出： $$ 2y\\frac{dy}{dx} = 1 \\quad \\frac{dy}{dx} = \\frac{1}{2y} $$ 这一微分方程，其中 dy/dx 只是 y 的函数，称为自治微分方程 定义：平衡点或者静止点 如果 dy/dx = g(y) 是自治微分方程，那么使得 dy/dx = 0 的 y 的值称为平衡点或静止点 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:4:1","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"稳定和不稳定平衡点 ","date":"2025-09-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/:4:2","tags":["微积分"],"title":"微积分 - 导数的应用","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["微积分"],"content":"微积分的导数","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"作为函数的导数 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:0","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"导数的定义 函数 $ f(x) $ 关于变量 x 的导数是 $f’$，他在 x 处的值为： $$ f’(x) = \\lim_{h \\to 0} \\frac{f(x + h) - f(x)}{h} \\quad 如果该极限存在 $$ 例题（运用定义） 求 $ y = \\sqrt{x}，x \u003e 0 $ 的导数 $$ \\begin{gather*} f(x) = \\sqrt{x} \\quad 而 f(x + h) = \\sqrt{x + h} \\\\ \\\\ \\frac{f(x + h) - f(x)}{h} = \\frac{\\sqrt{x + h} - \\sqrt{x}}{h} = \\frac{(x + h) - x}{h(\\sqrt{x + h} + \\sqrt{x})} = \\frac{1}{\\sqrt{x + h} + \\sqrt{x}} \\\\ \\\\ f’(x) = \\lim_{h \\to 0} \\frac{1}{\\sqrt{x + h} + \\sqrt{x}} = \\frac{1}{2\\sqrt{x}} \\end{gather*} $$ 求曲线 $ y = \\sqrt{x} $ 在 x = 4 处的切线 $$ \\begin{gather*} 曲线在 x = 4 处的斜率为: f’(4) = \\frac{1}{2\\sqrt{4}} = \\frac{1}{4} \\\\ \\\\ 切线就是过点(4, 2)且斜率为\\frac{1}{4}的直线 \\\\ \\\\ y = 2 + \\frac{1}{4}(x - 4) \\\\ \\\\ y = \\frac{1}{4}x + 1 \\end{gather*} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:1","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"记号 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:2","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"常数函数、幂函数、函数乘以常数以及函数之和的导数 法则 1：常数函数的导数 如果 $f$ 取常数值 $ f(x) = c $，则： $$ \\frac{df}{dx} = \\frac{d}{dx}(c) = 0 $$ 例题（运用法则 1） 如果 $f$ 取常数值 $ f(x) = 8 $，则： $$ \\frac{df}{dx} = \\frac{d}{dx}(8) = 0 $$ 法则 2：正整数幂法则 如果 n 是正整数，则： $$ \\frac{d}{dx}x^n = nx^{n-1} $$ 法则 3：乘常数法则 如果 u 是 x 的可微函数，而 c 是一常数，则： $$ \\frac{d}{dx}(cu) = c \\frac{du}{dx} $$ 法则 4：导数和法则 如果 u 和 v 都是 x 的可微函数，则和 u + v 在 u 和 v 都是可微的每点也是可微的，在这种点处，有： $$ \\frac{d}{dx}(u + v) = \\frac{du}{dx} + \\frac{dv}{dx} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:3","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"区间上的可微函数：单侧导数 函数 $ y = f(x) $ 在一（有限或无限）区间上可微，如果函数在区间的每点处可微，函数在闭区间 [a，b] 上可微，如果函数在区间内部区间（a，b）上可微而且在端点处下述极限存在 $$ \\begin{gather*} \\lim_{h \\to 0^+} \\frac{f(a + h) - f(a)}{h} \\quad a点处的右侧导数 \\\\ \\\\ \\lim_{h \\to 0^-} \\frac{f(b + h) - f(b)}{h} \\quad b点处的左侧导数 \\end{gather*} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:4","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"从估算值画 $ f’ $ 的图形 例题（画导函数的图形） 画图 2.9a 中函数 $ y = f(x) $ 的导数的图形 解： 我们画一对坐标轴，用 x 单位标记水平轴而以 $ y’ $ 单位标记纵轴，并在许多区间上粗略的画出 $f$ 图形的切线并用这些切线的斜率来估算这些点处 $ y’ = f’(x)$ 的值，标出相应的 点 (x , y’) 并用光滑曲线把他们连接起来 从 $ y’ = f’(x) $ 的图形，我们一眼就能看出 何处 $f$ 的变化率是正、负或零 在某一 x 处增长率的粗略大小及其与 $f(x)$ 大小的关系 何处变化率本身是增长或递减的 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:5","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"可微函数是连续函数 在函数的导数存在的每一点处函数都是连续的 定理：可微性蕴含着连续性（逆定理不成立） 如果 $f$ 在 $ x = c$ 有导数，那么 $f$ 在 $ x = c $连续 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:6","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"导数的中间值性质 定理：导数的中间值性质 如果 a 和 b 是 $f$ 在其上可微的区间中的两个点，那么 $f’$ 一定取到 $f’(a)$和 $f’(b)$ 中间的每一个值 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:7","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"二阶和高阶导数 导数 $y’ = dy/dx $ 是 y 关于 x 的一阶导数。该导数本身就可能是 x 的可微函数； 如果是这样的话，他的导数 $ y’’ = \\frac{dy’}{dx} = \\frac{d}{dx}(\\frac{dy}{dx}) = \\frac{d^2y}{dx^2} $ 称为 y 关于 x 的 二阶导数 如果 $ y’’’ $ 是可微的，他的导数 $ y’’’ = \\frac{dy’’}{dx} = \\frac{d^3y}{dx^3} $ 就是 y 关于 x 的三阶导数 这个命名可以继续下去： $$ y^{(n)} = \\frac{d}{dx}y^{(n - 1)} $$ 表示 y 关于 x 的 n （任何正整数 n）阶导数 例题（求高阶导数） ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:1:8","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"作为变化率的导数 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:2:0","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"瞬时变化率 定义： $ f $ 关于 $ x $ 在 $ x_0 $ 的瞬时变化率就是导数 ps: 瞬时变化率是平均变化率的极限 $$ f’(x_0) = \\lim_{h \\to 0} \\frac{f(x_0 + h) - f(x_0)}{h} \\quad 倘若该极限存在 $$ 例题（圆面积怎样随直径变化） 圆面积 A 和直径的关系由下述方程表示，当直径为10米时面积关于直径的变化有多大？ $$ A = \\frac{\\pi}{4}D^2 $$ 解： 面积关于直径的变化率为： $$ \\frac{dA}{dD} = \\frac{\\pi}{4} \\cdot 2D = \\frac{\\pi D}{2} $$ 当 D = 10 米时，面积的变化率为： $$ (\\frac{\\pi D}{2})10 = 5 \\pi ~~ m^2/m $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:2:1","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"沿直线的运动：位移、速度、速率、加速度和急推 假设物体正沿坐标轴线运动，所以我们知道物体在直线上的位置 s 是时间 t 的函数： $$ s = f(t) $$ 物体从 $ t $ 到 $ t + \\Delta t $ 时间间隔内的位移为： $$ \\Delta s = f(t + \\Delta t) - f(t) $$ 而在该时间间隔内的平均速度为： $$ v_{平均} = \\frac{位移}{时间间隔} = \\frac{\\Delta s}{\\Delta t} = \\frac{f(t + \\Delta t) - f(t)}{\\Delta t} $$ 为求物体在精确瞬间 t 的速度，我们取从 $t$ 到 $ t + \\Delta t $ 时间间隔上的平均速度当 $ \\Delta t $收缩为 0 时的极限，该极限是 $f$ 关于 t 的导数 定义：（瞬时）速度 瞬时速度是位置关于时间的导数，如果物体在时刻 t 的位置为 $ s = f(t) $，那么物体在时刻 t 的速度为： $$ v(t) = \\frac{ds}{dt} = \\lim_{\\Delta t \\to 0} \\frac{f(t + \\Delta t) - f(t)}{\\Delta t} $$ 定义：速率 速率是速度的绝对值 $$ 速率 = \\mid v(t) \\mid = \\mid \\frac{ds}{dt} \\mid $$ 加速度、急推 加速度是速度关于时间的导数，如果物体在时刻 t 的位置为 $ s = f(t) $，那么物体在 t 时刻的加速度为： $$ a(t) = \\frac{dv}{dt} = \\frac{d^2s}{dt^2} $$ 急推是加速度关于时间的导数 $$ j(t) = \\frac{da}{dt} = \\frac{d^3s}{dt^3} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:2:2","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"对变化的敏感性 当 x 的小的变化会引起函数值 $ f(x) $ 的大的变化时，我们就说该函数对 x 的变化时相对敏感的，导数 $ f’(x) $是这种敏感性的度量 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:2:3","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"经济学中的导数 工程师用术语：速度和加速度指称所描述运动的函数的导数，经济学家也有其指称变化率和导数的特殊的词汇，他们称其为边际 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:2:4","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"积、商以及负幂的导数 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:3:0","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"积 法则：导数的积法则 如果 u 和 v 在 x 都可微，那么他们的积 uv 也在 x 可微，而且： $$ \\frac{d}{dx}(uv) = u\\frac{dv}{dx} + v\\frac{du}{dx} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:3:1","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"商 如果 u 和 v在 x 可微，又如果 $ v(x) \\neq 0 $，那么商 u/v 在 x 可微，且有： $$ \\frac{d}{dx}(\\frac{u}{v}) = \\frac{v\\frac{du}{dx} - u \\frac{dv}{dx}}{v^2} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:3:2","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"x 的负整数次幂 法则：如果 n 是负整数，且 $ x \\neq 0 $。那么： $$ \\frac{d}{dx}(x ^ n) = nx^{n - 1} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:3:3","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"三角函数的导数 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:4:0","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"正弦函数的导数 正弦函数的导数是余弦函数 $$ \\frac{d}{dx}(\\sin x) = \\cos x $$ 例题（与正弦函数有关的函数的导数） $ y = x^2 - \\sin x $ $$ \\begin{align*} \\frac{dy}{dx} \u0026= 2x - \\frac{d}{dx}(\\sin x) \\quad 差法则 \\\\ \\\\ \u0026= 2x - \\cos x \\end{align*} $$ $ y = \\frac{sinx}{x} $ $$ \\begin{align*} \\frac{dy}{dx} \u0026= \\frac{x \\cdot \\frac{d}{dx}(\\sin x) - \\sin x \\cdot 1}{x^2} \\quad 商法则 \\\\ \\\\ \u0026= \\frac{x \\cos x - \\sin x}{x^2} \\end{align*} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:4:1","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"余弦函数的导数 余弦函数的导数就是正弦函数取符号 $$ \\frac{d}{dx}(\\cos x) = - \\sin x $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:4:2","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"简谐运动 在弹簧或蹦极绳索端点的物体的上下自由摆动就是简谐运动的一个例子 位置：$ s = 5 \\cos t $ 速度：$ v = \\frac{ds}{dt} = \\frac{d}{dt}(5 \\cos t) = -5 \\sin t $ 加速度：$ a = \\frac{dv}{dt} = \\frac{d}{dt}(-5 \\sin t) = -5 \\cos t$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:4:3","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"其他基本三角函数的导数 因为 $ \\sin x $ 和 $ \\cos x $ 都是 x 的可微函数，所以有关的函数： $$ \\begin{align*} \\tan x \u0026= \\frac{\\sin x}{\\cos x} \\quad \\cot x = \\frac{\\cos x}{\\sin x} \\\\ \\\\ \\sec \u0026= \\frac{1}{\\cos x} \\quad \\csc x = \\frac{1}{\\sin x} \\end{align*} $$ 在他们有定义的每个 x 值处都是可微的，利用商法则计算得到的他们的导数，由下面的公式给出： $$ \\begin{align*} \\frac{d}{dx}(\\tan x) = \\sec^2 x \\\\ \\\\ \\frac{d}{dx}(\\sec x) = \\sec x \\tan x \\\\ \\\\ \\frac{d}{dx}(\\cot x) = - \\csc^2 x \\\\ \\\\ \\frac{d}{dx}(\\csc x) = - \\csc x \\cot x \\end{align*} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:4:4","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"三角函数的连续性 因为六个基本三角函数在其定义域上都是可微的，所以他们在其定义域上都是连续的 除 x 是 $ \\pi / 2 $ 的非零整数倍外 $ \\sec x $ 和 $ \\tan x $都是连续的，除 x 是 $ \\pi $ 的整数倍外 csc x 和 cot x 都是连续的 对每个函数，当 $ f(c) $ 有定义时有 $ \\displaystyle \\lim_{x \\to c} f(x) = f(c) $，因此，我们可以用直接代入法来计算三角函数的许多代数组合和复合函数的极限 例题（求三角函数的极限） $$ \\lim_{x \\to 0} \\frac{\\sqrt{2 + \\sec x}}{\\cos (\\pi - \\tan x)} = \\frac{\\sqrt{2 + \\sec 0}}{\\cos (\\pi - \\tan 0)} = \\frac{\\sqrt{2 + 1}}{\\cos (\\pi - 0)} = \\frac{\\sqrt{3}}{-1} = -\\sqrt{3} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:4:5","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"链式法则 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:5:0","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"复合函数的导数 1. 定理：链式法则 如果 $ f(u) $在点 $ u = g(x) $ 可微 而 $ g(x) $ 在 x 可微, 那么复合函数 $ (f \\circ g)(x) = f(g(x))在 x 可微 $，而且： $$ (f \\circ g)’(x) = f’(g(x)) \\cdot g’(x) $$ 用 Leibniz 的记号，如果 $ y = f(u) $ 而 $ u = g(x) $，那么： $$ \\frac{dy}{dx} = \\frac{dy}{du} \\cdot \\frac{du}{dx} $$ 其中 $ \\frac{dy}{du} $是在 $ u = g(x) $处取值 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:5:1","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"外面 - 里面 法则 用以下方式来想链式法则有时是会有助益的：如果 $ y = f(g(x)) $，那么： $$ \\frac{dy}{dx} = f’(g(x)) \\cdot g’(x) $$ 用文字表述就是对 外面的函数 $f$ 求导并单独在 里面的函数 $ g(x) $处取值，然后乘上里面函数的导数 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:5:2","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"累次应用链式法则 为求导数我们有时候要应用链式法则二次或多次 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:5:3","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"参数化曲线的斜率 dy/dx 的参数公式 如果三个导数都存在，且 $dx/dt \\neq 0$，那么： $$ \\frac{dy}{dx} = \\frac{dy/dt}{dx/dt} $$ $ d^2y / dx^2 $ 的参数公式 如果方程 $x = f(t)$，$y = g(t) $ 定义 y 作为 x 的二次可微函数，那么在 $ dx / dt \\neq 0 $的地方 $$ \\frac{d^2 y}{dx^2} = \\frac{dy’/dt}{dx/dt} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:5:4","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"幂链式法则 如果 $f$ 是 u 的可微函数，又若 u 是 x 的可微函数，那么把 $ y = f(u) $代入链式法则公式： $$ \\frac{dy}{dx} = \\frac{dy}{du} \\cdot \\frac{du}{dx} $$ 就导致公式： $$ \\frac{d}{dx}f(u) = f’(u) \\frac{du}{dx} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:5:5","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"隐函数微分法 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:6:0","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"隐式定义的函数 方程 $ x^3 + y^3 - 9xy = 0 $ 的图形在几乎每一点都有明确定义的斜率，因为它是除原点和点 A 外都可微的函数 $ y = f_1(x) $，$ y = f_2(x) $，$ y = f_3(x) $ 的联合。 当我们不能很方便的解出这些函数时我们该怎么样求斜率呢？ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:6:1","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"隐函数求导的四个步骤 把 y 作为 x 的可微函数处理，方程两边对 x 求导数 对 dy / dx 并项到等式的一边 提出因子 dy / dx 解出 dy / dx ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:6:2","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"高阶导数 隐函数微分法也可以用来求高阶导数 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:6:3","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"可微函数的有理幂 如果 n 是一有理数，那么在 $ x^{n-1} $ 的定义域的每个内点处 x^n 是可微的，而且： $$ \\frac{d}{dx}x^n = nx^{n-1} $$ ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:6:4","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"相关变化率 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:7:0","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"相关变化率方程 用另一个你能求得的速率来求出一个你不容易求得其速率的问题称为相关变化率问题 求解方法 画一个图并给变量和常数命名。用 t 表示时间。假设所有的变量都是 t 的可微函数 记下数值信息（利用你所选的记号） 写下要你求的东西（通常是用导数表示的变化率） 写出把变量联系起来的方程。你可能要把两个或者多个方程结合成你要求其变化率的变量和你已经知道其变化率的变量联系起来的单个方程 求关于 t 的导数，然后把你要求的变化率用你已知其值的变化率和变量表示出来 求值。利用已经知道的值去求待求的变化率的值 ","date":"2025-09-04","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/:7:1","tags":["微积分"],"title":"微积分 - 导数","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%AF%BC%E6%95%B0/"},{"categories":["微积分"],"content":"微积分的极限和连续","date":"2025-08-19","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/","tags":["微积分"],"title":"微积分 - 极限和连续 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"平均变化率 - 习题 在题 1 - 4中，求给定区间上函数的平均变化率 $ f(x) = x^3 + 1 $ [2, 3] $$ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{(3^3 + 1) - (2^3 + 1)}{3 - 2} = 3 $$ [-1, 1] $$ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{(1^3 + 1) - ((-1)^3 + 1)}{1 - (-1)} = 1 $$ $ R(\\theta) = \\sqrt{4 \\theta + 1} $ [0, 2] $$ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{(\\sqrt{4 \\cdot 2 + 1}) - (\\sqrt{4 \\cdot 0 + 1})}{2 - 0} = 1 $$ $ h(t) = \\cot t $ $ [ \\frac{\\pi}{4}, \\frac{3 \\pi}{4} ] $ $$ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{(\\cot \\frac{3 \\pi}{4}) - (\\cot \\frac{\\pi}{4})}{\\frac{3 \\pi}{4} - \\frac{\\pi}{4}} = \\frac{-2}{\\frac{\\pi}{2}} = -\\frac{4}{\\pi} $$ $ [\\frac{\\pi}{6}, \\frac{\\pi}{2}] $ $$ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{(\\cot \\frac{\\pi}{2}) - (\\cot \\frac{\\pi}{6})}{\\frac{\\pi}{2} - \\frac{\\pi}{6}} = \\frac{0 - \\sqrt{3}}{\\frac{2\\pi}{6}} = \\frac{-\\sqrt{3}}{\\frac{\\pi}{3}} = -\\sqrt{3} \\cdot \\frac{3}{\\pi} = -\\frac{3\\sqrt{3}}{\\pi} $$ $ g(t) = 2 + \\cos t $ $ [0, \\pi] $ $$ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{(2 + \\cos \\pi) - (2 + \\cos 0)}{\\pi - 0} = \\frac{-1 + 3}{\\pi} = -\\frac{2}{\\pi} $$ $ [-\\pi, \\pi] $ $$ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{(2 + \\cos \\pi) - (2 - \\cos \\pi)}{\\pi - (-\\pi)} = \\frac{1 - 1}{2\\pi} = \\frac{0}{2\\pi} = 0 $$ 福特马特眼镜蛇的汽车的速度 下图展示了1994 福特汽车从静止开始加速后的时间对距离的图形 估算割线 $ PQ_1, PQ_2, PQ_3 $ 和 $ PQ_4 $ 的斜率 $$ \\text{割线的斜率其实就是平均变化率，我在这只计算一个} PQ_1 \\\\ \\\\ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{650 - 220}{20 - 10} = \\frac{430}{10} = 43 $$ 估算该型号汽车在 $ t = 20 $秒的速度 我们可以通过观察割线斜率的趋势来估算这个值。当点 Q 越来越接近点 P 时，割线 PQ 的斜率会越来越接近点 P 处切线的斜率。 从图像上可以观察到，大约从 t=12 秒之后，图像变成了一条直线。这意味着汽车进入了匀速行驶阶段。对于一条直线，其上任意点的切线斜率都等于直线本身的斜率。 因此，我们可以确认，在 $ t = 20 $秒时，汽车的速度就是这段匀速阶段的速度。 结论：该型号汽车在 $ t = 20 $秒时的速度估算为 45 米/秒。 下落板钳的速度 估算割线 $ PQ_1, PQ_2, PQ_3 $ 和 $ PQ_4 $ 的斜率 $$ \\text{割线的斜率其实就是平均变化率，我在这只计算一个} PQ_1 \\\\ \\\\ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{80 - 20}{10 - 5} = \\frac{60}{5} = 12 $$ 当板钳在站顶时，他的下落速度有多快？ “在站顶时”指的是下落刚刚开始的时刻，即 t = 0 秒。 因此，当板钳在站顶时，他的下落速度是 0 米/秒。 球的速度 附表的数据给出了从斜面上滚下的球的距离，试着通过找速度的上，下界并求其平均来估算 $ t = 1 $ 时的瞬时速度。即：求 $ a \\leq v(1) \\leq b $ 然后估算 $ v(1) $ 为 $ \\frac{(a+b)}{2} $ $$ \\begin{gather*} \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{13.10 - 8.39}{1.0 - 0.8} = \\frac{4.71}{0.2} = 23.55 \\\\ \\\\ \\frac{\\Delta y}{\\Delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{18.87 - 13.10}{1.2 - 1.0} = \\frac{5.77}{0.2} = 28.85 \\\\ \\\\ v(1) = \\frac{(a+b)}{2} = \\frac{52.4}{2} = 26.2 \\end{gather*} $$ 火车行进的距离 一辆火车从静止加速到的最大缓慢巡行速度，然后以某个常速度行经一个城镇，经过该城镇后又加速到他缓慢巡行速度。最后，火车平稳的减速直到到达目的地时停下来，试着画一个火车的行进距离作为时间的函数的可能的图形 A：从静止加速到“缓慢巡行速度”（曲线向上、斜率逐渐变大） B：穿越城镇的匀速慢行（直线、斜率较小） C：驶出城镇后再次加速到更快的巡航（曲线向上、斜率继续变大） D：更高巡航速度的匀速段（直线、斜率更大） E：平稳减速至终点停下（曲线向上但逐渐变平，最后斜率为 0） 图中“斜率 = 速度”。加速段斜率随时间变大（凹向上），减速段斜率变小（凹向下），匀速段是直线。整条曲线单调递增、连续，在各阶段交界处可以有斜率的突变（理想化时也可光滑过渡）。 ","date":"2025-08-19","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:1:0","tags":["微积分"],"title":"微积分 - 极限和连续 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"对图形求极限 - 习题 对左下图的函数 $g(x)$，求下列极限，或者解释说为什么没有极限 $ \\displaystyle \\lim_{x \\to 1} g(x) $ 分析： 当 x 从左侧无限接近 1 时 $ (x→1^⁻) $，函数 $ g(x) $ 的值从图像上看趋近于 1。所以左极限是 1。 当 x 从右侧无限接近 1 时 $ (x→1^⁺) $，函数 $ g(x) $ 的值也趋近于 1。所以右极限是 1。 结论： 因为左极限和右极限相等，所以该点的极限存在。 答案： $ \\displaystyle \\lim_{x \\to 1} g(x) = 1 $ $ \\displaystyle \\lim_{x \\to 2} g(x) $ 分析： 当 x 从左侧无限接近 2 时 $ (x→2^⁻) $，函数 $ g(x) $ 的值趋近于 1。所以左极限是 1 当 x 从右侧无限接近 2 时 $ (x→2^⁺) $，函数 $ g(x) $ 的值也趋近于 1。所以右极限是 1。 结论： 因为左极限和右极限相等，所以该点的极限存在。 答案： $ \\displaystyle \\lim_{x \\to 2} g(x) = 1 $ $ \\displaystyle \\lim_{x \\to 3} g(x) $ 分析： 当 x 从左侧无限接近 3 时 $ (x→3^⁻) $，函数 $ g(x) $ 的值趋近于 0。所以左极限是 0。 当 x 从右侧无限接近 3 时 $ (x→3^⁺) $，函数 $ g(x) $ 的值也趋近于 0。所以右极限是 0。 结论： 因为左极限和右极限相等，所以该点的极限存在。 答案： $ \\displaystyle \\lim_{x \\to 3} g(x) = 0 $ 对于图片的函数 $ f(x) $，求下列极限，或结束为什么没有极限 $ \\displaystyle \\lim_{t \\to -2} f(t) $ 分析： 当 t 从左侧无限接近 -2 时 $ (t→-2^⁻) $，函数 $ f(t) $ 的值趋近于 0。所以左极限是 0。 当 t 从右侧无限接近 -2 时 $ (t→-2^⁺) $，函数 $ f(t) $ 的值也趋近于 0。所以右极限是 0。 结论： 因为左极限和右极限相等，所以该点的极限存在。 答案： $ \\displaystyle \\lim_{t \\to -2} f(t) = 0 $ $ \\displaystyle \\lim_{t \\to -1} f(t) $ 分析： 当 t 从左侧无限接近 -1 时 $ (t→-1^⁻) $，函数 $ f(t) $ 的值趋近于 -1。所以左极限是 -1。 当 t 从右侧无限接近 -1 时 $ (t→-1^⁺) $，函数 $ f(t) $ 的值也趋近于 -1。所以右极限是 -1。 结论： 因为左极限和右极限相等，所以该点的极限存在。 答案： $ \\displaystyle \\lim_{t \\to -1} f(t) = -1 $ $ \\displaystyle \\lim_{t \\to 0} f(t) $ 分析： 当 t 从左侧无限接近 0 时 $ (t→0^⁻) $，函数 $ f(t) $ 的值趋近于 -1。所以左极限是 -1。 当 t 从右侧无限接近 0 时 $ (t→0^⁺) $，函数 $ f(t) $ 的值趋近于 1。所以右极限是 1。 结论： 因为左极限 (-1) 不等于右极限 (1)，所以该点的极限不存在。 答案： 极限不存在 ","date":"2025-08-19","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:2:0","tags":["微积分"],"title":"微积分 - 极限和连续 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"从图形估计极限 - 习题 在题 1 - 6 中，利用图形来估算函数的极限，或解释为什么极限不存在 $ \\displaystyle \\lim_{x \\to 3^-} f(x) $ 分析： 当 x 从左侧无限接近 3 时 $ (x \\to 3^⁻) $，函数 $ f(x) $ 的值趋近于 3。所以左极限是 3。 答案： $ \\displaystyle \\lim_{x \\to 3^-} f(x) = 3 $ $ \\displaystyle \\lim_{x \\to 3^+} f(x) $ 分析： 当 x 从右侧无限接近 3 时 $ (x \\to 3^+) $，函数 $ f(x) $ 的值趋近于 -2。所以右极限是 -2。 答案： $ \\displaystyle \\lim_{x \\to 3^+} f(x) = -2 $ $ \\displaystyle \\lim_{x \\to 3} f(x) $ 分析： 当 x 从左侧无限接近 3 时 $ (x \\to 3^⁻) $，函数 $ f(x) $ 的值趋近于 3。所以左极限是 3。 当 x 从右侧无限接近 3 时 $ (x \\to 3^+) $，函数 $ f(x) $ 的值趋近于 -2。所以右极限是 -2。 答案： 因为左极限跟右极限不一样，所以极限不存在 $ f(3) $ 分析： 我们观察图像，在 x=3 的位置，有一个实心点，这个点对应的 y 值是 1（注意：极限值与函数在该点是否有定义或取值是多少没有必然联系） 答案： $ f(3) = 1 $ $ \\displaystyle \\lim_{ t \\to (-4)^-} g(t) $ 分析： 当 t 从左侧无限接近 -4 时 $ (t \\to -4^⁻) $，函数 $ g(t) $ 的值趋近于 5。所以左极限是 5。 答案： $ \\displaystyle \\lim_{ t \\to (-4)^-} g(t) = 5 $ $ \\displaystyle \\lim_{t \\to (-4)^+} g(t) $ 分析： 当 t 从右侧无限接近 -4 时 $ (t \\to -4^+) $，函数 $ g(t) $ 的值趋近于 5。所以右极限是 5。 答案： $ \\displaystyle \\lim_{ t \\to (-4)^+} g(t) = 5 $ $ \\displaystyle \\lim_{t \\to -4} g(t) $ 分析： 当 t 从左侧无限接近 -4 时 $ (t \\to -4^⁻) $，函数 $ g(t) $ 的值趋近于 5。所以左极限是 5。 当 t 从右侧无限接近 -4 时 $ (t \\to -4^+) $，函数 $ g(t) $ 的值趋近于 5。所以右极限是 5。 答案： $ \\displaystyle \\lim_{t \\to -4} g(t) = 5 $ $ g(-4) $ 分析： 我们观察图像，在 t=-4 的位置，有一个实心点，这个点对应的 y 值是 2（注意：极限值与函数在该点是否有定义或取值是多少没有必然联系） 答案： $ g(-4) = 2 $ ","date":"2025-08-19","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:3:0","tags":["微积分"],"title":"微积分 - 极限和连续 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"运用极限法则 - 习题 假设 $ \\displaystyle \\lim_{x \\to 0} f(x) = 1$ 和 $ \\displaystyle \\lim_{x \\to 0} g(x) = 5$，写出下面计算中步骤（a）（b）（c）中用得到的定理1中法则的名称 $$ \\displaystyle \\lim_{x \\to 0} f(x) = 1 和 \\displaystyle \\lim_{x \\to 0} g(x) = 5 $$ （a）商法则 （b）幂法则 （c）积法则 设 $ \\displaystyle \\lim_{x \\to 1}h(x) = 5, \\lim_{x \\to 1}p(x) = 1,\\lim_{x \\to 1}r(x) = -2 $ 写出下面计算中步骤（a）（b）（c）中用到的定理1中法则的名称 $$ \\displaystyle \\lim_{x \\to 1}h(x) = 5, \\lim_{x \\to 1}p(x) = 1,\\lim_{x \\to 1}r(x) = -2 $$ （a）商法则 （b）幂法则 （c）积法则 假设 $ \\displaystyle \\lim_{x \\to c} f(x) = 5 $ 以及 $ \\displaystyle \\lim_{x \\to c} g(x) = -2 $求： $ \\displaystyle \\lim_{x \\to c} f(x) g(x) $ $$ \\begin{gather*} \\displaystyle \\lim_{x \\to c} f(x) g(x) = 5 (-2) = -10 \\end{gather*} $$ $ \\displaystyle \\lim_{x \\to c} 2 f(x) g(x) $ $$ \\begin{gather*} \\displaystyle \\lim_{x \\to c} 2 f(x) g(x) = (2 \\cdot 5) (-2) = 10 \\cdot (-2) = -20 \\end{gather*} $$ $ \\displaystyle \\lim_{x \\to c} (f(x) + 3g(x)) $ $$ \\begin{gather*} \\displaystyle \\lim_{x \\to c} (f(x) + 3g(x)) = (5 + 3(-2)) = 5 - 6 = -1 \\end{gather*} $$ $ \\displaystyle \\lim_{x \\to c} \\frac{f(x)}{f(x) - g(x)} $ $$ \\displaystyle \\lim_{x \\to c} \\frac{f(x)}{f(x) - g(x)} = \\frac{5}{5 - (-2)} = \\frac{5}{7} $$ 假设 $ \\displaystyle \\lim_{x \\to c} f(x) = 0 $ 以及 $ \\displaystyle \\lim_{x \\to c} g(x) = -3 $求： $ \\displaystyle \\lim_{x \\to 4} (g(x) + 3) $ $ \\displaystyle \\lim_{x \\to 4} f(x) $ $ \\displaystyle \\lim_{x \\to 4} (g(x))^2 $ $ \\displaystyle \\lim_{x \\to 4} \\frac{g(x)}{f(x) - 1} $ ","date":"2025-08-19","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:4:0","tags":["微积分"],"title":"微积分 - 极限和连续 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"极限计算 - 习题 求 题 11 - 14 中的极限 $ \\displaystyle \\lim_{x \\to -7} (2x + 5) $ $ \\displaystyle \\lim_{x \\to 6} 8(t - 5)(t - 7) $ $ \\displaystyle \\lim_{x \\to 2} \\frac{y + 2}{y ^2 + 5y + 6} $ $ \\displaystyle \\lim_{h \\to 0} \\frac{3}{\\sqrt{3h + 1} + 1} $ $ \\displaystyle \\lim_{r \\to -2}(r^3 - 2r^2 + 4r + 8) $ $ \\displaystyle \\lim_{x \\to 2} \\frac{x + 3}{x + 6} $ $ \\displaystyle \\lim_{t \\to -3} (5 - y)^{\\frac{4}{3}} $ $ \\displaystyle \\lim_{\\theta - 5} \\frac{\\theta - 5}{\\theta^2 - 25} $ ","date":"2025-08-19","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:5:0","tags":["微积分"],"title":"微积分 - 极限和连续 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"微积分的极限和连续","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"变化律和极限 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:1:0","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"平均和瞬时速度 定义： 运动物体在一段时间区间上的平均速度是通过物体走过的距离除以所用的事件来求得的 例题1（求平均速度） 一块岩石突然松动从峭壁顶上掉下来、掉下来的头2秒中岩石的平均速度是多少? 解:实验表明一块致密的固体在地球表面附近从静止状态自由落下,下落的头秒中下落的英尺数为： $$ y = 16t^2 $$ 在任何给定时间区间上岩石的平均速度是所走过的距离 $ \\Delta y $ 除以时间区间的长度 $ \\Delta t$，从 t = 0 到 t = 2 的头 2 秒的下落平均速度为： $$ \\frac{\\Delta y}{\\Delta t} = \\frac{16(2)^2 - 16(0)^2}{2 - 0} = 32 英尺/秒 $$ 例题2（求瞬时速度） 求例题1中岩石在时刻 $ t = 2 $ 的速度 我们可以计算从 $ t = 2 $ 到任何稍后一点的时间 $ t = 2 + h, h \\geq 0 $ 的区间上的平均速度： $$ \\frac{\\Delta y}{\\Delta t} = \\frac{16(2 + h)^2 - 16(h)^2}{h} $$ 但是我们不能用该公式来计算在确切时刻 $ t = 2 $ 的速度，因为 这要求 $ h = 0 $，这样这个公式就无意义 我们可以计算 h 无限接近等于 0 的情况，当 h 趋于 0 的时候，平均速度趋于极限值 64英尺 / 秒 $$ \\frac{\\Delta y}{\\Delta t} = \\frac{16(2 + h)^2 - 16(h)^2}{h} = \\frac{16(4+4h+h^2) - 64}{h} = \\frac{64h + 16h^2}{h} = 64 + 16h $$ ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:1:1","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"平均变化率和割线 定义（平均变化率） $ y = f(x) $ 关于 x 在区间 $ [x_1, x_2] $ 上的平均变化率是： $$ \\frac{\\Delta{y}}{\\Delta{x}} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} = \\frac{(x_1 + h) - f(x_1)}{h}, \\quad h \\neq 0 $$ 注意，几何上，平均变化率就是割线的斜率 定义（割线） 几何上，连接曲线上两点的直线就是该曲线的割线，因此，$ f $ 从 $ x_1 $ 到 $ x_2 $ 的平均变化率就是割线的斜率 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:1:2","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"函数的极限 定义（极限的非正式定义） 设 $ f(x) $ 除了可能在点 $ x_0 $ 没有定义外，在 $ x_ 0 $ 的一个开区间上均有定义，如果对充分靠近 $ x_0 $ 的 $x$，$ f(x) $ 能任意靠近 L ，那么我们就说当 x 趋于 $ x_0 $时，$ f $ 趋于 极限 L，并记作： $$ \\lim_{x \\to x_0} f(x) = L $$ 这个定义是非正式的，因为像 充分靠近 这些说法都是不确切的；比如对于研究遥远银河系的天文学家，靠近可能就意味着几千光年以内。但是这个定义是足够清楚的，能使我们识别和计算许多特定函数的极限 定义（极限的精确定义） 设 $ f(x) $ 定义在 $ x_0 $ 的一个可能不包括 $x_0$ 的开区间上，我们说当 x 趋于 $x_0$ 时 $f(x)$ 趋于极限L，并记为： $$ \\lim_{x \\to x_0} f(x) = L $$ 如果，对任何数 $ \\varepsilon \u003e 0 $，存在相应的数 $ \\delta \u003e 0 $使得对所有满足 $ 0 \u003c \\mid x - x_0 \\mid \u003c \\delta $的 x，有： $$ \\mid f(x)-L \\mid \u003c \\varepsilon $$ 为说明 $ x \\to x_0 $ 时 $ f(x) $ 的极限等于 数L，我们要证明：如果 $ x $ 充分接近 $ x_0 $，那么就可以使 $ f(x) $ 和 L 之间的差距 要有多小就有多小，如果我们规定了$ f(x) $ 和 L 之间的差距，我们来看看对 x 的要求是什么 例题 8 （控制线性函数） 为确保输出 $ y = 2x - 1 $ 位于 $ y_0 = 7 $ 的 2个单位的范围内，输入x应该靠 $ x_0 = 4 $ 有多近？ 解：问我们的是：对什么样的 x值有 $ \\mid y - 7 \\mid \u003c 2 $? 为求得答案，我们首先用 x 表示 $ \\mid y - 7 \\mid $ $$ \\mid y - 7 \\mid = \\mid (2x - 1) -7 \\mid = \\mid 2x - 8 \\mid $$ 于是问题变成：什么样的 x值满足 $ \\mid 2x - 8 \\mid \u003c 2 $?，为求出这些 x，我们解不等式： $$ \\begin{gather*} \\mid 2x - 8 \\mid \u003c 2 \\\\ \\\\ -2 \u003c 2x - 8 \u003c 2 \\\\ \\\\ 6 \u003c 2x \u003c 10 \\\\ \\\\ 3 \u003c 2x \u003c 5 \\\\ \\\\ -1 \u003c x - 4 \u003c 1 \\end{gather*} $$ 故：使 x 保持和 $ x_0 = 4 $ 相距一个单位的距离就能使 y 保持在和 $ y_0 = 7 $ 相距 2个单位的距离内 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:1:3","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"求极限和单侧极限 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:2:0","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"极限性质 极限法则 如果 L，M，c 和 k 都是实数，且： $$ \\lim_{x \\to c} f(x) = L \\quad 和 \\quad \\lim_{x \\to c} g(x) = M $$ 和法则 两个函数之和的极限等于他们的极限之和 $$ \\lim_{x \\to c}(f(x) + g(x)) = L + M $$ 差法则 两个函数之差的极限等于他们的极限之差 $$ \\lim_{x \\to c}(f(x) - g(x)) = L -M $$ 积法则 两个函数之积的极限等于他们的极限之积 $$ \\lim_{x \\to c}(f(x) \\cdot g(x)) = L \\cdot M $$ 乘常数法则 常数乘一个函数后的极限等于该常数乘该函数的极限 $$ \\lim_{x \\to c} (k \\cdot f(x)) = k \\cdot L $$ 商法则 两个函数之商的极限等于他们的极限之商，如果分母的极限不为零 $$ \\lim_{x \\to c} \\frac{f(x)}{g(x)} = \\frac{L}{M}，\\quad m \\neq 0 $$ 幂法则 如果 r 和 s 都是整数，并且 $ s \\neq 0 $，那么： $$ \\lim_{x \\to c} (f(x))^{\\frac{r}{s}} = L^{\\frac{r}{s}} $$ 只要 $ L^{\\frac{r}{s}} $ 是实数，函数的有理幂的极限等于该函数极限的同样的幂，如果后者是实数 可用代入法求多项式的极限 如果 $ P(x) = a_{n}x^{n}+a_{n-1}x^{n-1}+\\cdots+a_{0} $，那么： $$ \\lim_{x \\to c} P(x) = P(c) = a_n c^n + a_{n-1} c^{n-1} + \\cdots + a_0 $$ 可用代入法求有理数的极限，如果分母的极限不等于零 如果 $ P(x) $ 和 $ P(Q) $ 都是多项式且 $ Q(c) \\neq 0 $，那么： $$ \\lim_{x \\to -1} \\frac{x^3 + 4x^2 - 3}{x^2 + 5} = \\frac{(-1)^3 + 4(-1)^2 - 3}{(-1)^2 + 5} = \\frac{0}{6} = 0 $$ ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:2:1","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"代数地消去零分母 仅当有理函数的分母在极限点 c 处不为零时才能应用定理 （可用代入法求有理数的极限，如果分母的极限不等于零）。如果分母为 0，消去分子和分母的公因子可能会把公式化为分母在 c 处不再为零的分式。 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:2:2","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"三明治（夹逼）定理 如果我们不能直接求极限，我们可以用三明治（夹逼）定理间接地求极限。该定理适用于函数 $f$ 的值夹在另外两个函数 g 和 h 之间，如果 $ x \\to c $ 时，g和h有相同的极限，那么 $f$ 也有同样的极限 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:2:3","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"单侧极限 定义（双侧极限） 为使 $ x \\to a $ 时有极限L，函数 $f$ 必须在 a 的双侧有定义，而且当 x从a 的双侧趋于 a 的时候函数值 $f(x)$ 必须趋于L，正因为这点，通常的极限都是双侧极限 定义（单侧极限） 如果在 a 双侧极限不存在，仍有可能存在单侧极限，即只是从单侧趋向的极限；如果是从右侧趋向，该极限就是右侧极限了；如果是从左侧趋向，该极限就是左侧极限 设 $ f(x) $ 定义在 (a, b) 上，$ a \u003c b $。如果当 x 在区间(a, b) 内趋于 a 时 $f(x)$ 任意接近地趋于 L，那么我们就说 $f$ 在 a有右侧极限，并记作： $$ \\lim_{x \\to a^+} f(x) = L $$ 设 $ f(x) $ 定义在 (c, a) 上，$ c \u003c a $。如果当 x 在区间(c, a) 内趋于 a 时 $f(x)$ 任意接近地趋于 M，那么我们就说 $f$ 在 a有左侧极限，并记作： $$ \\lim_{x \\to a^-} f(x) = M $$ 定理（单侧极限和双侧极限之间的关系） 当 $ x \\to c $ 时函数 $ f(x) $ 有极限当且仅当 $ f $ 的左侧极限和右侧极限存在且相等： $$ \\lim_{x \\to c} f(x) = L \\iff \\lim_{x \\to c^-} f(x) = L \\quad 且 \\quad \\lim_{x \\to c^+} f(x) = L $$ ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:2:4","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"有关 $ (\\sin \\theta) / \\theta $ 的极限 定理（有关$ (\\sin \\theta) / \\theta $ 的最重要的事实就是在弧度度量下 当 $ x \\to 0 $ 时其极限为 1） $$ \\lim_{\\theta \\to 0} \\frac{\\sin \\theta}{\\theta} = 1 \\quad （\\theta \\text{为弧度}） $$ ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:2:5","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"与无穷有关的极限 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:3:0","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"$ x \\to \\pm \\infty $ 时的有限极限 我们说 x 趋于无穷时 $ f(x) $ 有极限 L 并记作 $$ \\lim_{x \\to \\infty} f(x) = L $$ 如果当 x 沿正向离开原点越来越远时，$f(x)$ 任意接近 L 我们说 x 趋于负无穷时 $f(x)$有极限 L 并记作 $$ \\lim_{x \\to -\\infty} f(x) = L $$ 如果当 x 沿负向离开原点越来越远时，$f(x)$ 任意接近 L $ x \\to \\pm \\infty $ 极限法则 如果 L，M 和 k 都是实数，且 $$ \\lim_{x \\to \\pm \\infty} f(x) = L\\quad 和 \\quad \\lim_{x \\to \\pm \\infty} g(x) = M \\quad 那么： $$ 和法则 $$ \\lim_{x \\to \\pm \\infty}(f(x) + g(x)) = L + M $$ 差法则 $$ \\lim_{x \\to \\pm \\infty}(f(x) - g(x)) = L - M $$ 积法则 $$ \\lim_{x \\to \\pm \\infty}(f(x) \\cdot g(x)) = L \\cdot M $$ 常乘数法则 $$ \\lim_{x \\to \\pm \\infty}(k \\cdot f(x)) = k \\cdot L $$ 商法则 $$ \\lim_{x \\to \\pm \\infty} \\frac{f(x)}{g(x)} = \\frac{L}{M} \\quad M \\neq 0 $$ 幂法则：如果 r 和 s 都是整数，并且 $s \\neq 0$ 则： $$ \\lim_{x \\to \\pm \\infty} (f(x))^{r/s} = L^{r/s} $$ ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:3:1","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"$ x \\to \\pm \\infty $ 时有理函数的极限 为 $ x \\to \\pm \\infty $ 时确定有理函数的极限，分子和分母可以同除以分母中 x 的最高幂次，结果如何取决于有关多项式的次 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:3:2","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"水平和垂直渐近线：无穷极限 直线 y = b 是 函数 $ y = f(x) $ 图形的水平渐近线，如果有： $$ \\lim_{x \\to \\infty} f(x) = b \\quad 或 \\quad \\lim_{x \\to -\\infty} f(x) = b $$ 直线 x = a 是该图形的垂直渐近线，如果有： $$ \\lim_{x \\to a^+} f(x) = \\pm \\infty \\quad 或 \\quad \\lim_{x \\to a^-} f(x) = \\pm \\infty $$ 例题（求渐近线） $$ 求 \\quad y = \\frac{x + 3}{x + 2} \\quad 的渐近线 $$ 解： 我们对 $ x \\to \\pm \\infty $ 和 $ x \\to -2$(x = -2时分母为零)的形态感兴趣 如果我们通过(x + 2)除(x+3) 把一个有理函数重写为一个多项式加上余项，那么渐近线很快就显现出来了 结果是可把 y 重写为 $$ y = 1 + \\frac{1}{x + 2} $$ 那么我们就知道该曲线是由 $ y = 1/x $的图形往上平移1单位并向左边平移2单位得到的 现在的渐近线不是坐标轴而是直线 y = 1 和 x = -2 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:3:3","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"在论三明治（夹逼）定理 对于 $ x \\to \\pm \\infty $ 时极限的三明治（夹逼）定理也是成立的 例题（求 x 趋于 0 或者 $ \\pm \\infty $时的极限） 运用三明治（夹逼）定理求曲线的渐近线 $$ y = 2 + \\frac{\\sin{x}}{x} $$ 解： 我们对 $ x \\to \\pm \\infty $ 和 $ x \\to 0 $(分母为0)时函数的性态感兴趣 $ x \\to 0 $时的性态，我们知道 $ \\lim_{x \\to 0} (\\sin x)/x = 1 $，所以再原点没有渐近线 $ x \\to \\pm \\infty $时的形态，因为 $ 0 \\leq | \\frac{\\sin x}{x} | \\leq | \\frac{1}{x} |$，以及 $ \\displaystyle \\lim_{x \\to \\pm \\infty} | 1 /x | = 0 $，再有三明治（夹逼）定理我们有 $ \\displaystyle \\lim_{x \\to \\pm \\infty} (\\sin x) / x = 0 $，因此： $$ \\lim_{x \\to \\pm \\infty} (2 + \\frac{\\sin x}{x}) = 2 + 0 = 2 $$ 而直线 $ y = 2 $ 从左侧和右侧都是该曲线的渐近线 这个例子说明曲线可以跨过他的一条渐近线，也许是跨过许多次 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:3:4","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"无穷极限的精确定义 我们说 x 趋于 $ x_0 $ 时 $ f(x) $趋于无穷，并记作： $$ \\lim_{x \\to x_0} f(x) = \\infty $$ 如果对任何正实数 B存在相应的 $ \\delta \u003e 0 $，使得对一切满足 $ 0 \u003c | x - x_0| \u003c \\delta $ 的 x，有 $ f(x) \u003e B $ *我们说 x趋于$ x_0 $ 时 $ f(x) $趋于负无穷，并记作： $$ \\lim_{x \\to x_0} f(x) = -\\infty $$ 如果对任何负实数 -B存在相应的 $ \\delta \u003e 0 $，使得对一切满足 $ 0 \u003c | x - x_0| \u003c \\delta $ 的 x，有 $ f(x) \u003c -B $ 在 $ x_0 $ 的单侧无穷极限的精确定义是类似的 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:3:5","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"终极性态模型和斜渐近线 对于数值很大的 x，我们有时候可以对复杂函数的性态用一个实际上以同样方式起作用的较为简单的函数作为该复杂函数的模型 函数 g 是： $f$的右侧终极性态模型，当且仅当： $$ \\lim_{x \\to \\infty} \\frac{f(x)}{g(x)} = 1 $$ $f$的左侧终极性态模型，当且仅当： $$ \\lim_{x \\to -\\infty} \\frac{f(x)}{g(x)} = 1 $$ 函数的右侧，左侧终极性态模型不必是同一个函数 例题（求终极性态模型） 设 $ f(x) = x + e^{-x} $，试着证明 $ g(x) = x $是$ f $ 的右侧终极模型，而 $ h(x) = e^{-x} $ 是 $ f $ 的左侧终极模型 解： 在右边： $$ \\begin{gather*} \\lim_{x \\to \\infty} \\frac{f(x)}{g(x)} = \\lim_{x \\to \\infty} \\frac{x + e^{-3}}{x} = \\lim_{x \\to \\infty}(1 + \\frac{e^{-x}}{x}) = 1 \\\\ \\\\ 因为 \\lim_{x \\to \\infty} \\frac{e^{-x}}{x} = 0 \\end{gather*} $$ 在左边： $$ \\begin{gather*} \\lim_{x \\to -\\infty} \\frac{f(x)}{g(x)} = \\lim_{x \\to -\\infty} \\frac{x + e^-x}{-x} = \\lim_{x \\to -\\infty} (\\frac{x}{e^{-x}} + 1) = 1 \\\\ \\\\ 因为 \\lim_{x \\to -\\infty} \\frac{x}{e^{-x}} = 0 \\end{gather*} $$ 斜渐进线 有些情形，比如上面例题（求终极性态模型）我们求得有理函数的终极性态模型，如果分子的次比分母的次大1，那么有理函数$ f(x) $的图形就有一条，斜渐近线 我们可以通过分子除以分母把 $f$表为一个线性函数再加上一项当 $ x \\to \\pm \\infty $时趋于0的余项来求得渐近线的方程 例题（求一条斜渐近线） 求下面函数图形的斜渐近线： $$ f(x) = \\frac{2x^2 - 3}{7x + 4} $$ 解： 由长除法，我们得知： $$ \\begin{align*} f(x) \u0026= \\frac{2x^{2}+3}{7x+4} \\\\ \\\\ \u0026=\\underbrace{(\\frac{2}{7}x-\\frac{8}{49})}_{\\text{线性函数}g(x)}+\\underbrace{\\frac{-115}{49(7x+4)}}_{\\text{余项}} \\end{align*} $$ 当 $x \\to \\pm \\infty $时，给出 $ f $ 和 $ g $ 的图形间的垂直距离的余项趋于零，就使得（倾斜的）直线 $$ g(x) = \\frac{2}{7}x - \\frac{8}{49} $$ 成为 $ f $的图形的渐近线。函数 $g$ 是 $f$ 的右侧终极模型 也是 $ f $ 的左侧终极模型 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:3:6","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"连续性 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:4:0","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"在一点的连续性 内点： 函数 $ f(x) $ 在其定义域的内点 c 处是连续的，如果： $$ \\lim_{x \\to c} f(x) = f(c) $$ 端点： 函数 $ f(x) $在其定义域的左端点 a 或者 右端点 b 是连续的，如果分别有： $$ \\lim_{x \\to a^+} f(x) = f(a) \\quad 或 \\quad \\lim_{x \\to b^-} f(x) = f(b) $$ 如果函数 $ f $ 在点 c 处不是连续的，我们就说 $ f $ 在 c 间断，而 c 是 $ f $ 的一个间断点。注意 c 不必在 $ f $ 的定义域中 函数 $ f $ 在其定义域的点 x = c 是右连续（从右侧连续）的，如果 $ \\lim_{x \\to c^+} f(x) = f(c) $ 如果 $ \\lim_{x \\to c^-} f(x) = f(c) $，则 $f$ 在 c 是左连续的 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:4:1","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"连续性检验 函数 $ f(x) $在 x = c 连续，当且仅当它满足一下条件： $ f(c) $存在 （c 在 $f$ 的定义域中） $ \\displaystyle \\lim_{x \\to c} f(x) $存在 （当 $ x \\to c $时$f$有极限） $ \\displaystyle \\lim_{x \\to c} f(x) = f(c)$ （极限等于函数值） ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:4:2","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"连续函数 函数在一个区间上连续当且仅当它在该区间的每一点连续。连续函数是在其定义域中每一点连续的函数 连续函数不一定在所有可能的区间上连续 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:4:3","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"代数组合 连续函数的代数组合，当他们有定义的时候，是连续的 连续函数的性质： 如果函数 $f$ 和 $g$ 在 x = c 连续，那么下列 $ f $ 和 $ g $的组合在 x = c 都是连续的 和：$ f + g $ 差：$ f - g $ 积：$ f \\cdot g $ 乘常数：$ k \\cdot f $，对任何数 k 商：$ \\frac{f}{g} $，倘若 $ g(c) \\neq 0 $ ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:4:4","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"复合函数 连续函数的复合函数是连续函数，因此像： $$ y = \\sin(x^2) \\quad 和 \\quad y = | \\cos x | $$ 如果 $ f $在 c 连续，而 g 在 $ f(c) $ 连续，那么复合函数 $ g \\circ f $ 在 c 连续 例题（运用此定理） 说明下面函数是连续函数： $$ y = \\mid \\frac{x \\sin x}{x^2 + 2} \\mid $$ 解： $ y = \\mid x \\sin x / x^2 + 2 \\mid $ 的图形 揭示该函数在每个 x 值处连续，令： $$ g(x) = \\mid x \\mid \\quad 和 \\quad f(x) = \\mid \\frac{x \\sin x}{x^2 + 2} \\mid $$ ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:4:5","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"连续函数的中间值定理 在闭区间 [a, b] 上连续的函数一定取到 $f(a)$ 和 $f(b)$ 之间的每一个值 换言之，如果$y_0$是 $f(a)$和$f(b)$之间的任何值，那么 $y_0 = f(c)$ 对 [a, b]中的某个 c 成立 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:4:6","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"切线 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:5:0","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"什么是曲线的切线 从我们能计算的东西开始，即割线PQ的斜率 研究当点 Q 沿着曲线趋于点 P 时割线的极限 如果极限存在，就把他取做曲线在点 P 的斜率，并把过点 P 具有这个斜率的直线定义为曲线在点 P 的切线 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:5:1","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"求函数图形的切线 定义： 曲线 $ y = f(x) $在点 P (x_0, f(x_0)) 的斜率是： $$ m = \\lim_{h \\to 0} \\frac{f(x_0 + h) - f(x_0)}{h} \\quad (倘若这个极限存在) $$ 曲线在点 P 的切线是过点 P 且以 m 为斜率的直线 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:5:2","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"变化率：在一点处的导数 下述表达式称为 $f$ 在 $x_0$ 的导数 $$ \\frac{f(x_0 + h) - f(x_0)}{h} $$ 如果我们将差商解释为割线的斜率，那么导数就给出了在 $ x = x_0 $点处曲线的斜率和切线的斜率 如果我们将差商解释为平均变化率，那么导数就给出了函数在 $ x = x_0 $处关于 x 的变化率 ","date":"2025-08-18","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/:5:3","tags":["微积分"],"title":"微积分 - 极限和连续","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%9E%81%E9%99%90%E5%92%8C%E8%BF%9E%E7%BB%AD/"},{"categories":["微积分"],"content":"微积分的预备知识-习题答案","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"直线 - 习题 题 1 和题 2中，求从A到 B 的增量坐标 A(1,2), B(-1,-1) $$ \\begin{gather*} \\Delta{x} = -1 - 1 = -2 \\\\ \\Delta{y} = -1 - 2 = -3 \\end{gather*} $$ A(-3,2),B(-1,-2) $$ \\begin{gather*} \\Delta{x} = -1 - (-3) = 2 \\\\ \\Delta{y} = -2 - 2 = -4 \\end{gather*} $$ A(-3,1),B(-8,1) $$ \\begin{gather*} \\Delta{x} = -8 - (-3) = -5 \\\\ \\Delta{y} = 1 - 1 = 0 \\end{gather*} $$ A(0,4),B(0, -2) $$ \\begin{gather*} \\Delta{x} = 0 - 0 = 0 \\\\ \\Delta{y} = -2 - 4 = -6 \\end{gather*} $$ 题 3 和 题 4中，令L是点A和B决定的直线 图示A 和 B 求L的斜率 画出L的图形 A(1, -2), B(2, 1) $$ m = \\frac{\\Delta{y}}{\\Delta{x}} = \\frac{B_y - A_y}{B_x - A_x} = \\frac{1 - (-2)}{2 - 1} = \\frac{3}{1} = 3 $$ A (-2, -1), B(-1, -2) $$ m = \\frac{\\Delta{y}}{\\Delta{x}} = \\frac{B_y - A_y}{B_x - A_x} = \\frac{-2 - (-1)}{-1 - (-2)} = \\frac{-1}{1} = -1 $$ A(2, 3), B(-1, 3) 光看y轴就是一条水平线，故斜率为0 A(1, 2), B(1, -3) x轴相等，所以这是一条垂直线，斜率无意义 在题 5 和 题 6 中，对过点 P 的 垂直线 以及 水平线写出方程 在题 7 和 题 8中，对过点P的斜率为 m 的直线写出 点斜式方程 P(1, 1)， m = 1 $$ \\begin{gather*} y = m(x - x_1) + y_1 \\\\ y = 1(x - 1) + 1 \\\\ y = x \\end{gather*} $$ P(-1, 1)，m = -1 $$ \\begin{gather*} y = m(x - x_1) + y_1 \\\\ y = -1(x - (-1)) + 1 \\\\ y = -x \\end{gather*} $$ P(0, 3)，m = 2 $$ \\begin{gather*} y = m(x - x_1) + y_1 \\\\ y = 2(x - 0) + 3 \\\\ y = 2x + 3 \\end{gather*} $$ P(-4, 0)，m = -2 $$ \\begin{gather*} y = m(x - x_1) - y_1 \\\\ y = -2(x - (-4)) - 0 \\\\ y = -2x - 8 \\end{gather*} $$ 在题 9 和 题 10 中，写出过两点的一般线性方程 （0，0），（2，3） $$ \\begin{gather*} m = \\frac{3 - 0}{2 - 0} = \\frac{3}{2} \\\\ \\\\ y = m(x - x_1) + y_1 \\quad (用(0，0)) \\\\ \\\\ y = \\frac{3}{2}(x - 0) + 0 \\\\ \\\\ y = \\frac{3}{2}x \\\\ \\\\ 2y = 3x \\\\ \\\\ 3x - 2y = 0 \\end{gather*} $$ （1，1），（2，1） $$ \\begin{gather*} m = \\frac{1 - 1}{2 - 1} = 0 \\\\ \\\\ y = m(x - x_1) + y_1 \\quad (用(1，1)) \\\\ \\\\ y = 0(x - 1) + 1 \\\\ \\\\ y = 1 \\\\ \\\\ y - 1 = 0 \\\\ \\\\ 0x + y - 1 = 0 \\end{gather*} $$ （-2，0），（-2，-2） 通过计算斜率 $ m \u0026= \\frac{-2 - 0}{-2 - (-2)} = \\frac{-2}{0} $ 发现分母为 0 ，斜率无意义，所以这是一条垂直线 对于垂直线，线上所有点的 x 坐标都相同。观察两个点，它们的 x 坐标都是 -2。所以方程就是 x = -2 （-2，1），（2，-2） $$ \\begin{gather*} m = \\frac{-2 - 1}{2 - (-2)} = \\frac{-3}{4} \\\\ \\\\ y = m(x - x_1) + y_1 \\quad (用(-2，1)) \\\\ \\\\ y = -\\frac{3}{4}(x - (-2)) + 1 \\\\ \\\\ 4y = -3(x + 2) + 4 \\\\ \\\\ 4y = -3x - 6 + 4 \\\\ \\\\ 3x + 4y = -2 \\end{gather*} $$ 在题 11 和 题 12 中，对斜率为 m，y - 截距 为 b 的直线 写出 斜率截距方程 m = 3，b = -2 $$ \\begin{gather*} y = mx + b \\\\ y = 3x - 2 \\end{gather*} $$ m = -1，b = 2 $$ \\begin{gather*} y = mx + b \\\\ \\\\ y = -x + 2 \\end{gather*} $$ $ m = \\frac{-1}{2}，b = -3 $ $$ \\begin{gather*} y = mx + b \\\\ \\ y = -\\frac{1}{2}x - 3 \\end{gather*} $$ $ m = \\frac{1}{3}，b = -1 $ $$ \\begin{gather*} y = mx + b \\\\ \\\\ y = \\frac{1}{3}x - 1 \\end{gather*} $$ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:1:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"求函数的公式 - 习题 把等边三角形的面积和周长表为该三角形边长 x 的函数 $$ \\begin{gather*} \\text{周长:} \\quad y = f(x) = x + x + x = 3x \\\\ \\\\ \\text{面积:} \\quad y = f(x) = \\frac{1}{2}ab \\sin(C) = \\frac{1}{2} \\cdot x \\cdot x \\cdot \\sin{60} = \\frac{\\sqrt{3}}{4}x^2 \\end{gather*} $$ 把正方形的边长表为该正方形对角线长度 d 的函数，然后把该正方形的面积表为对角线长度的函数 $$ \\begin{gather*} \\text{边长：} \\quad y = f(x) \\Rightarrow y^2 \\cdot y^2 = d^2 \\Rightarrow y = \\frac{d}{\\sqrt{2}} \\\\ \\\\ \\text{面积：} \\quad y = f(x) = \\frac{d}{\\sqrt{2}} * \\frac{d}{\\sqrt{2}} = \\frac{d^2}{2} \\end{gather*} $$ 把立方体的棱边长表为该立方体对角线长度 d 的函数，然后把该立方体的表面积和体积表为对角线长度的函数 $$ \\begin{gather*} \\text{边长：} y = f(x) = (\\frac{\\sqrt{3}}{3})d \\\\ \\\\ \\text{表面积：} y = f(x) = 2d^2 \\\\ \\\\ \\text{体积：} y = f(x) = (\\frac{\\sqrt{3}}{9})d^2 \\end{gather*} $$ 第一象限中的点 P 位于函数 $ f(x) = \\sqrt{x} $ 的图形上，把点 P 的坐标表为连接点 P 和原点的直线的斜率的函数 $$ P(m) = (\\frac{1}{m^2}, \\frac{1}{m}) \\quad m \u003e 0 $$ 在题五 题六中，哪些图是 x 的函数，哪些不是，给出回答和理由 只有题五-b 是x 的函数，因为 一个 x 只能 对应一个 y ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:2:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"定义域和值域 - 习题 在 题7 - 题10 中，求每个函数的定义域和值域 $ f(x) = 1 + x^2 $ $$ \\begin{gather*} 定义域：(-\\infty,\\infty) \\\\ \\\\ 值域：[1, \\infty) \\end{gather*} $$ $ f(x) = 1 - \\sqrt{x} $ $$ \\begin{gather*} 定义域：[0, \\infty) \\\\ \\\\ 值域: (-\\infty, 1] \\end{gather*} $$ $ F(t) = \\frac{1}{\\sqrt{t}} $ $$ \\begin{gather*} 定义域： [0, \\infty) \\\\ \\\\ 值域：(0, \\infty) \\end{gather*} $$ $ F(t) = \\frac{1}{1 + \\sqrt{t}} $ $$ \\begin{gather*} 定义域： [0, \\infty) \\\\ \\\\ 值域：(0, 1] \\end{gather*} $$ $ g(z) = \\sqrt{4 - z^2} $ $$ \\begin{gather*} 定义域： [-2, 2] \\\\ \\\\ 值域：[0，2] \\end{gather*} $$ $ g(z)=\\sqrt[3]{z-3} $ $$ \\begin{gather*} 定义域： (-\\infty,\\infty) \\\\ \\\\ 值域：(-\\infty,\\infty) \\end{gather*} $$ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:3:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"函数和图形 - 习题 画 题十一 和 题十二的图形，如果图形有对称性的话，是什么样的对称性? $ y = -x^3 $ 原点对称，是个奇函数 $ y = -\\frac{1}{x^2} $ 很明显 y轴对称，是个偶函数 $ y = \\sqrt{\\mid x\\mid } $ y轴对称，偶函数 $ y = -\\frac{1}{x} $ 原点对称，是一个奇函数 画出下列式子的图形并解释他们为什么不是 x 的函数 $ \\mid y \\mid = x $ 因为一个 x 上有多个 y $ y^2 = x^2 $ 因为一个 x 上有多个 y 画出下列式子的图形并解释他们为什么不是 x 的函数 $ \\mid x \\mid + \\mid y \\mid = 1 $ 因为一个 x 上有多个 y $ \\mid x + y \\mid = 1 $ 因为一个 x 上有多个 y ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:4:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"偶函数和奇函数 - 习题 在题 15 - 20 中，说出函数是否是偶函数、奇函数或两者都不是 $ f(x) = 3 $ 偶函数，因为 y 永远都等于 3，也就是 $ f(x) = f(-x) $ $$ f(x) = 3 \\quad f(-x) = 3 $$ $ f(x) = x^{-5} $ 奇函数，因为 $ f(x) \\neq f(-x) $，但是 $ f(-x) = -f(x) $ $$ \\begin{gather*} f(-x) = -(x)^{-5} = \\frac{1}{-x^5} = -\\frac{1}{x^5} \\\\ \\\\ f(x) = x^{-5} = \\frac{1}{x^5} \\\\ \\\\ -f(x) = -(x^{-5}) = -\\frac{1}{x^5} \\\\ \\\\ f(-x) = -f(x) \\end{gather*} $$ $ f(x) = x^2 + 1 $ 偶函数 $$ \\begin{gather*} f(x) = x^2 + 1 \\\\ \\\\ f(-x) = (-x)^2 + 1 = x^2 + 1 \\\\ \\\\ f(x) = f(-x) \\end{gather*} $$ $ f(x) = x^2 + x $ 两者都不是 $$ \\begin{gather*} f(x) = x^2 + x \\\\ \\\\ f(-x) = (-x)^2 - x = x^2 - x \\\\ \\\\ -f(x) = -(x^2 + x) = -x^2 - x \\end{gather*} $$ $ g(x) = x^3 + x $ 奇函数 $$ \\begin{gather*} g(x) = x^3 + x \\\\ \\\\ g(-x) = (-x)^3 - x = -x^3 - x \\\\ \\\\ -g(x) = -(x^3 + x) = -x^3 - x \\end{gather*} $$ $ g(x) = x^4 + 3x^2 - 1 $ 偶函数 $$ \\begin{gather*} g(x) = x^4 + 3x^2 - 1 \\\\ \\\\ g(-x) = (-x)^4 + 3(-x)^2 - 1 = x^4 + 3x^2 - 1 \\\\ \\\\ g(x) = g(-x) \\end{gather*} $$ $ g(x) = \\frac{1}{x^2 - 1} $ 偶函数 $$ \\begin{gather*} g(x) = \\frac{1}{x^2 - 1} \\\\ \\\\ g(-x) = \\frac{1}{(-x)^2 - 1} = \\frac{1}{x^2 - 1} \\end{gather*} $$ $ g(x) = \\frac{x}{x^2 - 1} $ 奇函数 $$ \\begin{gather*} g(x) = \\frac{x}{x^2 - 1} \\\\ \\\\ g(-x) = \\frac{-x}{(-x)^2 - 1} = -\\frac{x}{x^2 - 1} \\\\ \\\\ -g(x) = -(\\frac{x}{x^2 - 1}) = -\\frac{x}{x^2 - 1} \\\\ \\\\ g(-x) = -g(x) \\end{gather*} $$ $ h(t) = \\frac{1}{t - 1} $ 两者都不是 $$ \\begin{gather*} h(t) = \\frac{1}{t - 1} \\\\ \\\\ h(-t) = \\frac{1}{-t - 1} = -\\frac{1}{t+1} \\\\ \\\\ -h(t) = -\\frac{1}{t -1} \\end{gather*} $$ $ h(t) = \\mid t^3 \\mid $ 偶函数 $$ \\begin{gather*} h(t) = \\mid t^3 \\mid \\\\ \\\\ h(-t) = \\mid (-t)^3 \\mid \\\\ \\\\ h(t) = h(-t) \\end{gather*} $$ $ h(t) = \\sqrt{t^2 + 3} $ 偶函数 $$ \\begin{gather*} h(t) = \\sqrt{t^2 + 3} \\\\ \\\\ h(-t) = \\sqrt{(-t)^2 + 3} = \\sqrt{t^2 + 3} \\\\ \\\\ h(t) = h(-t) \\end{gather*} $$ $ h(t) = 2\\mid t \\mid + 1 $ 偶函数 $$ \\begin{gather*} h(t) = 2\\mid t \\mid + 1 \\\\ \\\\ h(-t) = 2 \\mid -t \\mid + 1 \\\\ \\\\ h(t) = h(-t) \\end{gather*} $$ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:5:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"指数函数 - 习题 在题 1 - 6 中，把下列图形和下列函数配对 $ y = 2^2 $ $ y = 3^{-x} $ $ y = -3^{-x} $ $ y = -0.5^{-x} -2 $ $ y = 2^{-x} - 2 $ $ y = 1.5^x - 2 $ 在题 7 - 10 中，画函数的图形，说出其定义域、值域和截距 $ y = -2^x + 3 $ 定义域：$ (- \\infty，+ \\infty) $ 值域：$ (- \\infty, 3) $ $$ \\begin{gather*} -2^x + 3 = 0 \\quad -2^x = -3 \\quad 2^x = 3 \\quad x = log_2(3) \\\\ \\\\ y = -2^0 + 3 = -1 + 3 = 2 \\end{gather*} $$ $ y = e^x + 3 $ 定义域：$ (- \\infty，+ \\infty) $ 值域：$ (3, + \\infty) $ $$ \\begin{gather*} 0 = e^x + 3 \\quad e^x = -3 \\quad \\text{因为}e^x\\text{的值恒为正，所以没有x截距，此方程无意义} \\\\ \\\\ y = e^0 + 3 = 1 + 3 = 4 \\end{gather*} $$ $ y = 3 \\cdot e^{-x} - 2 $ 定义域：$ (- \\infty，+ \\infty) $* 值域：$ (-2, + \\infty) $ $$ \\begin{gather*} 0 = 3 \\cdot e^{-x} -2 \\quad \\frac{1}{e^{x}} = \\frac{2}{3} \\quad e^x = \\frac{3}{2} \\quad x = \\ln{ \\frac{3}{2}} \\\\ \\\\ y = 3 \\cdot e^0 - 2 = 3 \\cdot 1 - 2 = 1 \\end{gather*} $$ $y = -2^{-x} - 1$ 定义域：$ (- \\infty，+ \\infty) $ 值域：$ (- \\infty，-3) $ $$ \\begin{gather*} 0 = -2^{-x} - 1 \\quad 1 = -2^{-x} \\quad 2^{-x} = -1 \\quad \\text{因为}2^{-x}\\text{值恒为证数，所以没有x截距，此方程无意义} \\\\ \\\\ y = -2^0 - 1 = -1 - 1 = -2 \\end{gather*} $$ 在题 11 - 14 中，重写具有指定底的指数函数 $ 9^{2x}，底为 3 $ $$ 9^{2x} \\Rightarrow 3^{2 \\cdot {2x}} \\Rightarrow 3^{4x} $$ $ 16^{3x}，底为 2 $ $$ 16^{3x} = 2^{4 \\cdot 3x} = 2^{12x} $$ $ (\\frac{1}{8})^{2x}，底为 2 $ $$ (\\frac{1}{8})^{2x} = 2^{-3 \\cdot 2x} = 2^{-6x} $$ $ (\\frac{1}{27})^x，底为 3 $ $$ (\\frac{1}{27})^x = 3^{-3 \\cdot x} = 3^{-3x} $$ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:6:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"从图形识别一对一函数 - 习题 题 1 - 6 中图示的函数中那些是一对一的，哪些不是一对一的 1，5，6是一对一函数，其余不是一对一函数 ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:7:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"画反函数的图形 - 习题 题 7 - 10 中每道题都展示了函数 $ y = f(x) $ 的图形，复制该图形并画上直线 $ y = x$，然后利用对直线 $ y =x$ 的对成型把 $ f^{-1} $ 的图形加到你的图上（不必求 $ f^{-1} $ 的方程），识别 $ f^{-1} $ 的定义域和值域 ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:8:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"反函数的方程 - 习题 题 11 - 16 给出了函数 $ y = f(x) $ 的方程并展示了 $f$ 和 $f^{-1}$ 的图形，求每题中 $f^{-1}$ 的方程 $ f(x) = x^2 + 1，x \\geq 0 $ $$ \\begin{gather*} y = x^2 + 1，x \\geq 0 \\\\ \\\\ x = y^2 + 1 \\quad \\text{x，y交换} \\\\ \\\\ x - 1 = y^2 \\\\ \\\\ y = \\pm \\sqrt{x - 1} \\\\ \\\\ \\text{原函数的定义域是} x \\geq 0 \\text{，所以这意味反函数的值域必须是} y \\geq 0 \\\\ \\\\ y = \\sqrt{x - 1} \\quad \\Rightarrow \\quad f^{-1}(x) = \\sqrt{x - 1} \\end{gather*} $$ $ f(x) = x^2，x \\leq 0 $ $$ \\begin{gather*} y = x^2, x \\leq 0 \\\\ \\\\ x = y^2 \\quad \\text{x，y交换} \\\\ \\\\ y = \\pm \\sqrt{x} \\\\ \\\\ \\text{原函数的定义域是} x \\leq 0 \\text{，所以这意味反函数的值域必须是} y \\leq 0 \\\\ \\\\ y = -\\sqrt{x} \\quad \\Rightarrow \\quad f^{-1}(x) = -\\sqrt{x} \\end{gather*} $$ $ f(x) = x^3 - 1 $ $$ \\begin{gather*} f(x) = x^3 - 1 \\\\ \\\\ y = x^3 - 1 \\\\ \\\\ x = y^3 - 1 \\quad \\text{x，y交换} \\\\ \\\\ y = \\sqrt[3]{x - 1} \\\\ \\\\ f^{-1}(x) = \\sqrt[3]{x - 1} \\end{gather*} $$ $ f(x) = x^2 - 2x + 1，x \\geq 1 $ $$ \\begin{gather*} f(x) = x^2 - 2x + 1，x \\geq 1 \\\\ \\\\ y = x^2 - 2x + 1 \\\\ \\\\ y = (x - 1)^2 \\\\ \\\\ x = (y - 1)^2 \\quad \\text{x，y交换} \\\\ \\\\ y - 1 = \\pm \\sqrt{x} \\\\ \\\\ y = \\pm \\sqrt{x} + 1 \\\\ \\\\ \\text{原函数的定义域是} x \\geq 1 \\text{，所以这意味反函数的值域必须是} y \\geq 1 \\\\ \\\\ y = \\sqrt{x} + 1 \\quad \\Rightarrow \\quad f^{-1}(x) = \\sqrt{x} + 1 \\end{gather*} $$ $ f(x) = (x + 1)^2，x \\geq 1 $ $$ \\begin{gather*} f(x) = (x + 1)^2，x \\geq 1 \\\\ \\\\ y = (x + 1)^2 \\\\ \\\\ x = (y + 1)^2 \\quad \\text{x，y交换} \\\\ \\\\ y + 1 = \\pm \\sqrt{x} \\\\ \\\\ \\text{原函数的定义域是} x \\geq 1 \\text{，所以这意味反函数的值域必须是} y \\geq 1 \\\\ \\\\ y = \\sqrt{x} - 1 \\quad \\Rightarrow \\quad f^{-1}(x) = \\sqrt{x} - 1 \\end{gather*} $$ $ f(x) = x^{2/3}，x \\geq 0 $ $$ \\begin{gather*} f(x) = x^{2/3}，x \\geq 0 \\\\ \\\\ y = x^{2/3} \\\\ \\\\ x = y^{2/3} \\quad \\text{x，y交换} \\\\ \\\\ x^{3/2} = (y^{2/3})^{3/2} \\\\ \\\\ y = x^{3/2} \\\\ \\\\ y = \\sqrt{x}^3 \\\\ \\\\ \\text{原函数的定义域是} x \\geq 0 \\text{，所以这意味反函数的值域必须是} y \\geq 0 \\\\ \\\\ y = \\sqrt{x}^3 \\quad \\Rightarrow \\quad f^{-1}(x) = \\sqrt{x}^3 \\end{gather*} $$ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:9:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"求反函数 - 习题 在题 17 - 28 中，求 $ f^{-1} $ 并验证 $ (f\\circ f^{-1})(x)=(f^{-1}\\circ f)(x)=x $ $ f(x) = 2x + 3 $ 求 $ f^{-1} $ $$ \\begin{gather*} f(x) = 2x + 3 \\\\ \\\\ y = 2x + 3 \\\\ \\\\ y - 3 = 2x \\\\ \\\\ \\frac{y-3}{2} = x \\\\ \\\\ y = \\frac{x - 3}{2} \\quad \\text{交换x，y} \\\\ \\\\ f^{-1}(x) = \\frac{x - 3}{2} \\end{gather*} $$ 验证 $ f(f^{-1}(x)) = f^{-1}(f(x)) $ $$ \\begin{gather*} f(f^{-1}(x)) = f(\\frac{x - 3}{2}) = 2(\\frac{x - 3}{2}) + 3 = x - 3 + 3 = x \\\\ \\\\ f^{-1}(f(x)) = f^{-1}(2x + 3) = \\frac{2x + 3 -3}{2} = \\frac{2x}{2} = x \\\\ \\\\ f(f^{-1}(x)) = f^{-1}(f(x)) \\end{gather*} $$ $ f(x) = 5 - 4x $ 求 $ f^{-1} $ $$ \\begin{gather*} f(x) = 5 - 4x \\\\ \\\\ y = 5 - 4x \\\\ \\\\ 4x = -(y - 5) \\\\ \\\\ x = -\\frac{y - 5}{4} \\\\ \\\\ y = -\\frac{x - 5}{4} \\quad \\text{交换x，y} \\\\ \\\\ \\quad f^{-1}(x) = -\\frac{x - 5}{4} = \\frac{5 - x}{4} \\end{gather*} $$ 验证 $ f(f^{-1}(x)) = f^{-1}(f(x)) $ $$ \\begin{gather*} f(f^{-1}(x)) = f(\\frac{5 - x}{4}) = 5 - 4(\\frac{5 - x}{4})= 5 - (5 - x) = x \\\\ \\\\ f^{-1}(f(x)) = f^{-1}(5 - 4x) = \\frac{5 - (5 - 4x)}{4} = \\frac{4x}{4} = x \\\\ \\\\ f(f^{-1}(x)) = f^{-1}(f(x)) \\end{gather*} $$ $ f(x) = x^3 - 1 $ 求 $ f^{-1} $ $$ \\begin{gather*} f(x) = x^3 - 1 \\\\ \\\\ y = x^3 - 1 \\\\ \\\\ y + 1 = x^3 \\\\ \\\\ \\sqrt[3]{y + 1} = x \\\\ \\\\ y = \\sqrt[3]{x + 1} \\quad \\text{x，y交换} \\\\ \\\\ f^{-1}(x) = \\sqrt[3]{x + 1} \\end{gather*} $$ 验证 $ f(f^{-1}(x)) = f^{-1}(f(x)) $ $$ \\begin{gather*} f(f^{-1}(x)) = f(\\sqrt[3]{x + 1}) = \\sqrt[3]{x + 1}^3 - 1 = x + 1 - 1 = x \\\\ \\\\ f^{-1}(f(x)) = f^{-1}(x^3 - 1) = \\sqrt[3]{x^3 + 1 - 1} = x \\\\ \\\\ f(f^{-1}(x)) = f^{-1}(f(x)) \\end{gather*} $$ $ f(x) = x^2 + 1，x \\geq 0 $ 求 $ f^{-1} $ $$ \\begin{gather*} f(x) = x^2 + 1，x \\geq 0 \\\\ \\\\ y = x^2 + 1 \\\\ \\\\ y - 1 = x^2 \\\\ \\\\ \\sqrt{y - 1} = \\sqrt{x^2} = \\mid x \\mid = x \\quad \\text{因为} x \\geq 0 \\text{所以} \\mid x \\mid = x \\\\ \\\\ y = \\sqrt{x - 1} \\\\ \\\\ f^{-1}(x) = \\sqrt{x - 1} \\end{gather*} $$ 验证 $ f(f^{-1}(x)) = f^{-1}(f(x)) $ $$ \\begin{gather*} f(f^{-1}(x)) = f(\\sqrt{x-1}) = \\sqrt{x-1}^2 + 1 = x - 1 + 1 = x \\\\ \\\\ f^{-1}(f(x)) = f^{-1}(x^2 + 1) = \\sqrt{x^2 + 1 - 1} = x \\\\ \\\\ f(f^{-1}(x)) = f^{-1}(f(x)) \\end{gather*} $$ $ f(x) = x^2，x \\leq 0 $ 求 $ f^{-1} $ $$ \\begin{gather*} f(x) = x^2，x \\leq 0 \\\\ \\\\ y = x^2 \\\\ \\\\ \\sqrt{y} = \\sqrt{x^2} = \\mid x \\mid = -x \\quad \\text{因为} x \\leq 0 \\text{所以} \\mid x \\mid = -x \\\\ \\\\ y = -\\sqrt{x} \\\\ \\\\ f^{-1}(x) = -\\sqrt{x} \\end{gather*} $$ 验证 $ f(f^{-1}(x)) = f^{-1}(f(x)) $ $$ \\begin{gather*} f(f^{-1}(x)) = f(-\\sqrt{x}) =(-\\sqrt{x})^2 = x \\\\ \\\\ f^{-1}(f(x)) = f^{-1}(x^2) = -\\sqrt{x^2} = -(-x) = x \\quad \\text{因为原函数定义域是} x \\leq 0，\\text{所以} -() \\\\ \\\\ f(f^{-1}(x)) = f^{-1}(f(x)) \\end{gather*} $$ $ f(x) = x^{2/3}，x \\geq 0 $ 求 $ f^{-1} $ $$ \\begin{gather*} f(x) = x^{2/3}，x \\geq 0 \\\\ \\\\ y = x^{2/3} \\\\ \\\\ y^{3/2} = (x^{2/3})^{3/2} \\\\ \\\\ y^{3/2} = x \\\\ \\\\ y = x^{3/2} \\quad \\text{x,y 交换} \\\\ \\\\ f^{-1}(x) = x^{3/2} \\end{gather*} $$ 验证 $ f(f^{-1}(x)) = f^{-1}(f(x)) $ $$ \\begin{gather*} f(f^{-1}(x)) = f(x^{3/2}) = (x^{3/2})^{2/3} = x \\\\ \\\\ f^{-1}(f(x)) = f^{-1}(x^{2/3}) = (x^{2/3})^{3/2} = x \\\\ \\\\ f(f^{-1}(x)) = f^{-1}(f(x)) \\end{gather*} $$ $ f(x) = -(x - 2)^2，x \\leq 2 $ 求 $ f^{-1} $ $$ \\begin{gather*} f(x) = -(x - 2)^2，x \\leq 2 \\\\ \\\\ y = -(x - 2)^2 \\\\ \\\\ \\sqrt{-y} = \\sqrt{(x - 2)^2} = \\mid \\sqrt{(x - 2)^2} \\mid = -\\sqrt{(x - 2)^2} \\quad \\text{因为} x \\leq 2, 所以\\mid \\sqrt{(x - 2)^2} \\mid = -\\sqrt{(x - 2)^2} \\\\ \\\\ \\sqrt{-y} - 2 = -x \\\\ \\\\ y = 2 - \\sqrt{-x} \\end{gather*} $$ 验证 $ f(f^{-1}(x)) = f^{-1}(f(x)) $ $$ \\begin{gather*} f(f^{-1}(x)) = f(2 - \\sqrt{-x}) = -(2 - \\sqrt{-x} - 2)^2 = -(-\\sqrt{-x})^2 = -(-x) = x \\\\ \\\\ f^{-1}(f(x)) = f^{-1}(-(x-2)^2) = 2 - \\sqrt{-(-(x-2)^2)} = 2 - \\sqrt{(x - 2)^2} = 2 - \\mid (x - 2) \\mid = 2 - (-x + 2) = 2 + x - 2 = x \\\\ \\\\ \\text{因为} x \\leq 2 所以 \\mid (x - 2) \\mid = -(x - 2) = -x + 2 \\\\ \\\\ f(f^{-1}(x)) = f^{-1}(f(x)) \\end{gather*} $$ $ f(x) = x^2 + 2x + 1，x \\geq -1 $ 求 $ f^{-1} $ $$ \\begin{gather*} f(x) = x^2 + 2x + 1，x \\geq -1 \\\\ \\\\ y = x^2 + 2x + 1 \\\\ \\\\ y = (x + 1)^2 \\\\ \\\\ \\sqrt{y} = \\sqrt{(x + 1)^2} = \\mid (x + 1) \\mid = x + 1 \\quad 因为 x \\geq 1 所以 \\mid (x + 1) \\mid = x + 1 ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:10:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"自然化指数和对数函数 - 习题 在题 29 - 30 中，把指数函数表为 e 的幂函数。求定义域和值域 $y = 3^x - 1$ $y = 4^{x+1) 在题 31 - 32 中，把函数用自然对数表示出来，求定义域和值域并画图 $ y = 1 - (\\ln3)\\log_3 x $ $ y = (\\ln10)\\log(x+2) $ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:11:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"解指数方程 - 习题 在题 33 - 36中，代数地求解方程，如果你有一图形计算器或计算机绘图器，试图解地证实你得到的解 $(1.045)^t = 2$ $ e^{0.05t} = 3 $ $ e^x + e^{-x} = 3 $ $ 2^x + 2^{-x} = 5 $ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:12:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"解包含对数项的方程 - 习题 在题 37 - 38 中，解 y $ \\ln{y} = 2t + 4 $ $ \\ln{(y-1)} - \\ln{2} = x + \\ln{x} $ ","date":"2025-08-13","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/:13:0","tags":["微积分"],"title":"微积分 - 预备知识 - 部分习题及答案","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"categories":["微积分"],"content":"微积分的预备知识","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"直线 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"增量 定义： 当平面上一个质点从一点移动到另外一个点，其坐标的纯改变就是增量 公式： 如果一个质点从 $ (x_1, y_1) $ 移动到 $ (x_2, y_2) $，则其坐标的增量为： $$ \\Delta{x} = x_2 - x_1 ~~~~~~~~~~~~~~~ \\Delta{y} = y_2 - y_1 $$ 解释说明： 质点就是物理学一个有质量但没有体积和形状的理想化模型 $ \\Delta $ 这个叫 Delta，他是差的意思，并不是相乘的意思 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"直线的斜率 定义： 每条非垂直的直线都会有一个斜率，每行进单位距离时高度的变化为直线的斜率 公式： 设 点$ P_1 (x_1, y_1) $ 和 点$ P_2 (x_2, y_2) $ 是非垂直直线L上的两个点，那么L的斜率为： $$ m = \\frac{升高}{前进的距离} = \\frac{\\Delta{y}}{\\Delta{x}} = \\frac{(y_2 - y_1)}{(x_2 - x_1)} $$ 解释说明： 习惯上用 m 表示斜率 从这个公式我们也能看出，为什么垂直直线不会有斜率这个说法，因为当 $ \\Delta{y} ~~ \\Delta{x} $ 为 0 时，这个公式没有了意义 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"平行线与垂直线 定义： 当两个平行线与x轴夹角相等，因此，非垂直的平行线具有相同的斜率，反之，具有相同斜率的直线与x轴的夹角相等，所以是平行线。 当两条非垂直直线 L1 和 L2 是互相垂直的，他的斜率 m1 和 m2 满足 m1m2 = -1，所以 每个斜率是另一个斜率的负倒数： $$ m_1m_2 = -1 ~~~~~ m_1 = - \\frac{1}{m_2} ~~~~~~ m_2 = - \\frac{1}{m_1} $$ 我们还可以反过来，从斜率确定垂直性：若 L 是斜率为 $ \\frac{3}{4} $ 的直线,，任何斜率为 $ - \\frac{4}{3} $ 的直线垂直于 L 公式： $$ m_1m_2 = -1 $$ 推导： 论证大致如下：用图 3 的记号就是：$ m_1=\\tan\\phi_1=\\frac{a}{h} $ ，而 $ m_2=\\tan\\phi_2=-\\frac{h}{a} $，那么：$ m_1m_2 = (\\frac{a}{h}) (-\\frac{h}{a}) = -1 $ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"直线的方程 点斜式方程 定义： 如果我们知道直线的斜率 m，和直线上任意一个点 $ P_1(x_1, y_1) $，那么我们可以写出任意非垂直线的方程，因为如果 P(x, y) 是直线上任意一点，那么他的斜率就是： $$ \\begin{align*} \u0026 \\frac{(y - y_1)}{(x - x_1)} = m \\\\ \\\\ \u0026 (y - y_1) = m(x - x_1) \\\\ \\\\ \u0026 y = m(x - x_1) + y_1 \\end{align*} $$ 所以：$ y = m(x - x_1) + y_1 $ 是过点 $ (x_1, y_1) $，且斜率为 m 的直线的 点斜方程 公式： $$ y = m(x - x_1) + y_1 $$ 斜率 - 截距方程 定义： 非垂直直线和 y 轴的交点的 y轴坐标就是直线的 y截距 非垂直直线和 x 轴的交点的 x轴坐标就是直线的 x截距 斜率为 m 而 y截距为b的直线过 (0, b) ，所以： $$ y = m(x - 0) + b $$ 公式： $$ y = mx + b $$ 解释说明： 此公式是 斜率为 m 而 y截距为b的直线的斜率 - 截距方程，也叫做斜截方程 y截距一般用 b 表示，x截距一般用 a 表示 一般线性方程 定义： 如果 A和B 不全为0，则方程 Ax + By = C 的图形是一条直线，每条直线都有这种形式的方程，即使是一条具有不确定的斜率的直线 公式： $$ Ax+By=C \\quad(A\\text{ 和}B\\text{ 不全为 }0) $$ 解释说明： 虽然一般线性方程的形式有助于快速识别直线，但斜率 - 截距形式使用计算器来画直线图形的输入形式 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:1:4","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"什么是函数 定义： 从集合 D 到集合 R 的一个函数是对 D 中每个元素指定 R 中唯一确定的元素的一种规则 解释说明： 一个变量的值常常取决于另一个变量的值 水达到沸点的温度取决于海拔高度（当你越往上走沸点降低） 水的沸点 b 取决于 海拔高度 e； 我们称 b 为因变量，变量 e 为 自变量 故对一个集合中的每个元素指定另一个集合中唯一确定的一个元素的规则成为函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"定义域和值域 定义： 函数的输入构成了函数的定义域，输出构成了函数的值域 解释说明： 我们要以某种方式限制定义域，我们要说出来，比如 $ y^2=2x^2,x^2\u003e0 $ 自变量的许多实值函数的定义域和值域是区间或区间的组合，区间可以是开，闭，或半开以及有限无限的 图片 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"增函数与减函数 定义： 如果当你从左往右走，函数的图形是上升的，那么该函数就是增函数 如果当你从左往右走，函数的图形是下降的，那么该函数就是减函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"奇函数与偶函数 定义： 函数 y = f(x) 是 x 的偶函数，如果 $ f(-x)=f(x) $ 函数 y = f(x) 是 x 的偶函数，如果 $ f(-x)= - f(x) $ 性质：对称性 偶函数的图形是关于 y 轴对称的，因为 $ f(-x)=f(x) $，点（x, y）位于该图形上当且仅当 （-x, y）也在该图形上 奇函数的图形是关于 原点 对称的，因为 $ f(-x)= - f(x) $，点（x, y）位于该图形上当且仅当 （-x, -y）也在该图形上 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:4","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"分段定义的函数 定义： 可以通过在定义域的不同部分用不同的公式来定义函数 例子： $$ y = f(x) = \\begin{cases} -x,\\quad x \u003c 0 \\\\ \\\\ x^{2}, \\quad 0 \\leqslant x \\leqslant 1 \\\\ \\\\ 1, \\quad x\u003e1 \u0026 \\end{cases} $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:5","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"绝对值函数 定义： 绝对值函数 $ y = |x| $ 是由下述公式来定义的： $$ \\mid x \\mid = \\begin{cases} -x, \\quad x \u003c 0 \\\\ \\\\ x, \\quad x \\geq 0\u0026 \\end{cases} $$ 性质： $$ \\mid -a \\mid \\quad = \\quad \\mid a \\mid $$ $$ \\mid ab \\mid \\quad = \\quad \\mid a \\mid \\mid b \\mid $$ $$ \\mid \\frac{a}{b} \\mid \\quad = \\quad \\frac{\\mid a \\mid}{\\mid b \\mid} $$ $$ \\begin{array} {c}{a} \u0026 {+} \u0026 {b} \\end{array} \\quad \\leqslant \\quad \\begin{array} {c}{a}\u0026{+}\u0026{b} \\end{array}. $$ $$ \\mid x\\mid=\\sqrt{x^2}. $$ 解释说明： 绝对值函数就是偶函数，所以他是 y 轴对称的，因为符号 $ \\sqrt{a} $ 表示 a 的非负数平方根，所以 $ \\mid a \\mid $ 另一种定义就是： $$ \\mid x\\mid=\\sqrt{x^2}. $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:6","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"位移图形 定义： 为往上位移函数 $ y = f(x) $ 的图形，加一正常数到公式的右边，比如 $ y = x^2 + 1 $，就可以把图形往上移位1个单位 为往下位移函数 $ y = f(x) $ 的图形，加一负常数到公式的右边，比如 $ y = x^2 - 1 $，就可以把图形往下移位1个单位 往左位移函数 $ y = f(x) $ 的图形，将 x 加上常数，比如 $ y = (x + 1)^2 $，就可以把图形往左移位1个单位 往右位移函数 $ y = f(x) $ 的图形，将 x 减上常数，比如 $ y = (x - 1)^2 $，就可以把图形往移位1个单位 移位公式： 垂直移位：$y$ = $f($ $x$ ) + $k$ 若 $k$ \u003e 0,则向上移位 $k$ 个单位 若 $k\u003c0$,则向下移位 $\\mid k\\mid$ 个单位 水平移位：$y$ = $f($ $x$ + $h$ ) 若 $h$ \u003e 0,则向左移位 $h$ 个单位 若 $h\u003c0$,则向右移位 $\\mid h\\mid$ 个单位 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:7","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"复合函数 定义： 假定函数 g 的某些输出可以作为函数 f 的输入，那么函数 $ f(g(x)) $是 g 和 f 的复合函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:2:8","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"指数函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"指数函数 定义： 设 a 是不等于 1 的正实数，函数 $ f(x) = a^x $ 是底为 a 的指数函数。这个函数的定义域是 $(-\\infty,\\infty) $，值域为 $ (0,\\infty) $ 定律： 若 a \u003e 0，b \u003e 0，对所有实数 x, y，以下结果成立 $$ a^x \\cdot a^y = a^{x+y} $$ $$ \\frac{a^x}{a^y}=a^{x-y} $$ $$ (a^x)^y = (a^y)^x = a^{xy} $$ $$ a^x \\cdot a^y = (ab)^x $$ $$ \\frac{a^x}{b^x} = (\\frac{a}{b})^x $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"自然指数函数 定义： 自然指数函数就是以这个特殊的数字 e 为底的指数函数 标准公式： k 是 非零常数 $$ y = e^{kx} $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"指数增长与指数衰减 函数 $ y = y_0 e^{kx} $ 是指数增长的模式，前提是 k \u003e 0；如果 k \u003c 0 ，那么这个函数就是指数衰减的模型 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:3:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"反函数和对数函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"一对一函数 定义： 函数 $ f(x) $ 在定义域 D 上是一对一的，若每当 $ a\\neq b $ 时 $ f(a) \\neq f(b) $ 图形性质： 一对一函数 $ y = f(x) $ 的图形与任何水平直线相交至多一次（水平直线法则），如果他与水平直线相交多余两次，即他取同一y值多于一次的话，那么该函数就不是一对一的 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"反函数 定义： 由逆转一对一函数的定义域和值域定义的函数就是 $f$ 的反函数 反函数 $ f $ 的记号是 $ f^{-1} $，念作 $f$ 逆。记住他的左上角的-1不是指数的意思 反函数的测试： 函数 $f$ 和 $g$ 是反函数对，当且仅当： $$ f(g(x)) = x \\quad \\text{并且} \\quad g(f(x)) = x. $$ 这时，$ g = f^{-1} $ 而且 $ f = g^{-1} $ 怎么求反函数： 第一步：借助 y 对 x解方程 $ y = f(x) $ 第二步：交换 x, y，得到公式将是 $ y = f^{-1}(x) $ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"对数函数 定义： 底为 a 的对数函数 $ y = \\log_a x $ 是底为 a 的指数函数 $ y=a^{x}(a\u003e0,a\\neq1) $ 的反函数 以 e 为底和以 10 为底 的对数的应用是很重要以至于计算器有专门计算他们的键，他们也有其专门的记号和名称 $ \\log_{e}x\\quad $写作 $ \\quad\\ln x. $ $ \\log_{10}x \\quad$ 写作 $ \\quad \\log x$ 函数 $ \\ln x $ 称为自然对数函数，而 $ \\log x $ 称为普通对数函数 $a^{x}$ 和 $\\log_ax$ 的互为反函数性质： 底为 $ a: $ $ a^{\\log_ax},\\quad\\log_aa^x=2x,\\quad a\u003e0,a\\neq1,x\u003e0 $ 底为 $ e: $ $ \\mathrm{e}^{\\ln x}=-x,\\quad\\ln\\mathrm{e}^x=-x,\\quad x\u003e0 $ 对数的算术性质（对任何的实数 x \u003e 0 和 y \u003e 0）： 乘积法则：$ \\log_axy=\\log_ax+\\log_ay $ 商法则：$ \\log_{a}\\frac{x}{y}=\\log_{a}x-\\log_{a}y $ 幂法则：$ \\log_ax^y=y\\log_ax $ 每个指数函数是自然指数函数的幂函数 $$ a^{x}=\\mathrm{e}^{x\\ln a} $$ 即：$ a^x $ 和 $ e^x $ 的 $ \\ln{a} 次幂是同样的 $ 底变换公式： 每个对数函数是自然对数函数的常数倍： $$ \\log_ax=\\frac{\\ln x}{\\ln a}\\quad(a\u003e0,a\\neq1) $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:4:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"三角函数及其反函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"弧度 定义： 在单位圆中心处的 角 ACB 的弧度等于 ABC 从单位圆周上切割下的圆弧的长度 转换公式： $$ \\begin{gather*} 1\\textbf{ 度 }= \\frac \\pi {180}( \\approx 0. 02) 弧度 \\quad 度到弧度：乘以\\frac\\pi{180} \\\\ \\\\ 1\\textbf{ 弧 度 }= \\frac {180}{- 7}( \\approx 57) \\textbf{度 } \\quad 弧度到度：乘以\\frac{180}{x} \\end{gather*} $$ 三角函数公式定义： 当弧度为 $\\theta$ 的角置于半径为 r 的圆的标准位置时， $ \\theta $ 的 6 个基本三角函数定义如下： $$ 正弦：\\sin \\theta = \\frac y r \\quad 余割: \\csc \\theta = \\frac ry \\\\ \\\\ 余弦: \\cos \\theta = \\frac xr \\quad 正割: \\sec \\theta = \\frac rx \\\\ \\\\ 正切: \\tan \\theta=\\frac{y}{x} \\quad 余切：\\cot \\theta=\\frac{x}{y} $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"三角函数的图形 当我们在坐标平面上画三角函数的图形时，通常我们不用 $\\theta$ 而用 x 来记自变量(弧度) ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:2","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"三角函数的值 如图40的圆周的半径 r = 1，定义 $ \\sin \\theta $ 和 $ \\cos \\theta $ 的方程就变成： $$ \\cos \\theta = x \\quad \\sin \\theta = y $$ 于是我们可以直接从 点P坐标算出余弦和正弦的值。如果我们碰巧知道点P的坐标或者能从点P向下作垂线交于 x轴构成的锐角三角形间接知道点P坐标，我们也可以读出 x 和 y 的大小，他们的正负就由三角形的象限决定 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:3","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"周期性 定义： 函数 $ f(x) $ 是周期函数，如果存在正数p使得对每个 x 值有 $ f(x + p) = f(x) $, 最小的这样的 p 值就是 $f$ 的周期 三角函数的周期： $$ \\begin{aligned} \\text{周期 }\\pi: \\quad \u0026\\tan(x+\\pi)=\\tan x \\quad \\cot(x+\\pi)=\\cot x \\\\ \\\\ \\text{周期 }2\\pi: \\quad \u0026\\sin(x+2\\pi)=\\sin x \\quad \\cos(x+2\\pi)=\\cos x \\\\ \\\\ \u0026\\sec(x+2\\pi)=\\sec x \\quad \\csc(x+2\\pi)=\\csc x \\end{aligned} $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:4","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"偶和奇三角函数 $ \\cos x $ 和 $ \\sec x $ 是偶函数，他们的图形关于 y 轴对称，而其余的四个基本三角函数都是奇函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:5","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"三角函数的变换 把函数的移位，伸展，压缩和反射应用于三角函数。下面的图解会提醒你怎么控制参数： ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:6","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"恒等式 $ \\cos^2 \\theta + \\sin^2 \\theta = 1 $ $ 1 + \\tan^2 \\theta = sec^2 \\theta，\\quad 1 + \\cot^2 \\theta = csc^2 \\theta $ 和角公式： $$ \\begin{gather*} \\cos(A + B) = \\cos A \\cos B - \\sin A \\sin B \\\\ \\\\ \\sin(A + B) = \\sin A \\cos B + \\cos A \\sin B \\end{gather*} $$ 倍角公式（将和角公式中 A B 都用 $ \\theta $ 代替）： $$ \\begin{gather*} \\cos 2 \\theta = \\cos^2 \\theta - \\sin^2 \\theta \\\\ \\\\ \\sin 2 \\theta = 2\\sin \\theta \\cos \\theta \\end{gather*} $$ 余弦定理（如果 a, b, c 是三角形 ABC的三条边，又如果 $ \\theta $ 是 c边的对角）： $$ c^2 = a^2 + b^2 - 2ab \\cos \\theta $$ 余弦定律推广了毕达哥拉斯定律 $$ 若 \\theta = \\frac{\\pi}{2}，则 \\cos \\theta = 0，从而有 c^2 = a^2 + b^2 $$ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:7","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"反三角函数 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:8","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"与反正弦和反余弦有关的恒等式 $ \\sin^{-1}(-x) = -\\sin^{-1}x $ $ \\cos^{-1}x + \\cos^{-1}(-x) = \\pi $ 对于 x \u003e 0 $ \\sin^{-1}x + \\cos^{-1}x = \\frac{\\pi}{2} $ ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:5:9","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"参数方程 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:6:0","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["微积分"],"content":"平面曲线的参数化 定义： 如果 x 和 y 由 t 值 的区间上的函数 $ x = f(t), \\quad y = g(t) $ 给出，那么由这些方程定义的点集$ (x, y) = (f(t), g(t)) $ 是一条参数曲线，方程成为曲线的参数方程 ","date":"2025-08-08","objectID":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/:6:1","tags":["微积分"],"title":"微积分 - 预备知识","uri":"/%E5%BE%AE%E7%A7%AF%E5%88%86-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 行为树","date":"2025-08-05","objectID":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/","tags":["Unreal","行为树","Lyra"],"title":"Lyra - 行为树","uri":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/"},{"categories":["Unreal-Lyra"],"content":"Lyra行为树 Lyra是在生成Bot的时候会传入数据 生成AIController，随后在AIController里面绑定行为树 ","date":"2025-08-05","objectID":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/:1:0","tags":["Unreal","行为树","Lyra"],"title":"Lyra - 行为树","uri":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/"},{"categories":["Unreal-Lyra"],"content":"注意事项 我们使用 EQS 中的 Generator: Perceived Actors的时候，必须再AIController或者AI的Pawn中加入 AIPerceptionComponent，还有对感知对方物体中加入 AIPerceptionStimuliSource，并且进行这两个感知组件的 Senses Config 还有一个，这两个组件之间必须阵营不一样, 它依赖于一个接口：IGenericTeamAgentInterface。你需要让AI和玩家都实现这个接口，并告诉系统“我们是不同队伍的”, 或者直接将 Detection by Affiliation: 把 Detect Enemies, Detect Neutrals, Detect Friendlies 全部勾选上！ 这一步是为了暂时绕开复杂的阵营系统，看看AI到底能不能“感知”到任何东西。 还有 AI 自动导航，比如 MoveTo 需要 NavMeshBoundsVolume网格铺满地形，在这网格内AI才会自动导航 ","date":"2025-08-05","objectID":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/:2:0","tags":["Unreal","行为树","Lyra"],"title":"Lyra - 行为树","uri":"/lyra-%E8%A1%8C%E4%B8%BA%E6%A0%91/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 库存与装备系统","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"Equipment Equipment 是 Lyra 的装备系统，也就是执行装备这个过程逻辑的一个系统 它通过 ULyraEquipmentDefinition 这个类，来获得装备的Actor真正的实例，以及装备上会获得什么技能，还有装备到哪里，比如枪装备到人的一个左手骨骼点上 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:1:0","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraEquipmentDefinition 此类就是装备的一个数据结构，你需要提供一个Instance，还有一个装备上会有什么技能，比如装备一个剑，装备上了就会有一把剑的剑光技能，以及还有装备到人身上那个部位，比如剑装备到骨骼体上 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:1:1","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraEquipmentInstance 此类就是装备的一个实例，比如武器就有枪和剑两种，枪是有根据距离，散射程度来进行伤害衰减的，所以就可以继承此基类，去实现，Lyra也就是这么做的，装备以后就可以从各种各样的枪上面拿到伤害数据 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:1:2","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraEquipmentManagerComponent 此Component就是所有的装备到身上的一个管理者了，也是向外部提供各种CURD的接口 Lyra里会在Gamefeature里将这个绑定在Character上 ULyraQuickBarComponent 此Component就是游戏中的装备栏，可以通过此Component的方法快捷装备到人物身上 Lyra里会在Gamefeature里将这个绑定在PlayerState上 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:1:3","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"Inventory Inventory 是Lyra的库存系统，也可以理解为背包系统，然后管理着一个Actor身上所有的物品 它通过 ULyraInventoryItemFragment 的各种子类，来获得相对应的数据，比如 ULyraEquipmentDefinition ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:2:0","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraInventoryItemDefinition 这个就是库存系统中库存的数据了，他的成员就是一个显示名称，以及还有基类，比如UInventoryFragment_EquippableItem就是继承于这个基类，随后UInventoryFragment_EquippableItem只需要绑定一个装备系统的数据结构体-ULyraEquipmentDefinition, 这样就可以将库存系统与装备系统串起来了 核心职责: 定义物品的显示信息，如名称、图标。 通过一个Fragment（碎片）列表来组合物品的功能。一个物品可以由多个Fragment构成，例如： UInventoryFragment_EquippableItem: 表明这是一个可装备的物品。这个Fragment内部持有一个对 ULyraEquipmentDefinition 的引用，这正是将库存系统与装备系统串联起来的关键桥梁 UInventoryFragment_SetStats: 表明这个物品会提供一些基础属性（比如作为合成材料）。 与ULyraEquipmentDefinition的区别: ULyraInventoryItemDefinition 描述的是“背包里的物品是什么”，而 ULyraEquipmentDefinition 描述的是“这个物品装备后会发生什么”。 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:2:1","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraInventoryItemInstance 这个类就是库存的实例，他的主要职责就是存储这个实例相对应的数据-ULyraInventoryItemDefinition，以及还有一个自定义的 GameplayTagStackContainer，这个Tag的作用就是，Unreal原生提供的只能表示一个Tag，自定义的多了一个等级，比如这个库存的1级和2级效果不一致，这个时候加入一个等级概念就很好区分 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:2:2","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"ULyraInventoryManagerComponent 这个Component就是库存的管理者了，它的作用就是管理全部的库存，并且对外提供各种CURD的方法 Lyra里会在Gamefeature里将这个绑定在PlayerState上 ","date":"2025-07-23","objectID":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/:2:3","tags":["Unreal","Lyra"],"title":"Lyra - 库存与装备系统","uri":"/lyra-%E5%BA%93%E5%AD%98%E4%B8%8E%E8%A3%85%E5%A4%87%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 动画蓝图","date":"2025-07-23","objectID":"/lyra-animation/","tags":["Unreal","Lyra"],"title":"Lyra - Anim Layers","uri":"/lyra-animation/"},{"categories":["Unreal-Lyra"],"content":"参考资料 https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animation-in-lyra-sample-game-in-unreal-engine?application_version=5.3 https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-animation-blueprint-linking-in-unreal-engine?application_version=5.3 ","date":"2025-07-23","objectID":"/lyra-animation/:1:0","tags":["Unreal","Lyra"],"title":"Lyra - Anim Layers","uri":"/lyra-animation/"},{"categories":["Unreal-Lyra"],"content":"简介 Lyra 的 动画蓝图，首先是采用 蓝图线程安全更新动画，此开启方法在文档中就写了。再次提一句，这实现了使用属性访问（Property Access）来访问其所有数据，并避免了重新计算链接的图层可能使用的值，如 加速度（Acceleration） 或 速度（Velocity） 。 Lyra 还采用了 LinkLayersInterface，此动画层接口的作用是：比如你的角色可以拿枪和拿剑，但是他们的动作不一样，你就可以很好的利用这个来加载不同的动画 ","date":"2025-07-23","objectID":"/lyra-animation/:2:0","tags":["Unreal","Lyra"],"title":"Lyra - Anim Layers","uri":"/lyra-animation/"},{"categories":["Unreal-Lyra"],"content":"LyraLayersInterface 此动画层接口的使用方法可以看文档，我在这只解释比较绕的逻辑 你创建一个 LyraLayersInterface，创建好图层（接口方法），在创建一个Animation Blueprint，实现了具体的图层（接口方法），在lyra里这其实是创建了一个ABP基类，随后将各种动画创建变量，比如 Idle 变量，然后再创建具体的子类，去设置动画变量。这样再不同的场景就可以用各自的ABP子类 然后在我们的Character是不是必须要设置一个ABP，这个ABP不需要设置为 刚才说的那几个ABP，你可以继续创建一个新的，然后再这新的interface设置为 LyraLayersInterface，随后再具体的使用idle动画，咱们可以使用 这个动画层接口图层，此时记得再character上使用 Set Linked Anim Class，这个方法的参数，再传我们刚刚说的那个基类或者子类，这样就可以用你创建好的图层的ABP的方法了 ","date":"2025-07-23","objectID":"/lyra-animation/:3:0","tags":["Unreal","Lyra"],"title":"Lyra - Anim Layers","uri":"/lyra-animation/"},{"categories":["Unreal-Lyra"],"content":"坑 线程安全函数需要在detail里标记线程安全 如果想创建自定义线程安全函数函数，则一定要勾上纯（Pure）函数和线程安全选项 ","date":"2025-07-23","objectID":"/lyra-animation/:4:0","tags":["Unreal","Lyra"],"title":"Lyra - Anim Layers","uri":"/lyra-animation/"},{"categories":["杂谈"],"content":"我们在使用Rider开发UE时，Ride会为每一个项目创建一个解决方案缓存，如果开几个新项目写测试demo，我们的C盘会逐渐捉急 不知道官方怎么想的，默认在C盘就算了，还没法改 目前没有找到这个路径相关的设置，只能另辟蹊径 我们既然改不掉这个路径，那就将这个路径映射到其他路径上 windows下，可以使用mklink指令，创建类似linux的软连接 首先把C:\\Users\"用户名\"\\AppData\\Local\\JetBrains这个文件夹移动到你希望他出现的位置 然后用管理员身份打开CMD 使用下面的指令，把里面%引起来的内容替换成你的东西 mklink /j \"C:\\Users\\%你的用户名%\\AppData\\Local\\JetBrains\" \"%你希望这个缓存所在的路径%\" 我的就是 mklink /j C:\\Users\\User\\AppData\\Local\\JetBrains G:\\JetCache\\JetBrains 他已经不占用C盘空间了，也不影响Rider解析，大功告成，告别C盘焦虑 ","date":"2025-07-18","objectID":"/ue%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8rider%E6%97%B6%E7%BC%93%E5%AD%98c%E7%9B%98/:0:0","tags":["Rider","杂谈"],"title":"UE开发使用Rider时缓存干爆C盘的解决方案","uri":"/ue%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8rider%E6%97%B6%E7%BC%93%E5%AD%98c%E7%9B%98/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 AssetManager ","date":"2025-07-15","objectID":"/lyra-dataassetmanager/","tags":["Unreal","Lyra"],"title":"Lyra - 自定义 AssetManager","uri":"/lyra-dataassetmanager/"},{"categories":["Unreal-Lyra"],"content":"作用 在任何一个 Unreal Engine 项目中，资源（Assets）都是构成游戏世界的基础，包括模型、纹理、蓝图、数据资产等等。随着项目规模的扩大，如何高效、有序地加载和管理这些成千上万的资源，成了一个巨大的挑战。开发者常常会遇到这些问题： 资源加载代码散落在项目的各个角落，难以维护和修改。 软引用（Soft Reference）虽然能避免不必要的内存占用，但加载逻辑写起来很繁琐。 关键的游戏数据（如默认角色配置、全局设置等）没有一个统一的获取入口，导致代码依赖混乱。 需要一个中心化的系统来处理异步加载、内存管理和调试。 为了解决这些问题，虚幻引擎提供了一个强大的解决方案——UAssetManager。而自定义一个继承自 UAssetManager 的类，就是为你的项目量身打造一个终极的“资源大管家”。 这样做的好处： 集中化、统一化的资源加载入口 这是最核心、最直接的作用。你可以封装一个简单的静态函数（如 GetAsset())，让项目中的任何代码都能通过这一行调用来获取资源。 管理重要的全局数据资产 你的游戏很可能会有一些“全局”或“默认”的数据资产，你可以将这些数据资产的软指针作为 AssetManager 的成员变量，并提供简单的获取函数。 可靠的内存管理 对于那些加载后需要常驻内存的资源，我们可以在 AssetManager 内部维护一个 TSet 或 TArray 来持有它们的硬引用，防止它们被GC意外卸载 可以在适当的时候（如切换关卡），调用 AssetManager 的函数来主动释放某些资源的引用，从而触发GC进行内存回收。 增强的调试与分析能力 有了统一的处理，那么就可以很轻松的排查问题了 ","date":"2025-07-15","objectID":"/lyra-dataassetmanager/:1:0","tags":["Unreal","Lyra"],"title":"Lyra - 自定义 AssetManager","uri":"/lyra-dataassetmanager/"},{"categories":["Unreal-Lyra"],"content":"修改默认Manager 首先我们得在项目设置，选择到我们自定义的AssetManager类 ","date":"2025-07-15","objectID":"/lyra-dataassetmanager/:2:0","tags":["Unreal","Lyra"],"title":"Lyra - 自定义 AssetManager","uri":"/lyra-dataassetmanager/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 Game Feature","date":"2025-07-15","objectID":"/lyra-gamefeature/","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"什么是GameFeature Game Feature（游戏特性）是虚幻引擎中一个强大的插件系统，旨在实现高度模块化和可扩展的游戏开发。 想象一下，你可以像搭乐高积木一样构建你的游戏：角色的能力、新的游戏模式、季节性活动，甚至UI界面，都可以作为一个独立的“特性”插件来开发。当需要时，只需动态地激活这个插件，所有相关的功能、内容和逻辑就会自动应用到游戏中；不需要时，则可以随时停用，干净利落地移除，而不会影响游戏的核心代码。 这种方式极大地降低了团队协作的耦合度，让大型项目管理变得前所未有的清晰和高效。 简单理解就可以理解为游戏Mod把，加载了就有这块功能，卸载了就没有这块功能 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:1:0","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"创建一个GameFeature插件 打开GameFeature插件 在插件页面 点击 Add(添加) 根据是否需要c++ 创建GameFeature 他会帮你默认创建一个 GameFeature的 PrimaryDataAsset，写好你需要的即可 我们一定要打开项目设置查看下，这个是否加入，没有得补上去 这样的话我们就创建好了，记得在插件设置里面启动你刚刚创建好的插件 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:2:0","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"Feature State Installed：意味着该插件位于本地存储中（即位于硬盘上），但尚未注册、加载或激活。好比你买了一个游戏卡带，放在游戏机旁边，游戏机只知道你的卡带在哪里 Registered：已注册意味着插件中的资源已知，但尚未加载。好比你游戏卡带插进了游戏机，但是你还没有开始游戏 Loaded：已加载意味着插件已加载到内存中并注册到某些游戏系统，但尚未激活且不会影响游戏玩法。 Active：活动意味着插件已完全加载并处于活动状态。它的功能也影响了游戏玩法。 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:3:0","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"UGameFeatureData 在你创建好一个Feature后就会有该DataAsset，在里面填入这个GameFeature的数据 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:4:0","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"FeatureState Initial State: 显示当前插件状态，如果你在运行游戏的时候激活了，然后打开此DataAsset就会发现他变成了Active。后面的EditPlugin是可以让你修改此插件信息，比如插件信息，以及还有此插件依赖的其他插件 Current State: 插件当前状态，可以手动设置默认状态 GameplayTagConfigPath: 该插件的指定加载或存放 Gameplay Tags 的特定配置文件（.ini）路径。 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:4:1","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"GameFeature Actions: UGameFeatureAction类，专门用于在加载GameFeature的时候做的额外操作，比如 Add Component, 在加载的时候给类加上Component AssetManager：FPrimaryAssetTypeInfo结构体， 定义了规则、配置和源数据结构，用于告诉引擎如何识别、扫描、分配以及打包游戏中的各类资源 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:4:2","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"UGameFeatureAction UGameFeatureAction 是你在加载 Gamefeature的时候可以顺便干的事，比如你可以给主角或者其他类 Add Componment，也可以自定义给主角添加特定能力(Ability) ","date":"2025-07-15","objectID":"/lyra-gamefeature/:5:0","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"重要接口 virtual void OnGameFeatureRegistering() override; 当虚幻引擎启动并发现这个 Game Feature 插件时，会立即调用。 virtual void OnGameFeatureUnregistering() override; 引擎关闭的时候，会立刻调用 virtual void OnGameFeatureActivating(FGameFeatureActivatingContext\u0026 Context) override; 当游戏逻辑通过调用 UGameFeaturesSubsystem::Get().ActivateGameFeaturePlugin() 来主动激活这个插件时触发。这通常是游戏流程的一部分 virtual void OnGameFeatureDeactivating(FGameFeatureDeactivatingContext\u0026 Context) override; 当游戏逻辑通过调用 UGameFeaturesSubsystem::Get().DeactivateGameFeaturePlugin() 来主动停用这个插件时触发 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:5:1","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"FPrimaryAssetTypeInfo 它不包含复杂的逻辑，而是定义了规则、配置和源数据结构，用于告诉引擎如何识别、扫描、分配以及打包游戏中的各类资源。 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:6:0","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"FPrimaryAssetTypeInfo 用于在项目设置中定义资源类型的一种扫描规则 PrimaryAssetType：名称 AssetBaseClass：选定这个资源类型的基类 HasBlueprintClasses：如果是true，则也扫描该类的蓝图。反之，则只扫描 c++ 的实例资源 IsEditorOnly：如果为true，则该资产永远不会被烘焙 Directorires：资源所在的文件夹 SpecificAssets：直接指定某些特定的资源路径，而不通过文件夹扫描 Rules：FPrimaryAssetRules结构体，定义资源管理的核心规则 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:6:1","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"FPrimaryAssetRules 这是定义资源管理的核心规则 Priority：当一个次要资源(如贴图)被多个主资源引用时，优先级绝对谁拥有它。高优先级会覆盖低优先级。如果优先级一样，共同管理 ChunkId：用于分包下载或补丁管理。如果设置为0以上的，该资源及其依赖项会被放入指定的 .pak块中 bApplyRecursively：如果为true，该规则不仅影响主资源本身，还会自动应用到它所引用的所有次要资源（除非那些资源被更高优先级的规则管理） CookRule：EPrimaryAssetCookRule 枚举，这个枚举定义了一个主资源在打包过程中的行为。它决定了资源是在开发环境还是生成环境中被包含。 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:6:2","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"EPrimaryAssetCookRule FPrimaryAssetRules：这个枚举定义了一个主资源在打包过程中的行为。它决定了资源是在开发环境还是生产环境中被包含 Unknown: 默认值。如果没有特殊规定，只要被其他资源引用，它就会被烘焙。 NeverCook：绝对不烘焙，如果有引用该资源，直接报错 ProductionNeverCook：如果有其他东西依赖于资产，资产将在开发中被烘焙，但永远不会在生产构建中被烘焙。 DevelopmentAlwaysProductionNeverCook: 资产永远在开发的时候烘焙，即使没被引用。永远不会在生产构件中被烘焙 DevelopmentAlwaysProductionUnknownCook：资产永远在开发中被烘焙；关于它是否应该在生产中烘焙尚不清楚。如果有其他东西依赖于它，它会在生产中烘焙。 AlwaysCook：资产无论在什么环境都会被烘焙 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:6:3","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"注意 可以主项目引用 GameFeature 里的资源 但是编译会报 Error Log，所以不推荐这么做，因为你用 GameFeature 的资源的时候，这个GameFeature可能未被加载。故只能GameFeature引用主项目这块 ","date":"2025-07-15","objectID":"/lyra-gamefeature/:7:0","tags":["Unreal","Lyra"],"title":"Lyra - Game Feature","uri":"/lyra-gamefeature/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 GAS 流程","date":"2025-07-13","objectID":"/lyra-camera/","tags":["Unreal","GAS","Lyra"],"title":"Lyra - Camera","uri":"/lyra-camera/"},{"categories":["Unreal-Lyra"],"content":"Lyra的相机系统 简介 Lyra其实没有用最基本的UCameraComponent，也没有用 USpringComponent 他是自己实现了继承于 UCameraComponent的类，他的功能为： 它挂载在玩家角色上，并重写了引擎的 GetCameraView 函数。在每一帧，它负责启动整个更新和混合流程，并将最终计算出的视图结果提交给渲染器。 它拥有一个 CameraModeStack，这是一个“后进先出”的栈结构，用于存放所有当前激活的相机模式。它负责： 管理模式：处理相机模式的推入（Push）和移除 更新模式：在每帧调用每个模式自身的更新逻辑 混合视图：将栈中所有模式的视图根据权重混合成一个最终视图。 当我们需要一种特定的相机行为的时候，就可以自定义一个CameraMode，比如： CameraMode_ThirdPerson：定义了基础的第三人称跟随视角。 CameraMode_Aiming：定义了瞄准时，相机移动到角色肩膀的贴近视角。 其他可能的模式：冲刺模式（增加FOV和抖动）、蹲伏模式（降低相机高度）等。 我们可以把相机一些简单的数据存放到一个结构体 - FLyraCameraModeView (相机视图数据)，用于存放相机的位置（Location）、旋转（Rotation）、视场角（FieldOfView）等关键信息 ","date":"2025-07-13","objectID":"/lyra-camera/:1:0","tags":["Unreal","GAS","Lyra"],"title":"Lyra - Camera","uri":"/lyra-camera/"},{"categories":["Unreal-Lyra"],"content":"工作流程 void ULyraCameraComponent::GetCameraView(float DeltaTime, FMinimalViewInfo\u0026 DesiredView) 每帧都会调用一次，或者其他情况，在此函数会进行照相机的一系列数值计算 void ULyraCameraComponent::UpdateCameraModes() 发出委托，获得ULyraPawnData 里面的配置的 CameraMode void ULyraCameraModeStack::PushCameraMode(TSubclassOf\u003cULyraCameraMode\u003e CameraModeClass) 它的作用是将一个新的 摄像机模式（Camera Mode）压入堆栈，并处理 混合（Blending） 和 权重（Blend Weight）逻辑。 void ULyraCameraModeStack::UpdateStack(float DeltaTime) Lyra 摄像机模式堆栈（Camera Mode Stack）的更新逻辑，负责每帧更新堆栈中的摄像机模式，并清理不再需要的模式 void ULyraCameraModeStack::BlendStack(FLyraCameraModeView\u0026 OutCameraModeView) const 负责将堆栈中的所有摄像机模式按权重混合，生成最终的摄像机视图 ","date":"2025-07-13","objectID":"/lyra-camera/:2:0","tags":["Unreal","GAS","Lyra"],"title":"Lyra - Camera","uri":"/lyra-camera/"},{"categories":["P4"],"content":"如何在ubuntu上搭建p4","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["P4"],"content":"Rider ","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/:1:0","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["P4"],"content":"配置P4V信息 打开 Rider 设置: File -\u003e Settings (或者按 Ctrl+Alt+S)。 导航到 Version Control -\u003e Perforce。 配置连接参数: Port: 输入你的服务器地址和端口，格式为 host:port (例如 p4.mycompany.com:1666) User: 输入你的 Perforce 用户名。 Workspace: 输入你为这个项目创建的 工作区名称。这是 Rider 用来确定哪些文件在你的控制之下的关键。 Path to P4 executable: 通常你可以留空，Rider 会自动从系统 PATH 中找到 p4.exe。如果找不到，你可以点击 … 按钮手动指定 p4.exe 文件的完整路径。 Path to P4VC executable: 通常你可以留空，Rider 会自动从系统 PATH 中找到 p4v.exe。如果找不到，你可以点击 … 按钮手动指定 p4v.exe 文件的完整路径。 测试连接: 点击 Test Connection 按钮。 如果一切配置正确，你会看到一个 “Connection successful” 的提示。 如果提示需要输入密码，它会弹出一个对话框让你输入。输入后可以选择“记住密码”。 如果连接失败，请仔细检查你的服务器地址、用户名和工作区名称是否拼写正确。 ","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/:1:1","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["P4"],"content":"将项目与 Perforce 关联 即使配置好了连接，你还需要告诉 Rider 这个特定的项目要使用 Perforce 进行版本控制。 打开 Rider 设置: File -\u003e Settings (或者按 Ctrl+Alt+S)。 导航到 Version Control。 在右侧的 Directory Mappings 区域，你会看到你的项目根目录。（没有就新加一个） 在 VCS 这一列，点击下拉菜单，选择 Perforce。 点击 Apply 和 OK。 ","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/:1:2","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["P4"],"content":"Unreal 按照红框点击，并输入其配置即可 ","date":"2025-07-11","objectID":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/:2:0","tags":["Unreal","Porforce"],"title":"Rider \u0026 Unreal 配置P4V","uri":"/p4-rider%E8%BF%9E%E6%8E%A5p4v/"},{"categories":["Unreal-Lyra"],"content":"Lyra 是怎么动态加载游戏体验的","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"举的例子为 大厅 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:0:0","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"什么是 Experience DataAsset 的动态加载机制 Lyra中是分很多游戏玩法的，他在进入一个新的玩法的时候，就会找到玩法对应的 ULyraExperienceDefinition 的数据，系统根据 ULyraExperienceDefinition 里的内容去激活Game Features、Abilities 和 UI 等。 这样的好处是啥，举个例子： 传统方式（硬编码/硬引用）： 想象一下你走进一家自助餐厅。为了能让你随时吃到任何菜，厨房必须提前把所有菜品都做好并摆出来*。这会导致：* 启动慢： 厨房开工时间长。 资源浪费： 很多菜你根本不吃，但它们依然占着空间和保温的能源（内存）。 Lyra 的动态加载方式： 现在想象你走进一家点餐的餐厅。你拿到一本菜单 (Experience DataAsset)*。菜单上写着各种套餐的描述（比如“西部对决”套餐包含：牛仔Pawn、左轮手枪、沙漠地图UI）。* 启动快： 餐厅开门很快，因为厨房什么都还没做，只是准备好了菜单。 按需加载： 当你点单时（选择了一个 Experience），服务员（ExperienceManagerComponent）才把订单（PrimaryAssetId）交给厨房（AssetManager）。厨房只根据你点的菜去准备，然后上菜。 高效节约： 你没点的菜，就完全不占用厨房的任何资源。 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:1:0","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"动态加载代码流程 void ALyraGameMode::InitGame(const FString\u0026 MapName, const FString\u0026 Options, FString\u0026 ErrorMessage) void ALyraGameMode::HandleMatchAssignmentIfNotExpectingOne() 通过一系列的渠道，获取 ULyraExperienceDefinition， 此 ULyraExperienceDefinition 后面会讲解 void ALyraGameMode::OnMatchAssignmentGiven(FPrimaryAssetId ExperienceId, const FString\u0026 ExperienceIdSource) 获取到 GameState 里的 ULyraExperienceManagerComponent，此Component后面会讲解 void ULyraExperienceManagerComponent::SetCurrentExperience(FPrimaryAssetId ExperienceId) 通过 FPrimaryAssetId 进行加载 获取到里面的各种数据，并且保存 void ULyraExperienceManagerComponent::StartExperienceLoad() 将 ULyraExperienceDefinition 其里面的 DataAsset 包括自己本身 都异步加载出来，加载成功了就调用回调事件 OnExperienceLoadComplete void ULyraExperienceManagerComponent::OnExperienceLoadComplete() 加载需要 ULyraExperienceDefinition 里面 GameFeature 的插件，如果加载完成则调用 OnExperienceFullLoadCompleted void ULyraExperienceManagerComponent::OnExperienceFullLoadCompleted() 需要的数据都已经加载完成，获得所有的GameFeatureAction, 调用其生命周期函数，开始进入GameFeatureAction的表演 并发出 OnExperienceLoaded_HighPriority 等 3个优先级事件，通知接收事件的对象 void ALyraGameMode::OnExperienceLoaded(const ULyraExperienceDefinition* CurrentExperience) 将世界的所有 Playcontroller 遍历一遍，如果满足 Restart条件，则 RestartPlayer(PC) APawn* ALyraGameMode::SpawnDefaultPawnAtTransform_Implementation(AController* NewPlayer, const FTransform\u0026 SpawnTransform) 如果这时候经过 上述函数都是正常的，RestartPlayer(PC) 之后会到这个函数，随后根据我们 ULyraExperienceDefinition 里面的Pawn类生成我们的玩家 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:2:0","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"加载流程牵扯到的类 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:0","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"ALyraGameMode 设计理念 标准AGameModeBase： 通常是游戏规则的中心。 硬编码了许多核心逻辑，比如玩家的 Pawn 类型 (DefaultPawnClass)、玩家控制器类型 (PlayerControllerClass)、游戏状态 (GameStateClass) 等。 如果想换一个游戏模式（比如从“死亡竞赛”换到“夺旗”），你通常需要创建一个全新的 GameMode 子类，并在里面写新的逻辑。 ALyraGameMode： 它本身不包含具体游戏模式的逻辑。它不知道什么是“死亡竞赛”或“据点控制”。 它的设计目标是保持通用性，能够适应任何通过 Experience 定义的游戏玩法。 它将具体的游戏规则和玩家配置“外包”给了 LyraExperienceDefinition。 核心职责 ALyraGameMode 依然承担着 AGameMode 的传统职责，即管理玩家的连接、生成和重生。 他只会读取 ULyraExperienceDefinition 并且通过GameState的 ULyraExperienceManagerComponent 去加载他，随后加载完了，再去生成玩家Pawn。 所以他的核心职责就是推迟玩家Pawn的生成，读取 ULyraExperienceDefinition ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:1","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"ALyraGameState 设计理念 标准 GameStateBase 主要职责是同步那些需要被所有客户端知晓的游戏状态信息，例如比赛时间、分数、队伍信息等。 它的数据通常是被动的，由 GameMode 在服务器上修改，然后自动复制（Replicate）到所有客户端。 它本身很少主动执行复杂的逻辑。 ALyraGameState 继承了所有标准职责：它依然负责同步分数、比赛时间等传统状态。 新增了核心职责：它成为了体验（Experience）和游戏功能插件（Game Features）的管理中心。这是通过它所持有的组件实现的。 它的行为是主动的。它主动管理体验的加载、激活和状态切换，并向全场“广播”当前的状态。 核心职责 将 ExperienceManagerComponent 放在GameState身上，当游戏需要切换到一个新的体验时，负责接收 Experience 的 PrimaryAssetId，通过 AssetManager 异步加载它，并在加载完成后激活它。并激活后，发出事件通知 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:2","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"ULyraExperienceDefinition 结构成员 TArray\u003cFString\u003e GameFeaturesToEnable; 定义了这个体验依赖哪些游戏功能插件 (Game Feature Plugins)。 TObjectPtr\u003cconst ULyraPawnData\u003e DefaultPawnData; 指定了在这个体验中，玩家默认应该被生成为什么样子的Pawn TArray\u003cTObjectPtr\u003cUGameFeatureAction\u003e\u003e Actions; 定义了一系列直接嵌入到这个Experience中的Game Feature Actions。 TArray\u003cTObjectPtr\u003cULyraExperienceActionSet\u003e\u003e ActionSets; 允许你引用一个或多个可复用的功能集合。 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:3","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"ULyraExperienceManagerComponent 核心职责 ULyraExperienceDefinition 结构体 的 管理者 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:3:4","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"一些坑 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:4:0","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"GameModeBase /GameState混用 GameModeBase 与 GameState 不能混用，相反也是一样的道理 这是因为： 网络多人游戏设计：AGameModeBase是游戏模式的基类，它只在服务器上实例化，不会存在于客户端。这意味着AGameModeBase负责定义游戏的核心逻辑和规则，但它并不需要在客户端被复制或同步。 GameState的复制：AGameState（或AGameStateBase）用于存储和同步游戏中的全局状态信息，比如玩家的得分和游戏的当前状态。在网络多人游戏中，AGameState需要被复制到所有客户端以确保所有玩家都有相同的游戏信息。 兼容性问题：当你尝试将AGameState与AGameModeBase一起使用时，会出现兼容性问题，因为AGameModeBase不设计为与需要在客户端复制的AGameState一起工作。这种混合使用会导致运行时错误，因为AGameModeBase不会在客户端存在，而AGameState需要在客户端存在以同步状态。 ","date":"2025-07-10","objectID":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/:4:1","tags":["Unreal","Lyra\""],"title":"Lyra - Experience DataAsset 的动态加载机制","uri":"/lyra-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%B8%B8%E6%88%8F%E4%BD%93%E9%AA%8C/"},{"categories":["Unreal-Lyra"],"content":"UGameFrameworkComponentManager 怎么玩的","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/","tags":["Unreal","Lyra\""],"title":"Lyra - UGameFrameworkComponentManager","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"UGameFrameworkComponentManager 游戏框架组件管理器 是 模块化Gameplay插件（Modular Gameplay plugin） 中的一个 游戏实例子系统（Game Instance Subsystem） 。它可以与 游戏功能插件（Game Feature Plugins）一起使用。 该子系统中实现的函数可以由 游戏功能操作（Game Feature Actions） 用于支持可扩展性。 游戏功能操作由一般Gameplay代码用于协调不同Gameplay对象之间的通信。管理器实现两个基本系统：扩展处理程序（Extension Handlers）和 初始化状态（Initialization States）。 扩展处理程序也就是比如监听所有的Controller，如果有Controller初始化，并且有状态流转都会出发这个扩展处理事件 初始化功能一般都要和 IGameFrameworkInitStateInterface 打配合 ","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:1:0","tags":["Unreal","Lyra\""],"title":"Lyra - UGameFrameworkComponentManager","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"IGameFrameworkInitStateInterface IGameFrameworkInitStateInterface 的作用，就是将一个组件原本混乱、单体的初始化过程（主要挤在BeginPlay里），拆分成一个清晰、有序、分阶段的“生命周期”。 它允许不同组件之间优雅地声明和等待依赖关系，从而构建出可预测、可扩展、无惧异步加载的复杂系统。 在传统的开发模式（全是 BeginPlay）中，剧组就像是一群没有排练过的人，导演一喊“开机”，演员、灯光、摄影、录音全部同时开始干活，结果往往是：演员还没换好衣服摄影就开始拍了，或者灯光还没架好录音就开始录了。在程序里，这就是所谓的“竞态条件” —— 组件 A 还没初始化完数据，组件 B 就尝试去读取它，导致游戏崩溃或逻辑错误。 ","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:2:0","tags":["Unreal","Lyra\""],"title":"Lyra - UGameFrameworkComponentManager","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"IGameFrameworkInitStateInterface的核心接口 virtual FName GetFeatureName() const override { return NAME_ActorFeatureName; } 返回这个组件在 GameFrameworkComponentManager 系统中的唯一标识名称（身份证号） 其他组件如果想查询或依赖这个组件的初始化状态，就必须使用这个函数返回的 FName virtual bool CanChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) const override; 这是一个条件检查函数。当 Manager 尝试将组件的状态从 CurrentState 推进到 DesiredState 时，会调用这个函数来询问：“现在可以进行这个状态转换吗？” virtual void HandleChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) override; 这是一个状态改变回调函数。在 CanChangeInitState 返回 true 并且 Manager 成功地将组件的状态更新后，这个函数会被立即调用。 virtual void OnActorInitStateChanged(const FActorInitStateChangedParams\u0026 Params) override; 这是一个事件监听器。前提是你必须在 BeginPlay 中调用 BindOnActorInitStateChanged() 来注册这个监听。 注册后，当同一个Actor上其他被Manager管理的组件的初始化状态发生变化时，这个函数就会被调用。 virtual void CheckDefaultInitialization() override; 在这个函数内部，你会调用 UGameFrameworkComponentManager 提供的一些工具函数（如 ContinueInitStateChain），来触发一次从当前状态到最终状态的连续转换尝试 ","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:3:0","tags":["Unreal","Lyra\""],"title":"Lyra - UGameFrameworkComponentManager","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"正常工作流程 首先：我们需要在Actor中去注册到 UGameFrameworkComponentManager void AModularCharacter::PreInitializeComponents() { Super::PreInitializeComponents(); UGameFrameworkComponentManager::AddGameFrameworkComponentReceiver(this); // 注册 } void AModularCharacter::BeginPlay() { // 只要他BeginPlay了就会发送扩展事件 并且将自己的状态传递过去 UGameFrameworkComponentManager::SendGameFrameworkComponentExtensionEvent(this, UGameFrameworkComponentManager::NAME_GameActorReady); Super::BeginPlay(); } void AModularCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason) { UGameFrameworkComponentManager::RemoveGameFrameworkComponentReceiver(this); // 移除 Super::EndPlay(EndPlayReason); } 假设我们有4个 FGAmeplayTag： LyraGameplayTags::InitState_Spawned, LyraGameplayTags::InitState_DataAvailable, LyraGameplayTags::InitState_DataInitialized, LyraGameplayTags::InitState_GameplayReady 我们还有两个Component： class LYRAGAME_API ULyraHeroComponent : public UPawnComponent, public IGameFrameworkInitStateInterface class LYRAGAME_API ULyraPawnExtensionComponent : public UPawnComponent, public IGameFrameworkInitStateInterface 所以流程为： 先把这四个注册进去，比如在GameInstance注册： void ULyraGameInstance::Init() { Super::Init(); UGameFrameworkComponentManager* ComponentManager = GetSubsystem\u003cUGameFrameworkComponentManager\u003e(this); if (ensure(ComponentManager)) { ComponentManager-\u003eRegisterInitState(LyraGameplayTags::InitState_Spawned, false, FGameplayTag()); ComponentManager-\u003eRegisterInitState(LyraGameplayTags::InitState_DataAvailable, false, LyraGameplayTags::InitState_Spawned); ComponentManager-\u003eRegisterInitState(LyraGameplayTags::InitState_DataInitialized, false, LyraGameplayTags::InitState_DataAvailable); ComponentManager-\u003eRegisterInitState(LyraGameplayTags::InitState_GameplayReady, false, LyraGameplayTags::InitState_DataInitialized); } } 随后在两个Component初始化，并记得销毁状态（两个Component都一样） void ULyraPawnExtensionComponent::OnRegister() { Super::OnRegister(); // Register with the init state system early, this will only work if this is a game world RegisterInitStateFeature(); } void ULyraPawnExtensionComponent::BeginPlay() { Super::BeginPlay(); // Listen for changes to all features BindOnActorInitStateChanged(NAME_None, FGameplayTag(), false); // Notifies state manager that we have spawned, then try rest of default initialization ensure(TryToChangeInitState(LyraGameplayTags::InitState_Spawned)); CheckDefaultInitialization(); } void ULyraPawnExtensionComponent::EndPlay(const EEndPlayReason::Type EndPlayReason) { UnregisterInitStateFeature(); Super::EndPlay(EndPlayReason); } 只要BeginPlay触发了，CheckDefaultInitialization() 这个就会执行，当然你在其他地方也可以执行，只要满足你的需要 void ULyraPawnExtensionComponent::CheckDefaultInitialization() { // Before checking our progress, try progressing any other features we might depend on CheckDefaultInitializationForImplementers(); static const TArray\u003cFGameplayTag\u003e StateChain = { LyraGameplayTags::InitState_Spawned, LyraGameplayTags::InitState_DataAvailable, LyraGameplayTags::InitState_DataInitialized, LyraGameplayTags::InitState_GameplayReady }; // This will try to progress from spawned (which is only set in BeginPlay) through the data initialization stages until it gets to gameplay ready ContinueInitStateChain(StateChain); } 随后就会执行 CanChangeInitState，每当当前状态通过，返回 true 后，就会调用一次 HandleChangeInitState bool ULyraPawnExtensionComponent::CanChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) const { check(Manager); APawn* Pawn = GetPawn\u003cAPawn\u003e(); if (!CurrentState.IsValid() \u0026\u0026 DesiredState == LyraGameplayTags::InitState_Spawned) { return true; } if (CurrentState == LyraGameplayTags::InitState_Spawned \u0026\u0026 DesiredState == LyraGameplayTags::InitState_DataAvailable) { if (!PawnData) { return false; } return true; } else if (CurrentState == LyraGameplayTags::InitState_DataAvailable \u0026\u0026 DesiredState == LyraGameplayTags::InitState_DataInitialized) { return Manager-\u003eHaveAllFeaturesReachedInitState(Pawn, LyraGameplayTags::InitState_DataAvailable); } else if (CurrentState == LyraGamep","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:4:0","tags":["Unreal","Lyra\""],"title":"Lyra - UGameFrameworkComponentManager","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["Unreal-Lyra"],"content":"协作方法 bool UGameFrameworkComponentManager::HaveAllFeaturesReachedInitState(AActor* Actor, FGameplayTag RequiredState, FName ExcludingFeature) const 询问 “对于指定的这个 Actor（Pawn），所有在 Manager 中注册过的、并且与这个 Actor 相关的功能（Features），是否都已经达到或超过了给定的状态（InitState_DataAvailable）？” bool UGameFrameworkComponentManager::HasFeatureReachedInitState(AActor* Actor, FName FeatureName, FGameplayTag FeatureState) const 它在问 GameFrameworkComponentManager：“嘿，我的同事 PawnExtensionComponent，它是不是已经到达过 DataInitialized 状态？” 注意是：到达过 xxx 状态，也就是说如果目标已经经过这个状态也会返回 true ","date":"2025-07-10","objectID":"/lyra-igameframeworkinitstateinterface/:5:0","tags":["Unreal","Lyra\""],"title":"Lyra - UGameFrameworkComponentManager","uri":"/lyra-igameframeworkinitstateinterface/"},{"categories":["P4"],"content":"下载P4V","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"下载P4V URL: https://portal.perforce.com/s/downloads?product=Helix%20Visual%20Client%20%28P4V%29 ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:1:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"安装后 打开P4V，输入服务器地址和用户名（这些信息在安装服务器或配置 P4 Cloud 时已创建） ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:2:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"创建 Depot（仓库） 安装好 Unreal Engine 和 Perforce P4后，需要为项目创建一个 Depot——即你在 Perforce 服务器上用于存储项目的主目录。 操作步骤如下： 打开 P4V，点击菜单栏 Tools \u003e Administration ，进入 P4 Admin 在 P4 Admin 中切换到 Depots 选项卡 点击菜单 File \u003e New \u003e Depot… 给 depot 命名（例如 “ProjectName”）注意：名称不能包含空格，且一旦设定无法更改 将 Depot 类型设置为默认值 “stream”，然后点击 OK 创建 depot ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:3:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"设置 typemap（类型映射） 在向服务器添加文件之前，你需要设置 typemap，这样 P4 服务器才能正确处理不同类型的文件。例如，当你编辑 .uasset 或 .umap 这类二进制文件时，typemap 可以指示服务器对这些文件进行独占锁定，从而避免多人同时编辑造成的冲突。 此步骤只需在首次设置服务器时执行一次： 在 P4V 的左侧 Depot 面板中右键任意 depot，选择 Open Command Window Here 这将打开一个终端窗口，在终端中输入命令：p4 typemap 此操作将在你的默认文本编辑器（通常是记事本）中打开 typemap 文件 大多数用户可以直接复制粘贴 Game Engine Universal Typemap 保存并关闭文件。如果终端显示 “Typemap saved”，则表示操作成功 ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:4:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"创建 Mainline Stream（主线流） Perforce Streams 可以简化分支和合并操作，自动化开发与发布流程。虽然 Streams 功能非常强大，但建议先从一个 mainline stream 开始，后续再随着项目的发展逐步扩展。 操作步骤如下： 返回 P4V（不是 P4 Admin），点击 File \u003e New \u003e Stream… 为 stream 命名（常见的命名方式是使用简短的项目代码 + “_main”，例如 “ABC_main”） 在 Depot 字段中，选择你刚刚为该项目创建的 streams depot 确保 Stream type（流类型）设置为 mainline 取消勾选 Create a workspace to use with this stream （稍后再做这一步） 取消勾选 Populate the mainline stream after it is created （稍后再做这一步） 稍后会设置 p4ignore 文件，但为了更加安全，可以先确保一些文件夹始终被忽略。切换到“高级”选项卡，在 Ignored 字段中添加以下内容，然后点击“确定”： /Saved/... /Intermediate/... /DerivedDataCache/... /FileOpenOrder/... ","date":"2025-07-07","objectID":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/:5:0","tags":["Unreal","Porforce"],"title":"p4v的下载和使用","uri":"/p4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"categories":["P4"],"content":"如何在ubuntu上搭建p4","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"下载并安装 p4d cd /tmp wget https://www.perforce.com/downloads/perforce/r24.1/bin.linux26x86_64/p4d chmod +x p4d sudo mv p4d /usr/local/bin/ ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"创建服务用户和数据目录 sudo useradd -m perforce sudo mkdir -p /opt/perforce/depots sudo chown -R perforce:perforce /opt/perforce ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"设置环境变量（为 perforce 用户） sudo -i -u perforce bash 会进入到 perforce 命令行 sudo -i -u perforce bash vi ~/.bashrc ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:0","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"添加以下内容 export P4PORT=1666 export P4ROOT=/opt/perforce/depots ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:1","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"生效 source ~/.bashrc ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:2","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"初始化 Perforce 服务端 p4d -r $P4ROOT -p $P4PORT -xi ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:3","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"启动服务 p4d -r $P4ROOT -p $P4PORT ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:4","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["P4"],"content":"配置 systemd 服务 创建服务文件 sudo vi /etc/systemd/system/p4d.service 写入以下内容： [Unit] Description=Perforce Helix Core Server After=network.target [Service] Type=simple User=perforce ExecStart=/usr/local/bin/p4d -r /opt/perforce/depots -p 1666 Restart=on-failure [Install] WantedBy=multi-user.target 启用并启动服务： sudo systemctl daemon-reexec sudo systemctl daemon-reload sudo systemctl enable p4d sudo systemctl start p4d 检查状态 sudo systemctl status p4d 开放防火墙端口（如有需要） sudo ufw allow 1666 ","date":"2025-07-07","objectID":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:0","tags":["Unreal","Porforce"],"title":"Ubuntu搭建P4服务器","uri":"/p4-ubuntu%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 Plugins 介绍","date":"2025-06-16","objectID":"/lyra-plugins/","tags":["Unreal","Lyra"],"title":"Lyra - Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"ModularGameplayActors ","date":"2025-06-16","objectID":"/lyra-plugins/:1:0","tags":["Unreal","Lyra"],"title":"Lyra - Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"作用 Lyra 里的插件 ModularGameplayActors 是整个架构的一个核心部分，用来实现 角色、控制器、HUD 等 Gameplay 类的模块化（Modular）构建机制。它是 Lyra “模块化组件系统” 的基础，支持你以“插件化方式”给 Actor 添加功能，而不是通过硬继承和写死逻辑。 ","date":"2025-06-16","objectID":"/lyra-plugins/:1:1","tags":["Unreal","Lyra"],"title":"Lyra - Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"模块化系统的核心目标 传统方式的问题： 你通常会在 MyCharacter、MyPlayerController、MyHUD 里硬编码各种行为，比如：初始化输入/初始化技能系统组件/初始化 UI 控制逻辑 但这样：很难复用/不利于热更、插件式内容扩展/玩家控制器和角色之间的耦合度太高 ModularGameplayActors 将这些逻辑解耦成一个个“模块化组件”，通过注册自动注入到对应 Actor（如 Pawn, Controller, HUD）中。 ","date":"2025-06-16","objectID":"/lyra-plugins/:1:2","tags":["Unreal","Lyra"],"title":"Lyra - Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"此插件的主要功能 模块化 Actor 生命周期管理：支持在特定时机（如 Controller 初始化、Pawn Possess 等）注册模块组件 动态挂载组件：可以在运行时给 Pawn/Controller 添加组件（如 ULyraHeroComponent） 支持 GameFeature 插件动态注册组件：GameFeature 激活时可以给现有 Actor 动态添加模块逻辑 按类型分组扩展点：拥有像 ExtensionEvent-BindInputsNow、OnPawnExtensionAdded 等事件点 ","date":"2025-06-16","objectID":"/lyra-plugins/:1:3","tags":["Unreal","Lyra"],"title":"Lyra - Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"核心类说明 UGameFrameworkComponentManager 它负责监听 Pawn、Controller、HUD 等的创建事件，并调用注册的扩展。 这个语句会触发所有注册到该事件的组件（如 ULyraHeroComponent）执行绑定。 UGameFrameworkComponentManager::SendGameFrameworkComponentExtensionEvent(Pawn, NAME_BindInputsNow); UModularPawn / UModularPlayerController 等 这些是 Lyra 扩展出来的基类，继承自引擎默认的 APawn / APlayerController 等。 它们的特点： 自动调用 UGameFrameworkComponentManager 的初始化逻辑 支持组件注册、事件派发等 ","date":"2025-06-16","objectID":"/lyra-plugins/:1:4","tags":["Unreal","Lyra"],"title":"Lyra - Plugins","uri":"/lyra-plugins/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 GAS 流程","date":"2025-06-09","objectID":"/lyra-gas/","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"GAS 与 Input 调用 经过游戏体验DataAsset和一系列的组件初始化加载后，在 LyraHeroComponent 绑定按键 /* 此函数是技能函数，比如鼠标左键枪开火 在 ULyraInputConfig 里配置 AbilityInputActions */ LyraIC-\u003eBindAbilityActions(InputConfig, this, \u0026ThisClass::Input_AbilityInputTagPressed, \u0026ThisClass::Input_AbilityInputTagReleased, /*out*/ BindHandles); 在绑定了按键后，会在ASC的 void ULyraAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag\u0026 InputTag) 留下记录 void ULyraAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag\u0026 InputTag) { if (InputTag.IsValid()) { for (const FGameplayAbilitySpec\u0026 AbilitySpec : ActivatableAbilities.Items) { if (AbilitySpec.Ability \u0026\u0026 (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))) { InputPressedSpecHandles.AddUnique(AbilitySpec.Handle); InputHeldSpecHandles.AddUnique(AbilitySpec.Handle); } } } } 自然松开的时候，会调用ASC的void ULyraAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag\u0026 InputTag) 并留下相对应的记录 void ULyraAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag\u0026 InputTag) { if (InputTag.IsValid()) { for (const FGameplayAbilitySpec\u0026 AbilitySpec : ActivatableAbilities.Items) { if (AbilitySpec.Ability \u0026\u0026 (AbilitySpec.GetDynamicSpecSourceTags().HasTagExact(InputTag))) { InputReleasedSpecHandles.AddUnique(AbilitySpec.Handle); InputHeldSpecHandles.Remove(AbilitySpec.Handle); } } } } 在然后，ALyraPlayerController中会Tick调用void ALyraPlayerController::PostProcessInput(const float DeltaTime, const bool bGamePaused) 随后检索一些TArray记录下来的东西，通过 TryActivateAbility(AbilitySpecHandle); 调用到实际技能 ","date":"2025-06-09","objectID":"/lyra-gas/:1:0","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"从武器到技能 举个例子， 比如是捡到枪，或者默认装备枪，随后鼠标左键开火，这其实就是一个开枪技能 ","date":"2025-06-09","objectID":"/lyra-gas/:2:0","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"装备技能 捡到枪并且装备是通过 Lyra 的 Equipment系统和Inventory系统来实现的，在这里不详细讲，但是此时有一个ULyraEquipmentDefinition 中会记录一个 ULyraAbilitySet，里面有见到这个枪就会装备什么GameAbility技能，以及GameEffect效果，还有AttributeSet属性数值，这时候就会将GameAbility技能给GiveAbility装备上去 ","date":"2025-06-09","objectID":"/lyra-gas/:2:1","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"技能的实现 创建一个GA类，不管是蓝图还是c++，GameplayAbility有以下比较重要的接口 virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const override; 判断是否可以激活此技能，在 TryActivateAbility 后，其实会进行一系列的检查，此接口就在其中 virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData) override; 在经过一系列技能检查后就会触发，也就是此技能的核心逻辑，比如播放蒙太奇，然后蒙太奇播放完调用 EndAbility virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled) override; 技能结束的核心逻辑写在这个函数，但是记住这个函数不代表跟技能相关的实例就会销毁 virtual void InputPressed(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) override;* 此函数的作用就在于，如果是通过按键去触发技能，那么在按下键的时候就会触发 virtual void InputReleased(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) override; 抬起键的时候触发 随后不管c++还是蓝图，将其 InstancingPolicy 修改为：InstancedPerActor，此参数有以下几种： NonInstanced：此能力从未实例化。任何执行此能力的操作都是在 CDO 上进行的。 InstancedPerActor：当这个 Ability 被授予给一个 Actor 时，系统会为这个 Actor 创建一个全新的 UGameplayAbility 对象实例。如果 10 个不同的 Actor 都被授予了这个 Ability，内存中就会有 10 个独立的 Ability 对象。 InstancedPerExecution：当这个 Ability 被授予时，系统不会立即创建实例。只有在每次这个 Ability 被激活 (ActivateAbility) 时，系统才会临时创建一个新的 Ability 对象实例。当这个 Ability 执行完毕并结束 (EndAbility) 时，这个临时的实例会被立即销毁（垃圾回收）。 随后还得将一个变量Ability Triggers修改，将你的按键绑定的Tag输入进去，这样就可以将按键跟技能上面关联上啦 ","date":"2025-06-09","objectID":"/lyra-gas/:2:2","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"检测到伤害目标 这里不详细讲如何检测到伤害目标（可能后续会更新？），比如枪发射子弹，就发出射线，进行扫描。如果是近战武器，则利用动画通知去生成碰撞盒子，来进行伤害目标 如果要在这拿到GA实例，只要能拿到ASC，则可以利用 ASC-\u003eGetActivatableAbilities()，拿到所有激活的技能Spec，在通过 AbilitySpec.GetPrimaryInstance() Cast 成你的GA实例就好了 ","date":"2025-06-09","objectID":"/lyra-gas/:2:3","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"应用GE 这时候我们就会有目标Actor了，我们获取到自己的ASC和Target的ASC，可以利用如下代码，创建GameplayEffectSpecHandle，并且应用 FGameplayEffectSpecHandle DamageSpecHandle = MakeOutgoingGameplayEffectSpec(DamageEffect, GetAbilityLevel()); if (DamageSpecHandle.IsValid()) { SourceASC-\u003eApplyGameplayEffectSpecToTarget(*DamageSpecHandle.Data.Get(), TargetASC); } 好，这时候注意力来到 我们创建的GE，GE也有着很多的属性，我们关注点先放在Gameplay Effect Modifiers：这个可以应用比较简单的Attributes。比如直接将Health -\u003e Add -\u003e -10，这样每次攻击，都会对Target扣10点血。但是这样缺点就是不灵活，因为这个伤害值计算确实很复杂，比如lyra的枪，他有距离衰减，物理散射，包括打头伤害更高之类的，所以就需要 Executions Executions：我们可以创建一个 UGameplayEffectExecutionCalculation 的子类，这个类就可以帮助我们去算伤害的具体值，这个类的执行就是在应用AttricuteSet之前，所以我们可以直接操作他的伤害值 ","date":"2025-06-09","objectID":"/lyra-gas/:2:4","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"GameplayEffectContext 再聊到具体的 Executions 之前还得聊一聊这个，这个其实就是 GameplayEffect 的上下文，也就是储存着 GE 通知 AttricuteSet的各种信息，我们继承于这个Struct FGameplayEffectContext，这样就可以塞我们自己自定义的任何信息，比如伤害接口的伤害倍数，在这个struct有如下接口需要注意下，有可能用到： // ~Begin FGameplayEffectContext Interface virtual FGameplayEffectContext* Duplicate() const override; // 进行拷贝结构体的 virtual UScriptStruct* GetScriptStruct() const override; // 获取当前 GameplayEffectContext 实例的实际 UStruct 类型。 virtual bool NetSerialize(FArchive\u0026 Ar, class UPackageMap* Map, bool\u0026 bOutSuccess) override; // 进行网络复制 // ~End FGameplayEffectContext Interface 我们如果想要我们自定义的生效，必须重写AbilitySystemGlobals方法，并且在Project Setting里 设置我们默认的 AbilitySystemGlobals 类 并且要在 我们的GA中 重写 virtual FGameplayEffectContextHandle MakeEffectContext(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo) const override; 在这个函数里面去初始化我们的GEContext哦 ","date":"2025-06-09","objectID":"/lyra-gas/:2:5","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"AbilitySystemGlobals virtual FGameplayEffectContext* AllocGameplayEffectContext() const override; FGameplayEffectContext* USAbilitySystemGlobals::AllocGameplayEffectContext() const { return new FSGameplayEffectContext(); } ","date":"2025-06-09","objectID":"/lyra-gas/:2:6","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"Executions 好了，终于回到了我们的Executions，我们重写 virtual void Execute_Implementation(const FGameplayEffectCustomExecutionParameters\u0026 ExecutionParams, FGameplayEffectCustomExecutionOutput\u0026 OutExecutionOutput) const override;方法 ExecutionParams：这个参数就是带有各种数据，比如SourceASC，TargetASC OutExecutionOutput：这个参数就是我们要给AttricuteSets的数据，所以我们弄好了伤害具体数值后就可以通过这个直接扔过去 我们要注意 比如我们拿一个 BaseDamage，这个基础伤害，我们要通过FGameplayEffectAttributeCaptureDefinition 这个结构体去拿 struct FDamageStatics { FGameplayEffectAttributeCaptureDefinition BaseDamageDef; FDamageStatics() { BaseDamageDef = FGameplayEffectAttributeCaptureDefinition(USCombatSet::GetBaseDamageAttribute(), EGameplayEffectAttributeCaptureSource::Source, true); } }; static FDamageStatics DamageStatics() { static FDamageStatics Statics; return Statics; } USDamageExecution::USDamageExecution() { RelevantAttributesToCapture.Add(DamageStatics().BaseDamageDef); } 如上方代码所示，我们初始化的三个参数的意思分别为： USCombatSet::GetBaseDamageAttribute()：到我们的这个AttricuteSet去拿一个 Attricute EGameplayEffectAttributeCaptureSource::Source：是从Source拿 不是从Target拿 True: 是否拍快照，这个基本都是true，要不然你的数据可能会被污染 然后我们放在RelevantAttributesToCapture里，通过一下方式去拿： FAggregatorEvaluateParameters EvaluateParameters; EvaluateParameters.SourceTags = SourceTags; EvaluateParameters.TargetTags = TargetTags; float BaseDamage = 0.0f; ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(DamageStatics().BaseDamageDef, EvaluateParameters, BaseDamage); 我们最后通过拿到准确数据后就塞到数据里 返回回去： OutExecutionOutput.AddOutputModifier(FGameplayModifierEvaluatedData(USHealthSet::GetDamageAttribute(), EGameplayModOp::Additive, DamageDone)); Lyra是通过WeaponInstance计算好具体的倍数，然后继承了一个接口，送到这里来的 最后别忘记要在GE把这个Executions设置进去哦 ","date":"2025-06-09","objectID":"/lyra-gas/:2:7","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"应用AttributeSet 好了 这下数据都来AttributeSet了，我们就要修改角色身上的Attribute了，这Set也有几个很关键的接口 virtual bool PreGameplayEffectExecute(FGameplayEffectModCallbackData\u0026 Data) override; virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData\u0026 Data) override; virtual void PreAttributeBaseChange(const FGameplayAttribute\u0026 Attribute, float\u0026 NewValue) const override; virtual void PreAttributeChange(const FGameplayAttribute\u0026 Attribute, float\u0026 NewValue) override; virtual void PostAttributeChange(const FGameplayAttribute\u0026 Attribute, float OldValue, float NewValue) override; ","date":"2025-06-09","objectID":"/lyra-gas/:2:8","tags":["Unreal","GAS","Lyra"],"title":"Lyra - GAS","uri":"/lyra-gas/"},{"categories":["Unreal-Lyra"],"content":"Lyra 里的 Input","date":"2025-06-09","objectID":"/lyra-input/","tags":["Unreal","Lyra"],"title":"Lyra - 输入系统","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"前言 需要你先了解： Lyra 架构解析：Experience DataAsset 的动态加载机制 ","date":"2025-06-09","objectID":"/lyra-input/:1:0","tags":["Unreal","Lyra"],"title":"Lyra - 输入系统","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"Lyra 基础 Input 流程 void ULyraHeroComponent::HandleChangeInitState(UGameFrameworkComponentManager* Manager, FGameplayTag CurrentState, FGameplayTag DesiredState) 经历过加载游戏体验的DataAsset后，就来到了这个函数 void ULyraHeroComponent::InitializePlayerInput(UInputComponent* PlayerInputComponent) 这边就是初始化Input的一个重要函数，他会去拿到你的游戏体验中配置的InputConfig的信息，从而拿到 FInputMappingContextAndPriority 具体的信息 要注意，你需要建立一个 GameFeature 然后利用LyraDataAsset 将InputMappingContext 提前加载进内存，否则判断不会进去 你还要注意将项目设置里面的 UEnhancedInputComponent 给替换成自己实现的类，随后就是绑定输入了 蓝图中创建 InputAction 和 InputMappingContext 自己配置好其对应的游戏体验DataAsset 即可 LyraIC-\u003eBindAbilityActions(InputConfig, this, \u0026ThisClass::Input_AbilityInputTagPressed, \u0026ThisClass::Input_AbilityInputTagReleased, /*out*/ BindHandles); /* 此函数是技能函数，比如鼠标左键枪开火 在 ULyraInputConfig 里配置 AbilityInputActions */ /* 此函数则是配置一些角色基本移动输入 在 ULyraInputConfig 里配置 NativeInputActions */ LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_Move, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_Move, /*bLogIfNotFound=*/ false); LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_Look_Mouse, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_LookMouse, /*bLogIfNotFound=*/ false); LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_Look_Stick, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_LookStick, /*bLogIfNotFound=*/ false); LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_Crouch, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_Crouch, /*bLogIfNotFound=*/ false); LyraIC-\u003eBindNativeAction(InputConfig, LyraGameplayTags::InputTag_AutoRun, ETriggerEvent::Triggered, this, \u0026ThisClass::Input_AutoRun, /*bLogIfNotFound=*/ false); ","date":"2025-06-09","objectID":"/lyra-input/:2:0","tags":["Unreal","Lyra"],"title":"Lyra - 输入系统","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"要记住的点 需要在项目设置手动指定增强输入的setting类 Mouse上下移动的方向 [/Script/LyraGame.LyraPlayerController] InputYawScale=1.0 InputPitchScale=1.0 InputRollScale=1.0 ForceFeedbackScale=1.0 Lyra 是靠这个 来使得我们鼠标向上滑就是人往天看，InputPitchScale默认值是-2.5，如果是默认值，效果则反之 ","date":"2025-06-09","objectID":"/lyra-input/:3:0","tags":["Unreal","Lyra"],"title":"Lyra - 输入系统","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"相关类与结构体 ","date":"2025-06-09","objectID":"/lyra-input/:4:0","tags":["Unreal","Lyra"],"title":"Lyra - 输入系统","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"ULyraInputConfig 作用 如何定义 GameplayTag 与 InputAction 的映射 接口与方法 FLyraInputAction 该结构体用于将输入操作映射到游戏玩法的输入标签上。 FindNativeInputActionForTag 根据 GameplayTag来搜索 NativeInputAction FindAbilityInputActionForTag 根据 GameplayTag来搜索 AbilityInputAction 成员变量说明 NativeInputActions：就是WASD这些有关基本操作的 AbilityInputActions: 跟技能相关的，只要跟GAS有关联，都可放这里 ","date":"2025-06-09","objectID":"/lyra-input/:4:1","tags":["Unreal","Lyra"],"title":"Lyra - 输入系统","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"ULyraInputComponent 作用 用于通过输入配置数据资产来管理输入映射和绑定的组件。说白了就是处理ULyraInputConfig数据CURD的 接口与方法 不多说，基本每个方法直接看就能看出来 都是CURD ","date":"2025-06-09","objectID":"/lyra-input/:4:2","tags":["Unreal","Lyra"],"title":"Lyra - 输入系统","uri":"/lyra-input/"},{"categories":["Unreal-Lyra"],"content":"UGameFeatureAction_AddInputContextMapping 作用 给本地玩家添加输入映射: 自动添加 InputMappingContext 到 EnhancedInputSubsystem 中 和 GameInstance / LocalPlayer 生命周期关联：玩家加入时会自动添加；玩家离开时自动移除 支持优先级和是否注册到 Settings 的配置：每个 IMC 可以设置优先级、是否保存到设置中 核心结构体：FInputMappingContextAndPriority InputMapping: 要添加的输入映射资源（IMC） Priority: 优先级（高的优先） bRegisterWithSettings: 是否写入用户设置中（用户可以修改的那种） 生命周期函数 virtual void OnGameFeatureRegistering() override; virtual void OnGameFeatureActivating(FGameFeatureActivatingContext\u0026 Context) override; virtual void OnGameFeatureDeactivating(FGameFeatureDeactivatingContext\u0026 Context) override; virtual void OnGameFeatureUnregistering() override; GameFeature GameFeature 是 UE5 引入的一个 模块化插件系统，主要目标是： Feature 插件 功能 InputMapping 添加新的输入操作映射 Weapon_AR 加入一个步枪的逻辑、资源、蓝图 UI_HUD 添加一个特定的 HUD 或菜单界面 Ability_Fireball 加入一个技能火球术 每个 GameFeature 插件都能控制： 加载哪些资源（IMC、AbilitySet、蓝图、DataAsset…） 在哪个状态执行（只在服务器？只在客户端？） 在哪张地图中生效 ","date":"2025-06-09","objectID":"/lyra-input/:4:3","tags":["Unreal","Lyra"],"title":"Lyra - 输入系统","uri":"/lyra-input/"},{"categories":["3D图形学"],"content":"矩阵的变换习题","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"题目 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 的定义为 $ \\tau(x, y, z) = (x + y, x - 3, z) $ 。那么，$ \\tau $ 是一种线性变换吗？如果是，求出它 的标准矩阵表示。 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 的定义为 $ \\tau(x, y, z) = (3x + 4z, 2x - z, x + y + z) $ 。那么，$ \\tau $ 是一种线性变换吗？如果是，求出它的标准矩阵表示。 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 是一种线性变换，而且 $ \\tau(1, 0, 0) = (3, 1, 2)，\\tau(0, 1, 0) = (2, -1, 3)，\\tau(0, 0, 1) = (4, 0, 2) $, 求 $ \\tau(1, 1, 1)$ 构建一个缩放矩阵，使物体在 x 轴方向上放大 2 倍，在 y 轴方向上放大 − 3 倍，在 z 轴方向上保持不变。 构建一个旋转矩阵，使物体绕轴(1, 1, 1)旋转 30° 构建一个平移矩阵，使物体沿 x 轴正方向平移 4 个单位，在 y 轴方向保持不变，沿 z 轴正方向平移−9 个单位。 构建一个单独的变换矩阵，首先使物体在 x 轴方向上放大 2 倍，在 y 轴方向上放大−3 倍，在 z 轴上保持不变。接着将物体沿 x 轴正方向平移 4 个单位，在 y 轴上保持不变，沿 z 轴正方向平移 −9 个单位。 构建一个单独的变换矩阵，首先令物体绕 y 轴旋转 45° 。接着使之沿 x 轴正方向平移−2 个单位， 沿 y 轴正方向平移 5 个单位，最后沿 z 轴正方向平移 1 个单位。 重新计算例 3.2，但是这次使其中的正方形在 x 轴方向上放大 1.5 倍，在 y 轴方向上缩小至 0.75 倍，在 z 轴上保持不变。最后，绘制出变换前后的几何体，以确定所得到结果是否正确。 重新计算例 3.2，但是这次使其中的正方形在 x 轴方向上放大 1.5 倍，在 y 轴方向上缩小至 0.75 倍，在 z 轴上保持不变。最后，绘制出变换前后的几何体，以确定所得到结果是否正确。 重新计算例 3.4，此次将该正方形在 x 轴正方向平移−5 个单位，在 y 轴正方向平移−3.0 个单位， 沿 z 轴正方向平移 4.0 个单位。最后，画出变换前后的几何体，确认所得到结果的正确性。 ** ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:1:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第一题 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 的定义为 $ \\tau(x, y, z) = (x + y, x - 3, z) $ 。那么，$ \\tau $ 是一种线性变换吗？如果是，求出它 的标准矩阵表示。 $$ \\begin{align*} \\tau(\\vec{u} + \\vec{v}) \u0026= \\tau(u_x + v_x, u_y + v_y, u_z + v_z) \\\\ \\\\ \u0026= (u_x + v_x + u_y + v_y, u_x + v_x -3, u_z + v_z) \\\\ \\\\ \\tau{\\vec{u}} + \\tau{\\vec{v}} \u0026= (u_x + u_y, u_x - 3, u_z) + (v_x + v_y, v_x - 3, v_z) \\\\ \\\\ \u0026= (u_x + v_x + u_y + v_y, u_x + v_x - 6, u_z + v_z) \\\\ \\\\ \\tau(\\vec{u} + \\vec{v}) \u0026\\neq \\tau{\\vec{u}} + \\tau{\\vec{v}} \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:2:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第二题 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 的定义为 $ \\tau(x, y, z) = (3x + 4z, 2x - z, x + y + z) $ 。那么，$ \\tau $是一种线性变换吗？如果是，求出它的标准矩阵表示。 $$ \\begin{align*} \\tau(\\vec{u} + \\vec{v}) \u0026= \\tau(u_x + v_x, u_y + v_y, u_z + v_z) \\\\ \\\\ \u0026= (3u_x + 3v_x + 4u_z + 4v_z, 2u_x + 2v_x - u_z - v_z, u_x + v_x + u_y + v_y + u_z + v_z) \\\\ \\\\ \\tau{\\vec{u}} + \\tau{\\vec{v}} \u0026= (3u_x + 4u_z, 2u_x - u_z, u_x + u_y + u_z) + (3v_x + 4v_z, 2v_x - v_z, v_x + v_y + v_z) \\\\ \\\\ \u0026= (3u_x + 3v_x + 4u_z + 4v_z, 2u_x + 2v_x - u_z - v_z, u_x + v_x + u_y + v_y + u_z + v_z) \\\\ \\\\ \\tau({k\\vec{u}}) \u0026= \\tau(ku_x, ku_y, ku_z) \\\\ \\\\ \u0026= (3ku_x + 4ku_z, 2ku_x - ku_z, ku_x + ku_y + ku_z) \\\\ \\\\ k\\tau({u}) \u0026= k(3u_x + 4u_z, 2u_x - u_z, u_x + u_y + u_z) \\\\ \\\\ \u0026= (3ku_x + 4ku_z, 2ku_x - ku_z, ku_x + ku_y + ku_z) \\\\ \\\\ 因为 \u0026~ \\tau(\\vec{u} + \\vec{v}) = \\tau{\\vec{u}} + \\tau{\\vec{v}} ~ 并且 ~ \\tau({k\\vec{u}}) = k\\tau({u}) \\\\ \\\\ 故 \u0026~ \\tau ~ 为线性变换 \\\\ \\\\ \\tau(x, y, z) \u0026= (3x + 4z, 2x - z, x + y + z) \\\\ \\\\ \u0026= \\begin{bmatrix} 3x + 0y + 4z \\\\ \\\\ 2x + 0y - z \\\\ \\\\ x + y + z \\end{bmatrix} \\\\ \\\\ \u0026 \\begin{bmatrix} 3 \u0026 0 \u0026 4 \\\\ \\\\ 2 \u0026 0 \u0026 -1 \\\\ \\\\ 1 \u0026 1 \u0026 1 \\end{bmatrix} \\begin{bmatrix} x \\\\ \\\\ y \\\\ \\\\ z \\end{bmatrix} = \\begin{bmatrix} 3x + 0y + 4z \\\\ \\\\ 2x + 0y - z \\\\ \\\\ x + y + z \\end{bmatrix} \\\\ \\\\ \u0026 所以 ~ \\tau ~ 的标准矩阵为 ~~~ \\begin{bmatrix} 3 \u0026 0 \u0026 4 \\\\ \\\\ 2 \u0026 0 \u0026 -1 \\\\ \\\\ 1 \u0026 1 \u0026 1 \\end{bmatrix} \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:3:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第三题 设 $ \\tau = \\mathbb{R}^3 → \\mathbb{R}^3 $ 是一种线性变换，而且 $ \\tau(1, 0, 0) = (3, 1, 2)，\\tau(0, 1, 0) = (2, -1, 3)，\\tau(0, 0, 1) = (4, 0, 2) $, 求 $ \\tau(1, 1, 1)$ $$ \\begin{align*} A \u0026= \\begin{bmatrix} 3 \u0026 1 \u0026 2 \\\\ \\\\ 2 \u0026 -1 \u0026 3 \\\\ \\\\ 4 \u0026 0 \u0026 2 \\end{bmatrix} \\\\ \\\\ \\tau(1, 1, 1) \u0026= \\begin{bmatrix} 1 \u0026 1 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 3 \u0026 1 \u0026 2 \\\\ \\\\ 2 \u0026 -1 \u0026 3 \\\\ \\\\ 4 \u0026 0 \u0026 2 \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} 3 + 2 + 4 \u0026 1 - 1 + 0 \u0026 2 + 3 + 2 \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} 9 \u0026 0 \u0026 7 \\end{bmatrix} \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:4:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第四题 构建一个缩放矩阵，使物体在 x 轴方向上放大 2 倍，在 y 轴方向上放大 − 3 倍，在 z 轴方向上保持不变。 $$ \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 -3 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:5:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第五题 构建一个旋转矩阵，使物体绕轴(1, 1, 1)旋转 30° $$ \\begin{align*} \u0026 1. 首先将轴向量(1, 1, 1) 规范为单位向量 \\\\ \\\\ \\vec{u} \u0026= \\frac{(1, 1, 1)}{\\sqrt{1^2 + 1^2 + 1^2}} \\\\ \\\\ \u0026= (\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}) \\\\ \\\\ \u0026 2. 我们再构建其旋转矩阵 \\\\ \\\\ R_n \u0026= \\begin{bmatrix} c + (1 - c)x^2 \u0026 (1-c)xy + sz \u0026 (1-c)xz - sy \\\\ \\\\ (1-c)xy - sz \u0026 c + (1 - c)y^2 \u0026 (1-c)yz + sx \\\\ \\\\ (1-c)xz + sy \u0026 (1-c)yz - sx \u0026 c + (1-c)z^2 \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} \\frac{\\sqrt{3}}{2} + \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) \u0026 \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) - \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \u0026 \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) + \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \\\\ \\\\ \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) + \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \u0026 \\frac{\\sqrt{3}}{2} + \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) \u0026 \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) - \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \\\\ \\\\ \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) - \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \u0026 \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) + \\frac{1}{\\sqrt{3}}\\cdot\\frac{1}{2} \u0026 \\frac{\\sqrt{3}}{2} + \\frac{1}{3}\\left(1-\\frac{\\sqrt{3}}{2}\\right) \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} \\frac{2\\sqrt{3} + 2}{6} \u0026 \\frac{1}{3} \u0026 \\frac{1 - \\sqrt{3}}{3} \\\\ \\\\ \\frac{1 - \\sqrt{3}}{3} \u0026 \\frac{2\\sqrt{3} + 2}{6} \u0026 \\frac{1}{3} \\\\ \\\\ \\frac{1}{3} \u0026 \\frac{1 - \\sqrt{3}}{3} \u0026 \\frac{2\\sqrt{3} + 2}{6} \\end{bmatrix} \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:6:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第六题 构建一个平移矩阵，使物体沿 x 轴正方向平移 4 个单位，在 y 轴方向保持不变，沿 z 轴正方向平移−9 个单位。 $$ \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 4 \u0026 1 \u0026 -9 \u0026 1 \\end{bmatrix} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:7:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第七题 构建一个单独的变换矩阵，首先使物体在 x 轴方向上放大 2 倍，在 y 轴方向上放大−3 倍，在 z 轴上保持不变。接着将物体沿 x 轴正方向平移 4 个单位，在 y 轴上保持不变，沿 z 轴正方向平移 −9 个单位。 $$ S = \\begin{bmatrix} 2 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 -3 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} ~~~~~~~~~~~~~~ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 4 \u0026 0 \u0026 -9 \u0026 1 \\end{bmatrix} \\\\ \\\\ \\\\ \\\\ ST = \\begin{bmatrix} 2 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 -3 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 4 \u0026 0 \u0026 -9 \u0026 1 \\end{bmatrix} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:8:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第八题 构建一个单独的变换矩阵，首先令物体绕 y 轴旋转 45° 。接着使之沿 x 轴正方向平移−2 个单位， 沿 y 轴正方向平移 5 个单位，最后沿 z 轴正方向平移 1 个单位。 $$ R = \\begin{bmatrix} \\cos45^\\circ \u0026 0 \u0026 -\\sin45^\\circ \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\ \\sin45^\\circ \u0026 0 \u0026 \\cos45^\\circ \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{bmatrix} = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 -\\frac{\\sqrt{2}}{2} \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\ \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 \\frac{\\sqrt{2}}{2} \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{bmatrix} ~~~~~~~~~ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ -2 \u0026 5 \u0026 1 \u0026 1 \\end{bmatrix} \\\\ \\\\ RT = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 -\\frac{\\sqrt{2}}{2} \u0026 -\\sqrt{2} \\\\ 0 \u0026 1 \u0026 0 \u0026 5 \\\\ \\\\ \\frac{\\sqrt{2}}{2} \u0026 0 \u0026 \\frac{\\sqrt{2}}{2} \u0026 -\\frac{\\sqrt{2}}{2} \\\\ \\\\ -2 \u0026 5 \u0026 1 \u0026 1 \\end{bmatrix} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:9:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"矩阵的变换","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"变换矩阵 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"定义 先来研究一下数学函数 $ \\tau(\\vec{v}) = \\tau(x, y, z) = (x’, y’, z’) $。此函数的输入和输出都是 3D 向量。 我们称 τ 为 线性变换（linear transformation），当且仅当此函数具有下列性质： $ \\tau(\\vec{u} + \\vec{v}) = \\tau{\\vec{u}} + \\tau{\\vec{v}} $ $ \\tau({k\\vec{u}}) = k\\tau({u}) $ 其中，$ \\vec{u} = (u_x, u_y, u_z)和 \\vec{v} = (v_x, v_y, v_z) $是任意 3D 向量，k 为一个标量。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:1","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"示例 定义函数 $ \\tau(x, y, z) = (x^2, y^2, z^2) $, 例如 $ \\tau(1, 2, 3) = (1, 4, 9) $ 这个函数是非线性函数，因为当 k=2 且 $ \\vec{u} = (1, 2, 3) $时 $$ \\tau(k\\vec{u}) = \\tau(2，4，6) = (4, 16, 36) $$ 但 $$ k\\tau(u) = 2(1,4,9) = (2,8,18) $$ 因此，该函数不满足刚刚说的第二条性质 如果$ \\tau $ 是线性函数，那么有 $$ \\begin{align*} \\tau(a\\vec{u} + b\\vec{v} + c\\vec{w}) \u0026= \\tau(a\\vec{u} + (b\\vec{v} + c\\vec{w})) \\\\ \\\\ \u0026= a\\tau(\\vec{u}) + \\tau(b\\vec{v} + c\\vec{w}) \\\\ \\\\ \u0026= a\\tau(\\vec{u}) + b\\tau(\\vec{v}) + c\\tau(\\vec{w}) \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:2","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵表示法 设 $ \\vec{u} = (x, y, z) $，我们也可以将它写作 $$ \\vec{u} = (x, y, z) = x\\vec{i} + y\\vec{j} + z\\vec{k} = x(1, 0, 0) + y(0,1,0) + z(0,0,1) $$ $ \\vec{i} = (1, 0, 0)， \\vec{j} = (0, 1, 0)， \\vec{k} = (0, 0, 1) $ 分别表示位于当前坐标轴正方向上得3个单位向量，我们称之为 $ \\mathbb{R}^3 $（表示所有的3D坐标向量的集合）的标准基向量 现假设 $ \\tau $ 是一种线性变换，根据他的线性性质能够得到 $$ \\tau(u) = \\tau(x\\vec{i}, y\\vec{j}, z\\vec{k}) = x\\tau\\vec{i} + y\\tau\\vec{j} + z\\tau\\vec{k} $$ 可以看出，这个公式其实就是线性组合，可以表示为向量与矩阵的乘积。 这个公式还可以进一步优化： $$ \\begin{align} \\tau\\vec{u} \u0026= x\\tau\\vec{i} + y\\tau\\vec{j} + z\\tau\\vec{k} \\\\ \\\\ \u0026= \\vec{u}A \\\\ \\\\ \u0026= [x, y, z] \\begin{bmatrix} \\leftarrow \\tau(\\vec{i}) \\rightarrow \\\\ \\\\ \\leftarrow \\tau(\\vec{j}) \\rightarrow \\\\ \\\\ \\leftarrow \\tau(\\vec{k}) \\rightarrow \\end{bmatrix} \\\\ \\\\ \u0026= [x, y, z] \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\end{align} $$ 其中 $ \\tau\\vec{i} = A_{11}, A_{12}, A_{13}，\\tau\\vec{j} = A_{21}, A_{22}, A_{23}，\\tau\\vec{k} = A_{31}, A_{32}, A_{33} $。 我们称矩阵 A 是线性变换 τ 的矩阵表示法。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:3","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"缩放 缩放（scaling，也有译作比例变换）是指改变物体的大小 我们把缩放定义为 $$ S(x, y, z) = (s_x x, s_y y, s_z z) $$ 此变换将相对于当前坐标系中的原点，令向量在 x, y, z 轴上分别以系数 $ s_x, s_y, s_z $ 进行缩放 下面证明 S 其实就是一种线性变换: $$ \\begin{align} S(\\vec{u} + \\vec{v}) \u0026= (s_x(u_x + v_x), s_y(u_y, v_y), sz(u_z + v_z)) \\\\ \\\\ \u0026= (s_x u_x + s_x v_x, s_y u_y + s_y v_y, s_z u_z + s_z v_z) \\\\ \\\\ \u0026= (s_x u_x, s_y u_y, s_z u_z) + (s_x v_x, s_y v_y, s_z v_z) \\\\ \\\\ \u0026= S(\\vec{u}) + S(\\vec{v}) \\\\ \\\\ S(k\\vec{u}) \u0026= (s_x k u_x, s_y k u_y, s_z k u_z) \\\\ \\\\ \u0026= k(s_x u_x, s_y u_y, s_z u_z) \\\\ \\\\ \u0026= kS(\\vec{u}) \\end{align} $$ 因此，缩放变换 S 满足上述所有的性质。 这也就是说，S是线性变换并存在一种矩阵表示法。 为了求出S的矩阵表示，我们只需把每一个标准基向量一次代入 S，在将得到的向量作为矩阵的行向量 $$ \\begin{align*} S(i) = (s_x \\cdot 1, s_y \\cdot 0, s_z \\cdot 0) = (s_x, 0, 0) \\\\ \\\\ s(j) = (s_x \\cdot 0, s_y \\cdot 1, s_z \\cdot 0) = (0, s_y, 0) \\\\ \\\\ s(k) = (s_x \\cdot 0, s_y \\cdot 0, s_z \\cdot 1) = (0, 0, s_z) \\end{align*} $$ 这样就得到了缩放变换 S 的矩阵表示 $$ S= \\begin{bmatrix} s_x \u0026 0 \u0026 0 \\\\ 0 \u0026 s_y \u0026 0 \\\\ 0 \u0026 0 \u0026 s_z \\end{bmatrix} $$ 我们称此矩阵为缩放矩阵（scaling matrix，亦有译为比例变换矩阵）。 而其对用的逆矩阵则为： $$ S^{-1}= \\begin{bmatrix} \\frac{1}{s_x} \u0026 0 \u0026 0 \\\\ 0 \u0026 \\frac{1}{s_y} \u0026 0 \\\\ 0 \u0026 0 \u0026 \\frac{1}{s_z} \\end{bmatrix} $$ 例题 假设定义了一个最小点坐标为 (−4, −4, 0) 和最大点坐标为 (4, 4, 0) 的正方形。现欲将此正方形在 x 轴方 向上缩小 50%，在 y 轴方向上放大 2.0 倍，但在 z 轴方向上保持不变。其对应的缩放矩阵为： $$ S= \\begin{bmatrix} 0.5 \u0026 0 \u0026 0 \\\\ 0 \u0026 2 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 此时，若要对正方形进行缩放，只需将最小点、最大点坐标分别与缩放矩阵相乘即可： $$ \\begin{align} [-4, -4, 0] \\begin{bmatrix} 0.5 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 2 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \u0026= [-2, -8, 0] \\\\ \\\\ [4, 4, 0] \\begin{bmatrix} 0.5 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 2 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \u0026= [2, 8, 0] \\end{align} $$ 变换的效果如图所示 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:4","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"旋转 在本节中，我们将用数学的方式来描述令向量 v 绕轴 n 以角 θ 进行旋转 此过程如图 3.3 所示。注意，在沿 n 轴从上至下俯瞰时，我们按顺时针方向来测量角 θ ，并且假设 ||n|| = 1 将向量 v 分解为两部分：一部分平行于 n，另一部分正交于 n。 平行于 n 的部分即为 $ proj_n(\\vec{v}) $ ，正交于 n 的部分则是 $ \\vec{v_\\perp } = perp_n(\\vec{v}) = \\vec{v} = proj_n(\\vec{v}) $（由于 n 是单位向量，我们就可以得到 $ proj_n(\\vec{v}) = (\\vec{n} \\cdot \\vec{v})\\vec{n} $ ） 观察示意图能够发现这样一个关键信息：平行于 n 的部分 $ proj_n(\\vec{v}) $ 在旋转时是保持不变的。因此，我们只需考虑怎样旋转与 n 正交的部分。根据图 3.3 可知，旋转向量 $ R_n(\\vec{v}) = proj_n(\\vec{v}) + R_n(\\vec{v_\\perp}) $ 。 为了求出 $ R_n(\\vec{v_\\perp}) $，我们在旋转平面内建立一个2D坐标系，并将 $ \\vec (\\vec{v_\\perp} $ 作为一个参考向量 通过计算叉积 $ \\vec{n} x \\vec{v} $来获得既正交于 $ \\vec (\\vec{v_\\perp} $ 又正交于 $ \\vec{n}$ 的第二个参考向量（根据左手拇指法则） 基于图3.3所示的三角关系可知： $$ ||\\vec{n} \\times \\vec{v}|| = ||\\vec{n}|| \\cdot ||\\vec{v}|| sin\\alpha = ||\\vec{v}||sin\\alpha = ||v_\\perp|| $$ 其中，α 是 n 与 v 之间的夹角。由此可知：两个参考向量的长度相等，且都位于旋转的圆周之上。 根据三角学知识，我们就可以将这两个参考向量建立如下关系： $$ R_n(v_\\perp) = cos\\theta\\vec{v}_\\perp + sin\\theta(\\vec{n} \\times \\vec{v}) $$ 这样就推导除了下列旋转公式： $$ \\begin{align} R_n(\\vec{v}) \u0026= proj_n(\\vec{v}) + R_n(\\vec{v}_\\perp) \\\\ \\\\ \u0026= (\\vec{n} \\cdot \\vec{v})\\vec{n} + cos\\theta\\vec{v}_\\perp + sin\\theta(\\vec{n} \\times \\vec{v}) \\\\ \\\\ \u0026= (\\vec{n} \\cdot \\vec{v})\\vec{n} + cos\\theta(\\vec{v} - (\\vec{n} \\cdot \\vec{v})\\vec{n}) + sin\\theta(\\vec{n} \\times \\vec{v}) \\\\ \\\\ \u0026= cos\\theta\\vec{v} + (1 - cos\\theta)(\\vec{n} \\times \\vec{v})\\vec{n} + sin\\theta(\\vec{n} \\times \\vec{v}) \\end{align} $$ 若要得到旋转的变换矩阵表示，仅需将各个标准基向量代入到 Rn 中，再把得到的向量分别作为矩阵的行向量。 最终得到的结果为： $$ \\begin{align*} R_n \u0026= \\begin{bmatrix} c + (1 - c)x^2 \u0026 (1-c)xy + sz \u0026 (1-c)xz - sy \\\\ \\\\ (1-c)xy - sz \u0026 c + (1 - c)y^2 \u0026 (1-c)yz + sx \\\\ \\\\ (1-c)xz + sy \u0026 (1-c)yz - sx \u0026 c + (1-c)z^2 \\end{bmatrix} \\\\ \\\\ \u0026此处设 c = cos\\theta 且 s = sin\\theta \\end{align*} $$ 旋转矩阵有个有趣的性质：每个行向量都为单位长度且两两正交（请分别证明）。 也就是说，这些行 向量都是规范正交的（orthonormal，即互相正交且具有单位长度）。 若一个矩阵的行向量都是规范正交 的，则称此矩阵为正交矩阵（orthogonal matrix）。 正交矩阵有个引人注目的性质，即它的逆矩阵与转置 矩阵是相等的： $$ \\begin{align*} R^{-1}_n = R^T_n = \\begin{bmatrix} c + (1 - c)x^2 \u0026 (1-c)xy + sz \u0026 (1-c)xz - sy \\\\ \\\\ (1-c)xy - sz \u0026 c + (1 - c)y^2 \u0026 (1-c)yz + sx \\\\ \\\\ (1-c)xz + sy \u0026 (1-c)yz - sx \u0026 c + (1-c)z^2 \\end{bmatrix} \\\\ \\\\ 此处设 c = cos\\theta 且 s = sin\\theta \\end{align*} $$ 通常来说，由于正交矩阵的逆矩阵计算方便且高效，所以很受青睐。 特别地，如果选择绕 x 轴、y 轴或 z 轴进行旋转（即分别取 n = (1, 0, 0)、n = (0, 1, 0)和 n = (0, 0, 1)）， 便会获得以 x、y、z 为旋转轴的对应旋转矩阵： $$ R_x = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 cos\\theta \u0026 sin\\theta \\\\ \\ 0 \u0026 -sin\\theta \u0026 cos\\theta \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} ,R_y = \\begin{bmatrix} cos\\theta \u0026 0 \u0026 -sin\\theta \\\\ \\\\ 0 \u0026 1 \u0026 0 \\\\ \\ sin\\theta \u0026 0 \u0026 cos\\theta \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} ,R_z = \\begin{bmatrix} cos\\theta \u0026 sin\\theta \u0026 0 \\\\ \\\\ -sin\\theta \u0026 cos\\theta \u0026 0 \\\\ \\ 0 \u0026 0 \u0026 1 \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} $$ 例题 假设定义了一个最小点坐标为(−1, 0, −1)和最大点坐标为(1, 0, 1)的正方形。 现在，我们希望令它绕 y 轴顺时针旋转−30°（即按逆时针方向旋转 30°）。 根据问题所述可知， n = (0, 1, 0) ，代入 $ R_n $ 并进行化简， 可得到 y 轴的旋转矩阵为 $$ R_y = \\begin{bmatrix} \\cos\\theta \u0026 0 \u0026 -\\sin\\theta \\\\ 0 \u0026 1 \u0026 0 \\\\ \\sin\\theta \u0026 0 \u0026 \\cos\\theta \\end{bmatrix} = \\begin{bmatrix} \\cos(-30^\\circ) \u0026 0 \u0026 -\\sin(-30^\\circ) \\\\ 0 \u0026 1 \u0026 0 \\\\ \\sin(-30^\\circ) \u0026 0 \u0026 \\cos(-30^\\circ) \\end{bmatrix} = \\begin{bmatrix} \\frac{\\sqrt{3}}{2} \u0026 0 \u0026 \\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \\\\ -\\frac{1}{2} \u0026 0 \u0026 \\frac{\\sqrt{3}}{2} \\end{bmatrix} $$ 为了旋转该正方形，还需将其最小点、最大点坐标分别乘以得到的旋转矩阵 $$ \\begin{align*} [-1, 0, -1] \\begin{bmatrix} \\frac{\\sqrt{3}}{2} \u0026 0 \u0026 \\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \\\\ -\\frac{1}{2} \u0026 0 \u0026 \\frac{\\sqrt{3}}{2} \\end{bmatrix} \u0026\\approx [-0.36, 0, -1.36] \\\\ \\\\ [1, 0, 1] \\begin{bmatrix} \\frac{\\sqrt{3}}{2} \u0026 0 \u0026 \\frac{1}{2} \\\\ 0 \u0026 1 \u0026 0 \\\\ -\\frac{1}{2} \u0026 0 \u0026 \\frac{\\sqrt{3}}{2} \\end{bmatrix} \u0026\\approx [0.36, 0, 1.36] \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:1:5","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"仿射变换 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"齐次坐标 仿射变换 是一个线性变换和一个平移变换组合而成的。对于向量而言，平移操作是没有意义的，因为向量只描述方向和大小，却与位置无关。换句话说，平移向量不应该作用于向量。因此，平移变换只能应用于点(即位置向量) 齐次坐标（homogeneous coordinate）所提供的表示机制，使我们可以方便地对点和向量进行统一的处理。在采用齐次坐标表示法时，我们将坐标扩充为四元组，其中，第四个坐标 w 的取值将根据被描述对象是点还是向量而定。具体来讲： (x, y, z, 0) 表示向量 (x, y, z, 1)表示点 在后面我们将会证明：设 w = 1 能使点被正确地平移，设 w = 0 则可以防止向量坐标受到平移操作的 影响（我们不希望对向量的坐标进行平移变换，因为这个计算过程会改变它的方向和大小——而平移操 作不应当修改向量的任何一种“属性”）。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:1","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"仿射变换的定义及其矩阵表示 线性变换并不能表示出我们需要的所有变换，因此，现将其扩充为一种称作仿射变换的映射范围更广的函数类。 仿射变换为一个线性变换加上一个平移向量 b，即： $$ \\alpha(\\vec{u}) = \\tau(\\vec{u}) + \\vec{b} $$ 或者用矩阵表示法 $$ \\alpha(\\vec{u}) = \\vec{u}A + \\vec{b} = [x, y, z] \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} + [b_x, b_y, b_z] = [x’, y’, z’] $$ 其中，A 是一个线性变换的矩阵表示。 如果用 w = 1 把坐标扩充为齐次坐标，那么就可以将上式更简洁地写作： $$ [x, y, z, 1] \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \u0026 0 \\\\ \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \u0026 0 \\\\ \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \u0026 0 \\\\ \\\\ b_x \u0026 b_y \u0026 b_z \u0026 1 \\end{bmatrix} = [x’, y’, z’, 1] $$ 此 4 x 4 矩阵称为仿射变换的矩阵表示。 可以看出，加上向量 b 的这步运算，从本质上来说是一种平移操作（使目标对象的位置发生了改变）。但是，我们既不希望将此平移操作应用到向量上（因为向量的性质中并没有位置这个概念），又想令向量 受到仿射变换中线性部分的处理。此时，如果将向量的第四个分量设为 w = 0，它便不会受到向量 b 平移 操作的影响（可通过矩阵的乘法运算来验证这一点）。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:2","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"平移 恒等变换（identity transformation）是一种直接返回其输入参数的线性变换，形如 I(u) = u。不难证 明，这种线性变换的矩阵表示即为单位矩阵 现将平移变换（translation transformation）定义为仿射变换，此时， 其中的线性变换就是一种恒等变换，即： $$ \\tau(\\vec{u}) = \\vec{u}I + \\vec{b} = \\vec{u} + \\vec{b} $$ 如您所见，此线性变换简单地利用向量 b 对点 u 进行平移（或位移）。 $ \\tau $ 的矩阵表示为 $$ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ b_x \u0026 b_y \u0026 b_z \u0026 1 \\end{bmatrix} $$ 该矩阵称为平移矩阵（translation matrix）。 平移矩阵的逆矩阵则为： $$ T^{-1} = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ -b_x \u0026 -b_y \u0026 -b_z \u0026 1 \\end{bmatrix} $$ 例子 假设定义了一个正方形，其最小点坐标为(−8, 2, 0)，最大点坐标为(−2, 8, 0)。我们希望将此正方形沿 x 轴正方向平移 12 个单位，沿 y 轴正方向平移 −10 个单位，在 z 轴方向保持不变 则其对应的平移矩阵为： $$ T = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 12 \u0026 -10 \u0026 0 \u0026 1 \\end{bmatrix} $$ 现对此正方形进行平移（变换），将其最小点、最大点坐标分别乘以上述平移矩阵： $$ \\begin{align*} [-8, 2, 0, 1] \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 12 \u0026 -10 \u0026 0 \u0026 1 \\end{bmatrix} \u0026= [4, -8, 0 ,1] \\\\ \\\\ [-2, -8, 0, 1] \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ \\\\ 12 \u0026 -10 \u0026 0 \u0026 1 \\end{bmatrix} \u0026= [10, -2, 0 ,1] \\end{align*} $$ ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:3","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"缩放和旋转的仿射矩阵 通过观察可以发现，如果 b = 0，则仿射变换将退化为线性变换。这样一来，我们就能用 b = 0 的仿射变换来表示任意线性变换。更进一步说，也就意味着仅通过一个 4 × 4 的仿射矩阵表达出任意的线性变换。例如，缩放矩阵与旋转矩阵可写作下列的 4 × 4矩阵： $$ \\begin{align*} S \u0026= \\begin{bmatrix} s_x \u0026 0 \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 s_y \u0026 0 \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 s_z \u0026 0 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\\\ \\\\ R_n \u0026= \\begin{bmatrix} c + (1 - c)x^2 \u0026 (1-c)xy + sz \u0026 (1-c)xz - sy \u0026 0 \\\\ \\\\ (1-c)xy - sz \u0026 c + (1 - c)y^2 \u0026 (1-c)yz + sx \u0026 0 \\\\ \\\\ (1-c)xz + sy \u0026 (1-c)yz - sx \u0026 c+ (1-c)z^2 \u0026 \\\\ \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} \\end{align*} $$ 如此一来，就能用 4 × 4 矩阵统一地表示所有变换，并通过1 × 4 齐次行向量来表示点和向量。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:4","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"仿射变换矩阵的几何意义 首先让我们来考察刚体变换（rigid body transformation），其本质是一种保形（shape preserving，即保持形状） 变换。 以下便是刚体变换在现实生活中的一个例子：从书桌上拿起书，再将它放到书架上。在移动书的这个过程中（平移），很可能会改变它的朝向（旋转）。 设 $ \\tau $ 为描述物体旋转操作的旋转变换，而 b 为定义物体平移操作的平移向量。那么，刚体变换就可以用仿射变换来表示： $$ \\alpha(x, y, z) = \\tau(x, y, z) + \\vec{b} = x\\tau(\\vec{i}) + y\\tau(\\vec{j}) + z\\tau{\\vec{k}} + \\vec{b} $$ 在矩阵表示法中，若采用齐次坐标（表示点时，w = 1；表示向量时，w = 0，如此一来，平移变换就不会作用于向量），上式将被改写为： $$ [x, y, z, w] \\begin{bmatrix} \\leftarrow \\tau(\\vec{i}) \\rightarrow \\\\ \\\\ \\leftarrow \\tau(\\vec{j}) \\rightarrow \\\\ \\\\ \\leftarrow \\tau(\\vec{k}) \\rightarrow \\\\ \\\\ \\leftarrow \\vec{b} \\rightarrow \\end{bmatrix} = [x’, y’, z’, w] $$ 至此，为了理解此方程的几何意义，我们还要将矩阵中的行向量依次绘制出来（见图 3.7）。由于 $ \\tau $ 是一个 旋转变换，所以它具有保长性与保角性（详见章末习题 26）。 特别是我们能看到 $ \\tau $ 仅将标准基向量 i、j 和 k，分 别旋转到对应的新方向 $ \\tau(\\vec{i}) 、\\tau(\\vec{j}) 和 \\tau(\\vec{k}) $ 。而向量b 则是一个位置向量，它表示物体相对于原点的位移。现在来看图3.7，它以几何学的角度展示了如何通过计算 $ \\alpha(x, y, z) = x\\tau(\\vec{i}) + y\\tau(\\vec{j}) + z\\tau{\\vec{k}} + \\vec{b} $ 来求取变换后的点。 这种思路同样可以运用在缩放或斜切（skew，也有译作倾斜、扭曲等）变换上。请考虑这样一种线性变换 $ \\tau $，它将图 3.8 所示的正方形拉扯为一个平行四边形。斜切处理后的点即为斜切变换后的基向量的线性组合。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:2:5","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"变换的复合 假设 S 是一个缩放矩阵，R 是一个旋转矩阵，T 是一个平移矩阵。 现给定一个由 8 个顶点 $ v_i $（其 中 i = 0, 1, …, 7）构成的立方体，并希望将这 3 种变换相继应用到此正方体的每个顶点之上。 我们以下列简明的方式来逐步对顶点进行变换： $$ \\begin{align} ((\\vec{v}, S)R)T \u0026= (v’_i R)T = v’’_i T = v’’’_i \\\\ \\\\ 其中i\u0026=0,1, …,7 \\end{align} $$ 然后，由于矩阵乘法满足结合律，因而此式可以等价的改写为： $$ \\begin{align} v_i(SRT) \u0026= v’’’_i \\\\ \\\\ 其中 i \u0026= 0, 1, … , 7 \\end{align} $$ 还可将 C = SRT 视为一个矩阵，即提前将3种变换封装为一个净变换矩阵。换句话说，矩阵之间的乘法法则使我们将不同的变换连接在一起 这里十级还涉及性能问题，来看一个例子： 假设有一个由 20000 个点组成的 3D 物体，我们希望将 上述 3 种几何变换，逐个作用到这个物体上。 如果采用按部就班的计算方法，我们需要进行 20000 3 × 次 向量与矩阵的乘法运算。但通过上述组合矩阵的计算方法，只需要执行 20000 次的向量与矩阵乘法运算以及两次矩阵与矩阵的乘法运算即可。 显而易见的是，比起前者中近 3 倍的大量向量与矩阵乘法运算而 言，后者中两次额外的矩阵与矩阵乘法运算真可谓是九牛一毛。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:3:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"坐标系变换 根据标架 A 与另一不同标架 B 的关系，我们就可以将相对于标架 A 表示某量的标量 k，转换为相对于标架 B 描述同一种量的新标量 k' 我们把不 同标架间的坐标的转换称之为坐标系变换 值得注意的是，在坐标变换的过程中，几何体本身并没有随之发生改变。坐标变换改变的仅是物体的参考系（又称参照系），因此改变的实为几何体的坐标表示。 相比之下，我们可以认为旋转、平移和缩放这些操作才使几何体发生了实质上的移动或形变。 3D 计算机图形学中，我们往往会用到许多不同的坐标系，所以需要了解在它们之间互相转换坐标 的方法。由于位置是点的属性，与向量无关，所以点和向量的坐标变换是不同的 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"向量的坐标变换 思考图 3.11，其中有一向量 p 分别位于标架 A 和标架 B 之中。 假设给定向量 p 在标架 A 中的坐标为 $ p_A = (x, y) $，现希望求得向量 p 在标架 B 中的对应坐标 $ p_B = (x’, y’) $。 说人话就是，向量p在另一个坐标系的坐标是什么 从图可以看出 $$ \\vec{p} = x\\vec{u} + y\\vec{v} $$ 其中，u 和 v 分别是标架Ａ中 x 轴、y 轴正方向上的单位向量。用标架 B 中的坐标来表示以上公式中的单位向量，可得： $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B $$ 所以，如果给定 $ p_A = (x, y) $，也已知向量 u 和向量 v 相对于标架 B 的坐标分别为 $ u_B = (u_x, u_y) $ 以及 $ v_B = (v_x, v_y) $， 那么就一定能求出 $ p_B = (x’, y’) $。 现将向量的坐标变换推广到3D空间，如果 $ \\vec{p_A} = (x, y, z) $, 那么 $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B $$ 其中，u, v, w分别指向标价A中 x 轴，y 轴和 z 轴正方向上的单位向量 现将向量的坐标变换推广到 3D 空间，如果 $ p_A = (x, y, z) $，那么： $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B $$ 其中，u、v 和 w 分别是指向标架Ａ中 x 轴、y 轴和 z 轴正方向上的单位向量。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:1","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"点的坐标变换 点与向量的坐标变换稍有不同，这是由于位置是点的一个重要属性，因而不能将图 3.11 所示的向量 平移方法应用于点上。 图 3.12 展示了一个对点进行坐标变换的情景，通过观察，可以将点 p 表示为： $$ \\vec{p} = x\\vec{u} + y\\vec{v} + Q $$ 其中 u 和 v 是分别指向标架 A 中 x 轴和 y 轴正方向上的单位向量，且 Q 是标架 A 中的原点。用标架 B 中的坐标来表示上式中的每一个向量和点，可得： $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B + Q_B $$ 如果给出 $ p_A = (x, y) $，同时也知道向量 u、v 以及原点 Q 相对于标架 B 的坐标分别为 $ u_B = (u_x, u_y)、v_B = (v_x, v_y) $ 以及 $ Q_B = (Q_x, Q_y) $，那么，我们总能求出 $ p_B = (x’, y’) $ 现把点的坐标变换推广到 3D 空间，如果 $ p_A = (x, y, z) $，那么： $$ \\vec{p}_B = x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B + Q_B $$ 其中，向量 u、v 和 w 是分别指向标架 A 中 x 轴、y 轴和 z 轴的正方向上的单位向量，Q 则为标架 A 中的原点。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:2","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"坐标变换的矩阵表示 到目前为止，我们已经分别探讨了向量和点的坐标变换： $$ \\begin{align*} (x’, y’, z’) \u0026= x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B \\\\ \\\\ (x’, y’, z’) \u0026= x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B + Q_B \\end{align*} $$ 如果使用齐次坐标，就可以用同一公式对点和向量进行处理： $$ (x’, y’, z’, w) = x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B + Q_B $$ 如果 w= 0, 此式化简为向量的坐标变换公式；如果 w = 1，则此时化简为点的坐标变换公式，此式子的优点在于：只要为其正确的 设置 w 分量值，他就能相应的处理点或向量的坐标变换。 这样，我们也就无需分别记住两个公式了，而且我们可以将此式子改写为矩阵形式： $$ \\begin{align*} [x’, y’, z’, w] \u0026= [x, y, z, w] \\begin{bmatrix} \\leftarrow \\vec{u}_B \\rightarrow \\\\ \\\\ \\leftarrow \\vec{u}_B \\rightarrow \\\\ \\\\ \\leftarrow \\vec{u}_B \\rightarrow \\\\ \\\\ \\leftarrow \\vec{u}_B \\rightarrow \\end{bmatrix} \\\\ \\\\ \u0026= [x, y, z, w] \\begin{bmatrix} u_x \u0026 u_y \u0026 u_z \u0026 0 \\\\ \\\\ v_x \u0026 v_y \u0026 v_z \u0026 0 \\\\ \\\\ w_x \u0026 w_y \u0026 w_z \u0026 0 \\\\ \\\\ Q_x \u0026 Q_y \u0026 Q_z \u0026 1 \\end{bmatrix} \\\\ \\\\ \u0026= x\\vec{u}_B + y\\vec{v}_B + z\\vec{w}_B + wQ_B \\end{align*} $$ 其中，$ Q_B = (Q_x, Q_y, Q_z, 1)，\\vec{u}_B = (u_x, u_y, u_z, 0)，\\vec{v}_B = (v_x, v_y, v_z, 0)与 \\vec{w}_B = (w_x, w_y, w_z, 0) $分别表示标架 A 中的 原点和诸坐标轴相对于标架 B 的齐次坐标。我们把上述式子里能把标架 A 中的坐标转换（或映射， map）为标架 B 中坐标的 4 x 4矩阵，称为坐标变换矩阵（change of coordinate matrix）或标架变换矩阵 （change of frame matrix）。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:3","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"坐标变换矩阵及其结合律 现假设有 3 个标架 F、G 和 H。A 为将坐标从 F 转换到 G 的标架变换矩阵，B 为把坐标由 G 转换至 H 的标架变换矩阵 在标架 F 中，有一向量的坐标为 $ p_F $，我们希望求出此向量相对于标架 H 的坐标 $ p_H $。 可按一般顺序来逐步计算： $$ \\begin{align*} (\\vec{p}_FA)B \u0026= \\vec{p}_H \\\\ \\\\ (\\vec{p}_G)B \u0026= \\vec{p}_H \\end{align*} $$ 由于矩阵的乘法运算满足结合律，我们可将 $ (\\vec{p}_FA)B = \\vec{p}_H $ 写作： $$ (\\vec{p}_F)AB = \\vec{p}_H $$ 这样一来，就能把矩阵乘积 C = AB 看作是将坐标从标架 F 直接变换至标架 H 的标架变换矩阵，它将变换矩阵 A 和 B 结合为一个净矩阵——-其思路就类似于函数的复合。 这种计算方法还会对性能产生影响。为了说明这一点，我们假设一个由 20000 个点构成的 3D 物体， 现要对它的每个点进行两次标架变换。若使用逐步计算的方法，我们需进行 20000 × 2 次向量与矩阵的乘法运算。但利用结合矩阵的方法，我们只要进行 20000 次向量与矩阵的乘法运算以及一次矩阵与矩阵的乘法运算（用于结合两个标架变换矩阵）即可。不难看出，仅借助一次开销极低的矩阵之间的乘法运算， 便可以节省多次向量与矩阵乘法所需的大量计算资源。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:4","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"坐标变换矩阵及其逆矩阵 假设给定向量 p 相对于标架 B 的坐标 $p_B$，以及将坐标由标架 A 转换到标架 B 的变换矩阵 M，即有 $ p_B = p_AM $。现希望求得 $ p_A $。换句话说，我们这次是希望通过坐标变换矩阵，将标架 B 中的坐标映射到标架 A 中。 为了求出这个矩阵，我们假设矩阵 M 是可逆的（即存在 $ M^−1 $）。通过下列步骤，我们就能得到坐标 $ p_A $： $ \\vec{p}_B = \\vec{p}_AM $ $ \\vec{p}_B M^-1 = \\vec{p}_AM M^-1 $ 等式左右两次同时乘以矩阵 M^-1 $ \\vec{p}_B = \\vec{p}_AI$ 由逆矩阵的定义可知 MM^-1 = I $ \\vec{p}_B M^-1 = \\vec{p}_A 由单位矩阵的定义可知\\vec{p}_AI = \\vec{p}_A $ 所以矩阵 $ M^-1 $ 即为将坐标由标架B转换到标架A的变换矩阵 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:4:5","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"变换矩阵与坐标变换矩阵 到目前为止，我们已经对“使几何体本身发生改变”的变换（缩放、旋转和平移）与坐标变换进行了区分 在本节中，我们将证明：从数学角度上看，两者在数学上其实是等价的。即，可将改变几何体的变换解释为坐标变换，反之亦然。 如果我们能认识到这一点，会发现其意义非凡。对于坐标变换来说，标架之间的差异仅为位置和朝向。因此，令坐标在标架之间转换的数学公式实质上描述的即为所需执行的旋转和平移操作，最终也会得到与几何变换（对物体进行缩放、旋转和平移）相同的数学形式，可谓殊途同归。几何变换也好，坐标变换也罢，计算出的结果都是相同的，差别只在于解释变换的角度。对于某些情况来说，保持物体不变，使之在多个坐标系之间转换是种更直观的办法。但是，若描述对象的参考系发生了变化，则物体的 坐标表示也会随之改变。有些时候，我们又希望在同一个坐标系中表示物体的变换，而不改变其参考系，此时即可采用几何变换法。 ","date":"2025-02-06","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/:5:0","tags":["Unreal","3D图形学","变换矩阵"],"title":"变换矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵的概念及数学运算的一些习题","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"题目大纲 求解下列矩阵方程中的矩阵 X $ 3(\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix}- 2X) = 2\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix} $ 计算下列矩阵的乘积： （a）$ \\begin{bmatrix}-2 \u0026 0 \u0026 3 \\\\ \\\\ 4 \u0026 1 \u0026 -1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026 -1 \\\\ \\\\ 0 \u0026 6 \\\\ \\\\ 2 \u0026 -3 \\end{bmatrix} $ （b）$ \\begin{bmatrix}1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\end{bmatrix} \\begin{bmatrix} -2 \u0026 0 \\\\ \\\\ 1 \u0026 1 \\end{bmatrix} $ （c）$ \\begin{bmatrix} 2 \u0026 0 \u0026 2 \\\\ \\\\ 0 \u0026 -1 \u0026 -3 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ \\\\ 2 \\\\ \\\\ 1 \\end{bmatrix} $ 计算下列矩阵的转置矩阵 （a）$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\end{bmatrix} $ （b）$ \\begin{bmatrix} x \u0026 y \\\\ \\\\ z \u0026 w \\end{bmatrix} $ （c）$ \\begin{bmatrix} 1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\\\ \\\\ 5 \u0026 6 \\\\ \\\\ 7 \u0026 8 \\end{bmatrix} $ 将下列线性组合写作向量与矩阵乘积的形式： （a）v = 2(1, 2, 3) − 4(−5, 0, −1) + 3(2, −2, 3) （b）v = 3(2, −4) + 2(1, 4) − 1(−2, −3) + 5(1, 1) 证明：$ AB = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33}\\end{bmatrix}\\begin{bmatrix} B_{11} \u0026 B_{12} \u0026 B_{13} \\\\ B_{21} \u0026 B_{22} \u0026 B_{23} \\\\ B_{31} \u0026 B_{32} \u0026 B_{33} \\end{bmatrix} =\\begin{bmatrix} \\leftarrow A_{1,*}B \\rightarrow \\\\ \\\\ \\leftarrow A_{2,*}B \\rightarrow\\\\ \\\\ \\leftarrow A_{3,*}B \\rightarrow \\end{bmatrix} $ 证明：$ A\\vec{u} = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = xA_{*,1} + y A_{*,2} + zA_{*,3} $ 证明向量的叉积可以用矩阵的乘积来表示：$ \\vec{u} \\times \\vec{v} = \\begin{bmatrix} v_x \u0026 v_y \u0026 v_z \\end{bmatrix} \\begin{bmatrix} 0 \u0026 u_z \u0026 -u_y \\\\ \\\\ -u_z \u0026 0 \u0026 u_x \\\\ \\\\ u_y \u0026 -u_x \u0026 0 \\end{bmatrix} $ 设矩阵A = $ \\begin{bmatrix} 2 \u0026 0 \u0026 1 \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $, 那么请问矩阵B = $ \\begin{bmatrix} \\frac{1}{2} \u0026 0 \u0026 - \\frac{1}{2} \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $ 是 A 的逆矩阵吗 设矩阵A = $ \\begin{bmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{bmatrix} $, 那么请问矩阵B = $ \\begin{bmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 \\frac{1}{2} \\end{bmatrix} $ 是A的逆矩阵吗 求下列矩阵的行列式：$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $ 求下列矩阵的逆矩阵：$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $ 下列矩阵是可逆矩阵吗？\\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ \\\\ 0 \u0026 4 \u0026 5 \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} 假设矩阵A是可逆矩阵，证明 $ (A^{-1})^T = (A^T)^{-1} $ 所有的线性代数书籍都会证明 $ det(AB) = detA \\cdot detB $这一性质。设A和B皆为 n x n 矩阵，并假设A是可逆的，试根据 $ det I = 1 $与上述性质来证明 $ detA^{-1} = \\frac{1}{detA}$ 证明2D矩阵 $ \\begin{bmatrix} u_x \u0026 u_y \\\\ v_x \u0026 v_y \\end{bmatrix} $的行列式得到的是：由 $ \\vec{u} = (u_x, u_y) $与向量 $ \\vec{v} = (v_x, v_y) $ 张成的平行四边形的有向面积。如果向量 u 以逆时针方向旋转角θ ∈(0, π) 能与向量 v 重合，则结果为正，否则为负。 求由下列向量张成的平行四边形面积： u = (3, 0)与 v = (1, 1) u = (−1, −1)与 v = (0, 1) 设 A = $ \\begin{bmatrix} A_{11} \u0026 A_{12} \\\\ A_{21} \u0026 A_{22} \\end{bmatrix} $. B = $ \\begin{bmatrix} B_{11} \u0026 B_{12} \\\\ B_{21} \u0026 B_{22} \\end{bmatrix} $, C = $ \\begin{bmatrix} C_{11} \u0026 C_{12} \\\\ C_{21} \u0026 C_{22} \\end{bmatrix} $。证明 A(BC) = (AB)C。这个结论说明了 2 × 2矩阵之间的乘法运算满足结合律。（事实上，只要矩阵的乘法有意义，任意规模的矩阵乘法都满足结合律。） ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:1:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第一题 求解下列矩阵方程中的矩阵 X $ 3(\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix}- 2X) = 2\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix} $ $$ \\begin{gather*} 3(\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix}- 2X) = 2\\begin{bmatrix}-2 \u0026 0\\\\ \\\\ 1 \u0026 3\\end{bmatrix} \\\\ \\\\ \\begin{bmatrix} -6 \u0026 0 \\\\ \\\\ 3 \u0026 9 \\end{bmatrix} - 6X = \\begin{bmatrix} -4 \u0026 0 \\\\ \\\\ 2 \u0026 6 \\end{bmatrix} \\\\ \\\\ -6X = \\begin{bmatrix} -4 \u0026 0 \\\\ \\\\ 2 \u0026 6 \\end{bmatrix} - \\begin{bmatrix} -6 \u0026 0 \\\\ \\\\ 3 \u0026 9 \\end{bmatrix} \\\\ \\\\ -6X = \\begin{bmatrix} 2 \u0026 0 \\\\ \\\\ -1 \u0026 -3 \\end{bmatrix} \\\\ \\\\ X = \\begin{bmatrix} -\\frac{1}{3} \u0026 0 \\\\ \\\\ \\frac{1}{6} \u0026 \\frac{1}{2} \\end{bmatrix} \\end{gather*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:2:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第二题 计算下列矩阵的乘积： （a）$ \\begin{bmatrix}-2 \u0026 0 \u0026 3 \\\\ \\\\ 4 \u0026 1 \u0026 -1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026 -1 \\\\ \\\\ 0 \u0026 6 \\\\ \\\\ 2 \u0026 -3 \\end{bmatrix} $ $$ \\begin{bmatrix}-2 \u0026 0 \u0026 3 \\\\ \\\\ 4 \u0026 1 \u0026 -1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026 -1 \\\\ \\\\ 0 \u0026 6 \\\\ \\\\ 2 \u0026 -3 \\end{bmatrix} = \\begin{bmatrix} 2 \u0026 -7 \\\\ \\\\ 6 \u0026 5 \\end{bmatrix} $$ （b）$ \\begin{bmatrix}1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\end{bmatrix} \\begin{bmatrix} -2 \u0026 0 \\\\ \\\\ 1 \u0026 1 \\end{bmatrix} $ $$ \\begin{bmatrix}1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\end{bmatrix} \\begin{bmatrix} -2 \u0026 0 \\\\ \\\\ 1 \u0026 1 \\end{bmatrix} = \\begin{bmatrix} 0 \u0026 2 \\\\ \\\\ -2 \u0026 4 \\end{bmatrix} $$ （c）$ \\begin{bmatrix} 2 \u0026 0 \u0026 2 \\\\ \\\\ 0 \u0026 -1 \u0026 -3 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ \\\\ 2 \\\\ \\\\ 1 \\end{bmatrix} $ $$ \\begin{bmatrix} 2 \u0026 0 \u0026 2 \\\\ \\\\ 0 \u0026 -1 \u0026 -3 \\\\ \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ \\\\ 2 \\\\ \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 4 \\\\ \\\\ -5 \\\\ \\\\ 1 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:3:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第三题 计算下列矩阵的转置矩阵 （a）$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\end{bmatrix} $ $$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\end{bmatrix}^T = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} $$ （b）$ \\begin{bmatrix} x \u0026 y \\\\ \\\\ z \u0026 w \\end{bmatrix} $ $$ \\begin{bmatrix} x \u0026 y \\\\ \\\\ z \u0026 w \\end{bmatrix} ^ T = \\begin{bmatrix} x \u0026 z \\\\ \\\\ y \u0026 w \\end{bmatrix} $$ （c）$ \\begin{bmatrix} 1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\\\ \\\\ 5 \u0026 6 \\\\ \\\\ 7 \u0026 8 \\end{bmatrix} $ $$ \\begin{bmatrix} 1 \u0026 2 \\\\ \\\\ 3 \u0026 4 \\\\ \\\\ 5 \u0026 6 \\\\ \\\\ 7 \u0026 8 \\end{bmatrix} ^ T = \\begin{bmatrix} 1 \u0026 3 \u0026 5 \u0026 7 \\\\ \\\\ 2 \u0026 4 \u0026 6 \u0026 8 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:4:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第四题 将下列线性组合写作向量与矩阵乘积的形式： （a）v = 2(1, 2, 3) − 4(−5, 0, −1) + 3(2, −2, 3) $$ \\begin{bmatrix} 1 \u0026 -5 \u0026 2 \\\\ \\\\ 2 \u0026 0 \u0026 -2 \\\\ \\\\ 3 \u0026 -1 \u0026 3 \\end{bmatrix} \\begin{bmatrix} 2 \\\\ \\\\ -4 \\\\ \\\\ 3 \\end{bmatrix} $$ （b）v = 3(2, −4) + 2(1, 4) − 1(−2, −3) + 5(1, 1) $$ \\begin{bmatrix} 2 \u0026 1 \u0026 -2 \u0026 1 \\\\ \\\\ -4 \u0026 4 \u0026 -3 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 3 \\\\ \\\\ 2 \\\\ \\\\ -1 \\\\ \\\\ 5 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:5:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第五题 证明：$ AB = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33}\\end{bmatrix}\\begin{bmatrix} B_{11} \u0026 B_{12} \u0026 B_{13} \\\\ B_{21} \u0026 B_{22} \u0026 B_{23} \\\\ B_{31} \u0026 B_{32} \u0026 B_{33} \\end{bmatrix} =\\begin{bmatrix} \\leftarrow A_{1,*}B \\rightarrow \\\\ \\\\ \\leftarrow A_{2,*}B \\rightarrow\\\\ \\\\ \\leftarrow A_{3,*}B \\rightarrow \\end{bmatrix} $ $$ AB = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\begin{bmatrix} B_{11} \u0026 B_{12} \u0026 B_{13} \\\\ B_{21} \u0026 B_{22} \u0026 B_{23} \\\\ B_{31} \u0026 B_{32} \u0026 B_{33} \\end{bmatrix} = \\begin{bmatrix} \\leftarrow A_{1,*}B \\rightarrow \\\\ \\\\ \\leftarrow A_{2,*}B \\rightarrow \\\\ \\\\ \\leftarrow A_{3,*}B \\rightarrow \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:6:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第六题 证明：$ A\\vec{u} = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = xA_{*,1} + y A_{*,2} + zA_{*,3} $ $$ A\\vec{u} = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\end{bmatrix} = xA_{*,1} + y A_{*,2} + zA_{*,3} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:7:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第七题 证明向量的叉积可以用矩阵的乘积来表示：$ \\vec{u} \\times \\vec{v} = \\begin{bmatrix} v_x \u0026 v_y \u0026 v_z \\end{bmatrix} \\begin{bmatrix} 0 \u0026 u_z \u0026 -u_y \\\\ \\\\ -u_z \u0026 0 \u0026 u_x \\\\ \\\\ u_y \u0026 -u_x \u0026 0 \\end{bmatrix} $ $$ \\vec{u} \\times \\vec{v} = \\begin{bmatrix} v_x \u0026 v_y \u0026 v_z \\end{bmatrix} \\begin{bmatrix} 0 \u0026 u_z \u0026 -u_y \\\\ \\\\ -u_z \u0026 0 \u0026 u_x \\\\ \\\\ u_y \u0026 -u_x \u0026 0 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:8:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第八题 设矩阵A = $ \\begin{bmatrix} 2 \u0026 0 \u0026 1 \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $, 那么请问矩阵B = $ \\begin{bmatrix} \\frac{1}{2} \u0026 0 \u0026 - \\frac{1}{2} \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $ 是 A 的逆矩阵吗 $$ \\begin{bmatrix} 2 \u0026 0 \u0026 1 \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{2} \u0026 0 \u0026 - \\frac{1}{2} \\\\ 0 \u0026 -1 \u0026 -3 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:9:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第九题 设矩阵A = $ \\begin{bmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{bmatrix} $, 那么请问矩阵B = $ \\begin{bmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 \\frac{1}{2} \\end{bmatrix} $ 是A的逆矩阵吗 $$ \\begin{bmatrix} 1 \u0026 2 \\\\ 3 \u0026 4 \\end{bmatrix} \\begin{bmatrix} -2 \u0026 1 \\\\ \\frac{3}{2} \u0026 \\frac{1}{2} \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:10:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十题 求下列矩阵的行列式：$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $ $$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:11:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十一题 求下列矩阵的逆矩阵：$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $ $$ \\begin{bmatrix} 21 \u0026 -4 \\\\ 10 \u0026 7 \\end{bmatrix} 与 \\begin{bmatrix} 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 3 \u0026 0 \\\\ 0 \u0026 0 \u0026 7 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:12:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十二题 下列矩阵是可逆矩阵吗？$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ \\\\ 0 \u0026 4 \u0026 5 \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} $ $$ \\begin{bmatrix} 1 \u0026 2 \u0026 3 \\\\ \\\\ 0 \u0026 4 \u0026 5 \\\\ \\\\ 0 \u0026 0 \u0026 0 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:13:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十三题 假设矩阵A是可逆矩阵，证明 $ (A^{-1})^T = (A^T)^{-1} $ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:14:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十四题 所有的线性代数书籍都会证明 $ det(AB) = detA \\cdot detB $这一性质。设A和B皆为 n x n 矩阵，并假设A是可逆的，试根据 $ det I = 1 $与上述性质来证明 $ detA^{-1} = \\frac{1}{detA}$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:15:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十五题 证明2D矩阵 $ \\begin{bmatrix} u_x \u0026 u_y \\\\ v_x \u0026 v_y \\end{bmatrix} $的行列式得到的是：由 $ \\vec{u} = (u_x, u_y) $与向量 $ \\vec{v} = (v_x, v_y) $ 张成的平行四边形的有向面积。如果向量 u 以逆时针方向旋转角θ ∈(0, π) 能与向量 v 重合，则结果为正，否则为负。 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:16:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十六题 求由下列向量张成的平行四边形面积： u = (3, 0)与 v = (1, 1) u = (−1, −1)与 v = (0, 1) ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:17:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十七题 设 A = $ \\begin{bmatrix} A_{11} \u0026 A_{12} \\\\ A_{21} \u0026 A_{22} \\end{bmatrix} $. B = $ \\begin{bmatrix} B_{11} \u0026 B_{12} \\\\ B_{21} \u0026 B_{22} \\end{bmatrix} $, C = $ \\begin{bmatrix} C_{11} \u0026 C_{12} \\\\ C_{21} \u0026 C_{22} \\end{bmatrix} $。证明 A(BC) = (AB)C。这个结论说明了 2 × 2矩阵之间的乘法运算满足结合律。（事实上，只要矩阵的乘法有意义，任意规模的矩阵乘法都满足结合律。） ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/:18:0","tags":["3D图形学","矩阵"],"title":"矩阵-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"矩阵的概念及数学运算","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵的定义 一个规模为 m × n 的矩阵（matrix）M，是由 m 行 n 列实数所构成的矩形阵列。行数和列数的乘积表示了矩阵的维度。 矩阵中的数字则称作元素（element）或元（entry）。通过双下标表示法 Mij指定元素 的行和列就可以确定出对应的矩阵元素，Mij表示的是矩阵中第 i 行、第 j 列的元素。 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:1:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"例子 $$ A = \\quad \\begin{bmatrix} 3.5 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0.5 \u0026 0 \\\\ 2 \u0026 -5 \u0026 \\sqrt{2} \u0026 1 \\end{bmatrix} ~~~~~~~~ B = \\quad \\begin{bmatrix} B_{11} \u0026 B_{12} \\\\ B_{21} \u0026 B_{22} \\\\ B_{31} \u0026 B_{32} \\end{bmatrix} ~~~~~~~~ u = \\quad \\left[u_1, u_2 \\right] ~~~~~~~~ v = \\quad \\begin{bmatrix} 1 \\\\ 2 \\\\ \\sqrt{3} \\\\ \\pi \\end{bmatrix} $$ A是一个 4 x 4 矩阵，B是一个 3 x 2 矩阵，u 是一个特殊的 1 x 3矩阵，v是一个 4 x 1 矩阵 我们通过双下标表示法 A42 =−5 将矩阵 A 中第 4 行第 2 列的元素指定为−5，并以 B21表示矩阵 B中第 2 行第 1 列的这一元素。 u \u0026 v 是特殊的矩阵，其实他们就是向量，分别只用一行或者一列来表示矩阵，有时候也被称为行向量或者列向量，我们只需要使用单下标表示就好了 在某些情况下，我们倾向于把矩阵的每一行都看作一个向量 比如 A1,* 第一个索引 1 表示特定的行，第二个索引\"*\" 表示该行的整个向量\u0026#42 自然而然，A,1 第一个索引\"\" 表示该列的整个向量，第二个表示特定的列 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:1:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"算数运算 $$ A = \\begin{bmatrix} 1 \u0026 5 \\\\ -2 \u0026 3 \\end{bmatrix} ~~~~~~~ B = \\begin{bmatrix} 6 \u0026 2 \\\\ 5 \u0026 -8 \\end{bmatrix} ~~~~~~~ C = \\begin{bmatrix} 1 \u0026 5 \\\\ -2 \u0026 3 \\end{bmatrix} ~~~~~~~ D = \\begin{bmatrix} 2 \u0026 1 \u0026 -3 \\\\ -6 \u0026 3 \u0026 0 \\end{bmatrix} ~~~~~~~ $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:2:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"相等 A = C ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:2:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"加减 $$ A + B = \\begin{bmatrix} 1 \u0026 5 \\\\ -2 \u0026 3 \\end{bmatrix} + \\begin{bmatrix} 6 \u0026 2 \\\\ 5 \u0026 -8 \\end{bmatrix} = \\begin{bmatrix} 1+6 \u0026 5+2 \\\\ -2+5 \u0026 3+(-8) \\end{bmatrix} = \\begin{bmatrix} 7 \u0026 7 \\\\ 3 \u0026 -5 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:2:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"标量相乘 $$ 3D = 3\\begin{bmatrix} 2 \u0026 1 \u0026 -3 \\\\ -6 \u0026 3 \u0026 0 \\end{bmatrix} = \\begin{bmatrix} 3(2) \u0026 3(1) \u0026 3(-3) \\\\ 3(-6) \u0026 3(3) \u0026 3(0) \\end{bmatrix} = \\begin{bmatrix} 6 \u0026 3 \u0026 -9 \\\\ -18 \u0026 9 \u0026 0 \\end{bmatrix} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:2:3","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵乘法 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:3:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"定义 如果 A 是一个 m × n 矩阵，B 是一个 n × p 矩阵，那么，两者乘积 AB 的结果是一个规模为 m × p 的矩阵 C。矩阵 C 中第 i 行、第 j 列的元素，由矩阵 A 的第 i 个行向量与矩阵 B 的第 j 个列向量的点积求得 为了使矩阵乘积 AB 有意义，矩阵 A 中的列数与矩阵 B 中的行数必须相同 ! 不能运算的例子 $$ A = \\begin{bmatrix} 1 \u0026 5 \\\\ -2 \u0026 3 \\end{bmatrix} \\quad 和 \\quad B = \\begin{bmatrix} 2 \u0026 -6 \\\\ 1 \u0026 3 \\\\ -3 \u0026 0 \\end{bmatrix} $$ 因为矩阵 A 的行向量维数为 2，矩阵 B 的列向量维数为 3，所以乘积 AB 无定义。 不妨这么想，由于 2D向量不能与 3D 向量进行点积计算，因此，矩阵 A 中的第一个行向量与矩阵 B 中的第一个列向量也就无法开展点积运算 能运算的例子 $$ A = \\begin{bmatrix} -1 \u0026 5 \u0026 -4 \\\\ 3 \u0026 2 \u0026 1 \\end{bmatrix} \\quad 和 \\quad B = \\begin{bmatrix} 2 \u0026 1 \u0026 0 \\\\ 0 \u0026 -2 \u0026 1 \\\\ -1 \u0026 2 \u0026 3 \\end{bmatrix} $$ 由于矩阵 A 的列数与矩阵 B 的行数相同，可首先指出乘积 AB 是有意义的 我们还可以发现乘积 BA 却没有意义，因为矩阵 B 的列数不等于矩阵 A 的行数。这表明，矩阵的乘法一般不满足交换律，即 AB ≠ BA $$ \\begin{align*} AB \u0026= \\begin{bmatrix} -1 \u0026 5 \u0026 -4 \\\\ 3 \u0026 2 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 2 \u0026 1 \u0026 0 \\\\ 0 \u0026 -2 \u0026 1 \\\\ -1 \u0026 2 \u0026 3 \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} (-1,5,-4) ~ \\cdot ~ (2, 0, -1) \u0026 (-1,5,-4) \\cdot (1,-2,2) \u0026 (-1,5,-4) \\cdot (0,1,3) \\\\ (3,2,1) \\cdot (2,0.-1) \u0026 (3,2,1) \\cdot (1,-2,2) \u0026 (3,2,1) \\cdot (0,1,3) \\end{bmatrix} \\\\ \\\\ \u0026= \\begin{bmatrix} 2 \u0026 -19 \u0026 -7 \\\\ 5 \u0026 1 \u0026 5 \\end{bmatrix} \\end{align*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:3:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"向量与矩阵的乘法 $$ \\vec{u}A = \\begin{bmatrix} x,y,z \\end{bmatrix} \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} = \\begin{bmatrix} x,y,z \\end{bmatrix} \\begin{bmatrix} \\uparrow \u0026 \\uparrow \u0026 \\uparrow \\\\ A_{*,1} \u0026 A_{*,2} \u0026 A_{*,3} \\\\ \\downarrow \u0026 \\downarrow \u0026 \\downarrow \\end{bmatrix} $$ 可以观察到：该例中，uA 的计算结果是一个规模为 1 × 3 的行向量 $$ \\begin{align*} uA \u0026= \\left[ \\vec{u} \\cdot A_{*,1}, \\vec{u} \\cdot A_{*,2}, \\vec{u} \\cdot A_{*,3} \\right] \\\\ \\\\ \u0026= \\left[ xA_{11} + yA_{21} + zA_{31}, xA_{12} + yA_{22} + zA_{32}, xA_{13} + yA_{23} + zA_{33} \\right] \\\\ \\\\ \u0026= \\left[ xA_{11}, xA_{12}, xA_{13} \\right] + \\left[ yA_{21}, yA_{22}, yA_{23} \\right] + \\left[ zA_{31}, zA_{32}, zA_{33} \\right] \\\\ \\\\ \u0026= x\\left[ A_{11}, A_{12}, A_{13} \\right] + y\\left[ A_{21}, A_{22}, A_{23} \\right] + z\\left[ A_{31}, A_{32}, A_{33} \\right] \\\\ \\\\ \u0026= xA_{1,*} + yA_{2,*} + zA_{3,*} \\end{align*} $$ 这个结果实为一种线性组合（linear combination），这意味着向量与矩阵的乘积 uA 就相当于：向量 u 给定的标量系数 x、y、z 与矩阵 A 中各行向量的线性组合。注意，尽管我们只展示了1 × 3 行向量与 3 × 3 矩阵的乘法，但是这个结论却具有一般性。也就是说，对于一个 1 × n 行向量 u 与一个 n × m 矩阵 A，我们总可得到 u 所给出的标量系数与 A 中诸行向量的线性组合 uA ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:3:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"转置矩阵 转置矩阵（transpose matrix）指的是将原矩阵的行与列进行互换所得到的新矩阵。所以，根据一个 m × n 矩阵可得到一个规模为 n × m的转置矩阵。我们将矩阵 M 的转置矩阵记作 MT ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:4:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"例子 $$ \\begin{gather*} A = \\begin{bmatrix} 2 \u0026 -1 \u0026 8 \\\\ 3 \u0026 6 \u0026 -4 \\end{bmatrix} ~~~~~~~~ B = \\begin{bmatrix} a \u0026 b \u0026 c \\\\ d \u0026 e \u0026 f \\\\ g \u0026 h \u0026 i \\end{bmatrix} ~~~~~~~~ C = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\end{bmatrix} \\\\ \\\\ A^T = \\begin{bmatrix} 2 \u0026 3 \\\\ -1 \u0026 6 \\\\ 8 \u0026 -4 \\end{bmatrix} ~~~~~~~~ B^T = \\begin{bmatrix} a \u0026 d \u0026 g \\\\ b \u0026 e \u0026 h \\\\ c \u0026 f \u0026 i \\end{bmatrix} ~~~~~~~~ C^T = \\begin{bmatrix} 1 \u0026 2 \u0026 3 \u0026 4 \\end{bmatrix} \\end{gather*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:4:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"实用性质 ( A + B )T = AT + BT ( cA )T = cAT ( AB )T = BTAT ( AT )T = A ( A-1 )T = ( AT )-1 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:4:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"单位矩阵 单位矩阵（identity matrix）比较特殊，是一种主对角线上的元素均为 1，其他元素都为 0 的方阵。例如，下列依次是规模为 2 × 2， 3 × 3 和 4 × 4 的单位矩阵 $$ \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{bmatrix} $$ 单位矩阵是矩阵的乘法单位元（multiplicative identity）。即如果 A 为 m n × 矩阵，B 为 n × p 矩阵，而 I 为 n × n 的单位矩阵，那么 AI = A 且 IB = B; 换句话说，任何矩阵与单位矩阵相乘，得到的依然是原矩阵。我们可以将单位矩阵看作是矩阵中的“数字 1”。特别地，如果 M 是一个方阵，那么它与单位矩阵的乘法满足交换律：MI = IM = M ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:5:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"证明 MI = IM = M $$ \\begin{gather*} 设 ~ M = \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} ~ 以及 ~ I = \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\\\ \\\\ MI = \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} = \\begin{bmatrix} (1, 2) \\cdot (1,0) \u0026 (1,2) \\cdot (0,1) \\\\ (0,4) \\cdot (1,0) \u0026 (0,4) \\cdot (0,1) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} \\\\ \\\\ IM = \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} = \\begin{bmatrix} (1, 0) \\cdot (1,0) \u0026 (1,0) \\cdot (2,4) \\\\ (0,1) \\cdot (1,0) \u0026 (0,1) \\cdot (2,4) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 2 \\\\ 0 \u0026 4 \\end{bmatrix} \\\\ \\\\ 所以 ~ MI = IM = M ~ 是成立的 \\end{gather*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:5:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"证明 AI = A $$ \\begin{gather*} 设 ~ \\vec{u} = \\begin{bmatrix} -1, \u0026 2 \\end{bmatrix} 且 ~ I = \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix} ~ 验证 ~ \\vec{u}I = \\vec{u} \\\\ \\\\ \\vec{u}I = \\begin{bmatrix} -1 \u0026 2 \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix} = \\begin{bmatrix} (-1,2) \\cdot (1,0), \u0026 (-1,2) \\cdot (0,1) \\end{bmatrix} = \\begin{bmatrix} -1, \u0026 2 \\end{bmatrix} \\\\ \\\\ 所以 ~ \\vec{u}I = \\vec{u} ~ 另外我们也可以看出，我们无法计算乘积 ~ I\\vec{u}, 因为此矩阵乘法是无定义的 \\end{gather*} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:5:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"矩阵的行列式 行列式是一个特殊的函数，他以一个方阵作为输出，并输出一个实数。方阵A的行列式通常表示为 $ \\det(A) $ 我们可以从几何的角度来解释行列式。行列式反映了在线性变换下，（n 维多面体）体积变化的相关信息。另外，行列式也应用于解线性方程组的克莱姆法则（Cramer’s Rule，亦称克莱默法则）。 然而，我们在此学习行列式的主要目的是：利用它推导出求逆矩阵的公式 此外， 行列式还可以用于证明：方阵 A 是可逆的，当且仅当 det A ≠ 0 。这个结论很实用，因为它为我们确认矩阵的可逆性提供了一种行之有效的计算工具。不过在定义行列式之前，我们先要介绍一下余子阵的 概念 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:6:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"余子阵 指定一个 n × n 的矩阵 A，余子阵（minor matrix）$ \\overline{A}_{ij} $ 即为从 A 中去除第 i 行和第 j 列的 (n-1)x(n-1) 矩阵。 例子 求出下列矩阵的余子阵 $ \\overline{A}_{11} ~ \\overline{A}_{22} ~ \\overline{A}_{13} $ $$ A = \\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix} $$ 去除矩阵A的第一行和第一列，得到 $ \\overline{A}_{11} $ 为: $ A = \\begin{bmatrix} A_{22} \u0026 A_{23} \\\\ A_{32} \u0026 A_{33} \\end{bmatrix} $ 去除矩阵A的第二行和第二列，得到 $ \\overline{A}_{22} $ 为: $ A = \\begin{bmatrix} A_{11} \u0026 A_{13} \\\\ A_{31} \u0026 A_{33} \\end{bmatrix} $ 去除矩阵A的第一行和第三列，得到 $ \\overline{A}_{13} $ 为：$ A = \\begin{bmatrix} A_{21} \u0026 A_{22} \\\\ A_{31} \u0026 A_{32} \\end{bmatrix} $ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:6:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"行列式的定义 矩阵的行列式有一种递归定义 例如，一个 4 × 4 矩阵的行列式要根据 3 × 3 矩阵的行列式来定义，而 3 × 3 矩阵的行列式要靠 2 × 2 矩阵的行列式来定义，最后， 2 × 2 矩阵的行列式则依赖于1 × 1矩阵的行列式来定义： 1 x 1 矩阵 $ A = [A_{11}] $ 的行列式被简单的定义为 $ \\det{[A_{11}]} = A_{11} $ 例子 设 A 为一个 $ n \\times n $ 的矩阵. 那么 n \u003e 1时， 我们定义： $$ \\det{A} = \\sum_{j=1}^{n} A_{1j}(-1)^{1+j} \\det{\\overline{A}_{ij}} $$ 对照余子阵 $ \\overline{A}_{ij} $ 的定义可知，对于 2 x 2 矩阵来说，其相应的行列式公式为： $$ \\det{\\begin{bmatrix} A_{11} \u0026 A_{12} \\\\ A_{21} \u0026 A_{22} \\end{bmatrix}} = A_{11} \\det[A_{22}] - A_{12} \\det{[A_{21}]} = A_{11}A_{22} - A_{12}A_{21} $$ 对于3 x 3矩阵来说，其行列式计算公式为： $$ \\det{\\begin{bmatrix} A_{11} \u0026 A_{12} \u0026 A_{13} \\\\ A_{21} \u0026 A_{22} \u0026 A_{23} \\\\ A_{31} \u0026 A_{32} \u0026 A_{33} \\end{bmatrix}} = A_{11} \\det{\\begin{bmatrix} A_{22} \u0026 A_{23} \\\\ A_{32} \u0026 A_{33} \\end{bmatrix}} - A_{12} \\det{\\begin{bmatrix} A_{21} \u0026 A_{23} \\\\ A_{31} \u0026 A_{33} \\end{bmatrix}} + A_{13} \\det{\\begin{bmatrix} A_{21} \u0026 A_{22} \\\\ A_{31} \u0026 A_{32} \\end{bmatrix}} $$ 对于 4 x 4 矩阵, 其行列式计算公式为： 在 3D 图形学中，主要使用 4 × 4矩阵。因此，我们不再继续推导 n \u003e 4 的行列式公式。 例子2 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:6:2","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"伴随矩阵 设A为一个 n x n 矩阵。 乘积 $ C_{ij} = (-1)^{i+j}\\det{\\overline{A}_ij} $ 称为元素 $ A_{ij} $的代数余子式 如果为矩阵A中的每个元素分别计算出 $ C_{ij} $，并将他置于 $ C_A $中的第i行，第j列的相应位置, 那么将获得矩阵A的代数余子式; $$ C_A = \\begin{bmatrix} C_{11} \u0026 C_{12} \u0026 \\cdots \u0026 C_{1n} \\\\ \\\\ C_{21} \u0026 C_{22} \u0026 \\cdots \u0026 C_{2n} \\\\ \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\\\ C_{n1} \u0026 C_{n2} \u0026 \\cdots \u0026 C_{nn} \\end{bmatrix} $$ 若取矩阵 $ C_A $ 的转置矩阵, 将得到矩阵A的伴随矩阵, 记作: $ A^* = C^T_A $ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:7:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"逆矩阵 矩阵代数不存在除法运算的概念，但是却另外定义了一种矩阵乘法的逆运算。下面总结了与矩阵逆 运算有关的关键信息。 只有方阵才具有逆矩阵。因此，当提到逆矩阵时，我们便假设要处理的是一个方阵。 n x n 矩阵 M 的逆也是一个 n x n矩阵，并表示为 $ M^-1 $。 不是每个方阵都有逆矩阵。存在逆矩阵的方阵称为可逆矩阵（invertible matrix），不存在逆矩阵 的方阵称作奇异矩阵（singular matrix）。 可逆矩阵的逆矩阵是唯一的。 矩阵与其逆矩阵相乘将得到单位方阵：$ MM^-1 = M^-1M = I $。可以发现，矩阵与其逆矩阵的乘法运 算满足交换律。 另外，可以利用逆矩阵来解矩阵方程。例如，设矩阵方程 p’ = pM，且已知 p’与 M，求 p。假设矩阵 M 是可逆的（即存在 $ M^{−1} $），我们就能解得 p。过程如下： p’ = pM $ p^‘M^{-1} = pMM^{-1} $，方程两端各乘 $ M^{-1} $ $ p^‘M^{-1} = pI $，根据可逆矩阵的定义，有 $ MM^{-1} = I$ $ p^‘M^{-1} = p $，根据单位矩阵的定义，有 $ pI = p $ 在任何一本大学水平的线性代数教科书里，都可以找到求逆矩阵公式的推导过程，这里也就不再赘述了。此公式由原矩阵的伴随矩阵和行列式构成： $$ A^{-1} = \\frac{A^*}{detA} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:8:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"例子 推导 2 × 2矩阵 A = $ \\begin{bmatrix} A_{11} \u0026 A_{12} \\\\ \\\\ A_{21} \u0026 A_{22} \\end{bmatrix} $ 的逆矩阵通式，并利用此式求出矩阵 M = $ \\begin{bmatrix} 3 \u0026 0 \\\\ \\\\ -1 \u0026 2 \\end{bmatrix} $ 的逆矩阵 $$ \\begin{gather} \\det A = A_{11}A_{22} - A_{12}A_{21} \\\\ \\\\ C_A = \\begin{bmatrix} (-1)^{1+1} \\det \\overline{A}_{11} \u0026 (-1)^{1+2} \\det \\overline{A}_{12} \\\\ (-1)^{2+1} \\det \\overline{A}_{21} \u0026 (-1)^{2+2} \\det \\overline{A}_{22} \\end{bmatrix} = \\begin{bmatrix} A_{22} \u0026 -A_{21} \\\\ -A_{12} \u0026 A_{11} \\end{bmatrix} \\end{gather} $$ 因此： $$ A^{-1} = \\frac{A^*}{\\det A} = \\frac{C_A^T}{\\det A} = \\frac{1}{A_{11}A_{22} - A_{12}A_{21}} \\begin{bmatrix} A_{22} \u0026 -A_{12} \\\\ \\\\ -A_{21} \u0026 A_{11} \\end{bmatrix} $$ 现在运用此公式来求矩阵 M = $ \\begin{bmatrix} 3 \u0026 0 \\\\ \\\\ -1 \u0026 2 \\end{bmatrix} $ 的逆矩阵： $$ M^{-1} = \\frac{1}{3 \\cdot 2 - 0 \\cdot (-1)} \\begin{bmatrix} 2 \u0026 0 \\\\ \\\\ 1 \u0026 3 \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{3} \u0026 0 \\\\ \\\\ \\frac{1}{6} \u0026 \\frac{1}{2} \\end{bmatrix} $$ 为了核实结果，我们来验证 $ MM^{−1} = M^{−1}M = I $： $$ \\begin{bmatrix} 3 \u0026 0 \\\\ \\\\ -1 \u0026 2 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{3} \u0026 0 \\\\ \\\\ \\frac{1}{6} \u0026 \\frac{1}{2} \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 0 \\\\ \\\\ 0 \u0026 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{3} \u0026 0 \\\\ \\\\ \\frac{1}{6} \u0026 \\frac{1}{2} \\end{bmatrix} \\begin{bmatrix} 3 \u0026 0 \\\\ \\\\ -1 \u0026 2 \\end{bmatrix} $$ 我们以下列“矩阵乘积的逆”这一实用的代数性质，为此节画上句号： $$ (AB)^{-1} = B^{-1}A^{-1} $$ 该性质假设矩阵 A 与矩阵 B 都是可逆的，而且皆为同维方阵。为了证明 $ B^{−1} A^{−1} $ 是乘积 AB 的逆，我 们必须证实 $ (AB)(B^{−1}A^{−1}) = I $ 以及 $ (B^{−1}A^{−1}) (AB) = I $。证明过程如下： $$ \\begin{gather} (AB)(B^{-1}A^{-1}) = A(BB^{-1})A^{-1} = AIA^{-1} = AA^{-1} = I \\\\ \\\\ (B^{-1}A^{-1})(AB) = B^{-1}(A^{-1}A)B = B^{-1}IB = B^{-1}B = I \\end{gather} $$ ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:8:1","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"基本运算定律 由于在矩阵的加法和标量乘法的运算过程中，是以元素为单位展开计算的，所以它们实际上也分别从实数运算中继承了下列性质 A + B = B + A 加法交换律 (A + B) + C = A + (B + C) 加法结合律 r (A + B) = rA + rB 标量乘法对矩阵加法的分配律 (r + s) A = rA + sA 矩阵乘法对标量加法的分配律 ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:9:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"小结 m × n 矩阵 M 是一个由 m 行 n 列实数所构成的矩形阵列 如果 A 是一个 m × n矩阵，且 B 为一个 n × p矩阵，那么两者乘积 AB 的结果是一个规模为 m × p 的矩阵 C。 矩阵乘法不满足交换律（即一般来说， AB ≠ BA ），但是却满足结合律 (AB)C = A(BC) 转置矩阵由原矩阵互换行与列来求得。所以， m × n矩阵的转置矩阵为 n × m矩阵。我们将矩阵 M 的转置矩阵表示为 $ M^T $。 单位矩阵是一种除主对角线上的元素为 1 外，其他元素均为 0 的方阵。 行列式 det A 是一种特殊的函数，向它传入一个方阵便会计算出一个对应的实数。方阵 A 是可逆的，当且仅当 det A ≠ 0。行列式常常用于计算逆矩阵。 矩阵与其逆矩阵的乘积结果为单位矩阵，即 $ MM^−1 = M^−1M = I $。如果一个矩阵是可逆的，则此矩阵的逆矩阵是唯一的。只有方阵才可能有逆矩阵，即便是方阵也未必可逆。逆矩阵可由公式 $ A^{-1} = \\frac{A^}{detA} $ 来计算，其中 * A 是伴随矩阵（即矩阵 A 的代数余子式矩阵的转置矩阵）。* ","date":"2024-12-24","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/:10:0","tags":["3D图形学","矩阵"],"title":"矩阵","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/"},{"categories":["3D图形学"],"content":"标量与向量的一些习题","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"题目大纲 设向量 u = (1, 2)和向量 v = (3, –4)。写出下列各式的演算过程，并在 2D 坐标系内画出相应的向量 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。写出下列问题的解答过程 证明式子 (a) $ \\vec{u} + \\vec{v} = \\vec{v} + \\vec{u} $ （加法交换律） (b) $ \\vec{u} + (\\vec{v} + \\vec{w}) = (\\vec{u} + \\vec{v}) + \\vec{w} $ （加法结合律） (c) $ (ck)\\vec{u} = c(k\\vec{u}) $ （标量乘法的结合律） (d) $ k(\\vec{u} + \\vec{v}) = k\\vec{u} + k\\vec{v} $ （分配律 1） (e) $ \\vec{u}(k + c) = k\\vec{u} + c\\vec{u} $ （分配律 2） 根据等式 “2[(1, 2, 3) − x] − (−2, 0, 4) = −2(1, 2, 3)\"，求其中的向量 x。 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。对 u 和 v 进行规范化处理。 设 k 为标量，$向量 u = (u_x, u_y, u_z)。求证||ku|| = ||k|| ||u||$ 下列各组向量中，u 与 v 之间的夹角是直角、锐角还是钝角？ （a）u = (1, 1, 1)，v = (2, 3, 4) （b）u = (1, 1, 0)，v = (−2, 2, 0) （c）u = (−1, −1, −1)，v = (3, 1, 0) 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。计算 u 和 v 之间的夹角 θ 设向量 $ u = (u_x, u_y, u_z)、v = (v_x, v_y, v_z)和 w = (w_x, w_y, w_z)，且 c 和 k 为标量。证明下列点积性质。 （a）$ \\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u} $ （b）$ \\vec{u} \\cdot (\\vec{v} + \\vec{w}) = \\vec{u} \\cdot \\vec{v} + \\vec{u} \\cdot \\vec{w} $ （c）$ k(\\vec{u} \\cdot \\vec{v}) = (k\\vec{u}) \\cdot \\vec{v} = \\vec{u} \\cdot (k\\vec{v}) $ （d）$ \\vec{v} \\cdot \\vec{v} = ||v||^2 $ （e）$ 0 \\cdot \\vec{v} = 0 $ 利用余弦定理 （ $ c^2 = a^2 + b^2 - 2ab \\cos\\theta $ ，其中 a、b、c 分别是三角形 3 条边的边长， θ 为 a 与 b 之间的夹角）来证明：$ u_x v_x + u_y v_y + u_z v_z = ||u|| ||v|| \\cos\\theta $ 设向量 n = (−2, 1)。将向量 g = (0, −9.8) 分解为两个相互正交的向量之和，使它们一个平行于 n、 一个正交于 n。最后，在同一 2D 坐标系中画出这些向量。 设向量 u = (−2, 1, 4)和向量 v = (3, −4, 1)。求向量 w = u × v ，再证明 w⋅ u= 0 及 w ⋅ v= 0 。 设 A = (0, 0, 0)，B = (0, 1, 3)和 C = (5, 1, 0)三点在某坐标系中定义了一个三角形。求出一正交于此三角形的向量。 证明 $ \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta $ 证明：由向量 u 和向量 v 张成的平行四边形面积为|| u × v || ，如图 1.21 所示。 举例证明：存在 3D 向量 u、v 和 w，满足 u x (v x w) ≠ (u x v) x w 。这说明叉积一般不满足结合律。 证明两个非零且相互平行向量的叉积为零向量，即 $ \\vec{u} \\times k\\vec{u} = 0 $。 利用格拉姆—施密特正交化方法，令向量集 {(1, 0, 0), (1, 5, 0), (2, 1, −4)} 规范正交化。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:1:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第一题 设向量 u = (1, 2)和向量 v = (3, –4)。写出下列各式的演算过程，并在 2D 坐标系内画出相应的向量 $$ \\begin{align*} \\vec{u} + \\vec{v} \u0026= (u_x + v_x, u_y + v_y) \\\\ \\\\ \u0026= (1 + 3, 2 + (-4)) \\\\ \\\\ \u0026= (4, -2) \\end{align*} $$ $$ \\begin{align*} \\vec{u} - \\vec{v} \u0026= (u_x - v_x, u_y - v_y) \\\\ \\\\ \u0026= (1 - 3, 2 - (-4)) \\\\ \\\\ \u0026= (-2, 6) \\end{align*} $$ $$ \\begin{align*} 2\\vec{u} + \\frac{1}{2} \\vec{v} \u0026= (2u_x, 2u_y) + (\\frac{1}{2} v_x, \\frac{1}{2} v_y) \\\\ \\\\ \u0026= (2u_x + \\frac{1}{2} v_x, 2u_y + \\frac{1}{2} v_y) \\\\ \\\\ \u0026= (2 + 1.5, 4 + (-2)) \\\\ \\\\ \u0026= (3.5, 2) \\end{align*} $$ $$ \\begin{align*} -2\\vec{u} + \\vec{v} \u0026= (-2u_x, -2u_y) + (v_x,v_y) \\\\ \\\\ \u0026= (-2u_x + v_x, -2u_y, v_y) \\\\ \\\\ \u0026= (-2 + 3, -4 + -4) \\\\ \\\\ \u0026= (1, -8) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:2:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第二题 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。写出下列问题的解答过程 $$ \\begin{align*} \\vec{u} + \\vec{v} \u0026= (u_x + v_x, u_y + v_y, u_z + v_z) \\\\ \\\\ \u0026= (-1 + 3, 3 + (-4), 2 + 1) \\\\ \\\\ \u0026= (2, -1, 3) \\end{align*} $$ $$ \\begin{align*} \\vec{u} - \\vec{v} \u0026= (u_x - v_x, u_y - v_y, u_z - v_z) \\\\ \\\\ \u0026= (-1 - 3, 3 - (-4), 2 - 1) \\\\ \\\\ \u0026= (-4, 7, 1) \\end{align*} $$ $$ \\begin{align*} 3\\vec{u} + 2\\vec{v} \u0026= (3u_x, 3u_y, 3u_z) + (2v_x, 2v_y, 2v_z) \\\\ \\\\ \u0026= (-3, 9, 6) + (6, -8, 2) \\\\ \\\\ \u0026= (-3 + 6, 9 + (-8), 6 + 2) \\\\ \\\\ \u0026= (3, 1, 8) \\end{align*} $$ $$ \\begin{align*} -2\\vec{u} + \\vec{v} \u0026= (-2u_x, -2u_y, -2u_z) + (v_x, v_y, v_z) \\\\ \\\\ \u0026= (2, -6, -4) + (3, -4, 1) \\\\ \\\\ \u0026= (2 + 3, -6 + (-4), -4 + 1) \\\\ \\\\ \u0026= (5, -10, -3) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:3:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第三题 (a) $ \\vec{u} + \\vec{v} = \\vec{v} + \\vec{u} $ （加法交换律） $$ \\vec{u} + \\vec{v} = (u_x + v_x, u_y + v_y, u_z + v_z) = (v_x + u_x, v_y + u_y, v_z + u_z) = \\vec{v} + \\vec{u} $$ (b) $ \\vec{u} + (\\vec{v} + \\vec{w}) = (\\vec{u} + \\vec{v}) + \\vec{w} $ （加法结合律） $$ \\begin{align*} \\vec{u} + (\\vec{v} + \\vec{w}) \u0026= (u_x, u_y, u_z) + (v_x + w_x, v_y + w_y, v_z + w_z) \\\\ \\\\ \u0026= (u_x + (v_x + w_x), u_y + (v_y + w_y), u_z + (v_z + w_z)) \\\\ \\\\ \u0026= ((u_x + v_x) + w_x, (u_y + v_y) + w_y, (u_z + v_z) + w_z) \\\\ \\\\ \u0026= (u_x + v_x, u_y + v_y, u_z + v_z) + (w_x, w_y, w_z) \\\\ \\\\ \u0026= (\\vec{u} + \\vec{v}) + \\vec{w} \\end{align*} $$ (c) $ (ck)\\vec{u} = c(k\\vec{u}) $ （标量乘法的结合律） $$ \\begin{align*} (ck)\\vec{u} \u0026= (ck)(u_x, u_y, u_z) \\\\ \\\\ \u0026= ((ck)u_x, (ck)u_y, (ck)u_z) \\\\ \\\\ \u0026= (c(ku_x), c(ku_y), c(ku_z)) \\\\ \\\\ \u0026= c(k\\vec{u}) \\end{align*} $$ (d) $ k(\\vec{u} + \\vec{v}) = k\\vec{u} + k\\vec{v} $ （分配律 1） $$ \\begin{align*} k(\\vec{u} + \\vec{v}) \u0026= k(u_x + v_x, u_y + v_y, u_z + v_z) \\\\ \\\\ \u0026= (ku_x + kv_x, ku_y + kv_y, ku_z + kv_z) \\\\ \\\\ \u0026= k\\vec{u} + k\\vec{v} \\end{align*} $$ (e) $ \\vec{u}(k + c) = k\\vec{u} + c\\vec{u} $ （分配律 2） $$ \\begin{align*} \\vec{u}(k + c) \u0026= (u_x(k+c), u_y(k+c), u_z(k+c)) \\\\ \\\\ \u0026= (ku_x + cu_x, ku_y + cu_y, ku_z + cu_z) \\\\ \\\\ \u0026= k\\vec{u} + c\\vec{u} \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:4:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第四题 根据等式 “2[(1, 2, 3) − x] − (−2, 0, 4) = −2(1, 2, 3)\"，求其中的向量 x。 $$ \\begin{align*} 2[(1, 2, 3) − \\vec{x}] − (−2, 0, 4) \u0026= -2(1, 2, 3) \\\\ \\\\ [(2, 4, 6) - 2(\\vec{x})] - (-2, 0, 4) \u0026= (-2, -4, -6) \\\\ \\\\ [(2, 4, 6) - 2(\\vec{x})] \u0026= (-2, -4, -6) + (-2, 0, 4) \\\\ \\\\ [(2, 4, 6) - 2(\\vec{x})] \u0026= (-4, -4, -2) \\\\ \\\\ - 2(\\vec{x}) \u0026= (-4, -4, -2) - (2, 4, 6) \\\\ \\\\ 2(\\vec{x}) \u0026= - (-6, -8, -8) \\\\ \\\\ \\vec{x} \u0026= (3, 4, 4) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:5:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第五题 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。对 u 和 v 进行规范化处理。 $$ \\begin{align*} \\vec{u} = \\frac{\\vec{u}}{\\Vert \\vec{u} \\Vert} = \\frac{(u_x, u_y, u_z)}{\\sqrt{u_x^2 + u_y^2 + u_z^2}} = \\frac{(-1, 3, 2)}{\\sqrt{1 + 9 + 4}} = \\frac{(-1, 3, 2)}{\\sqrt{14}} = (\\frac{-1}{\\sqrt{14}}, \\frac{3}{\\sqrt{14}}, \\frac{2}{\\sqrt{14}}) \\\\ \\\\ \\vec{v} = \\frac{\\vec{v}}{\\Vert \\vec{v} \\Vert} = \\frac{(v_x, v_y, v_z)}{\\sqrt{v_x^2 + v_y^2 + v_z^2}} = \\frac{(3, -4, 1)}{\\sqrt{9 + 16 + 1}} = \\frac{(3, -4, 1)}{\\sqrt{26}} = (\\frac{3}{\\sqrt{26}}, \\frac{-4}{\\sqrt{26}}, \\frac{1}{\\sqrt{26}}) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:6:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第六题 设 k 为标量，$向量 u = (u_x, u_y, u_z)。求证||ku|| = ||k|| ||u||$ $$ \\begin{align*} ||ku|| \u0026= ||ku_x, ku_y, ku_z|| \\\\ \\\\ \u0026= \\sqrt{(ku_x)^2 + (ku_y)^2 + (ku_z)^2} \\\\ \\\\ \u0026= \\sqrt{k^2u_x^2 + k^2u_y^2 + k^2u_z^2} \\\\ \\\\ \u0026= \\sqrt{k^2 + (u_x^2, u_y^2, u_z^2)} \\\\ \\\\ \u0026= \\sqrt{k^2} + \\sqrt{\\vec{u}^2} \\\\ \\ \u0026= ||k|| + ||\\vec{u}|| \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:7:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第七题 下列各组向量中，u 与 v 之间的夹角是直角、锐角还是钝角？ （a）u = (1, 1, 1)，v = (2, 3, 4) $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = ||u|| ||v|| \\cos\\theta \\\\ \\\\ \\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{||u|| ||v||} \\\\ \\\\ \\cos\\theta = \\frac{u_x v_x + u_y v_y + u_z v_z}{\\sqrt{u_x^2 + u_y^2 + u_z^2} \\cdot \\sqrt{v_x^2 + v_y^2 + v_z^2}} \\\\ \\\\ \\cos\\theta = \\frac{2 + 3 + 4}{\\sqrt{3} \\cdot \\sqrt{29}} \\\\ \\\\ \\cos\\theta = \\frac{9}{\\sqrt{87}} \\\\ \\\\ 因\\cos\\theta \u003e 0, 故为锐角 \\\\ \\\\ 如果想求出角度 则可以 θ=arccos(\\frac{9}{\\sqrt{87}})≈15.8^\\circ \\end{gather*} $$ （b）u = (1, 1, 0)，v = (−2, 2, 0) $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = ||u|| ||v|| \\cos\\theta \\\\ \\\\ \\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{||u|| ||v||} \\\\ \\\\ \\cos\\theta = \\frac{u_x v_x + u_y v_y + u_z v_z}{\\sqrt{u_x^2 + u_y^2 + u_z^2} \\cdot \\sqrt{v_x^2 + v_y^2 + v_z^2}} \\\\ \\\\ \\cos\\theta = \\frac{-2 + 2 + 0}{\\sqrt{2} \\cdot \\sqrt{8}} \\\\ \\\\ \\cos\\theta = \\frac{0}{\\sqrt{16}} = 0 \\\\ \\\\ 因\\cos\\theta = 0, 故为直角 \\end{gather*} $$ （c）u = (−1, −1, −1)，v = (3, 1, 0) $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = ||u|| ||v|| \\cos\\theta \\\\ \\\\ \\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{||u|| ||v||} \\\\ \\\\ \\cos\\theta = \\frac{u_x v_x + u_y v_y + u_z v_z}{\\sqrt{u_x^2 + u_y^2 + u_z^2} \\cdot \\sqrt{v_x^2 + v_y^2 + v_z^2}} \\\\ \\\\ \\cos\\theta = \\frac{(-3) + (-1) + 0}{\\sqrt{3} \\cdot \\sqrt{10}} \\\\ \\\\ \\cos\\theta = \\frac{-4}{\\sqrt{30}} \\\\ \\\\ 因\\cos\\theta \u003c 0, 故为钝角 \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:8:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第八题 设向量 u = (−1, 3, 2)和向量 v = (3, −4, 1)。计算 u 和 v 之间的夹角 θ $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = ||u|| ||v|| \\cos\\theta \\\\ \\\\ \\cos\\theta = \\frac{\\vec{u} \\cdot \\vec{v}}{||u|| ||v||} \\\\ \\\\ \\cos\\theta = \\frac{u_x v_x + u_y v_y + u_z v_z}{\\sqrt{u_x^2 + u_y^2 + u_z^2} \\cdot \\sqrt{v_x^2 + v_y^2 + v_z^2}} \\\\ \\\\ \\cos\\theta = \\frac{(-3) + (-12) + 2}{\\sqrt{14} \\cdot \\sqrt{26}} \\\\ \\\\ \\cos\\theta = \\frac{-13}{\\sqrt{2\\sqrt{91}}} \\\\ \\\\ θ=arccos(\\frac{-13}{2\\sqrt{91}})≈123.7^\\circ \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:9:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第九题 设向量 $ u = (u_x, u_y, u_z)、v = (v_x, v_y, v_z)和 w = (w_x, w_y, w_z)，且 c 和 k 为标量。证明下列点积性质。 （a）$ \\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u} $ $$ \\begin{align*} \\vec{u} \\cdot \\vec{v} \u0026= (u_x, u_y, u_z) + (v_x, v_y, v_z) \\\\ \\\\ \u0026= (u_x v_x + u_y v_y + u_z v_z) \\\\ \\\\ \u0026= (v_x, v_y, v_z) + (u_x, u_y, u_z) \\\\ \\\\ \u0026= \\vec{v} \\cdot \\vec{u} \\end{align*} $$ （b）$ \\vec{u} \\cdot (\\vec{v} + \\vec{w}) = \\vec{u} \\cdot \\vec{v} + \\vec{u} \\cdot \\vec{w} $ $$ \\begin{align*} \\vec{u} \\cdot (\\vec{v} + \\vec{w}) \u0026= (u_x, u_y, u_z) \\cdot ((v_x + w_x, v_y + w_y, v_z + w_z)) \\\\ \\\\ \u0026= u_x(v_x + w_x) + u_y(v_y + w_y) + u_z(v_z + w_z) \\\\ \\\\ \u0026= (u_x v_x + u_x w_x) + (u_y v_y + u_y w_y) + (u_z v_z + u_z w_z) \\\\ \\\\ \u0026= (u_x v_x + u_y v_y + u_z v_z) + (u_x w_x + u_y w_y + u_z w_z) \\\\ \\\\ \u0026= \\vec{u} \\cdot \\vec{v} + \\vec{u} \\cdot \\vec{w} \\end{align*} $$ （c）$ k(\\vec{u} \\cdot \\vec{v}) = (k\\vec{u}) \\cdot \\vec{v} = \\vec{u} \\cdot (k\\vec{v}) $ $$ \\begin{align*} k(\\vec{u} \\cdot \\vec{v}) \u0026= k(u_x v_y + u_y v_y + u_z v_z) \\\\ \\\\ \u0026= (ku_x)v_x + (ku_y)v_y + (ku_z)v_z \\\\ \\\\ \u0026= (k\\vec{u}) \\cdot \\vec{v} \\\\ \\\\ \u0026= u_x(kv_x) + u_y(kv_y) + u_z(kv_z) \\\\ \\\\ \u0026= \\vec{u} \\cdot (k\\vec{v}) \\end{align*} $$ （d）$ \\vec{v} \\cdot \\vec{v} = ||v||^2 $ $$ \\begin{align*} \\vec{v} \\cdot \\vec{v} \u0026= v_x v_x + v_y v_y + v_z v_z \\\\ \\\\ \u0026= v_x^2 + v_y^2 + v_z^2 \\\\ \\\\ \u0026= \\sqrt{v_x^2 + v_y^2 + v_z^2}^2 \\\\ \\\\ \u0026= ||v||^2 \\end{align*} $$ （e）$ 0 \\cdot \\vec{v} = 0 $ $$ \\begin{align*} 0 \\cdot \\vec{v} \u0026= 0v_x + 0v_y + 0v_z \\\\ \\\\ \u0026= 0 + 0 + 0 \\\\ \\\\ \u0026= 0 \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:10:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十题 利用余弦定理 （ $ c^2 = a^2 + b^2 - 2ab \\cos\\theta $ ，其中 a、b、c 分别是三角形 3 条边的边长， θ 为 a 与 b 之间的夹角）来证明：$ u_x v_x + u_y v_y + u_z v_z = ||u|| ||v|| \\cos\\theta $ $$ \\begin{gather*} c^2 = a^2 + b^2 - 2ab \\cos\\theta \\\\ \\\\ ||w||^2 = ||u||^2 + ||v||^2 - 2||u|| ||v|| \\cos\\theta ~~~~~~ (因为 c a b都是各边对应的模) \\\\ \\\\ ||w||^2 = (\\vec{u} - \\vec{v})^2 = ||u||^2 + ||v||^2 - 2(\\vec{u} \\cdot \\vec{v}) ~~~~~ (点积分配律) \\\\ \\\\ ||u||^2 + ||v||^2 - 2||u|| ||v|| \\cos\\theta = ||u||^2 + ||v||^2 - 2(\\vec{u} \\cdot \\vec{v}) ~~~~~ (||w||^2 = ||w||^2) \\\\ \\\\ - 2||u|| ||v|| \\cos\\theta = - 2(\\vec{u} \\cdot \\vec{v}) \\\\ \\\\ ||u|| ||v|| \\cos\\theta = \\vec{u} \\cdot \\vec{v} \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:11:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十一题 设向量 n = (−2, 1)。将向量 g = (0, −9.8) 分解为两个相互正交的向量之和，使它们一个平行于 n、 一个正交于 n。最后，在同一 2D 坐标系中画出这些向量。 $$ \\begin{align*} \\vec{g_{||}} \u0026= proj_n(\\vec{g}) \\\\ \\\\ \u0026= (\\vec{g} \\cdot \\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert})\\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert} \\\\ \\\\ \u0026= (\\frac{(\\vec{g} \\cdot \\vec{n})}{\\Vert \\vec{n} \\Vert ^ 2}) \\vec{n} \\\\ \\\\ \u0026= (\\frac{(g_x n_x + g_y n_y)}{\\sqrt{n_x^2 + n_y^2}}) (-2, 1) \\\\ \\\\ \u0026= (\\frac{(0 + (-9.8))}{\\sqrt{5}})(-2, 1) \\\\ \\\\ \u0026= −1.96(−2,1) \\\\ \\\\ \u0026= (-3.92, −1.96) \\\\ \\\\ \\vec{g}_\\perp \u0026= \\vec{g} - \\vec{g_{||}} \\\\ \\\\ \u0026= (0, −9.8) − (3.92, −1.96) \\\\ \\\\ \u0026= (−3.92, −7.84) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:12:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十二题 设向量 u = (−2, 1, 4)和向量 v = (3, −4, 1)。求向量 w = u × v ，再证明 w⋅ u= 0 及 w ⋅ v= 0 。 $$ \\begin{align*} \\vec{w} = \\vec{u} \\times \\vec{v} \u0026= (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_x) \\\\ \\\\ \u0026= (1 - (-16), 12 - (-2), 8 - 3) \\\\ \\\\ \u0026= (17, 14, 5) \\\\ \\\\ \\vec{w} \\cdot \\vec{u} \u0026= (w_x u_x + w_y u_y + w_z u_z) \\\\ \\\\ \u0026= (-34 + (14) + (20)) \\\\ \\\\ \u0026= 0 \\\\ \\\\ \\vec{w} \\cdot \\vec{v} \u0026= (w_x v_x + w_y v_y + w_z v_z) \\\\ \\\\ \u0026= (51 + (-56) + 5) \\\\ \\\\ \u0026= 0 \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:13:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十三题 设 A = (0, 0, 0)，B = (0, 1, 3)和 C = (5, 1, 0)三点在某坐标系中定义了一个三角形。求出一正交于此三角形的向量。 $$ \\begin{align*} \\vec{AB} \u0026= B - A = (0 - 0, 1 - 0, 3 - 0) = (0, 1, 3) \\\\ \\\\ \\vec{AC} \u0026= C - A = (5 - 0, 1 - 0, 0 - 0) = (5, 1, 0) \\\\ \\\\ \\vec{ABC_\\perp} \u0026= \\vec{AB} \\times \\vec{AC} \\\\ \\\\ \u0026= (AB_y AC_z - AB_z AC_y, AB_z AC_x - AB_x AC_z, AB_x AC_y - AB_y AC_x) \\\\ \\\\ \u0026= (0 - 3, 15 - 0, 0 - 5) \\\\ \\\\ \u0026= (-3, 15, -5) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:14:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十四题 证明 $ \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta $ $$ \\begin{gather*} \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta \\\\ \\\\ \\Vert \\vec{u} \\times \\vec{v} \\Vert = (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_z) \\\\ \\\\ \\Vert \\vec{u} \\times \\vec{v} \\Vert^2 = (u_y v_z - u_z v_y)^2 + (u_z v_x - u_x v_z)^2 + (u_x v_y - u_y v_z)^2 \\\\ \\\\ \\Vert \\vec{u} \\times \\vec{v} \\Vert^2 = (u_y^2 v_z^2 - 2u_yv_zu_zv_y + u_z^2 v_y^2) + (u_z^2 v_x^2 - 2u_zv_xu_xv_z + u_x^2 v_z^2) + (u_x^2 v_y^2 - 2u_xv_yu_yv_x + u_y^2 v_x^2) \\\\ \\\\ \\Vert \\vec{u} \\Vert^2 \\Vert \\vec{v} \\Vert^2 - (\\vec{u} \\cdot\\vec{v})^2 = (u_y^2 v_z^2 + u_z^2 v_y^2) + (u_z^2 v_x^2 + u_x^2 v_z^2) + (u_x^2 v_y^2 + u_y^2 v_x^2) - 2(u_yv_zu_zv_y + u_zv_xu_xv_z + u_xv_yu_yv_x) \\\\ \\\\ \\Vert \\vec{u} \\Vert^2 \\Vert \\vec{v} \\Vert^2 - (\\vec{u} \\cdot\\vec{v}) \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:15:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十五题 证明：由向量 u 和向量 v 张成的平行四边形面积为 || u x v || ，如图 1.21 所示。 $$ A = \\Vert \\vec{v} \\Vert h \\\\ \\\\ h = \\Vert \\vec{u} \\Vert \\sin\\theta \\\\ \\\\ A = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta \\\\ \\\\ A = \\Vert \\vec{u} \\times \\vec{v} \\Vert $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:16:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十六题 举例证明：存在 3D 向量 u、v 和 w，满足 u x (v x w) ≠ (u x v) x w 。这说明叉积一般不满足结合律。 $$ \\begin{gather*} 设 \\vec{u} = (1, 0, 0), \\vec{v} = (1, 1, 0), \\vec{w} = (0, 1, 1) \\\\ \\\\ \\vec{u} \\times (\\vec{v} \\times \\vec{w}) = \\vec{u} \\times (1, -1, 1) = (0, -1, -1) \\\\ \\\\ (\\vec{u} \\times \\vec{v}) \\times \\vec{w} = (0, 0, 1) \\times \\vec{w} = (-1, 0, 0) \\\\ \\\\ 故 \\vec{u} \\times (\\vec{v} \\times \\vec{w}) \\neq (\\vec{u} \\times \\vec{v}) \\times \\vec{w} \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:17:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十七题 证明两个非零且相互平行向量的叉积为零向量，即 $ \\vec{u} \\times k\\vec{u} = 0 $。 $$ \\begin{align*} \\vec{u} \\times k\\vec{u} \u0026= (u_y ku_z - u_z ku_y, u_z ku_x - u_x ku_z, u_x ku_y - u_y ku_x ) \\\\ \\\\ \u0026= k(u_y u_z - u_z u_y, u_z u_x - u_x u_z, u_x u_y - u_y u_x) \\\\ \\\\ \u0026= k(0, 0, 0) \\\\ \\\\ \u0026= (0, 0, 0) \\end{align*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:18:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"第十八题 利用格拉姆—施密特正交化方法，令向量集 {(1, 0, 0), (1, 5, 0), (2, 1, −4)} 规范正交化。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/:19:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量-习题","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F%E4%B9%A0%E9%A2%98/"},{"categories":["3D图形学"],"content":"标量与向量","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量的定义 向量（vector）是一种兼具大小（也称为模，magnitude）和方向的量。具有这两种属性的量皆 称为向量值物理量（vector-valued quantity） 与向量值物理量相关的例子有作用力（在特定方向上施 加的力—力的大小即为向量的模）、位移（质点沿净方向移动的距离）和速度（速率和方向）。这 样一来，向量就能用于表示力、位移和速度 另外，有时也用向量单指方向，例如玩家在 3D 游戏 里的视角方向、一个多边形的朝向、一束光线的传播方向以及它照射在某表面后的反射方向等 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:1:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"几何意义 通过图像中的一条有向线段即可表示一个向量， 其中，线段长度代表向量的模，箭头的指向代表向量的方向。我们可以注意到：向量的绘制位置之于其 自身是无足轻重的，因为改变某向量的位置并不会对其大小或方向这两个属性造成任何影响。因此，我 们说：两个向量相等，当且仅当它们的长度相等且方向相同。所以，图中的向量 u 和向量 v 相等， 因为它们的长度相等且方向相同 事实上，由于位置对于向量是无关紧要的，所以我们总是能在平移一 个向量的同时又完全不改变它的几何意义（因为平移操作既不影响它的长度，也不改变它的方向）。显而 易见，我们可以将向量 u 完全平移到向量 v 处（反之亦可），使两者完全重合，分毫不差—由此即可证明它们是相等的 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:1:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量与坐标系 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:2:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"左 /右手坐标系 Direct3D 采用的是左手坐标系（left-handed coordinate system）。 同一个向量在不同的坐标系中有着不同的坐标表示 对于向量来说，它的方向和模都表现 在对应的有向线段上，不会更改；只有在改变 描述它的参考系时，其坐标才会相应地改变。这一点是很重要的，因为这意味着：每当我们根据坐标来 确定一个向量时，其对应的坐标总是相对于某一参考系而言的。在 3D 计算机图形学中，我们通常会用 到较多的参考系。因此，我们需要记录向量在每一种坐标系中的对应坐标。另外，我们也需要知道如何 将向量坐标在不同的标架之间进行转换。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:2:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量的基本运算 $$ \\vec{u} = (u_x, u_y, u_z) ~ 和 ~ \\vec{v} = (v_x, v_y, v_z) $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量相等 两个向量相等，当且仅当他们的对应分量相等。即 $ \\vec{u} = \\vec{v} $ , 当且仅当 $ u_x = v_x，u_y = v_y，u_z = v_z $ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量相加 向量的加法即令两个向量的对应分量分别相加： $ \\vec{u} = \\vec{v} = ( u_x + v_x, u_y + v_y, u_z + v_z)$ 注意，只有同维 的向量之间才可以进行加法运算 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量相减 向量减法可以通过向量加法和标量乘法表示： $$ \\vec{u} - \\vec{v} = \\vec{u} + (-1 \\cdot \\vec{v}) = \\vec{u} + (-\\vec{v}) = (u_x - v_x, u_y - v_y, u_z - v_z) $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:3","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"标量 x 向量 向量可以与标量（即实数）相乘，所得到的结果仍是一个向量。 例如，设 k 为一个标量，则 $ k\\vec{u} = (ku_x, ku_y, ku_z) $。这种运算叫作标量乘法 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:3:4","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"零向量 有个叫作零向量（zero-vector）的特殊向量，它的所有分量都为 0， 可直接将它简记作 0 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:4:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量的几何意义 见图 1.6a由此可知，把一个向量的系数变为其相反数，就相当于在几何学中“翻 转”此向量的方向，而且对向量进行标量乘法即为对其长度进行缩放。 图 1.6b 展示了向量加法运算的几何意义：把 向量 u 进行平移，使 u 的尾部与 v 的头部重合。此时，向量 u 与向量 v 的和即：以 v 的尾部为 起点、以平移后 u 的头部为终点所作的向量（如果令向量 u 的位置保持不变，平移向量 v，使 v 的尾部与 u 的头部重合也能得到同样的结果。在这种情况下，u + v 的和就可以表示为以 u 的尾 部为起点、以平移后 v 的头部为终点所作的向量）。 可以看出，向量的加法运算与物理学中不同 作用力合成合力的规则是一致的。如果有两个力（两个向量）作用在同一方向上，则将在这个 方向上产生更大的合力（更长的向量）；如果有两个力（两个向量）作用于彼此相反的方向上， 那么便会产生更小的合力（更短的向量），如图 1.7 所示 图 1.6c 展示了向量减法运算的几何意义。从本质 上讲，v − u 的差值仍是一个向量，该向量自 u 的头部始至 v 的头部终。如果我们将 u 和 v 看作两个 点，那么 v − u 得到的是一个从点 u 指向点 v 的向量； 这种解释方式的重点在于使我们找出向量的方 向。同时，不难看出，在把 u 与 v 看作点的时候，v − u 的长度也就是“点 u 到点 v 的距离” ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:5:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"长度和单位向量 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:6:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"长度（模 ） 向量大小（亦称为模）的几何意义是对应有向线段的长度，用双竖线表示（例如||u||代表向量 u 的 模） 现给出向量 u = (x, y, z)，我们希望用代数的方法计算它的 模。3D 向量的模可通过运用两次勾股定理得出 $$ \\Vert u \\Vert = \\sqrt{y^2 + a^2 } = \\sqrt{y^2 + (\\sqrt x^2 + z^2)^2} = \\sqrt{x^2 + y^2 + z^2} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:6:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"单位向量 当向量的模为1的时候他就是单位向量 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:6:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"向量的规范化 在某些情况下，我们并不关心向量的长度，仅用它来表示方向。对此，我们希望使该向量的长度为 1。把一个向量的长度变为单位长度称为向量的规范化（normalizing）处理。具体实现方法是，将向量 的每个分量分别除以该向量的模 $$ \\begin{gather*} \\hat{u} = \\frac{\\vec{u}}{\\Vert \\vec{u} \\Vert} = (\\frac{x}{\\Vert \\vec{u} \\Vert}, \\frac{y}{\\Vert \\vec{u} \\Vert}, \\frac{z}{\\Vert \\vec{u} \\Vert}) \\\\ \\\\ 为了验证公式的正确性，下面计算 \\hat{u} 的长度，也就是模: \\\\ \\\\ \\Vert \\hat{u} \\Vert = \\sqrt{(\\frac{x}{\\Vert u \\Vert})^2 (\\frac{x}{\\Vert u \\Vert})^2 (\\frac{z}{\\Vert u \\Vert})^2} = \\frac{\\sqrt{x^2 + y^2 + z^2}}{\\sqrt{\\Vert u \\Vert ^ 2}} = \\frac{\\Vert u \\Vert}{\\Vert u \\Vert} = 1 \\\\ \\\\ 由此可见， \\hat{u} 确实是一个单位向量（unit vector） \\end{gather*} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:6:3","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"点积 点积（dot product，亦称数量积或内积）是一种计算结果为标量值的向量乘法运算，因此有时也称 为标量积（scalar product）。 $$ \\begin{gather*} 设向量 \\vec{u} = ( u_x, u_y, u_z),~ \\vec{v} = (v_x, v_y, v_z) \\\\ \\\\ 则点积的定义为: \\vec{u} \\cdot \\vec{v} = u_x v_x + u_y v_y + u_z v_z \\\\ \\\\ 可见，点积就是向量间对应分量的乘积之和。 \\end{gather*} $$ 点积的定义并没有明显地体现出其几何意义。但是我们却能根据余弦定理（law of cosines)，找到二向量点积的几何关系 $$ \\vec{u} \\cdot \\vec{v} = \\Vert u \\Vert \\Vert v \\Vert \\cos\\theta $$ 其中，$ \\theta $ 是向量 $ \\vec{u} $与向量 $ \\vec{v} $ 之间的夹角，$ 0 \\leq \\theta \\leq \\pi $ 如果向量 u 和向量 v 都是单位向量，那么 u ⋅ v 就等 于两向量夹角的余弦值，即 u⋅ v= cosθ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:7:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"点积几何性质 如果 u⋅ v = 0 ，那么 u ⊥ v （即两个向量正交） 如果 u⋅ v \u003e 0 ，那么两向量之间的夹角 θ 小于 90°（即两向量间的夹角为一锐角） 如果 u⋅ v \u003c 0 ，那么两向量之间的夹角 θ 大于 90°（即两向量间的夹角为一钝角） ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:7:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"正交投影 考虑图 1.10。给出向量 v 和单位向量 n，请借助点积公式求出用 v 和 n 表示向量 p 的公式。 $$ \\begin{align*} \\vec{p} \u0026= k\\vec{n} ~ (观察图示存在标量k，使得 \\vec{p} = k\\vec{n}。 只要都在同一方向 就可以用这个公式) \\\\ \\\\ \u0026= (\\Vert \\vec{v} \\Vert \\cos\\theta)\\vec{n} ~ (这是利用三角函数, \\cos \\theta = \\frac{k}{\\vec{v}}) \\\\ \\\\ \u0026= (\\Vert \\vec{v} \\Vert \\cdot 1 \\cos\\theta)\\vec{n} ~ (这个 1 其实就是单位向量n) \\\\ \\\\ \u0026= (\\Vert \\vec{v} \\Vert \\Vert \\vec{n} \\Vert \\cos\\theta)\\vec{n} \\\\ \\\\ \u0026= (\\vec{v} \\cdot \\vec{n})\\vec{n} \\end{align*} $$ 特别是这里证明了：当 n 是单位向量时， k = v ⋅ n 顺带也解释了在这种情况下 v ⋅ n的几何意义。我们 称 p 为向量 v 落在向量 n 上的正交投影（orthogonal projection），通常将它表示为： $$ \\vec{p} = proj_n(\\vec{v}) $$ 如果 n 不具有单位长度，就先对它进行规范化处理，使之成为单位向量。通过把向量 n 替换为单位向量 $ \\frac{n}{\\Vert n \\Vert} $，即可得到更具一般性的投影公式： $$ \\vec{p} = proj_n(\\vec{v}) = (\\vec{v} \\cdot \\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert})\\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert} = (\\frac{(\\vec{v} \\cdot \\vec{n})}{\\Vert \\vec{n} \\Vert ^ 2}) \\vec{n} $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:7:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"正交化 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"规范正交 如果向量集 $ {v_0, …, v_{n-1}} $中的每个向量都是互相正交（集合内的任一向量都与集合中的其他所有向量 相互正交）且皆具单位长度，那么我们就称此集合是规范正交（orthonormal）的 有时我们会接到一个 近乎（但并不完全）规范正交的集合。这时，一个常见的工作就是通过正交化手段，使之成为规范正交集。 例如，我们有时会在 3D 计算机图形学中用到规范正交集，但是由于处理过程中数值精度的问题， 它会随之逐步变为非规范正交集。这时就要用到正交化这一手段了 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"2个向量的正交化 先来考察相对简单的 2D 情况吧(也就是说，集合内只有 2 个向量的情况)。假设我们有向量集合$ {v_0, v_1} $，现欲将它正交化为图 1.11 中所示的 正交集${w_0, w_1}$ 首先设 $ w_0 = v_0 $，通过使 $v_1$减去它在 $w_0$上的分量（投影）来令它正交于 $w_0$ $$ \\vec{w}_1 = \\vec{v}_1 - proj_{\\vec{w}_0}(\\vec{v}_1) $$ 此时，我们便得到了一个元素互相正交的向量集合${w_0, w_1}$；最后一步是构建一个规范正交集，将向量 $w_0$和 $w_1$规范化为单位向量即可。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"3个向量的正交化 假设有向量集${v_0, v_1, v_2}$，现希望将它正交化为 正交集${w_0, w_1, w_2}$，过程如图 1.12 所示。 首先使 $w_0 = v_0$，通过令 $v_1$减去它在 $w_0$方向上的分量，让它正交 于 $w_0$： $$ \\vec{w}_1 = \\vec{v}_1 - proj_{\\vec{w}_0}(\\vec{v}_1) $$ 接下来，通过令 $v_2$依次减去它在 $w_0$方向与 $w_1$方向上的分量（投影），使之同时正交于 $w_0、w_1$： $$ \\vec{w}_2 = \\vec{v}_2 - proj_{\\vec{w}_0}(\\vec{v}_2) - proj_{\\vec{w}_1}(\\vec{v}_2) $$ 现在我们就得到了所有元素都彼此正交的向量集${w_0, w_1, w_2}$；最后一步是通过将 $w_0、w_1、 w_2$规范化为单位向量来构建一个规范正交集 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:3","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"n个向量的正交化(格拉姆—施密特正交化) 基本步骤：设$ \\vec{w}_0 = \\vec{v}_0 $ 对于 $ 1 \\leq i \\leq n-1 $ , 令 $ \\vec{w}_i = \\vec{v}_i - \\sum_{j=0}^{i-1} \\text{proj}_{\\mathbf{w}_j} (\\mathbf{v}_i) $ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:8:4","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"叉积 向量乘法的第二种形式是叉积（cross product，亦称向量积、外积）。与计算结果为标量的点积不同， 叉积的计算结果亦为向量。此外，只有 3D 向量的叉积有定义（不存在 2D 向量叉积）。 假设 3D 向量 u 和 v 的叉积得到的是另一个向量 w，则 w 与向量 u、v 彼此正交。也就是说，向量 w 既正交于 u，也正交于 v $$ \\begin{gather*} \\vec{u} = (u_x, u_y, u_z),~ \\vec{v} = (v_x, v_y, v_z) \\\\ \\\\ 那么叉积的计算方法是 \\\\ \\\\ \\vec{w} = \\vec{u} \\times \\vec{v} = (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_x) \\end{gather*} $$ 根据计算结果可以明确地得出一项结论：一般来说 $ \\vec{u} \\times \\vec{v} \\neq \\vec{v} \\times \\vec{u} $ ，即向量的叉积不满足交换律 事实上， 我们同时也能够证明 $ \\vec{u} \\times \\vec{v} = -\\vec{v} \\times \\vec{u} $ ，这正是叉积的反交换律。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:9:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"叉积的模长公式 $$ \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:9:1","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"2D 向量的伪叉积 我们刚刚证明了：通过叉积可以求出与两个指定 3D 向量 正交的向量。在 2D 空间中虽然不存在这种情况，但是若给定 一个 2D 向量 $u = (u_x, u_y)$，我们还是能通过与 3D 向量叉积相似 的方法，求出与 向量u 正交的向量 v $$ \\vec{u} \\cdot \\vec{v} = (u_x, u_y) \\cdot (-v_y, v_x) $$ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:9:2","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"通过叉积来进行正交化处理 我们也可以通过叉积来进行正交化处理,但是收到数值精度误差累计的影响，也许会导致成为非规范正交集 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:10:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"点 在一个坐标系中，通 过一个处于标准位置的向量就能表示出 3D 空间中的特定位置，我们称这种向量为位置向 量（position vector） 在这种情况下，向量箭头的位置才是值得关注的主要特征，而方向和大小都是无足 轻重的。“位置向量”和“点”这两个术语可以互相替代，这是因为一个位置向量足以确定一个点。 然而，用向量表示点也有副作用，在代码中则更为明显，因为部分向量运算对点来说是没有意义的。 例如，两点之和的意义何在？但从另一方面来讲，一些运算却可以在点上得到推广 可以将两个点 的差 q−p 定义为由点 p 指向点 q 的向量。 同样，也可以定义点 p 与向量 v 相加，其意义为：令点 p 沿向量 v 位移而得到点 q。 ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:11:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["3D图形学"],"content":"小结 向量可以用来模拟同时具有大小和方向的物理量。 在几何学上，我们用有向线段表示向量。当 向量平移至尾部与所在坐标系原点恰好重合的位置时，向量位于标准位置。一旦向量处于标准 位置，我们便可以用向量头部相对于坐标系的坐标来作为它的数学描述 假设有向量 $\\vec{u} = (u_x, u_y, u_z)$ 和向量 $ \\vec{v} = (v_x, v_y, v_z) $，那么就能对他们进行下列向量计算 （a）加法运算： $$ \\begin{gather*} \\vec{u} + \\vec{v} = (u_x + v_x, u_y + v_y, u_z + v_z) ~~~~~ 公式 \\\\ \\\\ \\vec{u} + \\vec{v} = \\vec{v} + \\vec{u} ~~~~~ 满足交换律 \\\\ \\\\ (\\vec{u} + \\vec{v}) + \\vec{w} = \\vec{u} + (\\vec{v} + \\vec{w}) ~~~~~ 满足结合律 \\\\ \\\\ (\\vec{u} + \\vec{v})k = k\\vec{u} + k\\vec{v} ~~~~~ 满足与标量相乘的分配律 \\end{gather*} $$ （b） 减法运算： $$ \\begin{gather*} \\vec{u} - \\vec{v} = (u_x - v_x, u_y - v_y, u_z - v_z) ~~~~~ 公式 \\\\ \\\\ \\vec{u} - \\vec{v} \\neq \\vec{v} - \\vec{u} ~~~~~ 不满足交换律 ~ 除非 \\vec{u} = \\vec{v} \\\\ \\\\ (\\vec{u} - \\vec{v}) - \\vec{w} \\neq \\vec{u} - (\\vec{v} - \\vec{w}) ~~~~~ 不满足结合律 ~ 除非\\vec{w} 是零向量 \\\\ \\\\ (\\vec{u} - \\vec{v})k = k\\vec{u} - k\\vec{v} ~~~~~ 满足与标量相乘的分配律 \\end{gather*} $$ （c）标量乘法运算： $$ k\\vec{u} = (ku_x, ku_y, ku_z) $$ （d） 向量长度（模）: $$ \\Vert \\vec{u} \\Vert = \\sqrt{x^2 + y^2 + z^2} $$ （e） 规范化： $$ \\hat{u} = \\frac{\\vec{u}}{\\Vert \\vec{u} \\Vert} = (\\frac{x}{\\Vert \\vec{u} \\Vert}, \\frac{y}{\\Vert \\vec{u} \\Vert}, \\frac{z}{\\Vert \\vec{u} \\Vert}) $$ （f） 点积： 点积的一个重要几何应用是计算两个向量之间的夹角 点积可以利用正交投影公式来一个向量在另一个向量方向上的投影 点积可以判断两条直线或两个平面是否垂直 $$ \\begin{gather*} \\vec{u} \\cdot \\vec{v} = \\Vert u \\Vert \\Vert v \\Vert \\cos\\theta = u_x v_x + u_u v_y + u_z v_z ~~~~~ 公式 \\\\ \\\\ \\vec{u} \\cdot \\vec{v} = \\vec{v} \\cdot \\vec{u} ~~~~~ 满足交换律 \\\\ \\\\ (\\vec{u} \\cdot \\vec{v}) \\cdot \\vec{w} = \\vec{u} \\cdot (\\vec{v} \\cdot \\vec{w}) ~~~~~ 满足分配律 \\\\ \\\\ (k \\vec{u}) \\cdot \\vec{v} = \\vec{u} \\cdot (k\\vec{v}) ~~~~~ 满足标量的结合律 \\\\ \\\\ (\\vec{u} \\cdot \\vec{v}) \\cdot \\vec{w} \\neq \\vec{u} \\cdot (\\vec{v} \\cdot \\vec{w}) \\\\ \\\\ \\downarrow \\\\ \\\\ 不满足 点积与点积的结合律 这是因为点积的结果是一个标量，而标量与向量的点积没有定义。 \\end{gather*} $$ （g） 叉积： 叉积的结果向量垂直于 向量u 和 向量v 所在的平面，因此常用于计算平面的法向量。 叉积的模长等于以 向量u 和 向量v 为邻边的平行四边形的面积 || u x v || 叉积的方向由右手定则确定，常用于判断向量的旋转方向。 在物理学中，叉积常用于计算力矩、角动量等与旋转相关的物理量。 $$ \\begin{gather*} \\vec{w} = \\vec{u} \\times \\vec{v} = (u_y v_z - u_z v_y, u_z v_x - u_x v_z, u_x v_y - u_y v_x) ~~~~~ 公式 \\\\ \\\\ \\Vert \\vec{u} \\times \\vec{v} \\Vert = \\Vert \\vec{u} \\Vert \\Vert \\vec{v} \\Vert \\sin\\theta ~~~~~~ 叉积的模长公式 \\\\ \\\\ \\vec{u} \\times \\vec{v} = \\vec{v} \\times \\vec{u} ~~~~~ 满足交换律 \\\\ \\\\ \\vec{u} \\times \\vec{v} = -\\vec{v} \\times \\vec{u} ~~~~~ 反交换律 \\\\ \\\\ \\vec{u} \\times (\\vec{v} + \\vec{w}) = \\vec{u} \\times \\vec{c} + \\vec{u} \\times \\vec{v} ~~~~~ 满足分配律 \\\\ \\\\ k\\vec{u} \\times \\vec{v} = \\vec{u} \\times k\\vec{v} ~~~~~~ 满足标量的结合律 \\\\ \\\\ (\\vec{u} \\times \\vec{v}) \\times\\vec{w} \\neq \\vec{u} \\times (\\vec{v} \\times\\vec{w}) ~~~~~ 不满足叉积与叉积的结合律 \\end{gather*} $$ 向量的几何意义 当向量的模为1的时候他就是单位向量 点积几何性质 正交投影 $$ \\vec{p} = proj_n(\\vec{v}) = (\\vec{v} \\cdot \\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert})\\frac{\\vec{n}}{\\Vert \\vec{n} \\Vert} = (\\frac{(\\vec{v} \\cdot \\vec{n})}{\\Vert \\vec{n} \\Vert ^ 2}) \\vec{n} $$ 向量的正交化其实就是一个递归，在将给定集合内的向量 $ \\vec{v_i} $添加到规范正交集中时，我们需要令 $ \\vec{v_i} $减去它 在现有规范正交集中其他向量$ {w_0, w_1, …, w_i−1} $方向上的分量（投影） 基本步骤：设$ \\vec{w}_0 = \\vec{v}_0 $ 对于 $ 1 \\leq i \\leq n-1 $ , 令 $ \\vec{w}_i = \\vec{v}_i - \\sum_{j=0}^{i-1} \\text{proj}_{\\mathbf{w}_j} (\\mathbf{v}_i) $ ","date":"2024-12-23","objectID":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/:12:0","tags":["Unreal","3D图形学","向量","标量"],"title":"向量","uri":"/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/"},{"categories":["Unreal"],"content":"Unreal 的模板方法","date":"2024-08-20","objectID":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/","tags":["Unreal","模板方法"],"title":"Unreal - 模板方法","uri":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["Unreal"],"content":"什么是模板 模板就是 代码的模具 你写一段代码，把类型挖空，用一个占位符 T 代替。编译时，编译器会根据你传入的真实类型，自动生辰对应的代码。 例如： // 这里的 typename T 就是占位符 template \u003ctypename T\u003e T* FindActor(UWorld* World) { // T::StaticClass() 要求传入的 T 必须是 UObject 体系的 // 这就是泛型编程的“隐式约束” return Cast\u003cT\u003e(UGameplayStatics::GetActorOfClass(World, T::StaticClass())); } // 使用： AMyCharacter* Char = FindActor\u003cAMyCharacter\u003e(GetWorld()); UCLASS \u0026 USTRUCT \u0026 UFUNCTION 不能是模板 ","date":"2024-08-20","objectID":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:1:0","tags":["Unreal","模板方法"],"title":"Unreal - 模板方法","uri":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["Unreal"],"content":"泛型编程 泛型编程的核心思想就是：我不关心你是什么类型，我只关心你能不能做这件事 例如我们要写一个函数，打印任何对象的名称，我们不关心他是 AActor 还是 UComponent，只要他有GetName() 方法就行 类型转换 一个 B 继承于 A，我们想把 A 转换成 B，只需要 Cast\u003cB\u003e(A)。 这 Cast\u003cT\u003e(Obj) 就很好用，他也是模板，泛型编程。他不关心T是什么，只关心 T 和 Obj 有继承关系 就够了 ","date":"2024-08-20","objectID":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:2:0","tags":["Unreal","模板方法"],"title":"Unreal - 模板方法","uri":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["Unreal"],"content":"模板偏特化 Unreal 其实是有偏特化的，因为他就是c++魔改 偏特化只能适用于 class or struct，不能用于 function 不能暴露给蓝图 UCLASS / USTRUCT / UFUNCTION 所以Unreal 的模板偏特化是用于编写底层工具库，序列化工具的核心技术 ","date":"2024-08-20","objectID":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:3:0","tags":["Unreal","模板方法"],"title":"Unreal - 模板方法","uri":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["Unreal"],"content":"可变长参数模板 这个模板允许你传入任意数量、任意类型的参数 // 1. 递归终止函数（Base Case） // 当参数被剥离完了，就调用这个空的 void MySuperLog() {} // 2. 递归展开函数 // FirstArg: 当前处理的第一个参数 // RestArgs: 剩下的一堆参数包 template \u003ctypename T, typename... Args\u003e void MySuperLog(const T\u0026 FirstArg, const Args\u0026... RestArgs) { // 打印当前的第一个参数 // 这里利用了 UE 的 FString::FromInt/FromFloat 等转换，或者简单的 \u003c\u003c 重载 // 为了演示简单，我们假设是 String UE_LOG(LogTemp, Warning, TEXT(\"Param: %s\"), *LexToString(FirstArg)); // 递归调用：把剩下的参数包传下去 MySuperLog(RestArgs...); } // --- 使用 --- void GameStart() { int32 Health = 100; float Speed = 50.5f; FString Name = \"PlayerOne\"; // 一次性打印不同类型，数量不限 MySuperLog(Name, Health, Speed); // 输出: // Param: PlayerOne // Param: 100 // Param: 50.500000 } ","date":"2024-08-20","objectID":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:4:0","tags":["Unreal","模板方法"],"title":"Unreal - 模板方法","uri":"/unreal-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["Unreal"],"content":"Unreal的委托系统","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"Unreal的委托系统 UE 的委托系统是标准 c++ 函数指针的超级增强版。 他是类型安全的、支持反射的、支持多播的 ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:1:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"单播委托 特点1：一对一，只能绑定一个函数。如果绑定新的，旧的会被覆盖 特点2：可以有返回值 适用场景：请求某个结果，比如背包已满… 定义宏：DECLARE_DELEGATE // 声明：带一个 int 参数 DECLARE_DELEGATE_OneParam(FOnItemUsed, int32 /*ItemID*/); // 声明：带返回值 bool，带一个 int 参数 DECLARE_DELEGATE_RetVal_OneParam(bool, FCheckCanEquip, int32 /*ItemID*/); // 调用： MyDelegate.ExecuteIfBound(101); // 安全调用 bool bResult = MyRetValDelegate.Execute(101); // 获取返回值 ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:2:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"多播委托 特点1：一对多。可以绑定无数个函数。调用时，所有绑定的函数都会执行（执行顺序不保证） 特点2：不能有返回值，因为那么多人回答，不知道听谁的 适用场景：广播事件（如：主角死亡后，UI要知道，音乐要转变） 定义宏：DECLARE_MULTICAST_DELEGATE... // 声明 DECLARE_MULTICAST_DELEGATE_OneParam(FOnPlayerDied, float /*TimeAlive*/); // 绑定： MyDelegate.AddUObject(this, \u0026MyClass::FuncA); MyDelegate.AddUObject(OtherObj, \u0026OtherClass::FuncB); // 广播：所有绑定的函数都会跑 MyDelegate.Broadcast(120.5f); ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:3:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"动态委托 特点1：蓝图可见。他们支持序列化 特点2：因为要支持反射 序列化等让蓝图可见，所以性能比上面两种要慢。 绑定的函数必须加上 UFUNCTION() 定义宏：DECLARE_DYNAMIC_DELEGATE...（单播）/ DECLARE_DYNAMIC_MULTICAST_DELEGATE... 多播 // 声明：必须加 DYNAMIC，且参数必须有名字 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnButtonClocked, int32, ButtonIndex); // 在 UCLASS 里： UPROPERTY(BlueprintAssignable) // 蓝图可以拖出来 Assign FOnButtonClocked OnClicked; ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:4:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"绑定方法 绑定方式 函数名 适用对象 备注 BindUObject AddUObject UObject 子类(Actor, Widget…)* 最常用。安全，如果对象被 GC 销毁了，委托不会执行，不会崩。 BindSP AddSP TSharedPtr (普通 C++ 类) 用于由智能指针管理的非 UObject 类。 BindRaw AddRaw 普通 C++ 指针 危险。不安全，如果对象被删了，委托还在，调用会崩。需手动解绑。 BindLambda AddLambda 匿名函数 非常方便写短逻辑。注意捕获 this 的生命周期。 BindStatic AddStatic 全局静态函数 绑定 static void Func()。 BindUFunction AddUFunction 按名字绑定 用于动态委托，或者反射调用。 ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:5:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"小技巧 // 1. 委托定义：只接受一个 bool DECLARE_DELEGATE_OneParam(FMyDelegate, bool); // 2. 你的函数：却有两个参数 void MyFunc(bool bSuccess, int32 UserID) { // ... } // 3. 绑定时：把 10086 硬塞进去 // 当委托执行 Execute(true) 时，UE 会自动补上 10086 MyDelegate.BindUObject(this, \u0026MyClass::MyFunc, 10086); ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:6:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"Event事件 你会看到 DECLARE_EVENT 宏。 它本质上就是多播委托 (Multicast Delegate)，唯一的区别是权限控制。 Multicast Delegate：任何拿到这个委托变量的人，都可以调用 .Broadcast()。 Event：只有定义这个 Event 的类，才能调用 .Broadcast()。外部类只能 .Add() (绑定监听)。 场景：如果你写一个底层的 Manager，不想让外面的 UI 随便乱发广播，就用 Event。 ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:7:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"FSimpleDelegate Unreal 帮你实现的最简单的 无参数 无返回值的单播委托 ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:8:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"FSimpleMulticastDelegate Unreal 帮你实现的最简单的 无参数 无返回值的多播委托 ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:9:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"FTSSimpleMulticastDelegate Unreal 帮你实现的最简单的 无参数 无返回值的多播委托，但是他是线程安全的 ","date":"2024-08-19","objectID":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/:10:0","tags":["Unreal","委托"],"title":"Unreal - 委托系统","uri":"/unreal-%E5%A7%94%E6%89%98%E7%B3%BB%E7%BB%9F/"},{"categories":["Unreal"],"content":"Unreal 的智能指针","date":"2024-08-19","objectID":"/unreal-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","tags":["Unreal","智能指针"],"title":"Unreal - 智能指针","uri":"/unreal-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":["Unreal"],"content":"智能指针 问题背景： 我们之前提到，在堆(Heap)上用 new 创建了对象，就必须在某个地方用 delete 来销毁它。这个过程完全靠程序员手动管理，极其容易出错。忘记 delete 会导致内存泄漏；对同一个指针 delete 两次会导致程序崩溃；访问一个已经被 delete 的指针（悬挂指针）也是灾难性的。 解决方案： 智能指针！它是一个C++对象（一个“管家”），内部包装了一个原始指针（一把“钥匙”）。这个管家对象利用C++的作用域规则，在自己被销毁时（例如函数结束、对象生命周期结束），自动地、确定地 delete 它所管理的指针。 管理 UObject 及其派生类 (如 AActor, UActorComponent) UObject 是Unreal引擎的核心，所有继承自它的对象都由垃圾回收 (Garbage Collection, GC) 系统统一管理生命周期。我们要做的是正确地“配合”GC工作。 指针类型 何时使用？(最佳实践) TObjectPtr\u003cT\u003e 【首选/默认】 任何时候你需要一个指向UObject的指针，都应该优先使用它。无论是成员变量还是局部变量。 核心优势： 当它指向的UObject被销毁时，TObjectPtr会自动变为空指针 (nullptr)，彻底杜绝了悬挂指针崩溃的风险。 UPROPERTY() 宏 当你需要防止一个UObject被GC回收时，必须用UPROPERTY()来标记持有它的指针。 黄金组合： UPROPERTY() TObjectPtr\u003cT\u003e。UPROPERTY负责“保活”，TObjectPtr负责“安全访问”。 TWeakObjectPtr\u003cT\u003e 当你需要引用一个UObject，但不想阻止它被GC回收时使用。 核心用途： 避免循环引用。例如，一个子Actor想引用它的父Actor，但不希望因为这个引用导致父Actor永远无法被销毁。 TSubclassOf\u003cT\u003e 【极其常用】 当你需要一个变量来持有某个蓝图或C++类本身，以便后续用它来生成(Spawn)新的实例时。 核心优势： 类型安全。它在编辑器和编译期就能保证你赋给这个变量的，必须是指定的基类 T 或其子类。 TSoftObjectPtr\u003cT\u003e 【软引用-实例】 当你需要引用一个资源（如纹理、网格体、音效），但不想在游戏一开始就把它加载到内存里时使用核心优势： 延迟加载 (Lazy Load)。它只存一个路径字符串，不占实际资源内存。你需要时才手动加载（同步或异步），是优化内存和启动速度的神器。 TSoftClassPtr\u003cT\u003e 【软引用-类型】 当你需要引用一个蓝图类（以便后续生成），但不想一开始就把这个蓝图类加载进内存时。核心优势： 它是 TSubclassOf 的“轻量版”。比如你有100种武器，用硬引用(TSubclassOf)会导致100个武器资源全部加载；用软引用(TSoftClassPtr)则只加载路径，玩家选中哪个才加载哪个。 阵营二：管理非 UObject 的普通 C++ 类 对于那些你自己创建的、不继承自 UOject 的普通C++类（例如 Slate UI 的逻辑类、自定义的数据管理器等），GC系统完全不管它们。 这时，我们就需要请出C++的传统智能指针来手动管理它们的生命周期。 说是c++的传统指针，其实也是Unreal在于基础上自己封装的 指针类型 所有权模型 何时使用？ TSharedPtr\u003cT\u003e / TSharedRef\u003cT\u003e 共享所有权 (Shared Ownership) 【最常用】 当一个对象需要被多个其他对象共同拥有和管理时。它使用引用计数，当最后一个所有者消失时，对象被自动销毁。TSharedRef是保证永不为空的版本。 核心用途：Slate UI, 异步任务, 共享的数据管理器。 TWeakPtr\u003cT\u003e 无所有权 (Non-owning Observer) 当你需要“观察”一个由TSharedPtr管理的对象，但不想成为它的所有者（即不想增加引用计数）时。 核心用途： 缓存指针，以及打破TSharedPtr之间的循环引用。 TUniquePtr\u003cT\u003e 独占所有权 (Exclusive Ownership) 当一个对象在任何时候都只能有一个唯一的所有者时。它非常轻量，性能接近原始指针，但不能被复制，只能被移动 (Move)。 核心用途：工厂函数的返回值，Pimpl惯用法。 ","date":"2024-08-19","objectID":"/unreal-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:0:1","tags":["Unreal","智能指针"],"title":"Unreal - 智能指针","uri":"/unreal-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":["Unreal"],"content":"最终决策流程图 当你需要一个指针时，这样问自己： 我要指向的对象是 UObject 吗？ (Actor, Widget, Asset等) 否 (普通 C++ 类/结构体) 我需要独占它吗？ (生命周期随我结束) 是 -\u003e TUniquePtr (最高效) 我需要和其他人共享它吗？ 是 -\u003e TSharedPtr (配合 TWeakPtr 破除循环) 是 (UObject 体系) 它必须现在就在内存里吗？ (还是说只是个硬盘路径？) 否 (硬盘路径/延迟加载) 指向具体资源 (如纹理) -\u003e TSoftObjectPtr 指向蓝图类 (如 BP_Enemy) -\u003e TSoftClassPtr 是 (内存中存在的对象) 它是“类”还是“实例”？ 是类 (用于生成) -\u003e TSubclassOf 是实例 (活着的对象) 我负责“保活”它吗？ (我是它的主人？) 是 -\u003e UPROPERTY() + TObjectPtr (强引用) 否 (我只是引用/观察，它可能死掉) 是 -\u003e TWeakObjectPtr (安全，死后变nullptr) ","date":"2024-08-19","objectID":"/unreal-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/:0:2","tags":["Unreal","智能指针"],"title":"Unreal - 智能指针","uri":"/unreal-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"categories":["Unreal"],"content":"什么是Gameplay框架","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"Gameplay定义 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:1:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"广义 广义的Gameplay：需要改动引擎源码叫做引擎开发。而基于引擎开发游戏则成为Gameplay ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:1:1","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"狭义 其实Gameplay这个概念还是来自于Unreal，以Unreal提供的Gameplay框架作为参考，其实就是游戏的规则和状态，用户界面。(UE5 Gamelay框架概念更为宽阔了) 但是更具体来讲就是Unreal Gameplay框架的类 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:1:2","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"UWorld 它是所有物体（Actors）的容器。当你加载一个关卡（Level），你实际上是在加载一个 World。所有的物理模拟、渲染、声音都在这里发生 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:2:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"UGameInstance 唯一跨关卡存在的对象。也就是全局数据实例 当你从“主菜单”切换到“第一关”时，World 被销毁了，GameMode 重置了，但 GameInstance 依然存在。通常用来保存全局数据（如设置、存档数据、网络Session管理）。 他是存在于客户端 和 服务端，主导权肯定在服务端，然后同步到客户端，防止玩家作弊 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:3:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"AGameMode 制定游戏规则。比如：怎么算赢？玩家在哪里出生？能不能暂停？ GameMode 只存在于服务器端。客户端不知道规则，只能听服务器指挥。这是为了防止作弊。 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:4:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"AGameState 记录整个游戏当前的状态。比如：比赛剩余时间、红蓝队总比分、当前是第几波怪。 它由服务器更新，并同步给所有客户端。每个玩家都能看到 GameState。 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:5:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"APlayerController 它是玩家意志的体现。它接收键盘鼠标输入，并告诉游戏里的角色该做什么。它也是处理 UI（HUD）的地方。 服务器有所有玩家的 Controller（为了验证操作）。 客户端只有自己的 Controller（你不能控制别人的灵魂）。 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:6:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"APlayerState 记录属于个人但在全局重要的数据。比如：玩家名字、个人击杀数、Ping值、当前等级。 即便玩家的角色（Pawn）死掉了，Controller 还没重生，PlayerState 依然存在，数据不会丢。它会同步给所有客户端（这样你按Tab键才能看到队友的分数）。 服务器有所有玩家的 APlayerState。 客户端只有自己的 APlayerState。 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:7:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"APawn 可以被 Controller “附身”的 Actor。是最小可控制单位，比如载具，说白了就是Character的行走逻辑不合适的都用这个 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:8:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"ACharacter Pawn 的特化子类。它自带了 CharacterMovementComponent（角色移动组件），帮你处理好了极其复杂的双足行走逻辑（走路、跳跃、游泳、网络平滑插值） ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:9:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"HUD / UI AHUD类是 UI管理者 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:10:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["Unreal"],"content":"总结 类名 (Class) 存在位置 作用总结 GameInstance Client \u0026 Server 跨关卡全局管理，如设置、存档。 GameMode Server Only 权威规则制定者，客户端不存在。 GameState Server \u0026 Clients 比赛的当前状态（比分、时间），大家都能看。 PlayerController Server \u0026 Client 玩家的输入处理、UI逻辑。我在服务器有备份，但我看不到别人的。 PlayerState Server \u0026 Clients 玩家的个人数据（KDA、名字），大家都能看。 Pawn/Character Server \u0026 Clients 玩家在世界里的实体模型。 HUD / UI Client Only 纯本地的UI显示。 ","date":"2024-08-18","objectID":"/unreal-gameplay%E6%A1%86%E6%9E%B6/:11:0","tags":["Unreal","Gameplay"],"title":"Unreal - Gameplay框架","uri":"/unreal-gameplay%E6%A1%86%E6%9E%B6/"},{"categories":["游戏"],"content":"游戏","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"环世界Mod ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:0","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"1. harmony 必装，运行库文件，很多mod需要此文件才能正常运行 无需汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:1","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"2. HugsLib 绝大多数Mod的必备前置 需要汉化：HugsLib - 简\u0026繁中文汉化包 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:2","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"3. Vanilla Expanded Framework 原版扩展系列的前置Mod，现已整合派系侦测Mod。 派系侦测：原先翻译叫 “派系发现”，游戏过程中会随机生成新派新、新派系基地，可以在Mod设置里调节参数，老档加入新派系mod时，可以不用重开，用此mod刷出新派系 需要汉化 ：Vanilla Expanded Framework - 简\u0026繁中文汉化包 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:3","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"4. Humanoid Alien Races 外星人框架，所有非人类种族、派系Mod的必备前置。 需要汉化 ：Humanoid Alien Races - 简\u0026繁中文汉化包 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:4","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"6. FSharp.Core 本地语言支持 无需汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:5","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"7. XML Extensions mod框架补丁，当XML扩展处于活动状态时，所有XML修补程序错误现在也将生成堆栈跟踪！这意味着您可以准 确地找出哪个修补程序失败了，在某些情况下，它甚至会告诉您修补程序的哪个部分失败了。 需要汉化 ：XML Extensions简繁中文汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:6","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"8. MoHAR framework 为种族模组提供支持 无需汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:7","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"9. Map Reroll 可以在选择落地点的时候直接预览大地图上的当前地形 需要汉化：Map Reroll - 简\u0026繁中文汉化包 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:8","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"10. Character Editor 可以开局修改人物属性，极度正义 需要汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:9","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"11. Allow Tool 最强大的快捷工具模组，功能包含允许全图操作、一键收割成熟的植物、紧急搬运等等功能，并且他还是智能化的你敢信，举个例子，他直接开掘一大片矿时，它会自己规划开掘的区域避免坍塌，这个绝对是我最推荐的环世界辅助mod，极大地方便了玩家的操作，极为推荐。 需要汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:10","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"12. Pick Up And Haul 将原版中极其简单的搬运逻辑彻底的进行优化，直接改写了原版的搬运机制，让小人的搬运不再傻傻的操作一个，这个可以说是提高了小人相当高的操作效率，可以说是开档必备，每一个人我都极为推荐。 需要汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:11","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["游戏"],"content":"13. Smart Medicine 也是一个逻辑优化mod，完美解决了原本在药物上的逻辑操作问题，医生再也不会跑老远拿极其昂贵的药品治疗一个小小的伤口，可以根据内置的选项自己更改觉得病态的机制，这模组图片可以说真形象了。 需要汉化 但是没找到汉化 14. RocketMan 环世界优化性能，必备 需要汉化 ","date":"2024-01-23","objectID":"/%E6%B8%B8%E6%88%8F/:1:12","tags":["游戏"],"title":"环世界Mod","uri":"/%E6%B8%B8%E6%88%8F/"},{"categories":["杂谈"],"content":"SteamDeck 最近在折腾steam deck 放一个博客存一些命令，以防格式化或者啥的，又得重弄 但是专门为deck弄一个分类不太好，所以放生活吧~ 在前言放一个niu b的网站: https://ohmydeck.net/ 还有放一些游戏的攻略及一些相关东西 ","date":"2024-01-23","objectID":"/index_zh-cn/:0:0","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"刚拿到机子必须要做的事 ","date":"2024-01-23","objectID":"/index_zh-cn/:1:0","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"注意事项 千万不能把桌面模式改成中文 会出不少问题 如果改了就恢复出厂!!! ","date":"2024-01-23","objectID":"/index_zh-cn/:1:1","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"前置 进入桌面模式 设置密码 passwd 解锁只读权限 sudo steamos-readonly disable ","date":"2024-01-23","objectID":"/index_zh-cn/:1:2","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"加速桌面模式下的商店 sudo flatpak remote-modify flathub --url=https://mirror.sjtu.edu.cn/flathub ","date":"2024-01-23","objectID":"/index_zh-cn/:1:3","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"桌面模式下 安装中文输入法 首先，打开Discover应用商店，搜索“input”并找到Fcitx 5应用。点击安装按钮，开始下载并安装这款输入法应用 安装完成后，进入Fcitx 5的详情页面，找到Addons选项。在这里，你可以找到并安装Chinese Addons，为你的输入法增添中文支持。 安装完毕后，记得先启动Fcitx 5哦！然后，你可以通过右键点击状态栏中的输入法图标，选择Configure来配置你的输入法。在配置窗口中，输入“pinyin”并添加到左侧，即可开启拼音输入法功能。 最后，为了确保每次开机都能自动启动Fcitx 5和中文输入法，你需要进入系统设置，选择Startup and shutdown选项，然后添加Fcitx 5到自启动列表中 ","date":"2024-01-23","objectID":"/index_zh-cn/:2:0","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"安装UU加速器插件 curl -s uudeck.com|sudo sh ","date":"2024-01-23","objectID":"/index_zh-cn/:3:0","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"Clash - ToMoon ","date":"2024-01-23","objectID":"/index_zh-cn/:4:0","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"安装 如果已经安装过 Plugin Loader 2.0 以上版本，直接从第 8 点开始即可。 打开到 Steam Deck 设置界面 系统 -\u003e 系统设置 -\u003e 打开开发者模式 回到设置向下翻，找到开发者 -\u003e 打开 CEF 远程调试 等待 Steam Deck 重启 按电源键切换到 Desktop 桌面模式 打开 Konsole，输入 curl -L http://dl.ohmydeck.net | sh 安装 Plugin Loader 输入 curl -L http://i.ohmydeck.net | sh 安装 Tomoon 切换回到 Gamming 游戏模式，按下右侧摇杆下的快捷按钮（三个点的按钮），可以看到多了一个 Decky 插件面板 ","date":"2024-01-23","objectID":"/index_zh-cn/:4:1","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"使用 打开 Manage Subscriptions，添加你服务商提供的 Clash 订阅链接并下载 下载完成后，切换回主界面选择订阅并点击启动 在桌面模式可通过浏览器 http://127.0.0.1:9090/ui 打开仪表盘 ","date":"2024-01-23","objectID":"/index_zh-cn/:4:2","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["杂谈"],"content":"复原 DNS，解决插件消失而导致无法联网 在桌面模式打开 Konsole，输入以下命令。 注意：不熟悉 Linux 的朋友请务必输入正确，看到命令执行完后有错误出现就是输入错了。 sudo chattr -i /etc/resolv.conf sudo systemctl stop systemd-resolved sudo chmod a+w /etc/NetworkManager/conf.d/dns.conf sudo echo -e \"[main]\\ndns=auto\" \u003e /etc/NetworkManager/conf.d/dns.conf sudo nmcli general reload 如果安装的是 v0.0.5 (2022/11/18) 以上版本，可以使用脚本直接恢复。 bash ~/tomoon_recover.sh ","date":"2024-01-23","objectID":"/index_zh-cn/:4:3","tags":["杂谈"],"title":"Steam Deck","uri":"/index_zh-cn/"},{"categories":["设计模式"],"content":"设计模式-示例c++代码","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"前言 在被吐槽代码写的烂之后 看了很多源码 学习别人怎么写的 也专门去看了设计模式 在学艺术的我 还是特别热衷于极简艺术的我 自己之前写的代码也实在看不进去 现在设计模式都看完了 用golang 还有 c++ 综合一下每个模式的代码示例 但是因为只是示范设计模式 不会遵守c++的代码规范,甚至是伪代码 本篇是 c++ 但是听我一句劝 虽然看代码模板也可以让你去应付一些场景 但是还是要真正去学设计模式 学设计模式 = 学面向对象 要理清 稳定与变化 设计模式有些模式也是应用于架构层次的 所以有些模式 并没有好的代码模板 而且设计模式 是人们智慧的精华 很值得我们去学习其中的思路精髓 不要被眼前的表象代码迷惑了 好的代码是一种艺术 也可以通过你的代码诉说你的生活极简品味 ---壬寅年七月初二 ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:1:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"模板方法 /* * 模版方法讲解 * eg: 厨房做菜的流程 * 流程: 先开火 再做具体的菜 随后关火 * */ #include \u003ciostream\u003e using namespace std; class Cooker { public: void CookProcess() { Fire(); CookDishes(); OutFire(); }; void Fire() { cout \u003c\u003c \"开火~\" \u003c\u003c endl; }; // 具体做什么菜 交给子类去实现 virtual void CookDishes() = 0; // 关火 void OutFire() { cout \u003c\u003c \"关火~\" \u003c\u003c endl; } }; class CookTomato : public Cooker { void CookDishes() { cout \u003c\u003c \"干西红柿\" \u003c\u003c endl; }; }; int main() { Cooker* cooker = new CookTomato(); cooker-\u003eCookProcess(); return 0; } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:2:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"简单工厂 #include \u003ciostream\u003e using namespace std; // 具体类 class Product { public: Product() {} virtual ~Product() {} virtual void Function() = 0; }; class ProductA : public Product { public: void Function() { cout \u003c\u003c \"ProductA\" \u003c\u003c endl; } }; class ProductB : public Product { public: void Function() { cout \u003c\u003c \"ProductB\" \u003c\u003c endl; } }; // 具体工厂 class NewProductFactory { public: virtual Product* CreateProduct() = 0; virtual ~NewProductFactory() {}; }; class NewProductAFactory : public NewProductFactory { public: virtual Product* CreateProduct() { return new ProductA(); }; }; class NewProductBFactory : public NewProductFactory { public: virtual Product* CreateProduct() { return new ProductB; }; }; // 调用product class类 class MainFrom { NewProductFactory* factory; // 工厂 public: MainFrom(NewProductFactory* factory) { this-\u003efactory = factory; } void click() { Product* product = factory -\u003e CreateProduct(); // 多态new product-\u003eFunction(); } }; int main() { NewProductAFactory* pa = new NewProductAFactory(); MainFrom* mf = new MainFrom(pa); mf-\u003eclick(); } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:3:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"抽象工厂 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; // 访问数据库有关基类 class IDBConnection { }; class IDBCommand { }; class IDataReader { }; class IDBFactory { public: virtual IDBConnection* CreateDBConnection() = 0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; }; //支持MYSQL class SqlConnection: public IDBConnection{ }; class SqlCommand: public IDBCommand{ }; class SqlDataReader: public IDataReader{ }; class SqlDBFactory:public IDBFactory{ public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; }; //支持Oracle class OracleConnection: public IDBConnection{ }; class OracleCommand: public IDBCommand{ }; class OracleDataReader: public IDataReader{ }; class OracleDBFactory : public IDBFactory { public: virtual IDBConnection* CreateDBConnection() = 0; virtual IDBCommand* CreateDBCommand() = 0; virtual IDataReader* CreateDataReader() = 0; }; class EmployeeDAO { IDBFactory* dbFactory; public: vector\u003cEmployeeDAO\u003e GetEmployees() { // 以下是伪代码 因为如果每个实现出来还挺麻烦 // 重要的思路就是 在你只需要用一个工厂 你就可以把这个工厂下的都 多态new出来 还不失关联性 IDBConnection* connection = dbFactory-\u003eCreateDBConnection(); connection-\u003eConnectionString(\"...\"); IDBCommand* command = dbFactory-\u003eCreateDBCommand(); command-\u003eCommandText(\"...\"); command-\u003eSetConnection(connection); //关联性 IDBDataReader* reader = command-\u003eExecuteReader(); //关联性 while (reader-\u003eRead()){ } } }; ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:4:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"策略模式 /* 策略模式 * eg: 计算不同国家的税 * */ #include \u003ciostream\u003e using namespace std; // 税的基类 class TaxStrategy { public: // 税的具体算法 virtual double Calculate(const double\u0026 Money) = 0; virtual ~TaxStrategy() { }; }; // 中国税收 class CNTax : public TaxStrategy { public: double Calculate(const double\u0026 Money) { return TaxBase * Money; }; private: double TaxBase = 2; }; // 德国税收 class GermanyTax : public TaxStrategy { public: double Calculate(const double\u0026 Money) { return TaxBase * Money + 10; } private: double TaxBase = 1.5; }; // 工厂 class NewTaxFactory { public: virtual TaxStrategy* CreateTax() = 0; virtual ~NewTaxFactory() { }; }; class NewCNTaxFactory : public NewTaxFactory { public: virtual TaxStrategy* CreateTax() { return new CNTax(); } }; class NewGermanyTaxFactory { public: virtual TaxStrategy* CreateTax() { return new GermanyTax(); } }; // 计算税的类 class SalesOrder { public: SalesOrder(NewTaxFactory* TaxFactory) { this -\u003e strategy = TaxFactory-\u003eCreateTax(); } ~SalesOrder() { delete this-\u003estrategy; } double CalculateTax() { double Money = 10000; double val = strategy-\u003eCalculate(Money); return val; } private: TaxStrategy* strategy; }; int main() { // 算中国税收 NewCNTaxFactory* CNTax = new NewCNTaxFactory(); SalesOrder* SO = new SalesOrder(CNTax); double val = SO-\u003eCalculateTax(); cout \u003c\u003c val \u003c\u003c endl; return 0; } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:5:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"装饰模式 /* 装饰模式 * eg: 男人类 有叫功能 在叫完之后 需要戴帽子和穿鞋子 * */ #include \u003ciostream\u003e using namespace std; class Man { public: void Speak() { cout \u003c\u003c \"男人使用了 尖叫 技能\" \u003c\u003c endl; } virtual void Cloth() {}; virtual ~Man() { } }; // 装饰抽象类 class ManWithCloth : public Man { public: // 构造函数 ManWithCloth(Man* PMan) :PMan(PMan) {} // 流程 void Cloth() { PMan-\u003eSpeak(); DressUp(); } // 穿衣服的方法 virtual void DressUp() {} // 重写析构函数 virtual ~ManWithCloth() { if (PMan != nullptr) { delete PMan; PMan = nullptr; } } private: Man* PMan; }; // 通过抽象类实现戴帽子 class ManWearHat : public ManWithCloth { public: ManWearHat(Man* PMan) : ManWithCloth(PMan) {} virtual void DressUp() { cout \u003c\u003c \"男人带上了绿帽子 奇怪的属性增加了\" \u003c\u003c endl; } }; // 通过抽象类实现穿鞋子 class ManWearShoes : public ManWithCloth { public: ManWearShoes(Man* PMan) : ManWithCloth(PMan) {} virtual void DressUp() { cout \u003c\u003c \"男人穿上了小鞋 防御力up\" \u003c\u003c endl;} }; // 工厂 class ManFactory { public: virtual Man* CreateMan() { return new Man(); }; virtual ~ManFactory() {}; }; // 抽象类工厂 class ManWithClothFactory { public: virtual ManWithCloth* CreateManWithCloth(Man* PMan) = 0; virtual ~ManWithClothFactory() {}; }; class ManWearHatFactory : public ManWithClothFactory { public: virtual ManWithCloth* CreateManWithCloth(Man* PMan) { return new ManWearHat(PMan); } }; class ManWearShoesFactory : public ManWithClothFactory { public: virtual ManWithCloth* CreateManWithCloth(Man* PMan) { return new ManWearShoes(PMan); } }; int main() { ManFactory* manFactory = new ManFactory(); Man* man = manFactory-\u003eCreateMan(); ManWearHatFactory* manWearHatFactory = new ManWearHatFactory(); ManWearHat a = manWearHatFactory-\u003eCreateManWithCloth(man); a.DressUp(); return 0; } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:6:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"桥模式 /* * 场景: * 假如你有一个几何形状(shape)类, 可以扩展出两个子类(圆形, 方形) * 但是你又想给每一个几何都上颜色 比如现有(red, blue) * 但是，由于你已有两个子类，所以总共需要创建四个类才能覆盖所有组合，例如蓝色圆形(BlueCircle)和红色方形(RedSquare) * * 坏处: * 在层次结构中和颜色将导致代码复杂程序指数增长 * 例如添加三角状, 你需要增加两个子类,也就是每种颜色一个 * 此后新增一种新颜色就需要新增三个子类 * 满满的子类数目将会急剧膨胀 * * 可以利用桥模式去改善这个坏处 并封装变化 */ #include \u003ciostream\u003e using namespace std; class Color { public: virtual void Draw() = 0; }; // 红色 class Red : public Color { public: void Draw() { cout \u003c\u003c \"红色\" \u003c\u003c endl; } }; // 蓝色 class Blue : public Color { public: void Draw() { cout \u003c\u003c \"蓝色\" \u003c\u003c endl; } }; class Shape { public: Shape(Color* c): color(c) {}; virtual void Self() = 0; protected: Color* color; }; // 圆形 class Cyclo : public Shape { public: Cyclo(Color* color) : Shape(color) {}; void Self() { cout \u003c\u003c \"我是圆形\" \u003c\u003c endl; color-\u003eDraw(); } }; // 方形 class Square : public Shape { public: void Self() { cout \u003c\u003c \"我是方形\" \u003c\u003c color \u003c\u003c endl; color-\u003eDraw(); } }; int main() { Red* red = new Red(); Cyclo* c = new Cyclo(red); c-\u003eSelf(); return 0; } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:7:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"原型模式 class MainForm : public Form { ISplitter* prototype;//原型对象 public: MainForm(ISplitter* prototype){ this-\u003eprototype=prototype; } void Button1_Click(){ ISplitter * splitter= prototype-\u003eclone(); //克隆原型 splitter-\u003esplit(); } }; //具体类 class BinarySplitter : public ISplitter{ public: virtual ISplitter* clone(){ return new BinarySplitter(*this); } }; class TxtSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new TxtSplitter(*this); } }; class PictureSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new PictureSplitter(*this); } }; class VideoSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new VideoSplitter(*this); } }; //抽象类 class ISplitter{ public: virtual void split()=0; virtual ISplitter* clone()=0; //通过克隆自己来创建对象 virtual ~ISplitter(){} }; ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:8:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"单例模式 /* * 单例模式 * \"单例模式\" 是 \"性能优化\" 的作用 全程下只存在一个实例 * 在内部会提供一个供外接访问的接口 * 他是将其构造函数和拷贝构造函数设为私有 * 它分为饿汉模式和懒汉模式 * 懒汉模式 由于用到实例才会实例化 所以需要注意线程安全 * 饿汉模式 由于一开始直接实例化 不需要注意线程安全 但是要注意返回一个指针实例 * */ //*********************************懒汉********************************* // 简单实现 class Singleton { private: Singleton(); Singleton(const Singleton\u0026 other); public: static Singleton* getInstance(); static Singleton* m_instance; }; Singleton* Singleton::m_instance = nullptr; //线程非安全版本 Singleton* Singleton::getInstance() { if (m_instance == nullptr) { m_instance = new Singleton(); } return m_instance; } //双检查锁，但由于内存读写reorder不安全 Singleton* Singleton::getInstance() { if(m_instance==nullptr){ Lock lock; if (m_instance == nullptr) { m_instance = new Singleton(); } } return m_instance; } //*******************************************饿汉********************************* class Singleton { private: Singleton() {} static Singleton instance; //静态变量只会有一份数据存在 从而保证只有一个实例 public: static Singleton* GetInstance() { return \u0026instance; } } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:9:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"享元模式 /* FileName: flyweight.h * Author: ting * Detail: { * 1. 享元模式示例 * 2. flyweight模式 跟 单例模式 的作用是一样的 都是性能优化 为了减少对象的实例个数 * } * */ #include \u003ciostream\u003e #include\u003cstring\u003e #include\u003cmap\u003e using namespace std; //用户类 用户网站的客户账号，是\"网站\"类的外部状态 class User { private: string m_name; public: User(string name) { m_name = name; } std::string GetName() { return m_name; } }; //抽象网站类 定义对象的内部状态和外部状态及其对应的方法 class WebSite { public: virtual ~WebSite() = default; virtual void Use(User user) = 0; }; //此处为具体网站类 实现抽象享元角色的方法，在具体的角色中，实现具体方法时需要注意将内部状态与外部状态区分开，不应出现二者同时被修改的方法。 class ConcreteWebSite :public WebSite { private: string m_name; public: ConcreteWebSite(std::string name) { m_name = name; } void Use(User user)override { cout \u003c\u003c \"网站分类：\" \u003c\u003c m_name \u003c\u003c \" 用户：\" + user.GetName() \u003c\u003c endl; } }; //此处为网站工程类 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象， //如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 class WebSiteFactory { private: std::map\u003cstd::string, WebSite*\u003e flyweights; public: ~WebSiteFactory() { for (auto it = flyweights.begin(); it != flyweights.end(); ++it) delete it-\u003esecond; } WebSite* GetWebSiteCategory(string key) { for (auto it = flyweights.begin(); it != flyweights.end(); ++it) { if (it-\u003efirst == key) return it-\u003esecond; } WebSite* website = new ConcreteWebSite(key); flyweights.insert(pair\u003cstd::string, WebSite*\u003e(key, website)); return website; } int GetWebSiteCount() { return flyweights.size(); } }; int main() { WebSiteFactory f; WebSite* fx = f.GetWebSiteCategory(\"产品展示\"); fx-\u003eUse(User(\"小菜\")); WebSite* fy = f.GetWebSiteCategory(\"产品展示\"); fy-\u003eUse(User(\"大鸟\")); WebSite* fz = f.GetWebSiteCategory(\"产品展示\"); fz-\u003eUse(User(\"娇娇\")); WebSite* fl = f.GetWebSiteCategory(\"博客\"); fl-\u003eUse(User(\"老顽童\")); WebSite* fm = f.GetWebSiteCategory(\"博客\"); fm-\u003eUse(User(\"桃谷六仙\")); WebSite* fn = f.GetWebSiteCategory(\"博客\"); fn-\u003eUse(User(\"南海鳄神\")); cout \u003c\u003c \"得到网站分类总数：\" \u003c\u003c f.GetWebSiteCount() \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:10:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"状态模式 /* Author: ting * Mail: vlicecream520@gmail.com * Detail: ( * 1. 状态模式示例 * 一个程序员会随着一天的不同时间处于不同状态 * * 2. 状态模式适用于 根据自己的状态发生变化 行为也随之发现变化 * 他跟观察者模式不一样 观察者模式是 一个或多个对象 根据 一个对象的状态发生变化而发生变化 * ) * */ #include \u003ciostream\u003e using namespace std; class Work; // 状态接口 class State { public: // 与 work 行为相关的函数 virtual void WriteProgram(Work *w) = 0; }; // 工作类 class Work { private: // 当前状态 State* current; // 当前时间 double hour; // 工作是否完成 bool taskFinish; public: Work() { taskFinish = false; } // 设置/获取时间 void SetTime(double hour) { this-\u003ehour = hour; } double GetTime() { return this-\u003ehour; } // 设置状态 void SetState(State *s) { current = s; } // 设置工程是否完成 void SetFinish() { this-\u003etaskFinish = true; } // 获取工作是否完成状态 bool GetFinish() { return taskFinish; } // work 行为 void WriteProgram() { current-\u003eWriteProgram(this); } }; //下班休息状态 class RestState : public State { public: void WriteProgram(Work *w) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 工作完成，下班回家了\" \u003c\u003c endl; } }; //睡眠工作状态 class SleepingState : public State { public: void WriteProgram(Work *w) { cout \u003c\u003c \"受不了了,\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点了，先睡吧\" \u003c\u003c endl; } }; //晚上工作状态 class EveningState : public State { public: void WriteProgram(Work *w) { //任务完成了，可以休息了 if(w-\u003eGetFinish()) { w-\u003eSetState(new RestState()); w-\u003eWriteProgram(); } else { if(w-\u003eGetTime()\u003c21) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 加班了，疲惫至极\" \u003c\u003c endl; } else { //找过21点 w-\u003eSetState(new SleepingState()); w-\u003eWriteProgram(); } } } }; //下午工作状态 class AfternoonState : public State { public: void WriteProgram(Work *w) { if(w-\u003eGetTime()\u003c17) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 状态还不错，继续努力\" \u003c\u003c endl; } else { w-\u003eSetState(new EveningState()); w-\u003eWriteProgram(); } } }; //中午工作状态 class NoonState : public State { public: void WriteProgram(Work *w) { if (w-\u003eGetTime()\u003c13) cout\u003c\u003c\"当前时间:\"\u003c\u003cw-\u003eGetTime()\u003c\u003c\"点 饿了，午饭:犯困，午休\"\u003c\u003cendl; else { w-\u003eSetState(new AfternoonState()); w-\u003eWriteProgram(); } } }; //上午工作状态 class ForenoonState : public State { public: void WriteProgram(Work *w) { if(w-\u003eGetTime()\u003c12) cout\u003c\u003c\"当前时间:\"\u003c\u003cw-\u003eGetTime()\u003c\u003c\"点 上午工作，精神百倍\"\u003c\u003cendl; else { w-\u003eSetState(new NoonState()); w-\u003eWriteProgram(); } } }; void main() { //紧急项目 Work *emergencyProjects = new Work(); emergencyProjects-\u003eSetState(new ForenoonState()); emergencyProjects-\u003eSetTime(9); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(10); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(12); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(14); emergencyProjects-\u003eWriteProgram(); //完成工作，不需要再加班了 //emergencyProjects-\u003eSetFinish(); emergencyProjects-\u003eSetTime(19); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(22); emergencyProjects-\u003eWriteProgram(); } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:11:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"组合模式 /* Author: ting * Date: 2022-08-14 * Detail: 组合模式示例 * 将多个对象依据树形结构看为一个整体 实现 \"部分 - 整体\"的效果 * 1. 抽象示例(Component)角色: 他的主要作用是为了树叶构件声明公共接口, 并实现他们的默认行为 * 2. 树叶构件(Composite)角色: 是组合中的分支节点对象, 他有子结点, 用于继承和实现抽象构件 * 主要作用是存储和管理子部件 通常包含 Add() Remove() GetChild() 等方法 * 3. 树叶构件(Leaf)角色: 是组合中的叶节点对象, 他没有子节点, 用于继承和实现抽象构件 * */ // 计数 class Counter { public: virtual ~Counter() {}; virtual int Count() = 0; }; // 树叶构件 class City : public Counter { public: City(int sum) : sum(sum) { }; int Count() override { return sum; } private: int sum; }; // 树枝构件 class Composite : public Counter { public: ~Composite() { for (auto\u0026 counter : counters) { delete counter; } } void add(Counter* counter) { counters.push_back(counter); } void del(Counter* counter) { auto it = find(counters.begin(), counters.end(), counter); counters.erase(it); } int count() { int sum = 0; for (const auto\u0026 counter : counters) { sum += counter-\u003ecount(); } return sum; } private: vector\u003cCounter*\u003e counters; }; // 使用：统计人口数量 int main() { Composite* china = new Composite(); City* beijing = new City(100000); // 直辖市 City* shanghai = new City(50000); // 直辖市 china-\u003eadd(beijing); china-\u003eadd(shanghai); Composite* shanxi = new Composite(); shanxi-\u003eadd(new City(3000)); // 大同市 shanxi-\u003eadd(new City(2000)); // 太原市 china-\u003eadd(shanxi); cout \u003c\u003c china-\u003ecount() \u003c\u003c endl; } ","date":"2023-08-20","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/:12:0","tags":["示例c++代码"],"title":"示例c++代码","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%A4%BA%E4%BE%8Bc-%E4%BB%A3%E7%A0%81/"},{"categories":["设计模式"],"content":"设计模式-解析器","date":"2023-08-15","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"领域规则模式 什么是领域规则 在特定领域中, 某些变化虽然频繁, 但可以抽象为某种规则，这时候, 结合特定领域, 将问题抽象为语法规则, 从而给出在该领域下的一般性的解决方案 典型模式 Interpreter ","date":"2023-08-15","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:1:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 如果某一特定领域的问题比较复杂, 类似的结构不断重复出现, 如果使用普通的编程方式来实现将面临非常频繁的变化 在这种情况下, 将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子, 从而达到解决问题的目的 ","date":"2023-08-15","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:2:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 给定一个语言, 定义他的文法的一种表示, 并定义一种解释器, 这个解释器使用该表示来解释语言中的句子 ","date":"2023-08-15","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:3:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 Interpreter模式的应用场景是这个模式的一个难点，只有满足 “业务规则频繁变化, 且类似的结构不断重复出现, 并且容易抽象为语言规则的问题\"才适合这种模式 使用这种模式来表示文法规则, 从而可以使用面向对象技巧来方便的 扩展 文法 Interpreter模式适合简单的文法表示, 对于复杂的文法表示, 这种模式会产生较大的类层次结构，需要求助于第三方的语法分析器 ","date":"2023-08-15","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/:4:0","tags":["解析器"],"title":"解析器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E6%9E%90%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-访问器","date":"2023-08-14","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"行为变化模式 什么是行为变化 在组件的构建过程中, 组件行为的变化经常导致组件本身剧烈的变化，“行为变化\"模式将组件的行为和组件本身进行解藕, 从而支持组件行为的变化, 实现两者之间的松耦合 典型模式 Command Visitor ","date":"2023-08-14","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:1:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"访问器 - 前言 访问器这个模式 有一个很难的前提 就是在扩展的类的子类个数必须稳定 也就是说要提前就知道有多少个子类 不能增加 ","date":"2023-08-14","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:2:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 由于需求的改变, 某些类层次结构中常常需要增加新的行为(方法)，如果直接在基类中做这样的更改, 将会给子类带来很繁重的变更负担, 甚至破坏原有设计 如何在不更改层次结构的前提下, 在运行时根据需要透明的为类层次结构上的各个类动态添加新的操作, 从而避免上述问题? ","date":"2023-08-14","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:3:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 表示一个作用于某对象结构中的各元素操作，使得可以在不改变(稳定)各元素的类的前提下定义(扩展)作用于这些元素的新操作(变化) ","date":"2023-08-14","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:4:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 Visitor模式通过所有双重分发来实现在不更改类层次结构的前提下, 在运行时透明的为类层次结构上的各个类动态添加新的操作 所有双重分发即Visitor模式中间包含了两个多态分发 第一个为accept方法的多态辨析 第二个为visitElementX方法的多态辨析 Visitor模式的最大缺点为扩展类层次结构, 会导致visitor类的改变，因此这个模式适用于类层次结构稳定, 而其中的操作方法频繁变化 ","date":"2023-08-14","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/:5:0","tags":["访问器"],"title":"访问器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-命令模式","date":"2023-08-13","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"行为变化模式 什么是行为变化 在组件的构建过程中, 组件行为的变化经常导致组件本身剧烈的变化，“行为变化\"模式将组件的行为和组件本身进行解藕, 从而支持组件行为的变化, 实现两者之间的松耦合 典型模式 Command Visitor ","date":"2023-08-13","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:1:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"命令模式前言 这个模式跟迭代器模式的地位很像，如果在c++中 其实这个模式很少用到 因为泛型编程里的函数对象已经优化的很好，然后在其他语言 java之类的 这个模式应用的也是很广泛 ","date":"2023-08-13","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:2:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, “行为请求者\"与\"行为实现者\"通常呈现一种\"紧耦合”，但在某一个场合—-比如需要对行为进行\"记录、撤销/重(undo/redo)、事务等处理”, 这种无法抵御变化的紧耦合是不合适的 在这种情况下, 如何将\"行为请求者\"与\"行为实现者\"解藕? 将一组行为抽象为对象, 可以实现二者之间的松耦合 ","date":"2023-08-13","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:3:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 将一个请求(行为)封装为一个对象, 从而使你可用不同的请求对客户进行参数化，对请求排队或记录日志, 以及支持可撤销的操作 ","date":"2023-08-13","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:4:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Command模式的根本目的在于将\"行为请求者\"与\"行为实现者\"解藕, 在面向对象语言中, 常见的实现手段是\"将行为抽象为对象\" 实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的状态信息。通过使用Composite模式, 可以将多个命令封装为一个复合命令 Command模式与c++中的函数对象有些类似, 但两者行为接口的规范有所区别，Command以面向对象中的\"接口-实现\"来定义行为函数规范, 更严格, 但有性能损失，c++函数对象以函数签名来定义行为函数规范, 更灵活, 性能更高 ","date":"2023-08-13","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/:5:0","tags":["命令模式"],"title":"命令模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-职责链","date":"2023-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"数据结构模式 什么是数据结构模式 常常有一些组件在内部具有特定的数据结构, 如果让客户程序依赖这些特定的数据结构, 将极大的破坏组件的复用 典型模式 Composite Iterator Chain of Resposibility ","date":"2023-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:1:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"职责链前言 这个模式 其实随着现在数据结构的发展 也过时了 但是还是老话 模式过时 思想不会过时 ","date":"2023-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:2:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 一个请求可能被多个对象处理, 但是每个请求在运行时只能有一个接受者，如果显式指定, 将必不可少的带来发送者和接受者的紧耦合 如何使请求的发送者不需要指定具体的接受者? 让请求的接受者自己在运行时决定来处理请求, 从而使两者解藕 ","date":"2023-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:3:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"模式定义 使多个对象都有机会处理请求, 从而避免请求的发送者和接受者之间的耦合关系，将这些对象形成一条链表, 并沿着这条链传递请求, 直到有一个对象处理它为止 ","date":"2023-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:4:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"要点总结 职责链模式的应用场合在于 “一个请求可能有多个接受者, 但是最后真正的接受者只有一个”，这时候请求发送者与接受者的耦合有可能出现\"变化脆弱\"的症状, 职责链的目的就是将二者解藕, 从而更好的应对变化 应用了职责链模式后, 对象的职责分派将更具有灵活性，我们可以在运行时动态添加/修改请求的处理职责 如果请求传递到职责链的末尾仍得不到处理, 应该有一个合理的缺省机制，这也是每一个接受对象的责任, 而不是发出 ","date":"2023-08-12","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/:5:0","tags":["职责链"],"title":"职责链","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%81%8C%E8%B4%A3%E9%93%BE/"},{"categories":["设计模式"],"content":"设计模式-迭代器","date":"2023-08-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"数据结构模式 什么是数据结构 常常有一些组件在内部具有特定的数据结构, 如果让客户程序依赖这些特定的数据结构, 将极大的破坏组件的复用 典型模式 Composite Iterator Chain of Resposibility ","date":"2023-08-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"迭代器前言 这个模式 在 c++ 上其实已经过时了 GoF 对迭代器的定义 是面向对象的迭代器 要去遍历很多的虚函数 然而虚函数是有性能代价的 运行时依赖 懂得STL 泛型编程的朋友都知道 STL 里面定义了很多迭代器 这里面的迭代器是 模板方法的迭代器 编译时依赖 但是一个模式过时 不代表思想会过时 c++的迭代器也是根据这个思想 把算法和容器给隔离开来，而且其他语言 比如java 这个面向对象的迭代器也在使用，所以我们还是得对这个模式一探究竟 ","date":"2023-08-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:2:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 集合对象内部结构常常变化各异，但对于这些集合对象, 我们希望在不暴露其内部结构的同时, 可以让外部客户代码透明的访问其中包含的元素，同时这种\"透明遍历\"也为\"同一种算法在多种集合对象上进行操作\"提供了可能 使用面向对象技术将这种遍历机制抽象为\"迭代器对象\"，为\"应对变化中的集合对象\"提供了一种优雅的方式 ","date":"2023-08-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:3:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露(稳定)该对象的内部表示 ","date":"2023-08-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:4:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 迭代抽象: 访问一个聚合对象的内容而无需暴露他的内部表示 迭代多态: 为遍历不同的集合结构提供一个统一的接口, 从而支持同样的算法在不同的集合结构上进行操作 迭代器的健壮性考虑: 遍历的同时更改迭代器所在的集合结构, 会导致问题 ","date":"2023-08-11","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/:5:0","tags":["迭代器"],"title":"迭代器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-组合模式","date":"2023-08-10","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"数据结构模式 什么是数据结构模式 常常有一些组件在内部具有特定的数据结构, 如果让客户程序依赖这些特定的数据结构, 将极大的破坏组件的复用 典型模式 Composite Iterator Chain of Resposibility ","date":"2023-08-10","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:1:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 在软件某些情况下, 客户代码过多的依赖于对象容器复杂的内部实现结构, 对象容器内部实现结构(而非对象接口)的变化将引起客户代码的频繁变化, 带来了代码的维护性、扩展性等弊端 如何将\"客户代码与复杂的对象容器结构\"解藕? 让对象容器自己来实现自身的复杂结构, 从而使得客户代码就像处理简单对象一样来处理复杂的对象容器? ","date":"2023-08-10","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:2:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 将对象组合成树形结构以表示 “部分 - 整体” 的层次结构 Composite使得用户对单个对象和组合对象的使用具有一致性(稳定) ","date":"2023-08-10","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:3:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 /* Author: ting * Date: 2022-08-14 * Detail: 组合模式示例 * 将多个对象依据树形结构看为一个整体 实现 \"部分 - 整体\"的效果 * 1. 抽象示例(Component)角色: 他的主要作用是为了树叶构件声明公共接口, 并实现他们的默认行为 * 2. 树叶构件(Composite)角色: 是组合中的分支节点对象, 他有子结点, 用于继承和实现抽象构件 * 主要作用是存储和管理子部件 通常包含 Add() Remove() GetChild() 等方法 * 3. 树叶构件(Leaf)角色: 是组合中的叶节点对象, 他没有子节点, 用于继承和实现抽象构件 * */ // 计数 class Counter { public: virtual ~Counter() {}; virtual int Count() = 0; }; // 树叶构件 class City : public Counter { public: City(int sum) : sum(sum) { }; int Count() override { return sum; } private: int sum; }; // 树枝构件 class Composite : public Counter { public: ~Composite() { for (auto\u0026 counter : counters) { delete counter; } } void add(Counter* counter) { counters.push_back(counter); } void del(Counter* counter) { auto it = find(counters.begin(), counters.end(), counter); counters.erase(it); } int count() { int sum = 0; for (const auto\u0026 counter : counters) { sum += counter-\u003ecount(); } return sum; } private: vector\u003cCounter*\u003e counters; }; // 使用：统计人口数量 int main() { Composite* china = new Composite(); City* beijing = new City(100000); // 直辖市 City* shanghai = new City(50000); // 直辖市 china-\u003eadd(beijing); china-\u003eadd(shanghai); Composite* shanxi = new Composite(); shanxi-\u003eadd(new City(3000)); // 大同市 shanxi-\u003eadd(new City(2000)); // 太原市 china-\u003eadd(shanxi); cout \u003c\u003c china-\u003ecount() \u003c\u003c endl; } ","date":"2023-08-10","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:4:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Composite模式采用树形结构来实现普遍存在的对象容器, 从而将\"一对多\"的关系转化为\"一对一\"的关系, 使得客户代码可以一致的(复用)处理对象和对象容器, 无需关心处理的是单个的对象, 还是组合的对象容器 将\"客户代码与复杂的对象容器结构\"解藕是Composite模式的核心思想，解藕之后, 客户代码将与纯粹的抽象接口—-而非对象容器内部实现结构 发生依赖, 从而更能\"应对变化\" Composite模式在具体实现中, 可以让父对象中的子对象反向追溯，如果父对象有频繁的遍历需求, 可使用缓存 ","date":"2023-08-10","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:5:0","tags":["组合模式"],"title":"组合模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-备忘录","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"状态变化模式 什么是状态变化 在组件构建过程中, 某些对象的状态面临变化, 如何对这些变化进行有效的管理? 同时又保证高层的稳定? 典型模式 Memento State ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:1:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 某些对象的状态在转换过程中, 可能由于某种需要, 要求程序能够回溯到对象之前的状态 如果使用一些公有接口来让其他对象得到对象的状态, 便会暴露对象的细节实现 如何实现对象状态的良好保存与恢复? 但同时又不会因此而破坏对象本身的封装性 ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:2:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"模式定义 在不破坏封装性的的前提下, 捕获一个对象的内部状态, 并在该对象之外保存此状态，这样以后就可以将该对象恢复到原先保存的状态 ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:3:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"要点总结 备忘录(Memento)存储原发器对象的内部状态 在需要时恢复原发器状态 Memento模式的核心是信息隐藏, 即原发器需要向外接隐藏信息, 保持其封装性，但同时有需要将状态保持到外界 (Memento) 由于现代语言运行时都具有相当的对象序列化支持, 因此往往采用效率高、又较容器正确实现的序列化方案来实现Memento模式 ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/:4:0","tags":["备忘录"],"title":"备忘录","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["设计模式"],"content":"设计模式-状态模式","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"状态变化模式 什么是状态变化 在组件构建过程中, 某些对象的状态面临变化, 如何对这些变化进行有效的管理? 同时又保证高层的稳定? 典型模式 Memento State ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:1:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 某些对象的状态如果改变, 其行为也会随之而发生变化 比如文档处于只读状态, 其支持的行为和读写状态支持的行为就可能完全不同 如何在运行时根据对象的状态来透明的更改对象的行为? 而不会为对象操作和状态转化之间引入紧耦合? ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:2:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 允许一个对象在其内部状态改变时改变他的行为, 从而使对象看起来似乎修改了其行为 ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:3:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 /* Author: ting * Mail: vlicecream520@gmail.com * Detail: ( * 1. 状态模式示例 * 一个程序员会随着一天的不同时间处于不同状态 * * 2. 状态模式适用于 根据自己的状态发生变化 行为也随之发现变化 * 他跟观察者模式不一样 观察者模式是 一个或多个对象 根据 一个对象的状态发生变化而发生变化 * ) * */ #include \u003ciostream\u003e using namespace std; class Work; // 状态接口 class State { public: // 与 work 行为相关的函数 virtual void WriteProgram(Work *w) = 0; }; // 工作类 class Work { private: // 当前状态 State* current; // 当前时间 double hour; // 工作是否完成 bool taskFinish; public: Work() { taskFinish = false; } // 设置/获取时间 void SetTime(double hour) { this-\u003ehour = hour; } double GetTime() { return this-\u003ehour; } // 设置状态 void SetState(State *s) { current = s; } // 设置工程是否完成 void SetFinish() { this-\u003etaskFinish = true; } // 获取工作是否完成状态 bool GetFinish() { return taskFinish; } // work 行为 void WriteProgram() { current-\u003eWriteProgram(this); } }; //下班休息状态 class RestState : public State { public: void WriteProgram(Work *w) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 工作完成，下班回家了\" \u003c\u003c endl; } }; //睡眠工作状态 class SleepingState : public State { public: void WriteProgram(Work *w) { cout \u003c\u003c \"受不了了,\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点了，先睡吧\" \u003c\u003c endl; } }; //晚上工作状态 class EveningState : public State { public: void WriteProgram(Work *w) { //任务完成了，可以休息了 if(w-\u003eGetFinish()) { w-\u003eSetState(new RestState()); w-\u003eWriteProgram(); } else { if(w-\u003eGetTime()\u003c21) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 加班了，疲惫至极\" \u003c\u003c endl; } else { //找过21点 w-\u003eSetState(new SleepingState()); w-\u003eWriteProgram(); } } } }; //下午工作状态 class AfternoonState : public State { public: void WriteProgram(Work *w) { if(w-\u003eGetTime()\u003c17) { cout \u003c\u003c \"当前时间:\" \u003c\u003c w-\u003eGetTime() \u003c\u003c \"点 状态还不错，继续努力\" \u003c\u003c endl; } else { w-\u003eSetState(new EveningState()); w-\u003eWriteProgram(); } } }; //中午工作状态 class NoonState : public State { public: void WriteProgram(Work *w) { if (w-\u003eGetTime()\u003c13) cout\u003c\u003c\"当前时间:\"\u003c\u003cw-\u003eGetTime()\u003c\u003c\"点 饿了，午饭:犯困，午休\"\u003c\u003cendl; else { w-\u003eSetState(new AfternoonState()); w-\u003eWriteProgram(); } } }; //上午工作状态 class ForenoonState : public State { public: void WriteProgram(Work *w) { if(w-\u003eGetTime()\u003c12) cout\u003c\u003c\"当前时间:\"\u003c\u003cw-\u003eGetTime()\u003c\u003c\"点 上午工作，精神百倍\"\u003c\u003cendl; else { w-\u003eSetState(new NoonState()); w-\u003eWriteProgram(); } } }; void main() { //紧急项目 Work *emergencyProjects = new Work(); emergencyProjects-\u003eSetState(new ForenoonState()); emergencyProjects-\u003eSetTime(9); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(10); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(12); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(14); emergencyProjects-\u003eWriteProgram(); //完成工作，不需要再加班了 //emergencyProjects-\u003eSetFinish(); emergencyProjects-\u003eSetTime(19); emergencyProjects-\u003eWriteProgram(); emergencyProjects-\u003eSetTime(22); emergencyProjects-\u003eWriteProgram(); } ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:4:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中, 在对象状态切换时, 切换相对应的对象，但同时维持State的接口, 这样实现了具体操作与状态转换之间的解藕 为不同的状态引入不同的对象使得状态转换变得更加明确, 而且可以保证不会出现状态不一致的情况, 因为转换是原子性的，即要么彻底转换过来 要么不转换 如果State对象没有实例变量, 那么各上下文可以共享一个State对象, 从而节省对象开销 ","date":"2023-08-09","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/:5:0","tags":["状态模式"],"title":"状态模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-中介者","date":"2023-08-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"接口隔离模式 什么是接口隔离 在组件构建过程中, 某些接口之间直接的依赖 常常会带来很多问题 甚至根本无法实现 采用添加一层间接(稳定)接口, 来隔离本来互相紧密关联的接口是一种常见的解决方案 典型模式 Façade Proxy Mediator Adapter ","date":"2023-08-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:1:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"动机 在软件构建过程中, 经常会出现多个对象互相关联交互的情况, 对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改, 这种直接的引用关系将面临不断的变化 在这种情况下, 我们可使用一个\"中介对象\"来管理对象之间的关联关系, 避免相互交互的对象之间的紧耦合引用关系, 从而抵御变化 ","date":"2023-08-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:2:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"模式定义 用一个中介对象来封装(变化)一系列的对象交互 中介者使各对象不需要显式的相互引用(编译时依赖 -\u003e 运行时依赖), 从而使得耦合松散, 而且可以独立的改变他们之间的交互 ","date":"2023-08-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:3:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"要点总结 将多个对象间复杂的关联关系, Mediator模式将多个对象间的控制逻辑进行集中管理 变\"多个对象互相关联\"为\"多个对象和一个中介者关联\", 简化了系统的维护, 抵御了可能的变化 随着控制逻辑的复杂变化, Mediator具体对象的实现可能相当复杂，这个时候可对Mediator对象进行分解处理 Facade模式是解耦系统间(单向)的对象关联关系 Mediator模式是解耦系统内各个对象间(双向)的关联关系 ","date":"2023-08-07","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/:4:0","tags":["中介者"],"title":"中介者","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85/"},{"categories":["设计模式"],"content":"设计模式-适配器","date":"2023-08-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"接口隔离模式 什么是接口隔离 在组件构建过程中, 某些接口之间直接的依赖 常常会带来很多问题 甚至根本无法实现 采用添加一层间接(稳定)接口, 来隔离本来互相紧密关联的接口是一种常见的解决方案 典型模式 Façade Proxy Mediator Adapter ","date":"2023-08-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:1:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"动机 在软件系统中, 由于应用环境的变化, 常常需要将\"一些现存的对象\"放在新的环境中应用, 但是新环境要求的接口是这些现存对象所不满足的 如何应对这种\"迁移的变化\"? 如何既能利用现有对象的良好实现, 同时又能满足新的应用环境所要求的接口? ","date":"2023-08-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:2:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 将一个类的接口转换成客户希望的另一个接口 Adapter模式使得由于接口不兼容而不能一起工作的那些类可以一起工作 ","date":"2023-08-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:3:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 Adapter模式主要应用于\"希望复用一些现存的类, 但是接口又与复用环境要求不一致的情况\", 在遗留代码复用、类库迁移等方面非常有用 GoF 23 定义了两种Adapter模式的实现结构, 对象适配器和类适配器 不推荐使用类适配器 因为类适配器用的是多继承的方法 推荐使用对象适配器 因为对象适配器使用的组合方法 Adapter模式的使用非常灵活, 不必拘泥于上述两种模式 例如 完全可以将Adapter模式中的现存对象作为新的接口方法参数, 来达到适配的目的 ","date":"2023-08-06","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/:4:0","tags":["适配器"],"title":"适配器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-代理模式","date":"2023-08-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"接口隔离模式 什么是接口隔离 在组件构建过程中, 某些接口之间直接的依赖 常常会带来很多问题 甚至根本无法实现 采用添加一层间接(稳定)接口, 来隔离本来互相紧密关联的接口是一种常见的解决方案 典型模式 Façade Proxy Mediator Adapter ","date":"2023-08-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 在面向对象系统中, 有些对象由于某种原因(比如对象创建的开销很大, 或者某些操作需要安全控制, 或者需要进程外的访问等)直接访问会给使用者或者系统结构带来很多麻烦 如何在不是去透明操作对象的同时来管理或者控制这些对象特有的复杂性？ 增加一层间接层是软件开发中常见的解决方式 ","date":"2023-08-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:2:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"初始代码 class ISubject{ public: virtual void process(); }; class RealSubject: public ISubject{ public: virtual void process(){ //.... } }; class ClientApp{ ISubject* subject; public: ClientApp(){ subject=new RealSubject(); } void DoTask(){ //... subject-\u003eprocess(); //.... } }; ","date":"2023-08-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:3:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"重构代码 class ISubject { public: virtual void process(); }; //Proxy的设计 class SubjectProxy: public ISubject { public: virtual void process(){ //对RealSubject的一种间接访问 //.... } }; class ClientApp { ISubject* subject; public: ClientApp() { subject=new SubjectProxy(); } void DoTask() { //... subject-\u003eprocess(); //.... } }; ","date":"2023-08-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:4:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 为其他对象提供一种代理以控制(隔离，使用接口) 对这个对象的访问 ","date":"2023-08-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:5:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 “增加一层间接层\"是软件系统中对许多复杂问题的一种常见解决方法. 在面向对象系统中, 直接使用某些对象会带来很多问题, 作为间接层的proxy对象便是解决这一问题的常用手段 具体proxy设计模式的实现方法 实现粒度都相差很大 有些可能对单个对象做细粒度的控制, 如copy-on-write技术, 有些可能对组件模块提供抽象代理层, 在架构层次对对象做proxy proxy并不一定要求保持接口完整的一致性, 只要能够实现间接控制, 有时候损失一些透明性是可以接受的 ","date":"2023-08-05","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:6:0","tags":["代理模式"],"title":"代理模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-门面模式","date":"2023-08-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"接口隔离模式 什么是接口隔离 在组件构建过程中, 某些接口之间直接的依赖 常常会带来很多问题 甚至根本无法实现 采用添加一层间接(稳定)接口, 来隔离本来互相紧密关联的接口是一种常见的解决方案 典型模式 Façade Proxy Mediator Adapter ","date":"2023-08-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:1:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动机 上述A方案的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合, 随着外部客户程序和各子系统的演化, 这种过多的耦合面临很多变化的挑战 如何简化外部客户程序和系统间的交互接口? 如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解藕? ","date":"2023-08-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:2:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 为子系统中的一组接口提供一个一致(稳定)的界面, Facade模式定义了一个高层接口, 这个接口使得这一子系统更加容易复用 ","date":"2023-08-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:3:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 这个模式下的类图其实没有很明确的概念 ","date":"2023-08-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:4:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 从客户程序的角度来看, 门面模式简化了整个组件系统的接口, 对于组件内部与外部客户程序来说, 达到了一种\"解藕\"的效果—-内部子系统的任何变化不会影响到Facade接口的变化 Facade设计模式更注重从架构的层次去看整个系统, 而不是单个类的层次 门面模式很多时间更是一种架构设计模式 Facade设计模式并非一个集装箱, 可以任意的放进任何多个对象. Facade模式中组件的内部应该是\"相互耦合关系比较大的一系列组件\", 而不是一个简单的功能集合 ","date":"2023-08-04","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/:5:0","tags":["门面模式"],"title":"门面模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-享元模式","date":"2023-08-03","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"对象性能模式 什么是对象性能 面向对象很好的解决了\"抽象\"的问题, 但是必不可免的要付出一定的代价，对于通常情况来讲, 面向对象的成本大都可以忽略不计，但是某些情况, 面向对象所带来的成本必须谨慎处理 典型模式 Singleton Flyweight ","date":"2023-08-03","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:1:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"享元模式动机 在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中， 从而带来很高的运行时代价–主要指内存需求方面的代价. 如何在避免大量细粒度对象问题的同时, 让外部客户程序仍然能够透明的使用面向对象的方式来进行操作 ","date":"2023-08-03","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:2:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"演示代码 /* FileName: flyweight.h * Author: ting * Detail: { * 1. 享元模式示例 * 2. flyweight模式 跟 单例模式 的作用是一样的 都是性能优化 为了减少对象的实例个数 * } * */ #include \u003ciostream\u003e #include\u003cstring\u003e #include\u003cmap\u003e using namespace std; //用户类 用户网站的客户账号，是\"网站\"类的外部状态 class User { private: string m_name; public: User(string name) { m_name = name; } std::string GetName() { return m_name; } }; //抽象网站类 定义对象的内部状态和外部状态及其对应的方法 class WebSite { public: virtual ~WebSite() = default; virtual void Use(User user) = 0; }; //此处为具体网站类 实现抽象享元角色的方法，在具体的角色中，实现具体方法时需要注意将内部状态与外部状态区分开，不应出现二者同时被修改的方法。 class ConcreteWebSite :public WebSite { private: string m_name; public: ConcreteWebSite(std::string name) { m_name = name; } void Use(User user)override { cout \u003c\u003c \"网站分类：\" \u003c\u003c m_name \u003c\u003c \" 用户：\" + user.GetName() \u003c\u003c endl; } }; //此处为网站工程类 负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象， //如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 class WebSiteFactory { private: std::map\u003cstd::string, WebSite*\u003e flyweights; public: ~WebSiteFactory() { for (auto it = flyweights.begin(); it != flyweights.end(); ++it) delete it-\u003esecond; } WebSite* GetWebSiteCategory(string key) { for (auto it = flyweights.begin(); it != flyweights.end(); ++it) { if (it-\u003efirst == key) return it-\u003esecond; } WebSite* website = new ConcreteWebSite(key); flyweights.insert(pair\u003cstd::string, WebSite*\u003e(key, website)); return website; } int GetWebSiteCount() { return flyweights.size(); } }; int main() { WebSiteFactory f; WebSite* fx = f.GetWebSiteCategory(\"产品展示\"); fx-\u003eUse(User(\"小菜\")); WebSite* fy = f.GetWebSiteCategory(\"产品展示\"); fy-\u003eUse(User(\"大鸟\")); WebSite* fz = f.GetWebSiteCategory(\"产品展示\"); fz-\u003eUse(User(\"娇娇\")); WebSite* fl = f.GetWebSiteCategory(\"博客\"); fl-\u003eUse(User(\"老顽童\")); WebSite* fm = f.GetWebSiteCategory(\"博客\"); fm-\u003eUse(User(\"桃谷六仙\")); WebSite* fn = f.GetWebSiteCategory(\"博客\"); fn-\u003eUse(User(\"南海鳄神\")); cout \u003c\u003c \"得到网站分类总数：\" \u003c\u003c f.GetWebSiteCount() \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2023-08-03","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:3:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 运用共享技术有效的支持大量细粒度的对象 ","date":"2023-08-03","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:4:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 面向对象很好的解决了抽象性的问题， 但是作为一个运行在机器中的程序实体, 我们需要考虑对象的代价问题，Flyweight主要解决面向对象的代价问题, 一般不触及面向对象的抽象性问题 Flyweight采用对象共享的做法来降低系统中对象的个数, 从而降低细粒度对象给系统带来的内存压力，在具体实现方面, 要注意对象状态的处理 对象的数量太大从而导致对象内存开销加大—什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估, 而不能凭空臆断 ","date":"2023-08-03","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/:5:0","tags":["享元模式"],"title":"享元模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-单例模式","date":"2023-08-02","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"对象性能模式 什么是对象性能 面向对象很好的解决了\"抽象\"的问题, 但是必不可免的要付出一定的代价，对于通常情况来讲, 面向对象的成本大都可以忽略不计，但是某些情况, 面向对象所带来的成本必须谨慎处理 典型模式 Singleton Flyweight ","date":"2023-08-02","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单例模式动机 在软件系统中 经常有这样一些特殊的类, 必须保证他们在系统中只存在一个实例, 才能确保他们的逻辑正确性以及良好的效率 如何绕过常规的构造器, 提供一种机制来保证一个类只有一个实例 ps：这个是类设计者的责任, 而不是使用者的责任 ","date":"2023-08-02","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"演示代码 class Singleton{ private: Singleton(); Singleton(const Singleton\u0026 other); public: static Singleton* getInstance(); static Singleton* m_instance; }; Singleton* Singleton::m_instance=nullptr; //线程非安全版本 Singleton* Singleton::getInstance() { if (m_instance == nullptr) { m_instance = new Singleton(); } return m_instance; } //线程安全版本，但锁的代价过高 Singleton* Singleton::getInstance() { Lock lock; if (m_instance == nullptr) { m_instance = new Singleton(); } return m_instance; } //双检查锁，但由于内存读写reorder不安全 Singleton* Singleton::getInstance() { if(m_instance==nullptr){ Lock lock; if (m_instance == nullptr) { m_instance = new Singleton(); } } return m_instance; } //C++ 11版本之后的跨平台实现 (volatile) std::atomic\u003cSingleton*\u003e Singleton::m_instance; std::mutex Singleton::m_mutex; Singleton* Singleton::getInstance() { Singleton* tmp = m_instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire);//获取内存fence if (tmp == nullptr) { std::lock_guard\u003cstd::mutex\u003e lock(m_mutex); tmp = m_instance.load(std::memory_order_relaxed); if (tmp == nullptr) { tmp = new Singleton; std::atomic_thread_fence(std::memory_order_release);//释放内存fence m_instance.store(tmp, std::memory_order_relaxed); } } return tmp; } ","date":"2023-08-02","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 保证一个类仅有一个实例, 并提供一个该实例的全局访问点 ","date":"2023-08-02","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Singleton模式中的实例构造器可以设置为protected以允许子类派生 Singleton模式一般不要支持拷贝构造函数和clone接口, 因为这有可能导致多个对象实例, 与Singleton模式的初衷违背 如何实现多线程环境下安全的Singleton？ 注意对双检查锁的正确实现 ","date":"2023-08-02","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["单例模式"],"title":"单例模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-构建器","date":"2023-08-01","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"对象创建模式 什么是对象创建 通过对象创建模式，绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)从而支持对象创建 他是接口抽象之后的第一步工作 典型模式 Factory Method Abstract Factory Prototype Builder ","date":"2023-08-01","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:1:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"构建器动机 在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？ ","date":"2023-08-01","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:2:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"模式定义 将一个复杂对象的构建与其表示相分离，使得同样的构建过程(稳定)可以创建不同的表示(变化) ","date":"2023-08-01","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:3:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"要点总结 Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。 变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs. C#) ","date":"2023-08-01","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/:4:0","tags":["构建器"],"title":"构建器","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E5%BB%BA%E5%99%A8/"},{"categories":["设计模式"],"content":"设计模式-原型模式","date":"2023-07-30","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"对象创建模式 什么是对象创建 通过对象创建模式，绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)从而支持对象创建 他是接口抽象之后的第一步工作 典型模式 Factory Method Abstract Factory Prototype Builder ","date":"2023-07-30","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"原型动机 在软件系统中，经常面临着\"某些接口复杂的对象\"的创建工作，由于需求的变化, 这些对象经常面临着剧烈的变化, 但是他们却拥有比较稳定一致的接口 如何应对这种变化? 如何向客户程序(使用这些对象的程序)隔离出 “这些易变对象”, 从而使得\"依赖这些易变对象的客户程序\"不随着需求改变而改变 ","date":"2023-07-30","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"在工厂方法重构的基础上再次用原型模式重构的代码 class MainForm : public Form { ISplitter* prototype;//原型对象 public: MainForm(ISplitter* prototype){ this-\u003eprototype=prototype; } void Button1_Click(){ ISplitter * splitter= prototype-\u003eclone(); //克隆原型 splitter-\u003esplit(); } }; //具体类 class BinarySplitter : public ISplitter{ public: virtual ISplitter* clone(){ return new BinarySplitter(*this); } }; class TxtSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new TxtSplitter(*this); } }; class PictureSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new PictureSplitter(*this); } }; class VideoSplitter: public ISplitter{ public: virtual ISplitter* clone(){ return new VideoSplitter(*this); } }; //抽象类 class ISplitter{ public: virtual void split()=0; virtual ISplitter* clone()=0; //通过克隆自己来创建对象 virtual ~ISplitter(){} }; ","date":"2023-07-30","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象 ","date":"2023-07-30","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-30","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 prototype模式同样用语隔离类对象的使用者和具体类型(易变类)之间的耦合关系, 他同样要求这些\"易变类\"拥有\"稳定的接口\" prototype模式对于\"如何创建易变类的实体对象\"采用\"原型克隆\"的方法来做。 他使得我们可以非常灵活的动态创建\"拥有某些稳定接口\"的新对象，所需工作仅仅是注册一个新类的对象(即原型) 然后在任何需要的地方clone prototype模式中的clone方法可以利用某些框架中的序列化来实现深拷贝 c++里面一般都是拷贝构造 我们什么时候用factory method 或者 原型模式呢，简单来说 就是如果用几个步骤就用factory method模式，如果对象很复杂 有中间状态 你还想保留中间状态 就用 原型模式 ","date":"2023-07-30","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["原型模式"],"title":"原型模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-抽象工厂","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"对象创建模式 什么是对象创建 通过对象创建模式，绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)从而支持对象创建 他是接口抽象之后的第一步工作 典型模式 Factory Method Abstract Factory Prototype Builder ","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:1:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"抽象工厂动机 在软件系统中 经常面临着 “一系列相互依赖的对象\"的创建工作，同时, 由于需求的变化, 往往存在更多系列对象的创建工作 如果应对这种变化? 如何绕过常规的对象创建方法(new), 提供一种\"封装机制\"来避免客户程序和这种\"多系列具体对象创建工作\"的紧耦合? ","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:2:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"初始代码 class EmployeeDAO{ public: vector\u003cEmployeeDO\u003e GetEmployees(){ SqlConnection* connection = new SqlConnection(); connection-\u003eConnectionString = \"...\"; SqlCommand* command = new SqlCommand(); command-\u003eCommandText=\"...\"; command-\u003eSetConnection(connection); SqlDataReader* reader = command-\u003eExecuteReader(); while (reader-\u003eRead()){ } } }; ","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:3:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"运用了工厂模式代码 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cvector\u003e #include \u003cmemory\u003e // 为了让代码能编译，定义空的 EmployeeDO 类 class EmployeeDO {}; // ================================================================= // 1. 抽象产品 (Abstract Products) // 定义了产品族中每个对象的接口。 // ================================================================= class IDataReader; // 前向声明 class IDBCommand { public: virtual void SetConnection(IDBConnection* connection) = 0; virtual void CommandText(const std::string\u0026 text) = 0; virtual std::unique_ptr\u003cIDataReader\u003e ExecuteReader() = 0; virtual ~IDBCommand() {} }; class IDBConnection { public: virtual void ConnectionString(const std::string\u0026 connStr) = 0; virtual ~IDBConnection() {} }; class IDataReader { public: virtual bool Read() = 0; virtual ~IDataReader() {} }; // ================================================================= // 2. 具体产品 (Concrete Products) // 实现了具体数据库（产品族）的各个组件。 // ================================================================= // --- SQL Server 产品族 --- class SqlDataReader; // 前向声明 class SqlCommand : public IDBCommand { public: void SetConnection(IDBConnection* connection) override { std::cout \u003c\u003c \"SqlCommand: Setting SQL connection.\" \u003c\u003c std::endl; } void CommandText(const std::string\u0026 text) override { std::cout \u003c\u003c \"SqlCommand: Setting command text.\" \u003c\u003c std::endl; } std::unique_ptr\u003cIDataReader\u003e ExecuteReader() override; // 实现放在后面 }; class SqlConnection : public IDBConnection { public: void ConnectionString(const std::string\u0026 connStr) override { std::cout \u003c\u003c \"SqlConnection: Setting connection string.\" \u003c\u003c std::endl; } }; class SqlDataReader : public IDataReader { public: bool Read() override { std::cout \u003c\u003c \"SqlDataReader: Reading data...\" \u003c\u003c std::endl; return false; // 简化示例 } }; // SqlCommand 的实现需要 SqlDataReader 的完整定义 std::unique_ptr\u003cIDataReader\u003e SqlCommand::ExecuteReader() { std::cout \u003c\u003c \"SqlCommand: Executing reader for SQL.\" \u003c\u003c std::endl; return std::make_unique\u003cSqlDataReader\u003e(); } // --- Oracle 产品族 --- // (为简洁起见，只写出类名，实现与 SQL Server 类似) class OracleDataReader; class OracleCommand : public IDBCommand { public: void SetConnection(IDBConnection* connection) override { std::cout \u003c\u003c \"OracleCommand: Setting Oracle connection.\" \u003c\u003c std::endl; } void CommandText(const std::string\u0026 text) override { std::cout \u003c\u003c \"OracleCommand: Setting command text.\" \u003c\u003c std::endl; } std::unique_ptr\u003cIDataReader\u003e ExecuteReader() override; }; class OracleConnection : public IDBConnection { public: void ConnectionString(const std::string\u0026 connStr) override { std::cout \u003c\u003c \"OracleConnection: Setting connection string.\" \u003c\u003c std::endl; } }; class OracleDataReader : public IDataReader { public: bool Read() override { std::cout \u003c\u003c \"OracleDataReader: Reading data...\" \u003c\u003c std::endl; return false; } }; std::unique_ptr\u003cIDataReader\u003e OracleCommand::ExecuteReader() { std::cout \u003c\u003c \"OracleCommand: Executing reader for Oracle.\" \u003c\u003c std::endl; return std::make_unique\u003cOracleDataReader\u003e(); } // ================================================================= // 3. 抽象工厂 (Abstract Factory) // 提供一个接口，用于创建产品族中的所有产品。 // ================================================================= class IDatabaseFactory { public: virtual std::unique_ptr\u003cIDBConnection\u003e CreateDBConnection() = 0; virtual std::unique_ptr\u003cIDBCommand\u003e CreateDBCommand() = 0; // DataReader 通常由 Command 创建，所以工厂里可以不提供 virtual ~IDatabaseFactory() {} }; // ================================================================= // 4. 具体工厂 (Concrete Factories) // 每个具体工厂实现一个特定的产品族。 // ================================================================= class SqlServerFactory : public IDatabaseFactory { public: std::unique_ptr\u003cIDBConnection\u003e CreateDBConnection() override { return std::make_unique\u003cSqlConnection\u003e(); } std::unique_ptr\u003cIDBCommand\u003e CreateDBCommand() override { return std::make_unique\u003cSqlCommand\u003e(); } }; class OracleFactory : public IDatabaseFactory { public: std::unique_ptr\u003cIDBConnection\u003e CreateDBConnection() override { return std::make_unique\u003cOracleConnection\u003e(); } std::unique_ptr\u003cIDBCommand\u003e","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:4:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"运用了抽象工厂的代码 //数据库访问有关的基类 class IDBConnection{ }; class IDBCommand{ }; class IDataReader{ }; class IDBFactory{ public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; }; //支持SQL Server class SqlConnection: public IDBConnection{ }; class SqlCommand: public IDBCommand{ }; class SqlDataReader: public IDataReader{ }; class SqlDBFactory:public IDBFactory{ public: virtual IDBConnection* CreateDBConnection()=0; virtual IDBCommand* CreateDBCommand()=0; virtual IDataReader* CreateDataReader()=0; }; //支持Oracle class OracleConnection: public IDBConnection{ }; class OracleCommand: public IDBCommand{ }; class OracleDataReader: public IDataReader{ }; class EmployeeDAO{ IDBFactory* dbFactory; public: vector\u003cEmployeeDO\u003e GetEmployees(){ IDBConnection* connection = dbFactory-\u003eCreateDBConnection(); connection-\u003eConnectionString(\"...\"); IDBCommand* command = dbFactory-\u003eCreateDBCommand(); command-\u003eCommandText(\"...\"); command-\u003eSetConnection(connection); //关联性 IDBDataReader* reader = command-\u003eExecuteReader(); //关联性 while (reader-\u003eRead()){ } } }; ","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:5:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"模式定义 提供一个接口, 让该接口负责创建一系列”相关或者互相依赖的对象\", 无需确定他们具体的类 ","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:6:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:7:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"要点总结 如果没有应对\"多系列对象构建\"的需求变化, 则没有必要使用 Abstract Factory模式, 这时候使用简单的工厂完全可以 “系列对象\"指的是在某一个特定系列下的对象之间有互相依赖\\或作用的关系.不同系列的对象自建不能相互依赖 Abstract Factory模式主要在于应对\"新系列\"的需求变动. 其缺点在于难以应对\"新对象\"的需求改动 ","date":"2023-07-29","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/:8:0","tags":["抽象工厂"],"title":"抽象工厂","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"},{"categories":["设计模式"],"content":"设计模式-工厂模式","date":"2023-07-28","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"对象创建模式 什么是对象创建 通过对象创建模式，绕开new，来避免对象创建(new)过程中所导致的紧耦合(依赖具体类)从而支持对象创建 他是接口抽象之后的第一步工作 典型模式 Factory Method Abstract Factory Prototype Builder ","date":"2023-07-28","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"工厂模式动机 在软件系统中 经常面临着创建对象的工作 由于需求的变化 需要创建的对象的具体类型经常变化 如何应对这种变化? 如何绕过常规的对象创建方法(new), 提供一种\"封装机制\"来避免客户程序和这种\"具体对象创建工作\"的紧耦合? ","date":"2023-07-28","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"初始代码 class ISplitter{ public: virtual void split()=0; virtual ~ISplitter(){} }; class BinarySplitter : public ISplitter{ }; class TxtSplitter: public ISplitter{ }; class PictureSplitter: public ISplitter{ }; class VideoSplitter: public ISplitter{ }; class MainForm : public Form { TextBox* txtFilePath; TextBox* txtFileNumber; ProgressBar* progressBar; public: void Button1_Click(){ ISplitter * splitter= new BinarySplitter();//依赖具体类 splitter-\u003esplit(); } }; ","date":"2023-07-28","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"重构代码 #include \u003ciostream\u003e #include \u003cmemory\u003e // 引入智能指针 // 为了让代码能编译，定义一个空的 Form 类 class Form {}; // ================================================================= // 1. 抽象产品 (Abstract Product) // 定义了工厂方法所创建的对象的接口。 // ================================================================= class ISplitter { public: virtual void split() = 0; virtual ~ISplitter() { std::cout \u003c\u003c \"ISplitter destructor called.\" \u003c\u003c std::endl; } }; // ================================================================= // 2. 具体产品 (Concrete Products) // 实现了 ISplitter 接口。 // ================================================================= class BinarySplitter : public ISplitter { public: void split() override { std::cout \u003c\u003c \"Splitting a BINARY file...\" \u003c\u003c std::endl; } }; class TxtSplitter : public ISplitter { public: void split() override { std::cout \u003c\u003c \"Splitting a TXT file...\" \u003c\u003c std::endl; } }; class PictureSplitter : public ISplitter { public: void split() override { std::cout \u003c\u003c \"Splitting a PICTURE file...\" \u003c\u003c std::endl; } }; class VideoSplitter : public ISplitter { public: void split() override { std::cout \u003c\u003c \"Splitting a VIDEO file...\" \u003c\u003c std::endl; } }; // ================================================================= // 3. 抽象工厂 (Abstract Factory / Creator) // 声明了工厂方法，该方法返回一个 ISplitter 类型的对象。 // ================================================================= class SplitterFactory { public: virtual ISplitter* CreateSplitter() = 0; // 这就是“工厂方法” virtual ~SplitterFactory() {} }; // ================================================================= // 4. 具体工厂 (Concrete Factories / Concrete Creators) // 重写工厂方法以返回一个具体产品的实例。 // ================================================================= class BinarySplitterFactory : public SplitterFactory { public: ISplitter* CreateSplitter() override { return new BinarySplitter(); } }; class TxtSplitterFactory : public SplitterFactory { public: ISplitter* CreateSplitter() override { return new TxtSplitter(); } }; class PictureSplitterFactory : public SplitterFactory { public: ISplitter* CreateSplitter() override { return new PictureSplitter(); } }; class VideoSplitterFactory : public SplitterFactory { public: ISplitter* CreateSplitter() override { return new VideoSplitter(); } }; // ================================================================= // 5. 客户端 (Client) // 客户端代码仅依赖于抽象接口（ISplitter 和 SplitterFactory）。 // ================================================================= class MainForm : public Form { private: SplitterFactory* factory; // 持有一个工厂的引用 public: // 通过构造函数注入具体的工厂实例 MainForm(SplitterFactory* fact) : factory(fact) {} void Button1_Click() { if (!factory) { std::cout \u003c\u003c \"Error: Factory is not set!\" \u003c\u003c std::endl; return; } // 多态创建：具体创建哪个 Splitter 由 factory 的类型决定 ISplitter* splitter = factory-\u003eCreateSplitter(); splitter-\u003esplit(); // 重要：必须手动释放内存，否则会造成内存泄漏！ delete splitter; splitter = nullptr; } }; // ================================================================= // 示例用法 // ================================================================= void RunExample() { // 场景1：主窗口需要处理文本文件 SplitterFactory* txtFactory = new TxtSplitterFactory(); MainForm txtMainForm(txtFactory); std::cout \u003c\u003c \"--- Text Form Simulation ---\" \u003c\u003c std::endl; txtMainForm.Button1_Click(); delete txtFactory; // 清理工厂 std::cout \u003c\u003c \"\\n----------------------------\\n\" \u003c\u003c std::endl; // 场景2：主窗口需要处理视频文件 SplitterFactory* videoFactory = new VideoSplitterFactory(); MainForm videoMainForm(videoFactory); std::cout \u003c\u003c \"--- Video Form Simulation ---\" \u003c\u003c std::endl; videoMainForm.Button1_Click(); delete videoFactory; // 清理工厂 } int main() { RunExample(); return 0; } ","date":"2023-07-28","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 定义一个用于创建对象的接口，让子类决定实例化哪一个类 Factory Method使得一个类的实例化延迟*(目的: 解藕，手段: 虚函数)*到子类 ","date":"2023-07-28","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-28","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:6:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Factory Method模式用于隔离类对象的使用者和具体类型之间的耦合关系，面对一个经常变化的具体类型,紧耦合关系(new)会导致软件的脆弱 Factor Method模式通过面向对象的手法,将所要创建的具体对象工作延迟到子类,从而实现一种扩展(并非更改)的策略，较好的解决了这种紧耦合关系 Factor Method模式解决\"单个对象\"的需求变化. 缺点在于要求创建方法/参数相同 ","date":"2023-07-28","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:7:0","tags":["工厂模式"],"title":"工厂模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-桥模式","date":"2023-07-27","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单一职责模式 什么是单一职责 在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充满着重复代码 这时候最关键是划清责任，每个类引起他变化的原因只有一个 典型模式 Decorator Bridge ","date":"2023-07-27","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用桥模式动机 由于某些类型的固有的实现逻辑 使得它们具有两个变化的维度 乃至多个维度的变化 如何应对这种\"多维度的变化\" 如何利用面向对象技术来使得类型可以轻松的沿着两个乃至多个方向变化 而不引入额外的复杂度 ","date":"2023-07-27","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"初始代码 代码演示 #include \u003ciostream\u003e #include \u003cstring\u003e // 为了让代码能编译，定义一个空的 Image 类 class Image {}; // ================================================================= // 1. 统一的抽象基类 // 这个基类混合了“业务逻辑”和“平台实现”的接口。 // ================================================================= class Messager { public: // 业务逻辑接口 virtual void Login(std::string username, std::string password) = 0; virtual void SendMessage(std::string message) = 0; virtual void SendPicture(Image image) = 0; // 平台实现接口 virtual void PlaySound() = 0; virtual void DrawShape() = 0; virtual void WriteText() = 0; virtual void Connect() = 0; virtual ~Messager() {} }; // ================================================================= // 2. 平台实现层 (n个平台) // 每个平台都从基类继承，并实现平台相关的部分。 // 但它们必须将业务逻辑接口保留为纯虚函数，留给下一层实现。 // ================================================================= // 平台实现 A: PC 平台 class PCMessagerBase : public Messager { public: // 实现平台相关功能 void PlaySound() override { std::cout \u003c\u003c \"[PC] Playing sound...\" \u003c\u003c std::endl; } void DrawShape() override { std::cout \u003c\u003c \"[PC] Drawing shape...\" \u003c\u003c std::endl; } void WriteText() override { std::cout \u003c\u003c \"[PC] Writing text...\" \u003c\u003c std::endl; } void Connect() override { std::cout \u003c\u003c \"[PC] Connecting...\" \u003c\u003c std::endl; } }; // 平台实现 B: 移动端平台 class MobileMessagerBase : public Messager { public: // 实现平台相关功能 void PlaySound() override { std::cout \u003c\u003c \"[Mobile] Playing sound...\" \u003c\u003c std::endl; } void DrawShape() override { std::cout \u003c\u003c \"[Mobile] Drawing shape...\" \u003c\u003c std::endl; } void WriteText() override { std::cout \u003c\u003c \"[Mobile] Writing text...\" \u003c\u003c std::endl; } void Connect() override { std::cout \u003c\u003c \"[Mobile] Connecting...\" \u003c\u003c std::endl; } }; // ================================================================= // 3. 业务逻辑层 (m * n 个具体类) // 这一层将业务逻辑和平台实现“固化”在一起。 // 每增加一个业务需求，就需要为每个平台都创建一个新类。 // 每增加一个新平台，就需要为每个业务需求都创建一个新类。 // ================================================================= // --- PC 平台的业务实现 --- class PCMessagerLite : public PCMessagerBase { public: void Login(std::string username, std::string password) override { std::cout \u003c\u003c \"--- PC Lite Login ---\" \u003c\u003c std::endl; PCMessagerBase::Connect(); // 直接调用基类的实现 } void SendMessage(std::string message) override { std::cout \u003c\u003c \"--- PC Lite SendMessage ---\" \u003c\u003c std::endl; PCMessagerBase::WriteText(); } void SendPicture(Image image) override { std::cout \u003c\u003c \"--- PC Lite SendPicture ---\" \u003c\u003c std::endl; PCMessagerBase::DrawShape(); } }; class PCMessagerPerfect : public PCMessagerBase { public: void Login(std::string username, std::string password) override { std::cout \u003c\u003c \"--- PC Perfect Login ---\" \u003c\u003c std::endl; PCMessagerBase::PlaySound(); PCMessagerBase::Connect(); } void SendMessage(std::string message) override { std::cout \u003c\u003c \"--- PC Perfect SendMessage ---\" \u003c\u003c std::endl; PCMessagerBase::PlaySound(); PCMessagerBase::WriteText(); } void SendPicture(Image image) override { std::cout \u003c\u003c \"--- PC Perfect SendPicture ---\" \u003c\u003c std::endl; PCMessagerBase::PlaySound(); PCMessagerBase::DrawShape(); } }; // --- 移动端平台的业务实现 --- class MobileMessagerLite : public MobileMessagerBase { public: void Login(std::string username, std::string password) override { std::cout \u003c\u003c \"--- Mobile Lite Login ---\" \u003c\u003c std::endl; MobileMessagerBase::Connect(); } void SendMessage(std::string message) override { std::cout \u003c\u003c \"--- Mobile Lite SendMessage ---\" \u003c\u003c std::endl; MobileMessagerBase::WriteText(); } void SendPicture(Image image) override { std::cout \u003c\u003c \"--- Mobile Lite SendPicture ---\" \u003c\u003c std::endl; MobileMessagerBase::DrawShape(); } }; class MobileMessagerPerfect : public MobileMessagerBase { public: void Login(std::string username, std::string password) override { std::cout \u003c\u003c \"--- Mobile Perfect Login ---\" \u003c\u003c std::endl; MobileMessagerBase::PlaySound(); MobileMessagerBase::Connect(); } void SendMessage(std::string message) override { std::cout \u003c\u003c \"--- Mobile Perfect SendMessage ---\" \u003c\u003c std::endl; MobileMessagerBase::PlaySound(); MobileMessagerBase::WriteText(); } void SendPicture(Image image) override { std::cout \u003c\u003c \"--- Mo","date":"2023-07-27","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"利用 组合 重构代码 代码示例 // 为了让代码能编译，定义一个空的 Image 类 class Image {}; // ================================================================= // 1. 实现部分 (Implementor) - 定义了实现类的接口 // 这部分关注的是“平台”或“底层”的功能。 // ================================================================= class MessagerImp { public: virtual void PlaySound() = 0; virtual void DrawShape() = 0; virtual void WriteText() = 0; virtual void Connect() = 0; virtual ~MessagerImp() {} }; // ================================================================= // 2. 具体实现 (Concrete Implementors) - n个平台实现 // 这里是平台相关的具体代码。 // ================================================================= // 平台实现 A: PC 平台 class PCMessagerImp : public MessagerImp { public: void PlaySound() override { std::cout \u003c\u003c \"[PC] Playing sound...\" \u003c\u003c std::endl; } void DrawShape() override { std::cout \u003c\u003c \"[PC] Drawing shape...\" \u003c\u003c std::endl; } void WriteText() override { std::cout \u003c\u003c \"[PC] Writing text...\" \u003c\u003c std::endl; } void Connect() override { std::cout \u003c\u003c \"[PC] Connecting...\" \u003c\u003c std::endl; } }; // 平台实现 B: 移动端平台 class MobileMessagerImp : public MessagerImp { public: void PlaySound() override { std::cout \u003c\u003c \"[Mobile] Playing sound...\" \u003c\u003c std::endl; } void DrawShape() override { std::cout \u003c\u003c \"[Mobile] Drawing shape...\" \u003c\u003c std::endl; } void WriteText() override { std::cout \u003c\u003c \"[Mobile] Writing text...\" \u003c\u003c std::endl; } void Connect() override { std::cout \u003c\u003c \"[Mobile] Connecting...\" \u003c\u003c std::endl; } }; // ================================================================= // 3. 抽象部分 (Abstraction) - 定义了业务逻辑的高层接口 // 它包含一个指向“实现部分”对象的指针。 // ================================================================= class Messager { protected: MessagerImp* messagerImp; // 持有一个实现部分的引用 public: // 构造函数，用于“桥接”实现 Messager(MessagerImp* imp) : messagerImp(imp) {} virtual void Login(std::string username, std::string password) = 0; virtual void SendMessage(std::string message) = 0; virtual void SendPicture(Image image) = 0; virtual ~Messager() {} }; // ================================================================= // 4. 扩展抽象 (Refined Abstractions) - m个业务逻辑实现 // 这里是业务需求相关的具体代码。 // ================================================================= // 业务抽象 A: 简洁版 Messager class MessagerLite : public Messager { public: // 继承构造函数 MessagerLite(MessagerImp* imp) : Messager(imp) {} void Login(std::string username, std::string password) override { std::cout \u003c\u003c \"--- MessagerLite Login ---\" \u003c\u003c std::endl; messagerImp-\u003eConnect(); // ... 其他登录逻辑 ... } void SendMessage(std::string message) override { std::cout \u003c\u003c \"--- MessagerLite SendMessage ---\" \u003c\u003c std::endl; messagerImp-\u003eWriteText(); // ... 其他发送消息逻辑 ... } void SendPicture(Image image) override { std::cout \u003c\u003c \"--- MessagerLite SendPicture ---\" \u003c\u003c std::endl; messagerImp-\u003eDrawShape(); // ... 其他发送图片逻辑 ... } }; // 业务抽象 B: 完美版 Messager class MessagerPerfect : public Messager { public: // 继承构造函数 MessagerPerfect(MessagerImp* imp) : Messager(imp) {} void Login(std::string username, std::string password) override { std::cout \u003c\u003c \"--- MessagerPerfect Login ---\" \u003c\u003c std::endl; messagerImp-\u003ePlaySound(); messagerImp-\u003eConnect(); // ... 其他登录逻辑 ... } void SendMessage(std::string message) override { std::cout \u003c\u003c \"--- MessagerPerfect SendMessage ---\" \u003c\u003c std::endl; messagerImp-\u003ePlaySound(); messagerImp-\u003eWriteText(); // ... 其他发送消息逻辑 ... } void SendPicture(Image image) override { std::cout \u003c\u003c \"--- MessagerPerfect SendPicture ---\" \u003c\u003c std::endl; messagerImp-\u003ePlaySound(); messagerImp-\u003eDrawShape(); // ... 其他发送图片逻辑 ... } }; // ================================================================= // 客户端代码 (Client) // ================================================================= void Process() { // 运行时装配：可以自由组合“业务”和“平台” // 组合1：在PC上运行简洁版 std::cout \u003c\u003c \"\u003e\u003e\u003e Running Lite version on PC \u003c\u003c\u003c\" \u003c\u003c std::endl; MessagerImp* pcImp = new PCMessagerImp(); Messager* m1 = new MessagerLite(pcImp); // 使用 MessagerLite 进行实例化 m1-\u003eLogin(\"user\", \"pass\"); m1-\u003eSendMessage(\"Hello!\"); std::cout \u003c\u003c std::endl; // 组合2：在移动端上运行完美版 std::cout \u003c\u003c \"\u003e\u003e\u003e Running Perfect version","date":"2023-07-27","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 将抽象部分(业务功能)与实现部分(平台实现)分离，使他们都可以独立的变化 ","date":"2023-07-27","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-27","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们 Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。 Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。 ","date":"2023-07-27","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/:7:0","tags":["桥模式"],"title":"桥模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-装饰模式","date":"2023-07-26","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"单一职责模式 什么是单一职责 在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充满着重复代码 这时候最关键是划清责任，每个类引起他变化的原因只有一个 典型模式 Decorator Bridge ","date":"2023-07-26","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:1:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用装饰模式动机 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性； 并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？ ","date":"2023-07-26","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:2:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"初始代码 类图 代码演示 //业务操作 class Stream{ public： virtual char Read(int number)=0; virtual void Seek(int position)=0; virtual void Write(char data)=0; virtual ~Stream(){} }; //主体类 class FileStream: public Stream{ public: virtual char Read(int number){ //读文件流 } virtual void Seek(int position){ //定位文件流 } virtual void Write(char data){ //写文件流 } }; class NetworkStream :public Stream{ public: virtual char Read(int number){ //读网络流 } virtual void Seek(int position){ //定位网络流 } virtual void Write(char data){ //写网络流 } }; class MemoryStream :public Stream{ public: virtual char Read(int number){ //读内存流 } virtual void Seek(int position){ //定位内存流 } virtual void Write(char data){ //写内存流 } }; //扩展操作 class CryptoFileStream :public FileStream{ public: virtual char Read(int number){ //额外的加密操作... FileStream::Read(number);//读文件流 } virtual void Seek(int position){ //额外的加密操作... FileStream::Seek(position);//定位文件流 //额外的加密操作... } virtual void Write(byte data){ //额外的加密操作... FileStream::Write(data);//写文件流 //额外的加密操作... } }; class CryptoNetworkStream : :public NetworkStream{ public: virtual char Read(int number){ //额外的加密操作... NetworkStream::Read(number);//读网络流 } virtual void Seek(int position){ //额外的加密操作... NetworkStream::Seek(position);//定位网络流 //额外的加密操作... } virtual void Write(byte data){ //额外的加密操作... NetworkStream::Write(data);//写网络流 //额外的加密操作... } }; class CryptoMemoryStream : public MemoryStream{ public: virtual char Read(int number){ //额外的加密操作... MemoryStream::Read(number);//读内存流 } virtual void Seek(int position){ //额外的加密操作... MemoryStream::Seek(position);//定位内存流 //额外的加密操作... } virtual void Write(byte data){ //额外的加密操作... MemoryStream::Write(data);//写内存流 //额外的加密操作... } }; class BufferedFileStream : public FileStream{ //... }; class BufferedNetworkStream : public NetworkStream{ //... }; class BufferedMemoryStream : public MemoryStream{ //... } class CryptoBufferedFileStream :public FileStream{ public: virtual char Read(int number){ //额外的加密操作... //额外的缓冲操作... FileStream::Read(number); //读文件流 } virtual void Seek(int position){ //额外的加密操作... //额外的缓冲操作... FileStream::Seek(position); //定位文件流 //额外的加密操作... //额外的缓冲操作... } virtual void Write(byte data){ //额外的加密操作... //额外的缓冲操作... FileStream::Write(data); //写文件流 //额外的加密操作... //额外的缓冲操作... } }; void Process(){ //编译时装配 CryptoFileStream *fs1 = new CryptoFileStream(); BufferedFileStream *fs2 = new BufferedFileStream(); CryptoBufferedFileStream *fs3 =new CryptoBufferedFileStream(); } ","date":"2023-07-26","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:3:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"利用 组合 重构代码 类图 代码示例 //业务操作 class Stream{ public: virtual char Read(int number)=0; virtual void Seek(int position)=0; virtual void Write(char data)=0; virtual ~Stream(){} }; //主体类 class FileStream: public Stream{ public: virtual char Read(int number){ //读文件流 } virtual void Seek(int position){ //定位文件流 } virtual void Write(char data){ //写文件流 } }; class NetworkStream :public Stream{ public: virtual char Read(int number){ //读网络流 } virtual void Seek(int position){ //定位网络流 } virtual void Write(char data){ //写网络流 } }; class MemoryStream :public Stream{ public: virtual char Read(int number){ //读内存流 } virtual void Seek(int position){ //定位内存流 } virtual void Write(char data){ //写内存流 } }; //扩展操作 class DecoratorStream: public Stream{ protected: Stream* stream;//... DecoratorStream(Stream * stm):stream(stm){ } }; class CryptoStream: public DecoratorStream { Stream* stream;//... public: CryptoStream(Stream* stm):DecoratorStream(stm){ } virtual char Read(int number){ //额外的加密操作... stream-\u003eRead(number);//读文件流 } virtual void Seek(int position){ //额外的加密操作... stream::Seek(position);//定位文件流 //额外的加密操作... } virtual void Write(byte data){ //额外的加密操作... stream::Write(data);//写文件流 //额外的加密操作... } }; class BufferedStream : public DecoratorStream{ Stream* stream;//... public: BufferedStream(Stream* stm):DecoratorStream(stm){ } //... }; void Process(){ //运行时装配 FileStream* s1=new FileStream(); CryptoStream* s2=new CryptoStream(s1); BufferedStream* s3=new BufferedStream(s1); BufferedStream* s4=new BufferedStream(s2); } ","date":"2023-07-26","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:4:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 \u0026 减少子类个数） ","date":"2023-07-26","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:5:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。 Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类 Decorator模式的目的并非解决“多子类衍生的多继承”问题， Decorator模式应用的要点在于解决“主体类在多个方向上的扩展 功能”——是为“装饰”的含义 其实能看到一个类 继承又组合了自己父类 绝大多数就是 装饰模式 ","date":"2023-07-26","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/:6:0","tags":["装饰模式"],"title":"装饰模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-观察者模式","date":"2023-07-25","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"组件协作模式 什么是组件协作模式 现代软件专业分工之后的第一个结果就是 框架与应用程序的划分 组件协作 模式通过晚绑定，来实现框架和应用之间的松耦合，是二者之间协作时常用的模式 典型模式 Template Method Observer / Event Strategy ","date":"2023-07-25","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 定义对象间的一种一对多(变化)的依赖关系 以便当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并自动更新 ","date":"2023-07-25","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 使用面向对象的抽象思想，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合 目标发送通知时，无需指定观察者，通知（可以携带通知信息作 为参数）会自动传播 观察者自己决定是否需要订阅通知，目标对象对此一无所知 Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。 ","date":"2023-07-25","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"具体代码先不展出 回头会补 想法是直接使用行为树的例子 ","date":"2023-07-25","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-策略模式","date":"2023-07-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"组件协作模式 什么是组件协作模式 现代软件专业分工之后的第一个结果就是 框架与应用程序的划分 组件协作 模式通过晚绑定，来实现框架和应用之间的松耦合，是二者之间协作时常用的模式 典型模式 Template Method Observer / Event Strategy ","date":"2023-07-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"使用策略模式的动机 在软件构建的过程中，某些对象使用的算法可能多种多样的，经常改变，如果将这种算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担 如何在运行时根据需要透明的更改对象的算法? 将算法与对象本身解藕 从而避免上述问题 ","date":"2023-07-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"静态代码 场景 每个国家税不同 所以要根据税去计算 演示代码及代码思路 这里的思路 就是 直接用一个枚举 记录各个国家的税 然后 根据不同的税 进行 if else if 计算，这里带来的需求变化 也是麻烦的 如果要加一个法国的税 就得新加else if 巨麻烦 这个就违反了 开放封闭 面向对象设计原则 支持扩展 拒绝更改，这样代码就会变成静态思路 这时候 我们扩展一下思路 加个\"时间轴\" 变成动态的 enum TaxBase { CN_Tax, US_Tax, DE_Tax }; class SalesOrder { TaxBase tax; public: double CalculateTax() { if (tax == CN_Tax) { // CN.... } else if (tax == US_Tax) { // US... } else if (tax == DE_Tax) { // DE... } //... } } ","date":"2023-07-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"动态代码 场景 每个国家税不同 所以要根据税去计算 演示代码及思路 在下述代码中，如果我们要增加一个法国的税，只需要写一个法国的子类，这样就是扩展，而不是更改了枚举，还有增加了if else 当然你其实会有这样的疑问，在静态代码的思路，if else 的代码不是也没有动，就只是加了一个 else if 这不也是复用扩展嘛 这肯定不叫复用，复用是编译级别，编译之后，部署之后，原封不动，而且你想的太美好，在大量的else中，很有可能也要改变前面的思路，从而引发bug ","date":"2023-07-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 定义一系列算法 把他们一个个封装起来 并且使他们可互相替换(变化) 该算法使得算法可独立于使用他的客户程序(稳定)而变化(扩展，子类化) ","date":"2023-07-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"类图 ","date":"2023-07-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"要点总结 Strategy及其子类为组件提供了一系列可重用的算法 从而可以使得类型在运行时方便的根据需要在各个算法之间进行切换 Strategy模式提供了在条件判断语句以外的另一种选择 消除条件判断语句 就是在解耦合 含有许多条件判断语句的代码通常都需要策略模式 如果Strategy对象没有实例变量， 那么各个上下文可以共享一个Strategy对象 从而节省对象开销 额外的解释 运行时 这个词 就是代码中多态调用的时候 其实 if else if 和 switch case 就是 分解 这个思路，我们将各种具体的计算税的算法抽象成了算法类，这个就是抽象的概念 不是所有的 if else策略模式就适用 在 if else绝对不变的情况下就可以用 if else 比如一周有7天的情况下 不能多出第八天 所以就可以用if else ","date":"2023-07-24","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/:7:0","tags":["策略模式"],"title":"策略模式","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"设计模式-模板方法","date":"2023-07-23","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"组件协作模式 什么是组件协作模式 现代软件专业分工之后的第一个结果就是 框架与应用程序的划分 组件协作 模式通过晚绑定，来实现框架和应用之间的松耦合，是二者之间协作时常用的模式 典型模式 Template Method Observer / Event Strategy ","date":"2023-07-23","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:1:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"使用模板方法的动机 在软件构建的过程中，对于某一项任务，他尝尝有稳定的整体操作结构，但是各个子步骤却有很多改变的需求，或者由于固有原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现 那么如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求 ","date":"2023-07-23","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:2:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"早绑定代码 什么是早绑定 早绑定代码演示 程序库开发人员 为了实现一个库 写了三个步骤 class Library{ public: void Step1(){ //... } void Step3(){ //... } void Step5(){ //... } }; app开发人员也要做步骤 并且还要写出一个步骤走的流程 class Application{ public: bool Step2(){ //... } void Step4(){ //... } }; int main() { Library lib(); Application app(); lib.Step1(); if (app.Step2()){ lib.Step3(); } for (int i = 0; i \u003c 4; i++){ app.Step4(); } lib.Step5(); } ","date":"2023-07-23","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:3:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"晚绑定代码 什么是晚绑定 晚绑定演示代码 程序库开发人员在开发的时候直接把主流程写好 调用每一步流程，把应用程序开发人员要开发的步骤定义成虚函数 class Library{ public: // 稳定 template method void Run() { Step1(); if (Step2()) Step3; // 支持变化 --\u003e 虚函数的多态调用 for (int i = 0; i \u003c 4; i++) Step4(); // 支持变化 --\u003e 虚函数的多态调用 Step5(); } virtual ~Library() { } protected: void Step1() { ... } void Step3() { ... } void Step5() { ... } virtual bool Step2() = 0; //变化 virtual void Step4() = 0; //变化 }; 应用程序开发人员只需要子类重写就即可 class Application : public Library { protected: virrual bool Step2() { // 子类重写实现 } virtual void Step4() { // 子类重写实现 } }; int main() { Library* pLib = new Application; lib-\u003eRun(); delete pLib; } ","date":"2023-07-23","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:4:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"模式定义 定义一个操作中的算法骨架（稳定） —–\u003e 也就是上面晚绑定代码，先把流程写出来 讲一些步骤延迟（变化）到子类中 —–\u003e 也就是上面晚绑定代码，子类去实现 “2” “4” 两个方法 Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤 ","date":"2023-07-23","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:5:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"再次强调的点 如果一个骨架不稳定(代码中) 那么这个模版方法就不适用 如果夸张一点 都不稳定 那没有任何一种设计模式适合 设计模式就是需要一个稳定点 如果反过来也是一样的道理，如果一个代码都是稳定的，那设计模式都不用存在的 所以，别闲的胃疼了，这两种极端都是不存在的，但是从这可以看出来，我们一定要分出哪些是稳定的 那些是变化的 ","date":"2023-07-23","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:6:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"要点总结 Template Method模式是一种非常基础性的设计模式, 在面向对象系统中有着大量的应用，他用最简洁的机制（虚函数的多态），为很多应用程序框架提供了灵活的扩展点 Template Method模式除了可以灵活应对子步骤的变化外，他也实现了早绑定 -\u003e 晚绑定的这一思路，也就是不要调用我，让我来调用你，反向控制结构是模版方法的典型应用 在具体实现方面，被模板方法调用的虚函数可以实现，也可以没有任何实现，可以把他们设置为protected方法 ","date":"2023-07-23","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/:7:0","tags":["模板方法"],"title":"模板方法","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"categories":["设计模式"],"content":"设计模式-分类","date":"2023-07-22","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"模式分类 ","date":"2023-07-22","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:1:0","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"从目的来看 创建型模式 将对象的部分创建工作延后到子类或者其他对象，从而应对需求变化为对象创建时带来的冲击 结构型模式 通过类继承或者对象组合获得灵活的结构，从而应对需求变化为对象的结构带来冲击 行为型模式 通过类继承或者对象组合来划分类与对象间的职责，从而应对需求变化为多个交互的对象带来的冲击 ","date":"2023-07-22","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:1:1","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"从范围来看 类模式处理类与子类的静态关系 对象模式处理对象间的动态关系 ","date":"2023-07-22","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:1:2","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"从封装变化角度来看 组件协作 Template Method Observer / Event Strategy 单一职责 Decorator Bridge 对象创建 Factory Method Abstract Factory Prototype Builder 对象性能 Singleton Flyweight 接口隔离 Façade Proxy Mediator Adapter 状态变化 Memento State 数据结构 Composite Iterator Chain of Resposibility 行为变化 Command Visitor 领域问题 Interpreter ","date":"2023-07-22","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:1:3","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"重构获得模式 ","date":"2023-07-22","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:2:0","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"重构获得模式 怎么去看待设计模式 面向对象模式是 “好的面向对象设计”，所谓好的面向对象设计就是指那些可以满足 应对变化，提高复用性 现代软件设计的特征就是 需求的频繁变化，所以设计模式重点在于 寻求变化点，然后在变化点应用设计模式，从而来更好的应对需求的变化 所以说，什么时候，什么地点应用设计模式比理解设计模式结构本身更为重要!!! 同时，设计模式的应用不宜先入为主，一上来就是用设计模式，这是最大的错误，而且也没有一步到位的设计模式让你去使用 重构与模式 很重要!!! 还有脚踏实地!!! ","date":"2023-07-22","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:2:1","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"重构关键方法 静态 -\u003e 动态 早绑定 -\u003e 晚绑定 继承 -\u003e 组合 编译时依赖 -\u003e 运行时依赖 紧耦合 -\u003e 松耦合 ","date":"2023-07-22","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/:2:2","tags":["分类"],"title":"分类","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB/"},{"categories":["设计模式"],"content":"设计模式-简介","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"设计模式 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:1:0","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"设计模式 什么是设计模式 每一个模式描述了一个在我们周围不断重复发生的问题以及该问题的解决方案的核心，这样你就能一次又一次的使用该方案而不必重复劳动 设计模式有可以说是 可复用面向对象软件的基础 重点在于 可复用 面向对象 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:1:1","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"如何解决复杂性 分解 分而治之，将大问题分成多个小问题，将复杂问题分成多个简单问题 这个在算法是一个最重要的核心思路，但是在设计模式，只能说可以用，但是不够用!!! 抽象 由于不能掌握全部的复杂对象，我们选择忽视他的非本质问题，而去处理泛化和理想化的对象模型 这个就是设计模式的核心思路 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:1:2","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"面向对象 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:2:0","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"面向对象设计 变化是复用的天敌，而面向对象设计就是抵御变化！！！ ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:2:1","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"重新认识面向对象 理解隔离变化 从宏观层面来看，面向对象的构建方式更能适应软件变化，能将变化所带来的影响度减为最小 从微观层面来看，面向对象的方式更强调每个类的责任，由于需求变化导致的新增类型不应该影响原来类型的实现 对象是什么 从语言实现层面来看，对象封装了代码和数据 从规格层面讲，对象是一系列可被使用的公共接口 从概念层面讲，对象是某种拥有责任的抽象 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:2:2","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["设计模式"],"content":"面向对象设计原则 依赖倒置原则 高层模块（稳定）不应该依赖于底层模块（变化），二者应该依赖于抽象（稳定） 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象 开放封闭原则 对扩展开放，对更改封闭，类模块应该是可扩展的，并且不能修改 单一职责原则 每个类引起他变化的原因只准一个，不能是多个 要多用组合，而不是多用继承 继承会造成子类的数目和功能急剧膨胀，所以要多用组合 封装变化 将变化点封装起来，不要去影响稳定点 替换原则 子类应该去重写父类方法，而不是去隐藏父类方法 接口隔离原则 接口应该小而完备，不应该强迫客户程序依赖他们不用的方法 针对接口编程，而不是针对实现编程 不将变量类型声明为某个特定的具体类，而是抽象出来声明为某个接口 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口 减少系统中各部分的依赖关系，从而实现 “高内聚， 松耦合” 的类型设计 ","date":"2023-07-21","objectID":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/:2:3","tags":["设计模式"],"title":"简介","uri":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E5%BF%B5/"},{"categories":["nvim"],"content":"配置nvim ","date":"2023-03-29","objectID":"/nvim/:0:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"centos7 这里说明 这里只配置了 ccls 因为golang的编译特性 其实什么平台写go都一样 /* 更新yum库 yum update centos7 python 默认为 3.6.8 升级为 3.8.11 yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make yum -y install epel-release yum -y install zlib zlib yum -y install zlib zlib-devel wget http://npm.taobao.org/mirrors/python/3.8.12/Python-3.8.12.tar.xz xz -d Python-3.8.12.tar.xz tar -xf Python-3.8.12.tar cd Python-3.8.12 ./configure prefix=/usr/local/python3 make \u0026\u0026 make install mv /usr/bin/python /usr/bin/python.bak ln -s /usr/local/python3/bin/python3.8 /usr/bin/python python --version vi /usr/bin/yum 把#! /usr/bin/python修改为#! /usr/bin/python2 vi /usr/libexec/urlgrabber-ext-down 把#! /usr/bin/python 修改为#! /usr/bin/python2 为何这样配是因为yum需要使用python2才能正常运行,而之前的python指向python3 ,版本不对应,所以将其改成python2 cd /usr/bin ll pip* rm pip3 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 pip3 install -U setuptools (有啥问题 可以看看 别人博客 https://www.cnblogs.com/yahoon/p/16172517.html) 下载nodejs curl -sL install-node.now.sh/lts | bash 下载nvim curl -o /usr/local/bin/nvim -LO https://github.com/neovim/neovim/releases/download/stable/nvim.appimage chmod u+x /usr/local/bin/nvim cp /usr/local/bin/nvim /usr/bin/nvim 安装插件管理器 使用新的 vim-plug sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' 创建初始化 neovim 配置文件 mkdir ~/.config/nvim/ nvim ~/.config/nvim/init.vim 下载 nodejs \u0026 npm wget https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz tar -xvf node-v16.15.1-linux-x64.tar.xz coc插件 需要的步骤 npm install neovim pip3 install neovim 下载 ccls sudo yum install epel-release sudo yum install snapd sudo systemctl enable --now snapd.socket sudo ln -s /var/lib/snapd/snap /snap sudo snap install ccls --classic vim ~/.bash_profile export PATH=\"$PATH:/snap/bin/\" 安装wget(如果没有wget) yum -y install gcc make gcc-c++ openssl-devel wget 使用 clash vpn 防止nvim下载插件失败 wget -c https://github.com/Dreamacro/clash/releases/download/v1.11.8/clash-linux-amd64-v1.11.8.gz gzip -d ./clash-linux-armv6-v1.10.6.gz chmod u+x ./clash-linux-armv6-v1.10.6.gz 处理 配置文件 wget -O config.yaml \u003c配置文件的url\u003e 启动clash ./clash-linux-armv6-v1.10.6.gz 启动 http 代理 export http_proxy=http://127.0.0.1:7890 export https_proxy=http://127.0.0.1:7890 验证是否ok curl https://www.google.com.hk/ 下载插件 nvim ~/.config/nvim/init.vim :PlugInstall 检查健康 :checkhealth 修复err 一般都会是coc出现问题 如果是 build/index.js cd ~/.vim/plugged/coc.nvim git checkout release */ ","date":"2023-03-29","objectID":"/nvim/:1:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"Mac /* mac 自带的python是 3.8 版本 可以跳过 安装nvim brew install neovim 安装vim-plug sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' 如果 443 可以通过 /ect/hosts 解决 具体的可以百度 创建初始化 neovim 配置文件 mkdir ~/.config/nvim/ nvim ~/.config/nvim/init.vim 下载node.js brew install nodejs coc插件 需要的步骤 npm install neovim pip3 install neovim brew install ccls 下载插件 nvim ~/.config/nvim/init.vim :PlugInstall 如果timeout请开启 vpn 并配置gitconfig 检查健康 :checkhealth 解决 checkhealth 错误后 nvim test.go :GoInstallB... 然后如果不行就重新启动命令行 随后即可 */ ","date":"2023-03-29","objectID":"/nvim/:2:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"Windows // 未完待续 ","date":"2023-03-29","objectID":"/nvim/:3:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"clash配置文件功能详解 # HTTP 代理端口 port: 7890 # SOCKS5 代理端口 socks-port: 7891 # Linux 和 macOS 的 redir 代理端口 redir-port: 7892 # 允许局域网的连接 allow-lan: true # 规则模式：Rule（规则） / Global（全局代理）/ Direct（全局直连） mode: rule # 设置日志输出级别 (默认级别：silent，即不输出任何内容，以避免因日志内容过大而导致程序内存溢出）。 # 5 个级别：silent / info / warning / error / debug。级别越高日志输出量越大，越倾向于调试，若需要请自行开启。 log-level: silent # Clash 的 RESTful API external-controller: '0.0.0.0:9090' # RESTful API 的口令 secret: '' # 您可以将静态网页资源（如 clash-dashboard）放置在一个目录中，clash 将会服务于 `RESTful API/ui` # 参数应填写配置目录的相对路径或绝对路径。 # external-ui: folder ","date":"2023-03-29","objectID":"/nvim/:4:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"Init.vim \" ==================== Editor behavior ==================== \" http://blog.guorongfei.com/2015/09/03/vim-shortcut/ set nu syntax on set foldmethod=marker set tabstop=2 set shiftwidth=2 set softtabstop=2 set showmode set showcmd set mouse=a set encoding=utf-8 set t_Co=256 set autoindent set cursorline set linebreak set showmatch set hlsearch set incsearch \"设置vim可以使用back键\" set backspace=2 nnoremap \u003cC-l\u003e :tabn\u003cCR\u003e \"移动到下一个标签\" nnoremap \u003cC-h\u003e :tabp\u003cCR\u003e \"移动到上一个标签\" au BufReadPost * if line(\"'\\\"\") \u003e 1 \u0026\u0026 line(\"'\\\"\") \u003c= line(\"$\") | exe \"normal! g'\\\"\" | endif inoremap ' ''\u003cESC\u003ei inoremap \" \"\"\u003cESC\u003ei inoremap ( ()\u003cESC\u003ei inoremap [ []\u003cESC\u003ei inoremap { {}\u003cESC\u003ei \"设置跳出自动补全的括号 func SkipPair() if getline('.')[col('.') - 1] == '\u003c' || getline('.')[col('.') - 1] == ')' || getline('.')[col('.') - 1 ] == ']' || getline('.')[col('.') - 1] == '\"' || getline('.')[col('.') - 1] == \"'\" || getline('.')[col('.' ) - 1] == '}' return \"\\\u003cESC\u003ela\" else return \"\\t\" endif endfunc \" ===================== Install Plugins with Vim-Plug ================= call plug#begin('~/.vim/plugged') \" style \" Plug 'crusoexia/vim-monokai' Plug 'shaunsingh/nord.nvim' \" Go Plug 'fatih/vim-go' , { 'for': ['go', 'vim-plug'], 'tag': '*' } \" Python Plug 'Vimjas/vim-python-pep8-indent', { 'for' :['python', 'vim-plug'] } Plug 'numirias/semshi', { 'do': ':UpdateRemotePlugins', 'for' :['python', 'vim-plug'] } Plug 'tweekmonster/braceless.vim', { 'for' :['python', 'vim-plug'] } \" Visual indentation Plug 'Yggdroot/indentLine' \" vim-monokai Plug 'crusoexia/vim-monokai' \" annotation Plug 'scrooloose/nerdcommenter' \" Nested parentheses are highlighted Plug 'luochen1990/rainbow' \" Directory management plug-in Plug 'preservim/nerdtree' Plug 'Xuyuanp/nerdtree-git-plugin' Plug 'ryanoasis/vim-devicons' \" Coc.nvim Plug 'neoclide/coc.nvim', {'branch': 'release'} \" dashboard Plug 'glepnir/dashboard-nvim' \" lualine Plug 'nvim-lualine/lualine.nvim' \" barbar Plug 'kyazdani42/nvim-web-devicons' Plug 'romgrk/barbar.nvim' \" diffview Plug 'nvim-lua/plenary.nvim' Plug 'sindrets/diffview.nvim' \" telescope Plug 'nvim-lua/plenary.nvim' Plug 'nvim-telescope/telescope.nvim', { 'tag': '0.1.0' } Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'} \" lazygit Plug 'kdheepak/lazygit.nvim' \" delve Plug 'sebdah/vim-delve' call plug#end() \" ==================== lazygit ======================== \" https://github.com/kdheepak/lazygit.nvim nnoremap \u003csilent\u003e \u003cleader\u003egg :LazyGit\u003cCR\u003e \" ==================== telescope ====================== \" https://github.com/nvim-telescope/telescope.nvim \" Find files using Telescope command-line sugar. nnoremap \u003cleader\u003eff \u003ccmd\u003eTelescope find_files\u003ccr\u003e nnoremap \u003cleader\u003efg \u003ccmd\u003eTelescope live_grep\u003ccr\u003e nnoremap \u003cleader\u003efb \u003ccmd\u003eTelescope buffers\u003ccr\u003e nnoremap \u003cleader\u003efh \u003ccmd\u003eTelescope help_tags\u003ccr\u003e \" Using Lua functions nnoremap \u003cleader\u003eff \u003ccmd\u003elua require('telescope.builtin').find_files()\u003ccr\u003e nnoremap \u003cleader\u003efg \u003ccmd\u003elua require('telescope.builtin').live_grep()\u003ccr\u003e nnoremap \u003cleader\u003efb \u003ccmd\u003elua require('telescope.builtin').buffers()\u003ccr\u003e nnoremap \u003cleader\u003efh \u003ccmd\u003elua require('telescope.builtin').help_tags()\u003ccr\u003e \" ==================== diffview ======================= \" https://github.com/sindrets/diffview.nvim \" ==================== barbar ======================== \" Move to previous/next nnoremap \u003csilent\u003e \u003cA-,\u003e \u003cCmd\u003eBufferPrevious\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-.\u003e \u003cCmd\u003eBufferNext\u003cCR\u003e \" Re-order to previous/next nnoremap \u003csilent\u003e \u003cA-\u003c\u003e \u003cCmd\u003eBufferMovePrevious\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-\u003e\u003e \u003cCmd\u003eBufferMoveNext\u003cCR\u003e \" Goto buffer in position... nnoremap \u003csilent\u003e \u003cA-1\u003e \u003cCmd\u003eBufferGoto 1\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-2\u003e \u003cCmd\u003eBufferGoto 2\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-3\u003e \u003cCmd\u003eBufferGoto 3\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-4\u003e \u003cCmd\u003eBufferGoto 4\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-5\u003e \u003cCmd\u003eBufferGoto 5\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-6\u003e \u003cCmd\u003eBufferGoto 6\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-7\u003e \u003cCmd\u003eBufferGoto 7\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-8\u003e \u003cCmd\u003eBufferGoto 8\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-9\u003e \u003cCmd\u003eBufferGoto 9\u003cCR\u003e nnoremap \u003csilent\u003e \u003cA-0\u003e \u003cCmd\u003eBufferLast\u003cCR\u003e \" Pin/un","date":"2023-03-29","objectID":"/nvim/:5:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["nvim"],"content":"coc-settings.json { \"coc.preferences.semanticTokensHighlights\": false, \"coc.preferences.enableFloatHighlight\": true, \"coc.preferences.snippetStatusText\": \"Ⓢ \", \"coc.preferences.extensionUpdateCheck\": \"daily\", \"coc.preferences.messageLevel\": \"error\", \"coc.source.around.firstMatch\": false, \"coc.source.buffer.firstMatch\": false, \"coc.source.syntax.firstMatch\": false, \"suggest.detailMaxLength\": 60, \"suggest.noselect\": true, \"suggest.enablePreselect\": false, \"suggest.triggerAfterInsertEnter\": true, \"suggest.autoTrigger\": \"always\", \"suggest.timeout\": 5000, \"suggest.enablePreview\": true, \"suggest.floatEnable\": true, \"suggest.detailField\": \"preview\", \"suggest.snippetIndicator\": \"\", \"suggest.triggerCompletionWait\": 100, \"suggest.echodocSupport\": true, \"suggst.completionItemKindLabels\": { \"class\": \"\\uf0e8\", \"color\": \"\\ue22b\", \"constant\": \"\\uf8fe\", \"default\": \"\\uf29c\", \"enum\": \"\\uf435\", \"enumMember\": \"\\uf02b\", \"event\": \"\\ufacd\", \"field\": \"\\uf93d\", \"file\": \"\\uf723\", \"folder\": \"\\uf115\", \"function\": \"\\u0192\", \"interface\": \"\\uf417\", \"keyword\": \"\\uf1de\", \"method\": \"\\uf6a6\", \"module\": \"\\uf40d\", \"operator\": \"\\uf915\", \"property\": \"\\ue624\", \"reference\": \"\\ufa46\", \"snippet\": \"\\ue60b\", \"struct\": \"\\ufb44\", \"text\": \"\\ue612\", \"typeParameter\": \"\\uf728\", \"unit\": \"\\uf475\", \"value\": \"\\uf89f\", \"variable\": \"\\ue71b\" }, \"diagnostic.signOffset\": 2, \"diagnostic.errorSign\": \"!\", \"diagnostic.warningSign\": \"!!\", \"diagnostic.infoSign\": \"\\uf129\", \"diagnostic.hintSign\": \"\\uf864\", \"diagnostic.displayByAle\": false, \"diagnostic.refreshOnInsertMode\": false, \"diagnostic.checkCurrentLine\": true, \"diagnostic.virtualTextPrefix\": \" ❯❯❯ \", \"diagnostic.virtualText\": false, \"codeLens.enable\": true, \"list.previewHighlightGroup\": \"Statement\", \"list.nextKeymap\": \"\u003cC-e\u003e\", \"list.previousKeymap\": \"\u003cC-u\u003e\", \"importCost.bundleSizeDecoration\": \"both\", \"importCost.typescriptExtensions\": [\"\\\\.tsx?$\"], \"importCost.javascriptExtensions\": [\"\\\\.jsx?$\"], \"importCost.showCalculatingDecoration\": true, \"importCost.debug\": false, \"snippets.ultisnips.directories\": [ \"$HOME/.config/nvim/Ultisnips/\", \"$HOME/.config/nvim/plugged/vim-snippets/UltiSnips/\" ], \"coc.preferences.formatOnSaveFiletypes\": [ \"javascript\", \"typescript\", \"typescriptreact\", \"html\", \"css\", \"json\", \"jsonc\", \"java\", \"python\", \"vue\", \"svelte\", \"cs\", \"racket\", \"prisma\" ], \"yaml.format.enable\": true, \"signature.target\": \"float\", \"yank.enableCompletion\": false, \"typescript.suggestionActions.enabled\": true, \"typescript.format.enabled\": true, \"jest.watch\": false, \"explorer.width\": 38, \"explorer.quitOnOpen\": true, \"explorer.sources\": [ { \"name\": \"buffer\", \"expand\": false }, { \"name\": \"file\", \"expand\": true } ], \"explorer.file.column.indent.indentLine\": true, \"explorer.file.showHiddenFiles\": true, \"explorer.icon.enableNerdfont\": true, \"explorer.file.column.git.showIgnored\": true, \"explorer.keyMappingMode\": \"none\", \"explorer.buffer.showHiddenBuffers\": false, \"explorer.keyMappings.global\": { \"u\": \"nodePrev\", \"e\": \"nodeNext\", \"h\": \"toggleSelection\", \"\u003ctab\u003e\": \"actionMenu\", \"gl\": \"expandRecursive\", \"gh\": \"collapseRecursive\", \"i\": [\"wait\", \"expandable?\", \"expand\", \"open\"], \"\u003ccr\u003e\": [\"wait\", \"expandable?\", \"cd\", \"open\"], \"I\": \"open:vsplit\", \"o\": [\"wait\", \"expanded?\", \"collapse\", \"expand\"], \"O\": \"open:tab\", \"n\": \"collapse\", \"l\": \"gotoParent\", \"yp\": \"copyFilepath\", \"yn\": \"copyFilename\", \"yy\": \"copyFile\", \"dd\": \"cutFile\", \"pp\": \"pasteFile\", \"dD\": \"deleteForever\", \"a\": \"addFile\", \"k\": \"addFile\", \"M\": \"addDirectory\", \"cw\": \"rename\", \".\": \"toggleHidden\", \"zh\": \"toggleHidden\", \"R\": \"refresh\", \"?\": \"help\", \"q\": \"quit\", \"X\": \"systemExecute\", \"gd\": \"listDrive\", \"f\": \"search\", \"F\": \"searchRecursive\", \"B\": \"gotoSource:file\", \"b\": \"gotoSource:buffer\", \"[[\": \"sourcePrev\", \"]]\": \"sourceNext\", \"[d\": \"diagnosticPrev\", \"]d\": \"diagnosticNext\", \"[c\": \"gitPrev\", \"]c\": \"gitNext\", \"\u003c\u003c\": \"gitStage\", \"\u003e\u003e\": \"gitUnstage\" }, \"flutter.outlineWidth\": 40, \"flutter.outlineIconPadding\": 0, \"flutter.UIPath\": true, \"flutter.openDevLogSplitCommand\": \"botright 12split\", \"flutter.lsp.init","date":"2023-03-29","objectID":"/nvim/:6:0","tags":["nvim"],"title":"nvim 配置","uri":"/nvim/"},{"categories":["C++"],"content":"友元 什么是友元 Friend 的意义在于打开封装的大门，可以直接从私有区域拿取数据 好比借钱，陌生人不可能借钱给他，但是朋友是可以的，但是朋友太多借太多钱也不太好，所以你自己选择，如果不设置friend，绕个弯从函数拿，也是可以的 private: double re, im; friend complex\u0026 __dopal (conplex*, const complex\u0026) inline complex\u0026 __doapl (complex* ths, const complex\u0026 r) { ths-\u003ere += r.re; ths-\u003eim += r.im; return *ths } ","date":"2023-03-26","objectID":"/c-friend/:1:0","tags":["C++"],"title":"friend","uri":"/c-friend/"},{"categories":["C++"],"content":"友元的使用场景 普通函数定义为类的友元函数，使得普通函数能够访问该类的私有成员和保护成员 #include \u003ciostream\u003e using namespace std; class A { friend ostream \u0026operator\u003c\u003c(ostream \u0026_cout, const A \u0026tmp); // 声明为类的友元函数 public: A(int tmp) : var(tmp) { } private: int var; }; ostream \u0026operator\u003c\u003c(ostream \u0026_cout, const A \u0026tmp) { _cout \u003c\u003c tmp.var; return _cout; } int main() { A ex(4); cout \u003c\u003c ex \u003c\u003c endl; // 4 return 0; } 友元类 由于类的 private 和 protected 成员变量只能由类的成员函数访问或者派生类访问，友元类则提供提供一种通用的方法，使得不同类之间可以访问其 private 和 protected 成员变量，用于不同类之间共享数据 #include \u003ciostream\u003e using namespace std; class A { friend class B; public: A() : var(10){} A(int tmp) : var(tmp) {} void fun() { cout \u003c\u003c \"fun():\" \u003c\u003c var \u003c\u003c endl; } private: int var; }; class B { public: B() {} void fun() { cout \u003c\u003c \"fun():\" \u003c\u003c ex.var \u003c\u003c endl; // 访问类 A 中的私有成员 } private: A ex; }; int main() { B ex; ex.fun(); // fun():10 return 0; } ","date":"2023-03-26","objectID":"/c-friend/:2:0","tags":["C++"],"title":"friend","uri":"/c-friend/"},{"categories":["C++"],"content":"相同class的各个obj互为friend 在下述代码中，我们竟然可以通过func直接获取到private中的值，我们也没有设置friend，这是因为相同class的各个obj互为friend class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} int func(const complex\u0026 param) { return param.re + param.im; } private: double re, im; }; { complex c1(2, 1); complex c2; c2.func(c1); } ","date":"2023-03-26","objectID":"/c-friend/:3:0","tags":["C++"],"title":"friend","uri":"/c-friend/"},{"categories":["C++"],"content":"什么是内联函数-inline 引出 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行 一个 C/C++程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如return 0;）来结束自己的生命，从而结束整个程序 函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码 如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视 为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数 怎么定义内联函数 #include \u003ciostream\u003e using namespace std; //内联函数，交换两个数的值 inline void swap(int *a, int *b){ int temp; temp = *a; *a = *b; *b = temp; } int main(){ int m, n; cin\u003e\u003em\u003e\u003en; cout\u003c\u003cm\u003c\u003c\", \"\u003c\u003cn\u003c\u003cendl; swap(\u0026m, \u0026n); cout\u003c\u003cm\u003c\u003c\", \"\u003c\u003cn\u003c\u003cendl; return 0; } 内联函数要注意的点 要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字 对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做 内联函数的坑 使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数 ","date":"2023-03-25","objectID":"/c-inline/:1:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline 工作原理 inline 不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现inline的调用表达式用内联函数的函数体来替换，普通函数调用时，需要切换栈帧寄存器，同时栈中压入参数，返回值，然后跳转，这些都需要开销，而内联函数不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销 虽然内联函数在调用时直接进行展开，但实际在编译后代码中存在内联函数的定义，可以供编译器进行调用。普通函数可以有指向它的函数指针，内敛函数也可以有指向它的函数指针 ","date":"2023-03-25","objectID":"/c-inline/:2:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline的优点 不会产生函数调用开销。节省了调用函数时在堆栈上推送/弹出变量的开销。节省了函数返回调用的开销。 当你inline一个函数的时候，你可以让编译器对函数体执行上下文特定的优化，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化 ","date":"2023-03-25","objectID":"/c-inline/:3:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline的缺点 从内联函数中添加的变量会消耗额外的寄存器，在内联函数之后，如果要使用寄存器的变量数量增加，则可能会在寄存器变量资源利用方面产生开销，在函数调用点替换内联函数体时，函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加 如果你使用太多的内联函数，那么二进制可执行文件的大小会很大，因为相同的代码重复 过多的内联也会降低指令缓存命中率，从而降低从缓存内存到主内存的指令获取速度 如果有人更改内联函数内的代码，内联函数可能会增加编译时间开销，那么所有调用位置都必须重新编译，因为编译器需要再次替换所有代码，否则它将继续使用旧功能 内联函数可能会导致抖动，因为内联可能会增加二进制可执行文件的大小。内存抖动会导致计算机性能下降 ","date":"2023-03-25","objectID":"/c-inline/:4:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline的使用场景 内联函数一般只适用于比较短小，处理较为简单的函数。内联只是对编译器的请求，而不是命令。编译器可以忽略内联请求。编译器可能不会在以下情况下执行内联 如果函数包含循环（for, while, do-while）； 如果一个函数包含静态变量； 如果一个函数是递归的； 如果函数返回类型不是 void，并且函数体中不存在 return 语句； 如果函数包含 switch 或 goto 语句； ","date":"2023-03-25","objectID":"/c-inline/:5:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"c++内联函数也可以用来代替宏 先来讲讲宏 使用宏的一个经典例子是求一个数的平方，如下所示： #include \u003ciostream\u003e using namespace std; #define SQ(y) y*y int main(){ int n, sq; cin\u003e\u003en; sq = SQ(n); cout\u003c\u003csq\u003c\u003cendl; return 0; } // 运行结果 9↙ 81 看运行结果是没有啥问题的，但是当我们将宏调用 SQ(n) 换成 SQ(n+1) 后，就会出现意想不到的状况 #include \u003ciostream\u003e using namespace std; #define SQ(y) y*y int main(){ int n, sq; cin\u003e\u003en; sq = SQ(n+1); cout\u003c\u003csq\u003c\u003cendl; return 0; } // 运行结果 9↙ 19 我们期望的结果是 100，但这里却是 19，两者大相径庭。这是因为，宏展开仅仅是字符串的替换，不会进行任何计算或传值，上面的 sq = SQ(n+1); 在宏展开后会变为sq = n+1*n+1;，这显然是没有道理的 如果希望得到正确的结果，应该将宏定义改为如下的形式： #define SQ(y) (y)*(y) 这样宏调用 sq = SQ(n+1); 就会展开为 sq = (n+1)*(n+1);，得到的结果就是 100。 如果你认为这样就万事大吉了，那下面的结果会让你觉得考虑不周： #include \u003ciostream\u003e using namespace std; #define SQ(y) (y)*(y) int main(){ int n, sq; cin\u003e\u003en; sq = 200 / SQ(n+1); cout\u003c\u003csq\u003c\u003cendl; return 0; } 9↙ 200 之所以会出现这么奇怪的结果，是因为宏调用 sq = 200 / SQ(n+1); 会被展开为sq = 200 / (n+1) * (n+1);，当 n 被赋值 9 后，相当于 sq = 200 / 10 * 10，结果显然是 200 要想得到正确的结果，还应该对宏加以限制，在两边增加 ( )，如下所示： #define SQ(y) ( (y)*(y) ) 这样宏调用 sq = 200 / SQ(n+1); 就会展开为sq = 200 / ( (n+1) * (n+1) );，得到的结果就是 2 说了这么多，我最终想强调的是，宏定义是一项 “细思极密” 的工作，一不小心就会踩坑，而且不一定在编译和运行时发现，给程序埋下隐患 如果在 1 的基础上将宏替换成 inline函数呢 #include \u003ciostream\u003e using namespace std; inline int SQ(int y){ return y*y; } int main(){ int n, sq; cin\u003e\u003en; //SQ(n) sq = SQ(n); cout\u003c\u003csq\u003c\u003cendl; //SQ(n+1) sq = SQ(n+1); cout\u003c\u003csq\u003c\u003cendl; //200 / SQ(n+1) sq = 200 / SQ(n+1); cout\u003c\u003csq\u003c\u003cendl; return 0; } 9↙ 81 100 2 看，一切问题迎刃而解！发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，这和简单的字符串替换相比省去了很多麻烦，所以在编写 C++ 代码时我推荐使用内联函数来替换带参数的宏 使用inline函数替换宏的优点 和宏一样，内联函数可以定义在头文件中（不用加 static 关键字），并且头文件被多次#include 后也不会引发重复定义错误。这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次#include 后会引发重复定义错误 内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，内联函数更像是编译期间的宏 ","date":"2023-03-25","objectID":"/c-inline/:6:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"inline的规范 inline 是一种\"用于实现的关键字\"，而不是一种\"用于声明的关键字\" inline 关键字可以只在函数定义处添加，也可以只在函数声明处添加，也可以同时添加；但是在函数声明处添加 inline 关键字是无效的，编译器会忽略函数声明处的 inline 关键字 更为严格地说，内联函数不应该有声明，应该将函数定义放在本应该出现函数声明的地方，这是一种良好的编程风格 将内联函数的声明和定义分散到不同的文件中会出错 在多文件编程中，我们通常将函数的定义放在源文件中，将函数的声明放在头文件中，希望调用函数时，引入对应的头文件即可，我们鼓励这种将函数定义和函数声明分开的做法。但这种做法不适用于内联函数，将内联函数的声明和定义分散到不同的文件中会出错，请看下面的例子 main.cpp 代码 #include \u003ciostream\u003e using namespace std; //内联函数声明 void func(); int main(){ func(); return 0; } module.cpp 代码 #include \u003ciostream\u003e using namespace std; //内联函数定义 inline void func(){ cout\u003c\u003c\"inline function\"\u003c\u003cendl; } 上面的代码能够正常编译，但在链接时会出错。func() 是内联函数，编译期间会用它来替换函数调用处，编译完成后函数就不存在了，链接器在将多个目标文件（.o或.obj文件）合并成一个可执行文件时找不到 func() 函数的定义，所以会产生链接错误 内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质 函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用 规范小结 内联函数看起来简单，但是有很多细节需要注意，从代码重复利用的角度讲，内联函数已经不再是函数了。我认为将内联函数作为带参宏的替代方案更为靠谱，而不是真的当做函数使用 在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举） ","date":"2023-03-25","objectID":"/c-inline/:7:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"Effective c++ Item 对于更多的inline知识请看《Effective c++ Item30》 ","date":"2023-03-25","objectID":"/c-inline/:8:0","tags":["C++"],"title":"inline","uri":"/c-inline/"},{"categories":["C++"],"content":"lambda 怎么去定义一个lambda [] { std::cout \u003c\u003c \"hello lambdas\" \u003c\u003c std::endl; } 对于上述代码，我们可以写成这个样子 [] { std::cout \u003c\u003c \"hello lambdas\" \u003c\u003c std::endl; } (); // prints \"hello lambdas\" 那我们改进后 看着也有点怪怪的，我们大费周章就为了一个cout，干嘛呢，假如要100次cout还不如抽出来 然后调用100次呢，所以多半我们会这么写 auto l = [] { std::cout \u003c\u003c \"hello lambdas\" \u003c\u003c std::endl; }; ... l(); // prints \"hello lambdas\" lambda是可以在语句和表达式中定义的功能定义。因此，您可以将lambda用作内联函数。最小lambd函数没有参数，只是简单地做一些事情，所以跟上述的不太一样，lambda是可以不用取名字，直接在语句或者表达式中定义，用完就直接不管的 lambdas的模板 [ capture-list ] ( params ) mutable(optional) constexpr(optional)(c++17) exception attribute -\u003e ret { body } // 可选的简化语法 [ capture-list ] ( params ) -\u003e ret { body } [ capture-list ] ( params ) { body } [ capture-list ] { body } capture-list: 捕捉列表，这个不用多说，前面已经讲过，它不能省略 [] // 没有定义任何变量。使用未定义变量会引发错误。 [x, \u0026y] // x pass by value（默认），y pass by reference。 [\u0026] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [\u0026, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, \u0026z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 params:参数列表，可以省略(但是后面必须紧跟函数体) mutable:可选，将 lambda 表达式标记为 mutable 后，函数体就可以修改传值方式捕获的变量 constexpr:可选 exception:可选，指定 attribute:可选，指定 ret:可选，返回值类型 body:函数执行体 ","date":"2023-03-24","objectID":"/c-lambda/:1:0","tags":["C++"],"title":"lambda","uri":"/c-lambda/"},{"categories":["C++"],"content":"lambda 的本质 最前边的 [] 是 lambda 表达式的一个很重要的功能，就是 闭包 先说明一下 lambda 表达式的大致原理 每当你定义一个 lambda 表达式后，编译器会自动生成一个匿名类，这个类当然重载载了()运算符，我们称为闭包类型* 那么在运行时，这个 lambda 表达式就会返回一个匿名的闭包实例，其实是一个右值 所以，我们上面的 lambda 表达式的结果就是一个个闭包实例 闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为 lambda 捕捉块。例子如下 int main() { int x = 10; auto add_x = [x](int a) { return a + x; }; // 复制捕捉x,lambda 表达式无法修改此变量 auto multiply_x = [\u0026x](int a) { return a * x; }; // 引用捕捉x，lambda 表达式可以修改此变量 cout \u003c\u003c add_x(10) \u003c\u003c \" \" \u003c\u003c multiply_x(10) \u003c\u003c endl; // 输出:20 100 return 0; } 而 lambda 表达式一个更重要的应用是其可以用于函数的参数，通过这种方式可以实现回调函数 其实，最常用的是在STL算法中，比如你要统计一个数组中满足特定条件的元素数量， 通过 lambda 表达式给出条件，传递给 count_if 函数 int val = 3; vector\u003cint\u003e v {1, 8, 5, 3, 6, 10}; int count = std::count_if(v.beigin(), v.end(), [val](int x) { return x \u003e val; }); // v中大于3的元素数􏰁 ","date":"2023-03-24","objectID":"/c-lambda/:2:0","tags":["C++"],"title":"lambda","uri":"/c-lambda/"},{"categories":["C++"],"content":"Summary c++ 11引入了lambda，允许定义内联函数，可以作为参数或局部对象使用 从本质上来讲，表达式只是一种语法糖，因为所有其能完成的工作都可以用其它稍微复杂的代码来实现，但是它简便的语法却给 C++ 带来了深远的影响 从广义上说， 表达式产生的是函数对象。 在类中，可以重载函数调用运算符()，此时类的对象可以将具有类似函数的行为，我们称这些对象为函数对象或者仿函数 相比 lambda表达式，函数对象有自己独特的优势 lambda是可以在语句和表达式中定义的功能定义。因此，您可以将lambda用作内联函数。最小lambda函数没有参数，只是简单地做一些事情 要弄清楚lambda的模板并且分清楚\"[ ]“的传值使用，想要修改值就pass by reference + mutable ","date":"2023-03-24","objectID":"/c-lambda/:3:0","tags":["C++"],"title":"lambda","uri":"/c-lambda/"},{"categories":["C++"],"content":"static 什么是static 下述代码括号里面传的就是this pointer 当不是静态方法的时候 c1, c2, c3调用同一个函数 那么就是靠this point区分到底是c1 还是 c2 的 complex c1, c2, c3; cout \u003c\u003c c1.real(); cout \u003c\u003c c2.real(); // 上述代码其实要是看透本质等于下面代码 complex c1, c2, c3; cout \u003c\u003c complex::real(\u0026c1); cout \u003c\u003c complex::real(\u0026c2); 所以静态就是不带这个this pointer 静态用在哪 - 存储静态的数据 不会变动的 ","date":"2023-03-23","objectID":"/c-static/:1:0","tags":["C++"],"title":"static","uri":"/c-static/"},{"categories":["C++"],"content":"static的修饰 static 修饰局部变量 存放原本从栈区变成了静态存储区 生命周期原本从包含语句模块结束变成了延续到整个程序结束 作用域不发生变化 static 修饰全局变量 static全局变量会存在静态存储区 生命周期会延续到整个程序结束 作用域从原本的全文件共享，变成了定义文件共享 static 修饰函数 跟全局变量类似，作用域发生了改变 static 修饰成员变量 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和 private、public、protected 访问规则 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象，且只能该变量只能被初始化一次，不能在类的构造函数中对静态成员变量进行初始化 静态成员变量可以作为成员函数的默认参数，而普通成员变量不可以 静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用 static 修饰成员函数 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数 静态成员函数不能声明成 virtual function、const funciton、volatile function static 对象 静态对象的生存周期为整个程序的生命周期，而非静态对象的生命周期只存在于某个循环中 ","date":"2023-03-23","objectID":"/c-static/:2:0","tags":["C++"],"title":"static","uri":"/c-static/"},{"categories":["C++"],"content":"inline 与 static 在c++17之后 静态成员直接类内inline就可以省去类外初始化的麻烦 class Person { public: ... private: inline static uint8_t age = 0; } ","date":"2023-03-23","objectID":"/c-static/:3:0","tags":["C++"],"title":"static","uri":"/c-static/"},{"categories":["C++"],"content":"引用 什么是引用 reference 其实就是一个漂亮的 pointer 引用的代码 int x = 0; int* p = \u0026x; // p is a pointer to x int\u0026 p = x; // r is a reference to x int x2 = 5; r = x2; int\u0026 r2= r; int*是 pointer to int，int\u0026是 reference to int，比如 int* p = \u0026x; 我们会说指针p指向了x，而int\u0026 r = x;我们会说 r 代表了 x，其实r里面有一个指针指向了x ，r 只要代表了 x 就不可以代表别的变量，pointer不同，pointer还可以指向别的变量 假象 我们观察上面的 x 和 r的地址和大小，就发现 sizeof(r) = sizeof(x) \u0026x == \u0026r object 和其 reference的大小相同，地址也相同（但是都是假象） reference的常见用途 reference一般不用在声明变量，而用在参数类型和返回类型的描述 void func1(Cls* pobj) { pobj-\u003exxx(); } // pass by pointer void func2(Cls obj) { obj.xxx(); } // pass by value void func3(Cls\u0026 obj) { obj.xxx(); } // pass by reference Cls obj; func1(\u0026obj); func2(obj); func(obj); 我们能发现 pass by pointer 跟其他的都不一样，而\"value\" “reference\"被调用端的写法相同，调用端接口也相同 所以最好用 reference 不行的情况下 比如返回临时对象的情况下，用value ","date":"2023-03-22","objectID":"/c-value-pointer-reference/:1:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"签名 什么是签名 不含return type的函数部分叫做签名 如下述代码 他们的签名都是 image(const double im) 所以他们两者不能同时存在 double image(const double\u0026 im) { ... } double image(const double im) { ... } const 也算函数签名 ","date":"2023-03-22","objectID":"/c-value-pointer-reference/:2:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"指针和引用的区别 指针和引用都是内存地址的一个概念，区别就是指针是一个实体，引用是一个别名 指针他指向一个内存，在编译的时候会以 “指针名 - 指向的内存地址” 存入符号表，所以说 指针包含的内容是可以改变的，并且是可以 const修饰的，允许拷贝和赋值，甚至可以为空，sizeof得到的就是指针类型的大小 引用则就是相当于一个内存的别名，在添加到符号表的时候，是以 “引用变量名 - 引用对象的地址\"添加到符号表中，符号表一经完成不能改变，所以引用必须而且只能在定义时被绑 定到一块内存上，后续不能更改，也不能为空，也没有 const 和非 const 区别 sizeof sizeof 引用得到代表对象的大小 sizeof 指针得到的是指针本身的大小 参数传递 传指针的实质是传值，传递的值是指针的地址。指针需要被解引用后才可以对对象进行操作 传引用的实质是传地址，传递的是参数的地址。直接对引用进行的修改会直接作用到引用对象上 ","date":"2023-03-22","objectID":"/c-value-pointer-reference/:3:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"参数传递 pass by value 形参是实参的拷⻉，函数内部对形参的操作并不会影响到外部的实参 值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参 值，从而形成了实参的一个副本(替身) 值传递的特点就是被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值(形参指针变了，实参指针不会变) pass by pointer 指针参数本质上就是一个值传递，他所传递的是一个地址值 当对地址值的指向操作时，就相当于对实参本身进行操作 pass by reference 被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时 存放的是由主调函数放进来的实参变量的地址 被调函数对形参(本体)的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量(根据别名找到主调函数中的 本体) 因此，被调函数对形参的任何操作都会影响主调函数中的实参变量 引用传递和指针传递是不同的 虽然他们都是被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量，而对于指针传递的参数，如果改变被调函数中的指针地址，他将应用不到主调函数的相关变量。 如果想通过指针参数传递来改变主调函数中的相关变量(地址)，那就得使用指向指针的指针或者指针引用 ","date":"2023-03-22","objectID":"/c-value-pointer-reference/:4:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"野指针 什么是野指针 就是没有被初始化过的指针 如何避免野指针 在平时的编码中，养成定义指针后初始化或者使用智能指针的习惯 ","date":"2023-03-22","objectID":"/c-value-pointer-reference/:5:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"悬空指针 什么是悬空指针 是指针最初指向的内存已经被释放的一种指针 ","date":"2023-03-22","objectID":"/c-value-pointer-reference/:6:0","tags":["C++"],"title":"value \u0026 poionter \u0026 reference","uri":"/c-value-pointer-reference/"},{"categories":["C++"],"content":"class内 编写防卫式声明 #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 #endif 编写class head #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { }; #endif 编写数据 放入private #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { private: char* m_data; }; #endif // __STRING__ 编写构造函数 类的名称要相同 有哪些参数要传，需不需要默认值，参数传递是 pass by value 还是 pass by reference 合理利用初始列，初始列就是设初始值 { } 内可能会有内存分配哦~ const!!! #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { public: String(const char* cstr = 0); // 构造函数 private: char* m_data; }; #endif // __STRING__ 设计三大函数 #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { public: String(const char* cstr = 0); // 构造函数 String(const String\u0026 str); // 拷贝构造 String\u0026 operator=(const String\u0026 str); // 拷贝赋值 ~String(); // 析构函数 private: char* m_data; }; #endif // __STRING__ 设计其他函数 当我们设计一个函数的时候，一定要思考，要不要加const 到底要不要加，只需要看，这个参数会不会被改变，如果不会改变或不能改变，则加const 结合此处代码考虑，取出和构造的拷贝的时候，都不会改变str，所以就加一个const class String { public: String(const char* cstr = 0); // 构造函数 String(const String\u0026 str); // 拷贝构造 String\u0026 operator=(const String\u0026 str); // 拷贝赋值 ~String(); // 析构函数 char* get_c_str() const { return m_data; } // 拿到私有的数据 private: char* m_data; }; #endif // __STRING__ ","date":"2023-03-21","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/:1:0","tags":["C++"],"title":"编写头文件的思路流程(reference)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/"},{"categories":["C++"],"content":"class外 构造函数和析构函数 inline String::String(const char* cstr = 0) { if (cstr) { m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); } else { m_data = new char[1]; *m_data = '\\0'; } } // c里面字符串是以 '\\0' 为结束符号 这是构造函数 inline String::~String() { delete[] m_data; } // 析构函数 因为上述构造函数 为str分配了一个内存 所以要释放内存 要不然会内存泄漏 // class 有指针 多半要做动态分配 所以就要在析构函数 释放内存 拷贝构造函数 // 拷贝构造没有返回值 inline String::String(const String\u0026 str) { m_data = new char[ strlen(str.m_data) + 1 ]; strcpy(m_data, str.m_data); } 拷贝赋值函数 inline String\u0026 String::operator=(const String\u0026 str) { // 这一行与下一行的\u0026不一样 第一行是引用(reference) 第二行是取\"str\"地址 if (this == \u0026str) return *this; // 判断是不是自我赋值 delete[] m_data; m_data = new char [ strlen(str.m_data) + 1]; strcpy(m_data, str.m_data); return *this; } ","date":"2023-03-21","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/:2:0","tags":["C++"],"title":"编写头文件的思路流程(reference)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/"},{"categories":["C++"],"content":"class内 编写防卫式声明 #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 #endif 编写class head #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { }; #endif 编写数据 放入private #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { private: double re, im; }; #endif // __COMPLEX__ 编写构造函数 类的名称要相同 有哪些参数要传，需不需要默认值，参数传递是 pass by value 还是 pass by reference 合理利用初始列，初始列就是设初始值 { } 内可能会有内存分配哦~ #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} private: double re, im; }; #endif // __COMPLEX__ 设计\"+=“函数 这里需要考虑是否为成员函数，如果是则在class内定义，如果不是则在class内定义，这里选择是 #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex\u0026 operator+=(const complex\u0026); private: double re, im; }; #endif // __COMPLEX__ 设计其他函数 当我们设计一个函数的时候，一定要思考，要不要加const 到底要不要加，只需要看，这个参数会不会被改变，如果不会改变或不能改变，则加const *结合此处代码考虑 real imag 是取出 re im 没有改动 所以 要加const * #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex\u0026 operator+=(const complex\u0026); double real() const { return re; } double imag() const { return im; } private: double re, im; }; #endif // __COMPLEX__ 想拿私有数据，我们可以交个朋友 #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex\u0026 operator+=(const complex\u0026); double real() const { return re; } double imag() const { return im; } private: double re, im; friend complex\u0026 __doapl(complex*, const complex\u0026); }; #endif // __COMPLEX__ ","date":"2023-03-21","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/:1:0","tags":["C++"],"title":"编写头文件的思路流程(value)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/"},{"categories":["C++"],"content":"class外 接口部分 inline complex\u0026 complex::operator += (const complex\u0026 r) inline complex\u0026 __doapl(complex* ths, const complex\u0026 r) /* 思考 参数 / const / pass by reference / return by reference / return type / class之外 inline */ 定义部分 inline complex\u0026 complex::operator += (const complex\u0026 r) { return __doapl(this, r); } inline complex\u0026 __doapl(complex* ths, const complex\u0026 r) { ths-\u003ere += r.re; ths-\u003eim += r.im; return *ths; } \"+” 非成员函数 为什么 “+” 要写为非成员函数 因为 “+” 其实有很多情况 比如复数+复数 复数+实数等 inline complex operator + (const complex\u0026 x, const complex\u0026 y) { return complex( real(x) + real(y), imag(x) + imag(y) ); } /* 思考 返回类型 参数类型 */ ","date":"2023-03-21","objectID":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/:2:0","tags":["C++"],"title":"编写头文件的思路流程(value)","uri":"/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/"},{"categories":["C++"],"content":"!!!本文基于这个一个 complex的类去讲解 操作符重载 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex\u0026 operator+=(const complex\u0026); double real() const { return re; } double imag() const { return im; } private: double re, im; friend complex\u0026 __doapl(complex *, const complex \u0026); }; ","date":"2023-03-20","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:0:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"操作符重载 示例操作符重载 “+=” +=就是一个操作符，那么操作符是怎么被编译器看待的 下述代码 += 会用到左边的c2上，如果c2有对+=的定义，就会调用+=的函数，操作符本来也就是一个函数 c2 += c1; 我们来示范一下重载 += 这个代码就是重写了+=函数，多包装了一层 inline complex\u0026 __doapl(complex* ths, const complex\u0026 r) { ths-\u003ere += r.re; ths-\u003eim += r.im; return *ths; // 返回的是一个value } inline complex\u0026 complex::operator+=(const complex\u0026 r) { return __doapl(this, r); } ","date":"2023-03-20","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:1:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"成员函数 - this 我们将上面的代码更深一层看，其实是这样的 这个this就是操作符左边的-也就是c2，但是在我们代码里面不可以写出来，知道他的存在就好 那么this就一定在第一个参数吗？ 其实不一定的，但是不用考虑 inline complex\u0026 complex::operator+=(this, const complex\u0026 r) { return __doapl(this, r); } ","date":"2023-03-20","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:2:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"Return by reference 还是上面的代码 我们来分析分析一个问题 *为什么 complex *ths 是指针的方式传进来的，return 的时候 ths 是返回指针所指向的value，然而声明返回值的时候，说返回的是一个内存地址\u0026 inline complex\u0026 __doapl(complex* ths, const complex\u0026 r) { // ... return *ths; } 这其实是允许的，你返回一个value，接收端怎么接收，是不需要管的，所以 传递者无需知道接收者是以reference形式接收 ","date":"2023-03-20","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:3:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"非成员函数 一个操作符也可以有很多个重载 下面三个操作符 + 由复数和实数组成三种，所以需要有三种全局函数 { complex c1(2, 1); complex c2; c2 = c1 + c2; c2 = c1 + 5; c2 = 7 + c1; } inline complex operator + (const complex\u0026 x, const complex\u0026 y) { return complex (real(x) + real(y), imag(x) + imag(y)); } inline complex operator + (const complex\u0026 x, double y) { return complex (real(x) + y, imag(x); } inline complex operator + (double x, const complex\u0026 y) { return complex (x + real(y), imag(y)); } ","date":"2023-03-20","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:4:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"临时对象 我们来看看上面 三个 +重载，他们绝不可return by reference 上述的 + 并非等同于 +=，x 和 y相加后的数据并没有地方放，所以在函数里一定会放在一个东西里 这里就是complex() conplex()相当于int()都会创建一个临时对象，这样的意思就是这个临时对象下一行就挂了，只是临时的作用 ","date":"2023-03-20","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:5:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"总结 const需不需要使用取决于这个值需不需要修改 pass by reference \u0026 return by reference 一切都优先考虑 reference，如果像需要用到临时对象，则使用return by value 同时也要注意 需不需要加上const ","date":"2023-03-20","objectID":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/:6:0","tags":["C++"],"title":"操作符重载","uri":"/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["C++"],"content":"模板 class template 类模板的作用就是可变类型 template\u003ctypename T\u003e class complex { public: complex(T r = 0, T i = 0) : re(r), im(i) {} complex \u0026operator+=(const complex \u0026); T real() const { return re; } T imag() const { return im; } private: T re, im; friend complex \u0026__doapl(complex *, const complex \u0026); }; complex\u003cdouble\u003e c1(2.5, 3.5); func template func template 也是相当于 class template 如果我们用stone类型去生成对象，实参推导结果：T为stone，于是调用stone::operator \u003c，所以stone必须实现\"\u003c“方法 class stone { public: stone(int w, int h, int we) : _w(w), _h(h), _weight(we) {} bool operator \u003c (const stone\u0026 rns) const { return _weight \u003c rhs._weight; } private: int _w, _h, _weight; }; template \u003cclass T\u003e inline const T\u0026 min(const T\u0026 a, const T\u0026 b) { return b \u003c a ? b : a; } stone r1(2, 3), r2(3, 3), r3; r3 = min(r1, r2); member template 成员模版就是我们在外面设置了T1，T2后，在里面的成员模版又可以让我们在设置一个U1，U2 template \u003cclass T1, class T2\u003e struct pair { typedef T1 first_type; typedef T2 second_type; T1 first; T2 second; pair() : first(T1()), second(T2()) { } pair()(const T1\u0026 a, const T2\u0026 b) : first(a), second(b) { } template \u003cclass U1, class U2\u003e pair(const pair\u003cU1, U2\u003e\u0026 p) : first(p.first), second(p.second) { } }; 是不是有点听不太懂，我们这么去想 Base1 鱼类 Dervied1 鲫鱼 / Base2 鸟类 Dervied2 麻雀 我们有这4个类 对应着继承关系 pair\u003cBase1, Base2\u003ep2\u003cpair\u003cDervied1, Dervied2\u003e()\u003e; 把一个由鲫鱼和麻雀组成的pair 放进(拷贝到)一个由鱼类和鸟类构成的pair中 可以吗 反之 可以嘛* 正着当然可以，反之，逻辑上说不通，因为 鸟类 \u003e 麻雀，为了显示这种逻辑，成员模板就因此而来 ","date":"2023-03-19","objectID":"/c-%E6%A8%A1%E7%89%88/:1:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模板特化 TODO: ","date":"2023-03-19","objectID":"/c-%E6%A8%A1%E7%89%88/:2:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模版偏特化 个数上的偏 template \u003ctypename T, typename Alloc=...\u003e // Alloc 分配器 class vector { ... }; // 如果第一个typename 一直为bool 的话 为了节省空间 我们可以进行绑定优化 template \u003ctypename Alloc=....\u003e // Alloc 分配器 class vector\u003cbool, Alloc\u003e { ... }; 范围上的偏 template \u003ctypename T\u003e class C { ... }; template \u003ctypename T\u003e class C\u003cT*\u003e { ... }; // 这样的意思就是我要求编译器 如果是指针的T 就走这个 不是就走上方 ","date":"2023-03-19","objectID":"/c-%E6%A8%A1%E7%89%88/:3:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模板模板参数 TODO: ","date":"2023-03-19","objectID":"/c-%E6%A8%A1%E7%89%88/:4:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"模板的可变长参数 // 就是python 和 golang 的可变长参数 template \u003ctypename T, typename... Types\u003e void print (const T\u0026 firstArg, const Types\u0026.. args) { cout \u003c\u003c firstArg \u003c\u003c endl; print(args...); } ","date":"2023-03-19","objectID":"/c-%E6%A8%A1%E7%89%88/:5:0","tags":["C++"],"title":"模版","uri":"/c-%E6%A8%A1%E7%89%88/"},{"categories":["C++"],"content":"虚函数 虚函数的种类 non-virtual： 你不希望派生类重新定义 virtual：你希望派生类重新定义，且他有默认定义 pure virtual：你希望派生类一定要重新定义，你对他没有默认定义 class Shape { public: virtual void draw() const = 0; // pure virtual virtual void error(const std::string \u0026msg); // impure virtual int objectID() const; // non-virtual }; ","date":"2023-03-19","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:1:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"虚函数的实现原理 虚表与虚指针 我们先把下述代码扫一遍，并且来看看图，我们可以看到最左边的表 上面记录着 继承的父类和 自己的数据，但是除了这些之外，是不是还有一个记录着内存地址的，这个就是虚指针（vtpr）这个虚指针指向着一张虚表（vtbl） class A { pubilc: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; }; class B : public A { pubilc: virtual void vfunc1(); void func2(); private: int m_data3; }; class C : public B { pubilc: virtual void vfunc1(); void func2(); private: int m_data1, m_data4; }; c++对一个虚函数进行调用的过程 他首先会考虑是静态绑定还是动态绑定 静态绑定 就是 call xxx call(汇编语言的一个动作) xxx(addr) 如果是满足三个条件就会动态绑定 通过指针来调用 指针满足向上转型 调用的是虚函数 只要满足这三个条件 就会变成 (*(p-\u003evptr)[n])(p); 或者 (*p-\u003evptr[n] )(p); 为什么叫动态绑定，因为要看\"p\"是什么 ","date":"2023-03-19","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:2:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"虚函数的妙用 通过虚指针我们可以实现多态 比如 一个list 需要放多个不同大小的 比如 矩形 圆形 长方形 各种的 就可以直接放父类A 的指针 指向不同大小的 具体图形 因为对于指针来说 都是4个byte list\u003cA*\u003e myList; ","date":"2023-03-19","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:3:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"虚函数的注意点 析构函数要写成虚函数 是为了降低内存泄漏的可能性 一个基类的指针指向一个派生类的对象，在使用完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指 针类型就会认为当前对象的类型是基类，调用基类的析构函数，仅执行基类的析构，所以造成内存泄漏 构造函数不写成虚函数 我们创建一个对象，是需要知道对象的完整信息的。特别是要知道对象的具体类型，而虚函数只需要知道函数接口，而不需要知道具体类型，所以构造函数不应该被定义为虚函数 从目前编译器实现虚函数进行多态的方式来看，虚函数的调用是通过实例化之后对象 的虚函数表指针来找到虚函数的地址进行调用的，如果说构造函数是虚的，那么虚函数表 指针则是不存在的，无法找到对应的虚函数表来调用虚函数，那么这个调用实际上也是违 反了先实例化后调用的准则 构造函数和析构函数中不要调用虚函数 举例来说，有一个动物的基类，基类中定义了一个动物本身行为的虚函数 action_type()， 在基类的构造函数中调用了这个虚函数 派生类中重写了这个虚函数，我们期望着根据对象的真实类型不同，而调用各自实现的虚函 数，但实际上当我们创建一个派生类对象时，首先会创建派生类的基类部分，执行基类的构造 函数，此时，派生类的自身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当 它们还不存在作为一种安全的方法 派生类中重写了这个虚函数，我们期望着根据对象的真实类型不同，而调用各自实现的虚函 数，但实际上当我们创建一个派生类对象时，首先会创建派生类的基类部分，执行基类的构造 函数，此时，派生类的自身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当 它们还不存在作为一种安全的方法 在析构函数中也是同理，派生类执行了析构函数后，派生类的自身成员呈现未定义的状态，那 么在执行基类的析构函数中是不可能调用到派生类重写的方法的 哪些函数不能写成虚函数 构造函数： 上述已说明 内联函数： 内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行 类型确定，所以内联函数不能是虚函数 静态函数： 静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚 函数没有任何意义 友元函数： 友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数 的说法 普通函数： 普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数 ","date":"2023-03-19","objectID":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/:4:0","tags":["C++"],"title":"虚函数","uri":"/c-%E8%99%9A%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"Composition 组合 什么是组合及实现 组合就是一个类里面用了另一个类，并且可以用另一个类的方法 template \u003cclass T, class Sequence = deque\u003cT\u003e\u003e class queue { ... protected: Sequence c; // 底层容器 public: // 以下完全利用 c 的操作函数完成 bool empty() const { return c.empty(); } size_type size() const { retiurn c.size(); } reference front() { return c.front(); } // deque 是两端可进出 queue 是先进先出 void push(const value_type \u0026x) { c.push_back(x); } void pop() { c.pop_front(); } } 组合其实是一个最容易被忽视的东西，设计模式的桥模式跟装饰模式组合是一个最重要的思路 组合下的构造和析构 比如 Container 类里面调用了 Component Container的构造函数首先调用Component的default构造函数然后才执行自己（从内到外） Container的析构函数首先执行自己 然后才调用Component的析构函数（从外到内） ","date":"2023-03-19","objectID":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/:1:0","tags":["C++"],"title":"组合与继承","uri":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"Inheritance 继承 什么是继承 所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类 子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用 struct _List_node_base { _List_node_base* _M_next; _List_node_base* _M_prev; }; template\u003ctypename _Tp\u003e struct _List_node : public _List_node_base { _Tp _m_data; }; // 父类的数据 子类都可以继承下来 继承下的构造和析构 Base: 父类 / Derived: 派生类 Derived 的构造函数首先调用Base的default构造函数 然后才执行自己（从内到外） Derived 的析构函数首先执行自己, 然后才调用Base的析构函数（从外到内） 注意: base class 的 dtor 必须是virtual 否则会出现 underfined behavior ","date":"2023-03-19","objectID":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/:2:0","tags":["C++"],"title":"组合与继承","uri":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"组合\u0026继承的构造和析构 Base: 父类 / Derived: 派生类 Derived 的构造函数 首先调用Base的default构造函数，然后调用Component的default构造函数，然后才执行自己 Derived 的析构函数首先执行自己，然后调用Component的析构函数，然后调用Base的析构函数 ","date":"2023-03-19","objectID":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/:3:0","tags":["C++"],"title":"组合与继承","uri":"/c-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"C++ PImpl ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:0:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl惯用法 PImpl术语，即\"pointer to implementation\" （指向实现的指针），由Jeff Summer最先引入。 该技巧可以避免在头文件中暴露私有细节，是促进API接口和实现保持完全分离的重要机制 PImpl并不是严格意义上的设计模式，而是桥模式的一种特例 在本人博客中有介绍《设计模式-桥模式》 如下图，Class A只提供公有接口Function1，Function2，其实现细节由Impl类实现，Class A通过一格Impl指针来提供服务，这样做的目的在于，使用Class A公有接口的用户，不必关系其实现细节，而且实现的变动，对用户也是透明的 注：- : private, + : public, # : protected 特点：该技巧在公有接口中完全隐藏内部细节。支持将私有成员数据和方法，从.h转移到.cpp文件。是构建接口和实现恰当分离的API的不可或缺的工具 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:1:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"使用PImpl PImpl将类的数据成员定义为指向某个已经声明过的类型的指针，如上面的例子中的impl。这里类型仅作为名字引入，没有被完整定义，只需要前向声明即可，隐藏可以将该类型定义隐藏在.cpp文件中。该指针也称为不透明指针，因为用户无法看到所指对象细节 示例：“自动定时器（AutoTimer）API，对象被销毁时打印出生存时间” // autotimer.h #ifdef _WIN32 #include \u003cwindows.h\u003e #else #include \u003csys/time.h\u003e #endif #include \u003cstring\u003e class AutoTimer { public: /// 使用易于理解的名字创建新定时器 explicit AutoTimer(const std::string\u0026 name); ~AutoTimer(); private: // 返回对象已经存在了多长时间 double GetElapsed() const; std::string name_; #ifdef _WIN32 DWORD startTime_; #else struct timeval startTime_; #endif }; 该API的问题：暴露了定时器在不同平台上存储的底层细节，任何人都可以从头文件看到这些平台的定义 可取之处：仅将必要的方法暴露为public方法（构造函数、析构函数），其余方法、数据标记为private 由于C++语言特性，要求这些private成员都声明在公有头文件中，导致API包含平台相关#if指令。而设计者的真正目的是将所有private成员隐藏在.cpp文件中 PImpl惯用法将所有private成员放在一个class/struct中，这个类在头文件中仅做前置声明，在.cpp中定义。可以像下面这样，利用pimpl重构前面的头文件 autotimer.h #include \u003cstring\u003e class AutoTimer // 接口类 { public: explicit AutoTimer(const std::string \u0026name); ~AutoTimer(); private: class Impl; // 前置声明 Impl *impl; // 通过私有内嵌类, 将实现细节封装到内嵌类中 }; autotimer.cpp // autotimer.cpp #include \"autotimer.h\" #include \u003ciostream\u003e #if _WIN32 #include \u003cwindows.h\u003e #else #include \u003csys/time.h\u003e #endif class AutoTimer::Impl // 实现类 { public: double GetElapsed() const { #ifdef _WIN32 return (GetTickCount() - startTime_) / 1e3; #else struct timeval end_time; gettimeofday(\u0026end_time, NULL); double t1 = startTime_.tv_usec / 1e6 + startTime_.tv_sec; double t2 = end_time.tv_usec / 1e6 + end_time.tv_sec; return t2 - t1; #endif } std::string name_; #ifdef _WIN32 DWORD starTime_; #else struct timeval startTime_; #endif }; AutoTimer::AutoTimer(const std::string \u0026name) : impl_(new AutoTimer::Impl()) { impl_-\u003ename_ = name; #ifdef _WIN32 imp_-\u003estartTime_ = GetTickCount(); #else gettimeofday(\u0026impl_-\u003estartTime, NULL); #endif } AutoTimer::~AutoTimer() { std::cout \u003c\u003c impl_-\u003ename_ \u003c\u003c \": took \" \u003c\u003c impl_-\u003eGetElapsed() \u003c\u003c \" secs\" \u003c\u003c std::endl; delete impl_; impl_ = NULL; } 这样，将原本暴露在原有头文件中的所有private方法和数据，转移到了.cpp文件中定义的AutoTimer::Impl类中 将Impl类（实现类）声明为AutoTimer类的private内嵌类，是为了避免与该实现相关的符号污染全局命名空间，只有AutoTimer的方法才能访问Impl成员 在Impl类中放哪些逻辑？接口类中有哪些部分，需要放到Impl类中？ 通常，有以下选择 仅private成员变量 private成员变量和方法 所有public方法。接口类中public方法只是对Impl类中等价方法进行简单包装 推荐第2项，将priavet变量和方法都放到Impl类中，这样可以保持数据和操作这些数据的方法的封装性，从而避免在public头文件中声明private方法。 不过，有2项需要注意 不能在impl类中隐藏private虚方法。virtual方法必须出现在接口类中，以保证任何派生类都能覆盖它 虽然可以将接口类传递给Impl类的方法，但必要时，可以在Impl类中增加指回接口类的指针，便于Impl类调用公有方法 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:2:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"复制语义 复制使用PImpl惯用法的接口类，存在潜在风险 当没有为类显式定义copy构造函数、assignment运算符（operator=）时，C++编译器会默认创建（trivial版本）。但这种trivail版本的copy构造函数、assigment运算符，只能执行浅复制。显然不利于使用PImpl惯用法，因为如果客户复制了接口类对象，那么2个对象就会指向同一个Impl实现类对象，析构时，就会删除同一个Impl对象2次，从而可能导致程序崩溃 *针对该问题，有2种可选方案： 禁止复制类 如果不打算让用户创建接口类对象副本，可以将对象声明为不可复制。 禁止编译器生成默认copy函数，有以下几种方法： 将方法设为private，禁止客户调用 如果使用Boost库，可以让接口类继承自boost::noncopyable C++11以后，可以将方法声明为\"=delete\" 显式定义复制语义 如果希望客户能复制采用PImpl的对象，就应该声明并定义自己的copy构造函数、assignment运算符，进行对象的深拷贝，创建Impl对象的副本 下面展示如何使得接口类AutoTimer禁止拷贝 #include \u003cstring\u003e // 方式1 class AutoTimer { public: explicit AutoTimer(const std::string \u0026name); ~AutoTimer(); private: // 使对象不可复制 AutoTimer(const AutoTimer\u0026); const AutoTimer\u0026 operator=(const AutoTimer\u0026); class Impl; Impl *impl_; }; // 方式2 class AutoTimer : boost::noncopyable // 使对象不可复制 { public: explicit AutoTimer(const std::string \u0026name); ~AutoTimer(); private: class Impl; Impl *impl_; }; // 方式3 class AutoTimer : boost::noncopyable { public: explicit AutoTimer(const std::string \u0026name); ~AutoTimer(); private: // 使对象不可复制 AutoTimer(const AutoTimer\u0026) = delete; const AutoTimer\u0026 operator=(const AutoTimer\u0026)= delete; class Impl; Impl *impl_; }; ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:3:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl与智能指针 详情可以看《Effective Modern c++ 条款22》 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:4:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl优点 信息隐藏 实现细节可以隐藏到Impl类实现中，保护闭源API专有性。同时，接口头文件也能更干净、清晰表达真正的公有接口，易于阅读和理解 降低耦合 接口类只用知道Impl类即可，不用包含私有成员变量所需头文件，也不必包含平台依赖的windows.h或sys/time.h。 加速编译 将实现相关头文件移入.cpp，API的引用层次降低，会导致编译时间减少。 更好的二进制兼容性 采用PImpl的对象大小从不改变，因为对象总是单个指针大小。对私有成员变量做任何修改，都只影响隐藏在cpp文件内的实现类大小。而对象的二进制表示可以不变 惰性分配 Impl类可以在需要时再构造，而不必在接口类构造时立即构造。 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:5:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl缺点 必须为你创建的每个对象分配并释放实现对象。这使得对象增加了一个指针（Impl impl），同时增加了通过指针访问成员的开销，增加了new和delete对象的开销* 必须通过impl-\u003e的形式访问私有成员，给开发人员带来了不便。 编译器不能捕获接口类中const对成员变量修改。因为成员变量现在存在于独立的对象（impl指针所指对象）中。编译器仅检查impl指针是否发生变化，而不会检查其成员。 ","date":"2023-03-18","objectID":"/%E7%BC%98%E8%B5%B7-pimpl/:6:0","tags":["PImpl"],"title":"PImpl","uri":"/%E7%BC%98%E8%B5%B7-pimpl/"},{"categories":["C++"],"content":"前言 此篇博客会按照一个逻辑推导 带你们区分到底什么是 左值/右值/左值引用/右值引用 ","date":"2023-03-18","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:1:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"逻辑推导1 我们来看这一行简单的代码 int i = 10; i 在左边 -\u003e 左值 / 10 在右边 -\u003e 右值 这句话，在这行代码是适用的，但是！这句话不准确 我们看 i 在内存中是有位置的实际变量 / 而 10 没有存储地址，也就是在内存中是没有职位的 所以我们不能说 10 = i;，因为10是没有位置的，不能存储数据 但是 i 是一个左值，我们可以用另一个变量a 等于 i int a = i; 这就是为什么说 “i 在左边-\u003e左值 / 10 在右边-\u003e右值” 这句话是不准确的 ","date":"2023-03-18","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:2:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"逻辑推导2 现在我们来加一个函数 int GetValue() { return 10; } 随后调用这个函数 int i = GetValue(); 在这个例子中，GetValue返回了一个临时值，也就是右值，然后将这个右值保存到左值 当然因为这是一个右值，所以我们是这给这个右值赋值，那么就会失败 GetValue() = 10; // Error!!! 我们在试着修改一下，如果将函数返回值改成返回左值，那就变得很有趣了 int\u0026 GetValue() { } 将\"int\"加上\"\u0026“就变成了左值引用 这时候需要为我的值提供某种存储空间 比如一个静态int，然后返回他 int\u0026 GetValue() { static int value = 10; return value; } int main() { int i = GetValue(); GetValue() = 10; // true! 我就可以给他赋值，这个表达式也没有啥问题了，这就是左值引用 return 0; } ","date":"2023-03-18","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:3:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"逻辑推导3 我们再再再展开看一下，现在再加了一个SetValue() void SetValue(int value) { } int main() { int i = value; SetValue(i); // true! SetValue(10); // true } 当函数调用时，传左值是可以的，传右值也是可以的，因为这个右值会被用来创建一个左值 So? 我们可以马上看出，哪个变量是临时的，哪个不是，这个规则就是你不能将右值赋给左值引用 我们可以很容易的去检查这个，如果我在 int 加一个 \u0026，现在我在取一个 referebce to int，这是一个左值引用，SetValue(10)马上这个就会error 因为非const引用的初始值必须是左值 所以 const int\u0026 i = 10; 这个是一个特殊的规则 实际情况就是 编译器可能会用你的存储创建一个临时变量，然后赋值给那个引用 const int\u0026 i = 10; ===\u003e int temp = 10; const int\u0026 a = temp; 所以实际上 还是不可避免的创建了一个左值 但是也同时支持了左值右值 ","date":"2023-03-18","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:4:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"题目 好！ 讲到了这里 来出道题目 来看看你们到底懂得了怎么区分左右值 题目: 请找出 所有的左值 和 所有的右值! int main() { std::string firstName = \"lin\"; std::string secondName = \"ting\"; std::string fullName = firstName + secondName; } 答案 /* 左值: firstName/secondName/fullName 右值: \"lin\"/\"ting\"/firstName + secondName \"firstName + secondName\" 为什么是右值 因为 两个字符串相加是一个临时变量 所以他是临时值 也就是右值 */ ","date":"2023-03-18","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:5:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"逻辑推导4 好 我们再次进行拓展 void PrintName(std::string\u0026 name) { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { std::string firstName = \"lin\"; std::string secondName = \"ting\"; std::string fullName = firstName + secondName; PrintName(firstName); // true!! PrintName(secondName); // true!! PrintName(firstName + secondName); // error!! 因为他是一个右值 } 这就是为什么会看到很多用c++写的常量引用 因为他支持左右值，所以我们可以通过这种方法来检测哪些是左值 哪些是右值 那我们有没有办法写一个函数，只接受临时对象，肯定是有的，那就是右值引用 右值引用跟左值引用差不多，只不过多了一个”\u0026“符号 void PrintName(std::string\u0026\u0026 name) { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { std::string firstName = \"lin\"; std::string secondName = \"ting\"; std::string fullName = firstName + secondName; PrintName(firstName); // error!! 右值不能绑定到左值 PrintName(firstName + secondName); // true!! } 这就说得通了！这很coooool，因为这意味着我们可以写函数重载，他只接受临时对象 void PrintName(const std::string\u0026 name) { std::cout \u003c\u003c name \u003c\u003c std::endl; } void PrintName(std::string\u0026\u0026 name) { std::cout \u003c\u003c name \u003c\u003c std::endl; } int main() { std::string firstName = \"lin\"; std::string secondName = \"ting\"; std::string fullName = firstName + secondName; PrintName(firstName); // true!! PrintName(firstName + secondName); // true!! } 那么他有啥作用呢 作用非常大 尤其是在移动语义方面 当然 我这里不会讲这个 这里代码的主要优势是优化，如果我们传入的是一个临时对象，那么我们就不需要担心他们是否活着 是否完整 是否拷贝，我们可以简单的偷他的资源 给到特定对象 或者其他地方使用它们，因为我们知道他是暂时的 他不会存在很长时间， 而如果你传入的不是右值，除了他是const之外 你不能从这个左值中窃取任何东西，因为他可能会在很多函数中使用 ","date":"2023-03-18","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:6:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"总结 左值是有某种存储支持的变量 右值是临时值 左值引用仅仅接受左值 除了const 右值引用仅仅接受右值 ","date":"2023-03-18","objectID":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:7:0","tags":["C++"],"title":"左值/右值/左值引用/右值引用","uri":"/c-%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"前言 想了想，最好的复习方法其实就是去写出来，good idea~ ","date":"2023-03-17","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:1:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"strlen V.S sizeof 什么是strlen strlen 是头文件 \u003ccstring\u003e 中的函数 strlen测量的是字符串的实际长度（其源代码如下）以\\0结尾 size_t strlen(const char *str) { size_t length = 0; while (*str++) ++length; return length; } 什么是sizeof sizeof是c++里的一个操作符，用来测量对象或者表达式类型所占字节的大小 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; int main() { char arr[10] = \"hello\"; cout \u003c\u003c strlen(arr) \u003c\u003c endl; // 5 cout \u003c\u003c sizeof(arr) \u003c\u003c endl; // 10 return 0; } 两者的不同点 若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; void size_of(char arr[]) { cout \u003c\u003c sizeof(arr) \u003c\u003c endl; // warning: 'sizeof' on array function parameter 'arr' will return size of 'char*' . cout \u003c\u003c strlen(arr) \u003c\u003c endl; } int main() { char arr[20] = \"hello\"; size_of(arr); return 0; } /* 输出结果： 8 5 */ strlen 本身是库函数，因此在程序运行过程中，计算长度 / 而 sizeof 是在编译时计算长度； strlen 的参数必须是 char * 类型的变量 / sizeof 的参数可以是类型，也可以是变量，且必须是完整类型 strlen 是一个函数，如果接受表达式则会对表达式进行运算 / sizeof 接受的参数可以是对象也可以是表达式，但是 sizeof(expression) 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小； #include \u003ciostream\u003e using namespace std; int main(int argc, char * argv[]) { int x = 4; char *s = \"12345678\"; char *p = s; sizeof(x++); printf(\"%d\\n\", x); strlen(p++); return 0; } ","date":"2023-03-17","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:2:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C 和 C++ static 中的作用 指路，在static的专题有讲解 https://vlicecream.github.io/c-static/ ","date":"2023-03-17","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:3:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"const 作用及用法 指路，在const的专题有讲解 https://vlicecream.github.io/c-const/ ","date":"2023-03-17","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:4:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"define V.S const 编译阶段 define 是在编译预处理阶段进行替换 / const 是在编译阶段确定其值 安全性 define 定义的宏常量没有数据类型，只是进行简单的代码替换，不会进行类型安全的检查 const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误 存储空间 define 定义的宏定义只是作为代码替换的表达式而已，宏定义本身不占用内存空间，define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，实际使用宏定义替换代码时占用的是代码段的空间 const 定义的常量占用静态存储区的只读空间，程序运行过程中常量只有一份 调试 define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了 const 定义的常量可以进行调试 接受参数 define 可以接受参数构造非常复杂的表达式 const 不能接受参数 ","date":"2023-03-17","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:5:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"inline 作用及使用方法 指路，在inline专题有讲解 https://vlicecream.github.io/c-inline/ ","date":"2023-03-17","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:6:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"inline V.S define 编译阶段 内联函数是在编译时展开，而宏在编译预处理时展开 在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换 安全性 宏定义编写较为复杂，常需要增加一些括号来避免歧义。宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查，因此在实际使用宏时非常容易出错 / 而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查 调试 内联函数可以进行调试 / 宏定义的“函数”无法调试 类 由于类的成员函数全部为内联函数，通过内联函数，可以访问类的数据成员，而宏不能访问类的数据成员 传递参数 在 inline 函数传递参数只计算一次，而在使用宏定义的情况下，每次在程序中使用宏时都会计算表达式参数，因此宏会对表达式参数计算多次 ","date":"2023-03-17","objectID":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/:7:0","tags":["C++"],"title":"c++ 关键字与关键库函数","uri":"/c-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E5%85%B3%E9%94%AE%E5%BA%93%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"const const object non-const object const member functions ✅ ✅ non-const member functions ❌ ✅ ","date":"2023-03-16","objectID":"/c-const/:1:0","tags":["C++"],"title":"const","uri":"/c-const/"},{"categories":["C++"],"content":"object 与 member func 的关系 我们根据上述表格来看看例子 我们创建了一个常量 str 并且调用print方法，但是如果当初设计 string::print() 时候没有指明const 那么会直接报错， 因为 “const obj” 调用 non-const 成员函数的时候 是不允许的～～ const String str(\"hello world\"); str.print(); 我们再来看一个标准库 string 的例子 class template std::basic_string\u003c...\u003e 有如下两个 成员函数 chatT operator[] (size_type pos) const { ... } // 不必考虑copy on write reference operator[] (size_type pos) { ... } // 必须考虑copy on write 在设计字符串的时候 因为字符串是共享的 可能a拷贝一份 b拷贝一份 就有多份 最致命的是 如果a修改了 b的字符串也随之修改了，所以我们必须要考虑这个共享的问题 所以这个就考虑到了 const 下面没有const，那么可能就会修改字符串，上面的有 const 那么就不允许修改 下面也是可行的 因为 non-const member func 是可以创建 non-const obj 的 但是上面的 const member func 又可以创建 const obj 又可以创建 non-const obj，那么编译器怎么调用呢 当成员函数的 “const\" 和 “non-const” 版本同时存在 const obj 只能调用const 版本 “non-const obj” 只能调用\"non-const\"版本 ","date":"2023-03-16","objectID":"/c-const/:2:0","tags":["C++"],"title":"const","uri":"/c-const/"},{"categories":["C++"],"content":"const修饰 const 修饰基本数据类型 基本数据类型，修饰符 const 可以用在类型说明符前，也可以 用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值即可 const 修饰指针变量和引用变量 const int* p1; //指向整形常量的指针，它指向的值不能修改 int* const p2; //指向整形的常量指针 ，它不能在指向别的变量，但指向(变量)的值可以修改。 const int* const p3; //指向整形常量的常量指针 。它既不能再指向别的常量，指向的值也不能修改。 const 应用到函数中 作为参数的 const 修饰符： 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化，保护了原对象的属性 注意：参数 const 通常用于参数为指针或引用的情况 作为函数返回值的 const 修饰符： 声明了返回值后，const 按照\"修饰原则\"进行修饰，起到相应的保护作用 const 在类中的用法 const成员变量 只在某个对象生命周期内是常量，而对于整个类而言 是可以改变的 const 数据成员的初始化只能在类的构造函数的初始化列表中进行 因为类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员，因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么 const成员函数 const 成员函数的主要目的是防止成员函数修改对象的内容 要注意，const 关键字和 static 关键字对于成员函数来说是不能同时使用的 因为 static 关键字修饰静态成员 函数不含有 this 指针，即不能实例化，const 成员函数又必须具体到某一个函数 const 修饰类对象，定义常量对象 常量对象只能调用常量函数，别的成员函数都不能调用 C++ 中的 const类成员函数(用法和意义) 常量对象可以调用类中的 const member func，但不能调用non-const member func 这是因为对象调用成员函数的时候，在形参列表最前面加一个形参this，但是这个是隐式的。this 指针是默认指向调用函数的当前对象的，所以，很自然，this是一个常量指针test* const，因为不可修改this指针代表的地址。但当member func的参数列表后加了 const 关键字 void print() const; ，此成员函数为常量成员函数，此时他的隐式this形参为 const test* const 即 不可以通过this指针来改变指向对象的值 非常量对象可以调用类中的 const 成员函数，也可以调用非 const 成员函数。 ","date":"2023-03-16","objectID":"/c-const/:3:0","tags":["C++"],"title":"const","uri":"/c-const/"},{"categories":["C++"],"content":"Effective c++ Item 对于更多的const的相关知识，可以查看《Effective c++ Item3 - 尽量使用const》 ","date":"2023-03-16","objectID":"/c-const/:4:0","tags":["C++"],"title":"const","uri":"/c-const/"},{"categories":["C++"],"content":"三个特殊函数 class String { public: String(const char* cstr = 0); // 构造函数 String(const String \u0026str); // 他是接受自己的东西 所以这是一个拷贝构造 String\u0026 operator = (const String\u0026 str); // 操作符重载 =右手边也是自己的东西 所以这是拷贝赋值 ~String(); // 析构函数 当这个类死亡的时候 就会调用 析构函数 char* get_c_str() const { return m_data; } private: char* m_data }; ","date":"2023-03-15","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:1:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"构造函数和析构函数 代码演示 inline String::String(const char* cstr = 0) { if (cstr) { m_data = new char[strlen(cstr)+1]; strcpy(m_data, cstr); } else { m_data = new char[1]; *m_data = '\\0'; } } // c里面字符串是以 '\\0' 为结束符号 这是构造函数 inline String::~String() { delete[] m_data; } // 析构函数 因为上述构造函数 为str分配了一个内存 所以要释放内存 要不然会内存泄漏 // class 有指针 多半要做动态分配 所以就要在析构函数 释放内存 构造函数析构函数里能不能抛出异常 C++只会析构已经完成的对象，对象只有其构造函数执行完毕才算是完成，在构造函数中发生异常，控制权转交给析构函数之外。因此，在对象b的构造函数中发生异常，并不会调用对象b的析构函数，所以会造成内存泄漏 用 auto_ptr 对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄 漏的危机，不再需要在析构函数中手动释放资源 如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++ 会调 用 terminate 函数让程序结束 如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完全他应该做的每一件事 ","date":"2023-03-15","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:2:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"深拷贝与浅拷贝 什么是浅拷贝 拷贝后，两个对象指向同一个内存地址，如果修改了其一个，另一个也会受到影响 String a(\"Hello\"); // 这个时候 a 的 data 指向了 'Hello\\0' 的地址 String b(\"World\"); // 这个时候 b 的 data 指向了 ‘World\\0’ 的地址 b = a; // 这个时候 b 就会指向 'Hello\\0' 的地址 a\u0026b都指向了同一个地址 可是 'World\\0' 还在 造成内存泄漏 而且你改a b就会受到影响 所以这种 'b = a' 叫做浅拷贝 出现类的等号赋值时，会调用拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调 用默认的拷⻉函数-即浅拷⻉，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷⻉是可行的，但当数据成员中有指针时，如果采用简单的浅拷⻉，则两类中的两个指针指向同一个地址，当对象快要结束时，会调用两次析构函数，而导致野指针的问题 什么是深拷贝 拷贝后，两个对象的值相同，但是不是同一个内存地址 简而言之，当数据成员中有指针时，必需要用深拷⻉更加安全 ","date":"2023-03-15","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:3:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"拷贝构造函数 什么是拷贝构造函数及实现 inline String::String(const String\u0026 str) { // 为什么叫构造 因为这是一个构造函数 为什么叫拷贝 因为传参是自己 m_data = new char[strlen(str.m_data)+1]; // 直接取另一个object的private data strcpy(m_data, str.m_data); } // 这也是深拷贝 什么情况会调用拷贝构造函数 一个对象以值传递传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间 一个对象以值传递的方式从函数返回，需要执行拷贝构造函数创建一个临时对象作为返回值 一个对象需要通过另一个对象进行初始化 为什么拷贝构造函数必须是pass by reference，不能是 pass by value 是为了防止死递归 当一个对象需要以值方式进行传递时，编译器会生成代码调用它的拷⻉构造函数生成一个副本，如果类 A 的拷⻉构造函数的参数不是引用传递，而是采用值传递，那么就又需要为了创建传递给拷⻉构造函数的参数的临时对象，而又一次调用类 A的拷⻉构造函数，这就是一个死递归 ","date":"2023-03-15","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:4:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"拷贝赋值函数 // 这个函数就是 如果 有 1 a\u0026b 先把 a 清销毁, 2 在new一个内存空间 , 3 在把 b 拷贝到 a 里面来 inline String\u0026 String::operator = (const String\u0026 str) { if (this == \u0026str) { // 检测自我赋值 return *this; } delete[] m_data; // 1 m_data = new char[ strlen(str.m_data)+1 ]; // 2 strcpy(m_data, str.m_data); // 3 return *this; } // 一定要检测自我赋值 要不然 a\u0026b 同时指向一个内存地址 然后杀掉之后 a\u0026b就指定不到值 ","date":"2023-03-15","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:5:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["C++"],"content":"Effective c++ Item 对于更多的三个特殊函数一些规范及其知识点，请看《Effective c++ Item5~Item12》 ","date":"2023-03-15","objectID":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:6:0","tags":["C++"],"title":"构造析构/拷贝构造/拷贝赋值","uri":"/c-%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["Effective Modern C++ 条款"],"content":"条款18~22 智能指针","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款18~22 智能指针 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:0:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"前言 其实《Effective C++ Item13》已经过时了，所以我们可以在《Effective Modern c++ Item18~Item22》条款中去理解智能指针 我们不爱裸指针的原因 裸指针的声明没办法告诉我们它指向的是单个对象还是数组 没办法知道用完这个裸指针后要不要销毁它指向的对象 没办法知道怎么销毁这个裸指针，是用operator delete还是什么其它自定义的途径 参照原因1，没办法知道该用delete还是delete[]，如果用错了，结果未定义 很难保证调用路径上恰好销毁这个指针一次，可能内存泄露，也可能double free 通常没办法知道裸指针是否是空悬指针，即是否指向已销毁的对象 智能指针的作用 智能指针就是来解这些问题的，它们用起来像裸指针，但能避免以上的很多陷阱 C++11中有4种智能指针：std::auto_ptr、std::unique_ptr、std::shared_ptr、std::weak_ptr 其中std::auto_ptr已经过时了，C++11中可以被std::unique_ptr取代了 正式看本博客之前，需要去弄懂\"PImpl\" 具体关于PImpl是什么，可以查看我这个博客《PImpl》 还有如果前言都没好好看，导致Item22不知道PImpl是啥，这时候你是不是应该要质疑一下自己，学习是不是太浮躁了? ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:1:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款18 对于占有性资源使用unique_ptr std::unique_ptr的特点 默认情况下，std::unique_ptr与裸指针一样大，且对于绝大多数操作来说（包括解引用），他们编译后的指令都是完全一样的，所有裸指针的空间和性能开销能满足要求的场景，std::unique_ptr一样能满足 std::unique_ptr体现了显式所有权的语义 非空的std::unique_ptr总是拥有他指向的对象 移动一个std::unique_ptr，所有权会从源指针转移到目的指针（之后源指针会设置为空指针） 拷贝std::unique_ptr是不允许的，因为如果你可以拷贝它，那么就有两个std::unique_ptr指向相同的资源，每一个都认为它拥有（和负责销毁）那份资源 因此std::unique_ptr是只可移动类型 当销毁的时候，一个非空的std::unique_ptr会销毁它的资源 默认情况下，资源销毁是通过对std::unique_ptr内的原生指针使用delete来完成的 一个例子是工厂函数。假设有一个基类和三个派生类，通过一个工厂函数来返回某个派生类的std::unique_ptr，这样调用方就不需要费心什么时候销毁返回的对象了：std::unique_ptr会负责这件事。 class Investment {...}; class Stock: public Investment {...}; class Bond: public Investment {...}; class RealEstate: public Investment {...}; template \u003ctypename... Ts\u003e std::unique_ptr\u003cInvestment\u003e makeInvestment(Ts\u0026\u0026... params); auto pInvestment = makeInvestment(args); // 注意这里实际上有个所有权的转移：工厂函数通过std::unique_ptr将Investment对象的所有权转移给了调用者 std::unique_ptr可以传入自定义的销毁器 在构造std::unique_ptr时，我们还可以传入一个自定义的销毁器，它会在std::unique_ptr析构时被调用，来销毁对应的资源 比如我们可能不想只是delete obj，还想输出一条日志 auto delInvmt = [](Investment* pInvestment) { makeLogEntry(pInvestment); // make log delete pInvestment; // delete obj }; template \u003ctypename... Ts\u003e std::unique_ptr\u003cInvestment, decltype(delInvmt)\u003e makeInvestment(Ts\u0026\u0026... params) { std::unique_ptr\u003cInvestment, decltype(delInvmt)\u003e pInv(nullptr, delInvmt); if (...) { pInv.reset(new Stock(std::forward\u003cTs\u003e(params)...)); } ... return pInv; } 从调用者的角度，你可以放心的处理std::unique_ptr，你可以相信在调用过程中资源只会销毁一次，且按恰当的方式销毁。理解以下几点能帮助你理解这种实现有多漂亮 delInvmt是自定义的销毁器，在std::unique_ptr析构时，自定义的销毁器会来完成释放资源必需的操作。这里用lambda表达式来实现delInvmt，不仅更方便，性能还更好 自定义的销毁器的类型必须与std::unique_ptr的第二个模板参数相同，因此我们要用decltype(delInvmt)来声明std::unique_ptr makeInvestment的基本策略是创建一个空的std::unique_ptr，再令它指向合适的类型，再返回。其中我们把delInvmt作为第二个构造参数传给std::unique_ptr，从而将销毁器与pInv关联起来 无法将裸指针隐式转换为std::unique_ptr，需要用reset来修改std::unique_ptr持有的裸指针 我们在创建具体的对象时，使用了std::forward将makeInvestment的所有参数完美转发给对应的构造函数 注意delInvmt的参数是Investment*，而它的实际类型可能是派生类，因此需要基类Investment有一个虚的析构函数 class Investment { public: ... virtual ~Investment(); ... }; 前文我们说过在不提供自定义的销毁器时，std::unique_ptr的大小与裸指针相同。但在有了自定义的销毁器后，这个假设不成立了。销毁器的大小取决于它内部保存了多少状态。对于无状态的函数对象（例如捕获列表为空的lambda表达式），销毁器实际不占用任何空间，这就意味着当你需要一个无状态的销毁器时，在lambda表达式和函数间做选择，lambda表达式更好 auto delInvmt1 = [](Investment* pInvestment) { ... }; template \u003ctypename... Ts\u003e std::unique_ptr\u003cInvestment, decltype(delInvmt1)\u003e makeInvestment(Ts\u0026\u0026... args); // return type has size of Investment* void delInvmt2(Investment* pInvestment) { ... } template \u003ctypename... Ts\u003e std::unique_ptr\u003cInvestment, void(*)(Investment*)\u003e makeInvestment(Ts\u0026\u0026... args); // return type has size of Investment* // plus at least size of function pointer std::unique_ptr另一个广泛应用的场景是pImpl模式 std::unique_ptr的两种形式分别是std::unique_ptr\u003cT\u003e和std::unique_ptr\u003cT[]\u003e，其中前者没有定义operator[]，后者在默认析构时会调用delete[]，且没有定义operator*和operator-\u003e。但在用到std::unique_ptr\u003cT[]\u003e的地方，你可能需要想一下是不是std::vector、std::array、std::string更合适。唯一一个用std::unique_ptr\u003cT[]\u003e更好的场合就是当你需要与C API交互时 std::unique_ptr另一个吸引人的地方在于，它可以作为std::shared_ptr的构造参数，因此上面的工厂函数返回std::unique_ptr就再正确不过了：调用者可以根据自己对所有权的需求来决定用std::unique_ptr还是std::shared_ptr，反正都支持 在C++11中，std::unique_ptr是表达独占所有权的方式，但它最吸引人的一个特性是它能即简单又高效地转化为std::shared_ptr std::shared_ptr\u003cInvestment\u003e sp = // 把 std::unique_ptr转换为 makeInvestment(argument); // std::shared_ptr 这是为什么std::unique_ptr如此适合做工厂函数的关键原因，工厂函数不会知道：独占所有权语义和共享所有权语义哪个更适合调用者。通过返回一个std::unique_ptr，工厂提供给调用者的是最高效的智能指针，但它不妨碍调用者用std::shared_ptr来替换它 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:2:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"Summary std::unique_ptr是一个具有开销小，速度快，只可移动的智能指针，使用独占所有权语义管理资源 默认情况下，释放资源由delete来完成，也可以指定自定义的析构函数来替代，但是具有丰富状态的deleters和以函数指针作为deleters增大了std::unique_ptr的存储开销 很容易将一个std::unique_ptr转化为std::shared_ptr ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:2:1","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款19 需要共享所有权的资源管理，用shared_ptr 什么是std::shared_ptr 使用std::shared_ptr管理的对象的所有权是共享的，没有哪个std::shared_ptr特别拥有这个对象，而是最后一个std::shared_ptr析构时，销毁这个对象 与垃圾回收类似，调用者不需要手动管理std::shared_ptr管理的对象 与析构函数类似，对象的析构时间是确定的 std::shared_ptr的特点 std::shared_ptr内部有引用计数，被复制时，引用计数+1，有std::shared_ptr析构时，引用计数-1，当引用计数为0时，析构持有的对象 引用计数的存在有以下性能影响 *std::shared_ptr的大小是裸指针的两倍：一个指针指向持有的对象，一个指针指向引用计数。* 引用计数使用的内存必须动态分配，原因是std::shared_ptr的引用计数是非侵入式的，必须要独立在对象外面。用std::make_shared能避免这次单独的内存分配 引用计数的加减必须是原子的，因此你必须假设读写引用计数是有成本的 注意，不是所有std::shared_ptr的构造都会增加引用计数，移动构造就不会。因此移动构造一个std::shared_ptr要比复制一个更快 与std::unique_ptr类似，std::shared_ptr的默认销毁动作也是delete，且也可以接受自定义的销毁器 但与std::unique_ptr不同的是，std::shared_ptr的销毁器类型不必作为它的模板参数之一 auto loggingDel = [](Widget* pw) { makeLogEntry(pw); delete pw; }; std::unique_ptr\u003cWidget, decltype(loggingDel)\u003e upw(new Widget, loggingDel); std::shared_ptr\u003cWidget\u003e spw(new Widget, loggingDel); 因此std::shared_ptr要比std::unique_ptr使用更灵活，比如不同销毁器的std::shared_ptr可以放到同一个容器中，而std::unique_ptr则不可以 另外，不同的销毁器不会改变std::shared_ptr的大小。std::shared_ptr内部需要为引用计数单独开辟一块内存，那么这块内存中再放一个销毁器也没什么额外开销。实际上这块内存被称为”控制块”，它里面包含以下元素 引用计数 弱引用计数 其它数据，包括 自定义销毁器 内存分配器 等等 控制块的创建规则为 std::make_shared总会创建一个控制块 通过一个独享所有权的指针（如std::unique_ptr或std::auto_ptr）创建出的std::shared_ptr总会创建一个控制块 通过裸指针创建的std::shared_ptr会创建控制块 一个推论就是：通过一个裸指针创建两个std::shared_ptr，会创建两个控制块，进而导致这个裸指针会被析构两次 从中我们可以得到两个教训 不要直接用裸指针构造std::shared_ptr，尽量用std::make_shared。当然在需要自定义的销毁器时不能用std::make_shared 非要用裸指针构造std::shared_ptr的话，尽量直接new，不要传入已有的裸指针变量 控制块会带来哪些开销呢？一个控制块通常只有几个word大，但其中会用到继承，甚至还有虚函数。这也意味着使用std::shared_ptr也会有调用虚函数的开销 但通常来说std::shared_ptr的额外开销是很小的。对于std::make_shared创建的std::shared_ptr，它的控制块只有3个word大，且内存分配上无额外成本。解引用一个std::shared_ptr也不会比解引用一个裸指针开销大。操作引用计数会带来一两次原子操作的开销，但通常也不大 std::shared_ptr的一个缺点是它不支持数组，但在C++11已经提供了std::array、std::vector、std::string这些容器类的前提下，还要用std::shared_ptr去管理一个数组，本身就是不好设计的信号 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:3:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"Summary std::shared_ptr为了管理任意资源的共享式内存管理，提供了自动垃圾回收的便利 std::shared_ptr是原生指针的两倍大小，因为他们内部除了包含一个原生指针以外，还包含了一个引用计数 std::shared_ptr 是 std::unique_ptr 的两倍大，除了控制块，还有需要原子引用计数操作引起的开销 避免从原生指针类型变量创建 std::shared_ptr 引用计数的内存必须被动态分配，当然用make_shared来创建shared_ptr会避免动态内存的开销 引用计数的递增和递减必须是原子操作 资源的默认析构一般通过delete来进行，但是自定义的deleter也是支持的。deleter的类型对于 std::shared_ptr 的类型不会产生影响 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:3:1","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款20 在需要共享语义且可能空悬的地方用weak_ptr 有时候我们需要一种类似std::shared_ptr，但又不参与这个共享对象的所有权的智能指针。这样它就需要能知道共享对象是否已经销毁了。这就是`std::weak_ptr`` ``std::weak_ptr不是单独存在的，它不能解引用，也不能检测是否为空，它就是配合std::shared_ptr`使用的 通常std::weak_ptr都是通过std::shared_ptr构造的，但它不会影响std::shared_ptr的引用计数 auto spw = std::make_shared\u003cWidget\u003e(); // ref count is 1 ... std::weap_ptr\u003cWidget\u003e wpw(spw); // ref count remains 1 ... spw = nullptr; 可以用expired()来检测std::weak_ptr指向的对象是否有效 if (wpw.expired()) ... 另一个常用的操作是lock()，它能原子地检测对象是否有效，以及返回这个对象的std::shared_ptr std::shared_ptr\u003cWidget\u003e spw = wpw.lock(); // if wpw's expired, spw is null 与之类似的操作是用std::weak_ptr构造一个std::shared_ptr std::shared_ptr\u003cWidget\u003e spw(wpw); 区别在于，如果wpw已经失效了，这次构造会抛std::bad_weak_ptr的异常 下面我们用几个例子来说明std::weak_ptr的必要性 想象我们要实现一个cache，希望其中的元素在无人使用后被销毁。这里我们用std::unique_ptr并不合适，因为cache天然需要共享的语义。这样每个调用者都可以获得一个cache中元素的std::shared_ptr，它的生命期由调用者控制。cache内还需要保存一份元素的指针，且有能力检测它是不是失效了。这里我们需要的就是std::weak_ptr std::shared_ptr\u003cconst Widget\u003e fastLoadWidget(WidgetID id) { static std::unordered_map\u003cWidgetID, std::weak_ptr\u003cconst Widget\u003e\u003e cache; auto objPtr = cache[id].lock(); if (!objPtr) { objPtr = loadWidget(id); cache[id] = objPtr; } return objPtr; } // 请不用在意上面的static，这只是个示意 第二个例子是设计模式中的“观察者模式”。它的一种典型实现是每个主题对象持有一组观察者的指针，每当主题对象有状态变化时依次通知每个观察者。这里主题对象不需要控制观察者的生命期，但需要知道观察者的指针是否还有效。用std::weak_ptr就可以非常自然的实现出这样的特性 第三个例子是，当A和C都持有B的std::shared_ptr时，如果B也需要持有A的某种指针，该持有什么？ 裸指针：如果A析构了，但C还在，B也就还在，此时B持有的A的裸指针就成了空悬指针，不好 std::shared_ptr：这样A与B就形成了循环依赖，永远不可能析构了 std::weak_ptr：唯一的好选择 但要注意的是，用std::weak_ptr来解std::shared_ptr可能造成的循环依赖，这种特性本身并没有价值。设计良好的数据结构，比如树，父节点控制子节点的生命期，但子节点也需要持有父节点的指针，这里最好的方案是父节点用std::unique_ptr来持有子节点，而子节点直接持有父节点的裸指针。即，严格层次结构，明确生命期的场景，不需要使用std::weak_ptr。std::weak_ptr的价值在于：在生命期不明确的场景，可以知道对象是否还有效 在效率方面，std::weak_ptr的大小与std::shared_ptr是相同的，它们使用相同的控制块，区别在于std::weak_ptr不会影响控制块中的引用计数，只会影响其中的弱引用计数 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:4:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"Summary std::weak_ptr 用来模仿类似std::shared_ptr的可悬挂指针 潜在的使用 std::weak_ptr的场景包括缓存，观察者列表，以及阻止 std::shared_ptr 形成的环 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:4:1","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款21 优先用make_unique和make_shared而不是直接new 前言 先做一下介绍，std::make_shared是在C++11中增加的，但std::make_unique却是在C++14中增加的。如果你想在C++11中就用上std::make_unique，自己写一个简单版的也不难 template \u003ctypename T, typename... Ts\u003e std::unique_ptr\u003cT\u003e make_unique(Ts\u0026\u0026... params) { return std::unique_ptr\u003cT\u003e(new T(std::forward\u003cTs\u003e(params)...)); } 这个版本不支持数组，不支持自定义的销毁器，但这些都不重要，它足够用了。但要记住的是，不要把它放到namespace std下面 优先用这两个make的好处 这两个make函数的功能就不解释了，和它们类似的还有一个std::allocate_shared auto upw1(std::make_unique\u003cWidget\u003e()); std::unique_ptr\u003cWidget\u003e upw2(new Widget); auto spw1(std::make_shared\u003cWidget\u003e()); std::shared_ptr\u003cWidget\u003e spw2(new Widget); 上面这个例子说明了用make函数的第一个好处：不需要重复写一遍类型。所有程序员都知道：不要重复代码。代码越少，bug越少 异常安全性。想象我们有两个函数 void processWidget(std::shared_ptr\u003cWidget\u003e spw, int priority); int computePriority(); 调用代码很可能长成这个样子 processWidget(std::shared_ptr\u003cWidget\u003e(new Widget), computePriority()); // potential resource leak! 上面这行代码有内存泄漏的风险，为什么？根据C++标准，在processWidget的参数求值过程中，我们只能确定下面几点： new Widget一定会执行，即一定会有一个Widget对象在堆上被创建。 std::shared_ptr\u003cWidget\u003e的构造函数一定会执行。 computePriority一定会执行。 new Widget的结果是std::shared_ptr\u003cWidget\u003e构造函数的参数，因此前者一定早于后者执行。除此之外，编译器不保证其它操作的顺序，即有可能执行顺序为： new Widget 执行computePriority 构造std::shared_ptr\u003cWidget\u003e 如果第2步抛异常，第1步创建的对象还没有被std::shared_ptr\u003cWidget\u003e管理，就会发生内存泄漏。 如果这里我们用std::make_shared，就能保证new Widget和std::shared_ptr\u003cWidget\u003e是一起完成的，中间不会有其它操作插进来，即不会有不受智能指针保护的裸指针出现： processWidget(std::make_shared\u003cWidget\u003e(), computePriority()); // no potential resource leak 更高效 std:shared_ptr\u003cWidget\u003e spw(new Widget); 这行代码中，我们以为只有一次内存分配，实际发生了两次，第二次是在分配std::shared_ptr控制块。如果用std::make_shared，它会把Widget对象和控制块合并为一次内存分配 但是make函数也有一些缺点。 第一个缺点：无法传入自定义的销毁器。 第二个缺点：make函数初始化时使用了括号初始化，而不是花括号初始化，比如std::make_unique\u003cstd::vector\u003cint\u003e\u003e(10, 20)创建了一个有着20个值为10的元素的vector，而不是创建了{10, 20}这么两个元素的vector(参见Item7)。 第三个缺点：对象和控制块分配在一块内存上，减少了内存分配的次数，但也导致对象和控制块占用的内存也要一次回收掉。即，如果还有std::weak_ptr存在，控制块就要在，对象占用的内存也没办法回收。如果对象比较大，且std::weak_ptr在对象析构后还可能长期存在，那么这种开销是不可忽视的。 如果我们因为前面这三个缺点而不能使用std::make_shared，那么我们要保证，智能指针的构造一定要单独一个语句。回到之前processWidget的例子中，假设我们有个自定义的销毁器void cusDel(Widget* ptr);，因此不能使用std::make_shared，那么我们要这么写来保证异常安全性： std::shared_ptr\u003cWidget\u003e spw(new Widget, cusDel); processWidget(spw, computePriority()); 但这么写还不够高效，这里我们明确知道spw就是给processWidget用的，那么可以使用std::move，将其转为右值，来避免对引用计数的修改： std::shared_ptr\u003cWidget\u003e spw(new Widget, cusDel); processWidget(std::move(spw), computePriority()); ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:5:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"Summary 和直接使用new相比，使用make函数减少了代码的重复量，提升了异常安全度，并且，对于std::make_shared以及std::allocate_shared来说，产生的代码更加简洁快速 也会存在使用make函数不合适的场景：包含指定自定义的deleter,以及传递大括号initializer的需要 对于std::shared_ptr来说，使用make函数的额外的不使用场景还包含 带有自定义内存管理的class 内存非常紧俏的系统，非常大的对象以及比对应的std::shared_ptr活的还要长的std::weak_ptr ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:5:1","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["Effective Modern C++ 条款"],"content":"条款22 在用到PImpl惯用法时，在实现文件中定义特殊成员函数 我们经常用名为PImpl的方法来实现接口与实现分离，进而大大降低程序构建的时间 PImpl是指把类A中的所有数据成员都移到一个impl类中，A中只留下一个impl类型的指针 举一个例子 class Widget { public: Widget(); ... private: std::string name; std::vector\u003cdouble\u003e data; Gadget g1, g2, g3; // Gadget is some user-defined type }; Widget的数据成员的类型为std::string、std::vector\u003cdouble\u003e、Gadget，这样就至少要include三个头文件，这也意味着每个需要include了这个包含Widget定义的头文件的地方，都被动引入了三个头文件。如果有一天我们修改了Widget的实现，比如增加或删除了一个成员，即使它们都是private的，即使接口完全没有变化，所有include它的用户文件都要重新编译。我们不想污染用户文件，也不想用户文件因为我们的实现修改而重新编译，我们就可以用PImpl class Widget { public: Widget(); ~Widget(); ... private: struct Impl; Impl* pImpl; }; 注意这里出现的Impl类型只是声明，没有定义，称为“不完整类型”，这样的类型只支持很少的操作，其中包括了我们需要的：声明一个不完整类型的指针 对应的实现文件内容为 struct Widget::Impl { std::string name; std::vector\u003cdouble\u003e data; Gadget g1, g2, g3; }; Widget::Widget() : pImpl(new Impl) {} Widget::~Widget() { delete pImpl; } 有了智能指针后，我们觉得直接new和delete不好，需要用std::unique_ptr class Widget { public: Widget(); ... private: struct Impl std::unique_ptr\u003cImpl\u003e pImpl; }; 因为不需要手动的delete，我们没有自己实现Widget的析构函数 看起来都很美好，编译也没问题，但在用户要用时，出事了 Widget w; // error!!! 究其原因，是因为我们没有给Widget实现自定义的析构函数，因此编译器为Widget准备了一个。这个析构函数会被放到Widget的定义体内，默认是内联的，因此会有一份实现在用户文件中。~Widget中只做一件事：析构pImpl，即析构一个std::unique_ptr\u003cImpl\u003e。注意，我们隐藏了Impl的实现，在析构std::unique_ptr\u003cImpl\u003e时编译器发现Impl还是个不完整类型，此时对它调用delete是危险的，因此编译器用static_cast禁止了这种行为 解决方案很简单：自己实现Widget的析构函数 // widget.h class Widget { public: Widget(); ~Widget(); ... private: struct Impl std::unique_ptr\u003cImpl\u003e pImpl; }; // widget.cpp ... Widget::Widget() : pImpl(std::make_unique\u003cImpl\u003e()) {} Widget::~Widget() {} 参考条款17，更好的方法是将析构函数定义为= default Widget::~Widget() = default; 根据条款17，自定义的析构函数会阻止编译器生成移动构造函数和移动赋值函数，因此如果你想要Widget有移动的能力，就要自己实现 class Widget { public: Widget(); ~Widget(); Widget(Widget\u0026\u0026 rhs) = default; // right idea, wrong code! Widget\u0026 operator=(Widget\u0026\u0026 rhs) = default; ... }; 注意不要在这些特殊成员函数的声明后面加= default，这样会重复上面析构函数的问题：会被内联，因此在用户代码中有一份实现，遇到不完整类型，game over。我们要做的就是在.cpp中将它们的实现定义为= default 接下来就是复制构造函数和复制赋值函数了。我们用std::unique_ptr是为了更好的实现PImpl方法，这也导致了Widget无法自动生成复制函数（std::unique_ptr不支持），但这并不意味着Widget就不能支持复制了，我们还可以自己定义两个复制函数 // widget.h class Widget { public: ... Widget(const Widget\u0026 rhs); Widget\u0026 operator=(const Widget\u0026 rhs); ... }; // widget.cpp Widget::Widget(const Widget\u0026 rhs) : pImpl(nullptr) { if (rhs.pImpl) { pImpl = std::make_unique\u003cImpl\u003e(*rhs.pImpl); } } Widget\u0026 Widget::operator=(const Widget\u0026 rhs) { if (!rhs.pImpl) { pImpl.reset(); } else if (!pImpl) { pImpl = std::make_unique\u003cImpl\u003e(*rhs.pImpl); } else { *pImpl = *rhs.pImpl; } } 有意思的是，如果你把pImpl的类型改为std::shared_ptr\u003cImpl\u003e，你会发现上面所有这些注意事项，都不见了。你不需要手动实现析构函数、移动函数、构造函数，程序编译仍然是好的。 这种差异来自于std::unique_ptr和std::shared_ptr对自定义销毁器的支持方式不同。std::unique_ptr的目标是从体积到性能上尽可能与裸指针相同，因此它将销毁器类型作为模板参数的一部分，这样实现起来更高效，代价是各种特殊函数在编译时就要知道元素的完整类型。而std::shared_ptr没有这种性能上的要求，因此它的销毁器不是模板参数的一部分，性能会有一点点影响，但好处是不需要在编译特殊函数时知道元素的完整类型 std::shared_ptr在构造时就把销毁器保存在了控制块中，之后即使传递到了不知道元素完整类型的地方，它仍然能调用正确的销毁器来销毁元素指针。而std::unique_ptr是依靠模板参数提供的类型信息来进行销毁，因此必须要知道元素的完整类型 ","date":"2023-03-13","objectID":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/:6:0","tags":["Effective Modern C++ 条款"],"title":"条款18~22 智能指针","uri":"/effective-modern-c-%E6%9D%A1%E6%AC%BE18-22/"},{"categories":["缘起 在人群中 我看见你"],"content":"RTTI","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"c++ RTTI ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:0:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"什么是RTTI RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法 ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:1:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"typeid 对于c++的内置数据类型以及自己创建的类对象，typeid可以方便的输出他们的数据类型 使用这个运算符，会返回一个 type_info 对象的引用，这个对象的结构大致如下 class type_info { // data public: virtual ~type_info(); // is polymorphic bool operator==(const type_info\u0026) const noexcept; // can be compared bool operator!=(const type_info\u0026) const noexcept; bool before(const type_info\u0026) const noexcept; // ordering size_t hash_code() const noexcept; // for use by unordered_map and the like const char* name() const noexcept; // name of type type_info(const type_info\u0026) = delete; // prevent copying type_info\u0026 operator=(const type_info\u0026) = delete; // prevent copying }; 这个对象包含了一个对象的类型信息，也就是c++中的 RTTI 有趣的是，当typeid作用于指针时，会返回指针自身的类型，但当作用于派生类（有虚函数）的对象或引用时，则会返回这个对象实际的类型 下面是测试代码 现在有基类SceneEntry 和派生类SceneUser class SceneEntry { public: SceneEntry(unsigned long long id, const std::string\u0026 name); virtual ~SceneEntry() = default; }; class SceneUser : public SceneEntry { public: SceneUser(unsigned long long id, const std::string\u0026 name); virtual ~SceneUser() = default; }; ... int main() { SceneEntry* entry = new SceneUser(1, \"xiaoming\"); SceneUser user(1,\"\"); SceneEntry\u0026 entry2 = user; std::cout \u003c\u003c typeid(entry).name() \u003c\u003c std::endl; std::cout \u003c\u003c typeid(*entry).name() \u003c\u003c std::endl; std::cout \u003c\u003c typeid(entry2).name() \u003c\u003c std::endl; return 0; } 以上代码可以得到以下输出 \u003e ./test P10SceneEntry 9SceneUser 9SceneUser 可以看到对于指针类型，他返回的就是指针声明时的类型，上面的P就表示指针，而引用和类返回的则是他们实际对应的派生类。不过这种获取实际派生类时依赖的时虚函数表，因此没有虚函数的时候也就无从知晓了 当去掉虚函数以后，输出就变为了 P10SceneEntry 10SceneEntry 10SceneEntry 最终输出的都是基类 ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:2:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"dynamic_cast dynamic_cast原理 通过了解type_info，也就基本知道dynamic_cast的原理了，其实他就是利用RTTI去判断一个指针所指的类实际是什么的，不过这也依赖于虚函数表，所以当你dunamic_cast一个没有虚函数类的时候就会报错，但是static_cast并不会哦~ error: 'SceneEntry' is not polymorphic ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:3:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"RTTI原理 所以最终，要研究 typeid 和 dynamic_cast 这两个运算符的原理，本质其实是研究 RTTI 的原理 我们可以通过以下代码来进行试验 class X { public: X() { mX = 101; } virtual void vfunc() { cout \u003c\u003c \"X::vfunc()\" \u003c\u003c endl; } private: int mX; }; class XX : public X { public: XX(): X() { mXX = 1001; } virtual void vfunc() { cout \u003c\u003c \"XX::vfunc()\" \u003c\u003c endl; } private: int mXX; }; 首先定义两个有继承关系的类，并且定义一个虚函数，然后通过以下代码来验证一个对象的布局 typedef void (*FuncPtr)(); int main() { XX xx; FuncPtr func; char* p = (char*)\u0026xx;// 此处声明为 char * 的原因主要是为了 + sizeof (xx) 时加对应 n 个字节，从而方便获取 n 个字节后的地址 // 获得虚函数表的地址 void** vtbl = (void**)*(void**)p; // 此处声明成二级指针也是为了在下面 [] 运算时按指针的步长取 // 输出虚函数表的地址，即 vptr 的值 cout \u003c\u003c vtbl \u003c\u003c endl; // 获得 type_info 对象的指针，并调用其 name 成员函数 cout \u003c\u003c \"\\t[-1]: \" \u003c\u003c (vtbl[-1]) \u003c\u003c \" -\u003e \" \u003c\u003c ((type_info*)(vtbl[-1]))-\u003ename() \u003c\u003c endl; // 调用第一个 virtual 函数 cout \u003c\u003c \"\\t[0]: \" \u003c\u003c vtbl[0] \u003c\u003c \" -\u003e \"; func = (FuncPtr)vtbl[0]; func(); // 输出基类的成员变量的值 p += sizeof(int**); cout \u003c\u003c *(int*)p \u003c\u003c endl; // 输出派生类的成员变量的值 p += sizeof(int); cout \u003c\u003c *(int*)p \u003c\u003c endl; return 0; } 运行得到以下输出 \u003e ./classStructTest 0x105127110 [-1]: 0x105127130 -\u003e 2XX [0]: 0x1051261d0 -\u003e XX::vfunc() 101 1001 由此可以得到 c++ 中的一个包含虚函数的 XX 对象的大致布局： 一个对象的内存第一段会保存一个类的虚函数表的指针，指针指向了虚函数表，即一个函数指针数组，而在这个虚函数表指针指向的地址前一个位置保存了一个 type_info 的指针。而虚函数表指针后面跟着的分别是父类的成员变量和自身的成员变量。 但当我们把虚函数去掉以后，再运行代码就会报错： 因此这种没有多态性质的类内存结构是不同的。这种类的 RTTI 信息在编译后便可以确定，所以猜想可能编译时就带入地址了（不过没查到相关资料，待考证）。因此不需要动态的通过类的虚函数表中的 type_info 去确定 ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:4:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["缘起 在人群中 我看见你"],"content":"Summary 通过 RTTI 可以让 c++ 在运行时去确定一个对象的实际类型，从而我们可以利用 dynamic_cast 去正确地转换。看到大佬代码用了这么多指针的转换，越来越觉得它是个很自由的语言，它应该是高级语言中最接近底层，最容易操作内存的语言了，不过这也对使用者有较高的要求，学习之路漫漫呀～ ","date":"2023-03-11","objectID":"/%E7%BC%98%E8%B5%B7-rtti/:5:0","tags":["RTTI"],"title":"RTTI","uri":"/%E7%BC%98%E8%B5%B7-rtti/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了位运算的一些场景","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"前言 本文分三个部分 有趣的位运算 算法比较常用的 n \u0026 (n - 1) 算法例题 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"位运算符 左移 \u003c\u003c 0011 -\u003e 0110 右移 \u003e\u003e 0110 -\u003e 0011 按位或 | 0011 -----\u003e 1011 1011 按位与 \u0026 0011 -----\u003e 0011 1011 按位取反 ~ 0011 -\u003e 1100 按位异或 ^ 0011 -----\u003e 1000 1011 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"XOR 异或 异或: 相同为0 不同为1 也可用 \"不进位加法\" 来理解 异或操作的一些特点: x ^ 0 = x x ^ 1s = ~x // 注意 1s = ~0 x ^ (~x) = 1s x ^ x = 0 c = a ^ b =\u003e a ^ c = b, b ^ c = a // 交换两个数 a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:3:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"有趣的位运算 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将x最右边的n位清零 x \u0026 (~0 \u003c\u003c n) ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:1","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"获取x的第n位值 (0 或者 1) (x \u003e\u003e n) \u0026 1 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:2","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"获取x的第n位的幂值 x \u0026 (1 \u003c\u003c (n - 1)) ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:3","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"仅将第n位置为1 x | (1 \u003c\u003c n) ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:4","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"仅见第n位置为0 x \u0026 (~(1 \u003c\u003c n)) ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:5","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将x最高位至第n位 (含)清零 x \u0026 ((1 \u003c\u003c n) -1) ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:6","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将第n位至第0位 x \u0026 (~((1 \u003c\u003c (n-1))-1)) ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:7","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"判断奇偶 x % 2 == 1 ---\u003e (x \u0026 1) == 1 x % 2 == 0 ---\u003e (x \u0026 1) == 0 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:8","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"x » 1 —\u003e x / 2 即 x = x/2; ---\u003e x = x \u003e\u003e 1; ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:9","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"得到最低位的1 X \u0026 -X ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:10","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"X \u0026 ~X -\u003e 0 X \u0026 ~X -\u003e 0 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:11","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"将英文字符串转为大小写 大写变小写、小写变大写 : 字符 ^= 32; 大写变小写、小写变小写 : 字符 |= 32; 小写变大写、大写变大写 : 字符 \u0026= -33; /* 以上操作能够产生奇特效果的原因在于 ASCII 编码 字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了 */ ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:12","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"判断两个数是否异号 int x = -1, y = 2; bool f = ((x ^ y) \u003c 0); // true int x = 3, y = 2; bool f = ((x ^ y) \u003c 0); // false ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:13","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"交换两个数 int a = 1, b = 2;a ^= b;b ^= a;a ^= b; ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:14","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"加1 int n = 1;n = -~n; ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:15","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"减1 int n = 2;n = ~-n; // 现在 n = 1 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:4:16","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"算法常用操 n\u0026(n-1) 这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:5:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 二进制中的1的个数 LCR 133. 位 1 的个数 - 力扣（LeetCode） 思路详解： `就是让你返回 n 的二进制表示中有几个 1 因为 n \u0026 (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止 int hammingWeight(uint32_t n) { int res = 0; while (n != 0) { n = n \u0026 (n - 1); res++; } return res; } ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:5:1","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"题目推荐 ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:6:0","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 插入 题目url 面试题 05.01. 插入 - 力扣（LeetCode） 解题思路 先将N的第i ~ j位全部置零； 在将M左移i位，使之对其上一步中N置零的位，直接相加即可。 示例代码 class Solution { public: int insertBits(int N, int M, int i, int j) { for (int k = i; k \u003c= j; ++ k) { //举例说明： (1 \u003c\u003c 3) 表示 00001000，取反后得 11110111 // N \u0026= (11110111) 表示将 N 的第3位置零了 N \u0026= ~(1 \u003c\u003c k); } return N + (M \u003c\u003c i); } }; ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:6:1","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["算法 \u0026 数据结构"],"content":"例题2 - 翻转数位 题目url 面试题 05.03. 翻转数位 - 力扣（LeetCode） 方法1 - 位运算 /* 在遍历num每一位时，追踪当前1序列的长度和上一段1序列的长度； 当遇到比特位为0时，分两种情况讨论： 1、若下一个比特位为1，那么preLen = curLen； 2、若下一个比特位为0，那么preLen = 0，我们不能合并这两个1序列 */ class Solution { public: int reverseBits(int num) { if (~num == 0) return 32; //全是1的情况，若不特判会输出33 int curLen = 0, preLen = 0； int maxLen = 1; //最少也能翻转1位 for (int i = 0; i \u003c 32; ++ i) { if ((num \u0026 1) == 1) { curLen ++ ; } else { preLen = ((num \u0026 2) == 0) ? 0 : curLen; //判断下一比特位是否为0 curLen = 0; } maxLen = max(maxLen, preLen + curLen + 1); num \u003e\u003e= 1; } return maxLen; } }; ","date":"2023-03-10","objectID":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/:6:2","tags":["位运算"],"title":"位运算","uri":"/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["Effective C++"],"content":"条款41~48 模板与泛型编程","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款41~48 模板与泛型编程 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:0:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款41 隐式接口和编译器多态 什么是显式接口和运行期多态 在面向对象编程世界里总是以显式接口和运行期多态解决问题，举个例子 // 无意义的类 class Widget{ public: Widget(); virtual Widget(); virtual std::size_t size() const; virtual void normalize(); void swap(Widget\u0026 other); } // 无意义的函数 void doProcessing(Widget\u0026 w){ if(w.size()\u003e10 \u0026\u0026 w!= somNastyWidget){ Widget temp(w); temp.normalize(); temp.swap(w); } } 在上述代码中，可知 由于w的类型被声明为Widget，所以w必须支持Widget接口。我们可以在源码中找出这个接口，看看它是什么样子，所以我们称此为一个显式接口，也就是他在源码中明确可见 由于Widget的某些成员是 virtual，w对那些函数的调用将表现出运行时多态，也就是说将于运行期根据w的动态类型（条款37）决定究竟调用哪一个函数 Template及泛型编程 Template及泛型编程与面向对象有根本不同。implicit interface 和 compile-time polymorphism移到前头。 还是用上一个例子，一探究竟，我们将doProcessing函数变成function template时看看发生咩事 template\u003ctypename T\u003e void doProcessing\u003cT\u0026 w\u003e { if (w.size() \u003e 10 \u0026\u0026 w != someNastyWidget) { T temp(w); temp.normalize(); temp.swap(w); } } 这里的doProcessing内的的w是如何操作的呢 w必须支持的哪一种接口，由template中执行于w身上的操作来决定 本例w的类型T必须支持size，normalize和swap成员函数，copy构造函数、不等比较!=，并非完全正确。这一组表达式便是T必须支持的一组隐式接口 凡设计w的任何函数调用，例如operator\u003e和operator!=，有可能造成template具现化，是这些调用得以成功。这样的具现行为发生在编译器。“以不同的template参数具现化会导致调用不同的函数，这便是所谓的编译器多态” 现在我们再来细看下述代码 template\u003ctypename T\u003e void doProcessing(T\u0026 w) { if (w.size() \u003e 10 \u0026\u0026 w != someNastyWidget) { ... } } T(w的type)的隐式接口看来好像有这些约束 必须提供一个名为size的成员函数，该函数返回一个整体值 必须支持一个operator!=函数，用来比较两个T对象 真要感谢操作符重载带来的可能性，这两个约束都不需要满足 是的，T必须支持size成员函数，然而这个函数也可能从base class继承而得。这个成员函数不需要返回一个整数值，甚至不需要返回一个数值类型。就此而言，他甚至不需要返回一个定义有operator\u003e的类型，他唯一需要做的就是返回一个类型为x的对象，而x对象加上一个int(10的类型)必须能够调用一个operator\u003e。这个operator\u003e不需要非得取得一个类型为x的参数不可，因为他可以取得类型Y的参数，只要存在一个隐式转换能够将类型x转换为类型y的对象 加诸于template参数身上的隐式接口，就像加诸于class对象身上的显式接口一样真实，而且两者都在编译期完成检查。就像你无法以一种\"与class提供之显式接口接口矛盾\"的方式来使用对象（代码无法通过编译），你也无法在template中使用\"不支持template所要求之隐式接口\"的对象（代码一样无法通过编译） ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:1:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary classes 和 template都支持接口和多态 对于classes而言接口是显式的，以函数签名为中心，多态则是通过virtual function发生于运行期 对template参数而言，接口是隐式的，基于有效表达式，多态则是通过template具现化和函数重载解析发生于编译期 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:1:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款42 了解typename 我们看以下代码 template\u003ctypename C\u003e void print2nd(const C\u0026 container) { if (container.size() \u003e= 2) { C::const_iterator iter(container.begin()); ... } } 现在应该很清楚为什么这不是有效的c++代码了吧。iter声明式只有在C::const_iterator是个类型时才合理，但我们并没有告诉c++说他是，于是c++假设他不是 若要矫正这个，我们必须告诉c++说C::const_iterator是个类型。只要紧临它之前放置关键字typename即可 template\u003ctypename C\u003e void print2nd(const C\u0026 container) { if (container.size() \u003e= 2) { typename C::const_iterator iter(container.begin()); ... } } 再次强调一下，任何时候当你想要在template中指一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename typename知识用来言明嵌套从属类型名称，其他名称不该有他的存在。例如下面这个function template，接收一个容器和一个指向该容器的迭代器 template\u003ctypename C\u003e // 允许使用 \"typename\" (或 class) void f(const C\u0026 container, // 不允许使用 \"typename\" typename C::iterator iter); // 一定要使用 typename 上述的c并不是嵌套从属类型名称（他并非嵌套于任何 取决于template参数 的东西内），所以声明container时并不需要以typename为前导，但C::iterator是个嵌套从属类型名称，所以必须以typename为辅导 typename必须作为嵌套从属类型名称的前缀词，这一规则的例外是，typename不可以出现在 base classed list内的嵌套从属类型名称之前，也不可在 member initialization list（成员初始列）中作为 base class 修饰符。例如 template\u003ctypename T\u003e class Derived : public Base\u003cT\u003e::Nested { // base class list中不允许 typename public: explicit Dervied(int x) : Base\u003cT\u003e::Nested(x) { // mem.init.list中 不允许 typename typename Base\u003cT\u003e::Nested temp; // 不再上述的两个特殊情况内，作为一个 base class 修饰符 需加上 typename } } ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:2:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 声明 template 参数时，前缀关键字 class 和 typename 可互换 请使用关键字 typename 标识嵌套从属类型名称，但不得在 基类列 或者 成员初始列 内以他作为 base class 修饰符 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:2:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款43 调用基类模板成员 模板中，派生类不可调用模板基类的成员函数 在模板类中，如果一个派生类在其方法中调用了基类的方法，那么这段代码可能无法编译通过 备注（重点）： ​ 这一现象是与编译器有关的，Effective C++的作者编译的时候出错，本人使用VS编译的时候没有出错，因此这个问题是与编译器有关 假设现在有这样一个类体系： 我们有若干公司类，其包含两个成员函数可以用来将信息发送到公司（一个为发送加密信息，一个为发送不加密信息） 有一个MsgSender类，其中有两个成员函数，函数中可以定义若干公司，然后调用公司的成员方法向公司发送信息 有一个MsgInfo类，用来封装消息（这个类不重要） //公司类 class CompanyA { public: void sendCleartext(const std::string\u0026 msg); //向公司发送未加密信息 void sendEncrypted(const std::string\u0026 msg); //向公司发送加密信息 }; class MsgInfo {}; //封装信息的类 //发送信息类 template\u003ctypename Company\u003e class MsgSender { public: //在其中定义公司A，并调用公司A的sendCleartext()函数向公司A发送信息 void sendClear(const MsgInfo\u0026 info) { std::string msg; CompanyA a; a.sendCleartext(msg); } //同上，只是发送加密信息 void sendSecret(const MsgInfo\u0026 info) { std::string msg; CompanyA a; a.sendEncrypted(msg); } }; 现在我们为MsgSender类添加了一个派生类，我们希望每次在发送信息的时候记录一下日志。因此定义如下： template\u003ctypename Company\u003e class LoggingMsgSender:public MsgSender\u003cCompany\u003e{ public: void sendClearMsg(const MsgInfo\u0026 info) { //记录一下日志 sendClear(info); //调用基类的方法发送消息，这段代码可能无法编译通过 //记录一下日志 } void sendSecretMsg(const MsgInfo\u0026 info) { //记录一下日志 sendSecret(msg); //调用基类的方法发送消息，这段代码可能无法编译通过 //记录一下日志 } }; 上面代码对于某些编译器会出错的原因在于： 编译期出错：当类遇到LoggingMsgSender类模板定义式时，其并不知道LoggingMsgSender继承的class属于什么类型，因为还没有具体被实例化 因此在编译到LoggingMsgSender的成员函数时，其并不知道其基类是否有一个sendClear()函数* 解决上面错误的3种方法 使用this指针：使用this指针调用这些函数，实现先告诉编译器这些函数是属于自身类的（在编译之后它们会从基类中继承而来） template\u003ctypename Company\u003e class LoggingMsgSender:public MsgSender\u003cCompany\u003e{ public: void sendClearMsg(const MsgInfo\u0026 info) { //记录一下日志 this-\u003esendClear(info); //记录一下日志 } void sendSecretMsg(const MsgInfo\u0026 info) { //记录一下日志 this-\u003esendSecret(info); //记录一下日志 } }; 使用using声明式 注意这种using声明式与非模板类的不同 在非模板类中，使用using是为了防止派生类隐藏继承的方法，而使基类中的方法在派生类中可见 在模板类中，使用using是为了让编译器去基类中查找这个函数 template\u003ctypename Company\u003e class LoggingMsgSender:public MsgSender\u003cCompany\u003e{ public: using MsgSender\u003cCompany\u003e::sendClearMsg; using MsgSender\u003cCompany\u003e::sendSecretMsg; void sendClearMsg(const MsgInfo\u0026 info) { //记录一下日志 sendClear(info); //记录一下日志 } void sendSecretMsg(const MsgInfo\u0026 info) { //记录一下日志 sendSecret(info); //记录一下日志 } }; 明确指出被调用的函数位于base class中 这种方法不太建议，因为：被调用的函数可能是virtual函数，这种修饰符会关闭“virtual绑定行为” template\u003ctypename Company\u003e class LoggingMsgSender:public MsgSender\u003cCompany\u003e{ public: void sendClearMsg(const MsgInfo\u0026 info) { //记录一下日志 sgSender\u003cCompany\u003e::sendClear(info); //记录一下日志 } void sendSecretMsg(const MsgInfo\u0026 info) { //记录一下日志 sgSender\u003cCompany\u003e::sendSecret(info); //记录一下日志 } }; ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:3:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 当一个类的基类包含模板参数时，需要通过this-\u003e的方式调用基类内的函数，例如 class F: public S\u003cC\u003e，在F中的成员函数中调用S中的成员函数this-\u003etest()，而直接写test()无法通过编译，原因是因为C是个模板没有办法确定类S的具体长相，或者说无法确定S中一定有test函数，即使你写的所有C都包含test函数，但是在编译器看来它是不确定这个问题的，因此无法通过编译 解决办法是： 使用this-\u003etest，这样做告诉编译器假设这个test已经被继承了 使用using声明式：using S\u003cC\u003e::test告诉编译期这个test位于S内。相当于必须手动通知编译器这个函数是存在的 直接指明 但是不推荐 因为丧失多态特性 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:3:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款44 将与参数无关的代码抽离template Templates能够节省时间和避免代码反复。对于相似的classes或functions。能够写一个class template或function template，让编译器来做剩余的事。这样做，有时候会导致代码膨胀（code bloat）：其二进制码带着反复（或差点儿反复）的代码、数据。或者两者。 但这时候源代码看起来可能非常整齐。 先来学习一个名词：共性与变性分析（commonality and variability analysis）。 还是比较容易理解的。比如，你在编写几个函数，会用到同样作用的代码。这时候你往往将同样代码搬到一个新函数中。给其它几个函数调用。同理，假设编写某个class。当中某些部分和另外几个class同样，这时候你不会反复编写这些同样部分，仅仅需把共同部分搬到新class中去就可以，去使用继承或复合（Item32 Item38 Item39），让原先的classes取用这些共同特性，原classes的互异部分（变异部分）仍然留在原位置不动。 编写templates时，也要做同样分析，避免反复。non-template代码中反复十分明白：你能够看到两个函数或classes之间有所反复。可是在template代码中，反复是隐晦的。由于仅仅有一份template源代码。 比如。你打算在为尺寸固定的正方矩阵编写一个template，该矩阵有个支持逆矩阵运算的函数 template\u003ctypename T, std::size_t n\u003e // T为数据类型。n为矩阵大小 class SquareMatrix{ public: …… void invert();// 求逆运算 }; SquareMatrix\u003cdouble,5\u003e sm1; sm1.invert(); // 调用SquareMatrix\u003cdouble,5\u003e::invert SquareMatrix\u003cdouble,10\u003e sm2; sm2.invert(); // 调用SquareMatrix\u003cdouble,10\u003e::invert 上面会详细化两份invert。 这两份函数差点儿全然同样（除了一个操作55矩阵。一个操作1010）。这就是代码膨胀的一个典型样例。 上面两个函数除了操作矩阵大小不同外。其它同样。这时能够为其建立一个带数值的函数，而不是反复代码。于是有了对SquareMatrix的第一份改动 template\u003ctypename T\u003e class SquareMatrixBase{ protected: void invert(std::size_t matrixSize); …… }; template\u003ctypename T, std::size_t n\u003e class SquareMatrix : private SquareMatrixBase\u003cT\u003e{ private: using SquareMatrixBase\u003cT\u003e::invert(); // 编码遮掩base中的invert，条款33有说到 public: …… void invert() { // 求逆运算 this-\u003einvsert(n); // 稍后解释为什么用this } }; SquareMatrixBase::invert仅仅是企图避免derived classes代码反复，所以它以protected替换public。这个函数使用this-\u003e，由于模板化基类内的函数名称会被derived classes掩盖（条款43） 注意，SquareMatrixBase和SquareMatrix之间继承关系是private。这说明base class是为了帮助derived classes实现，两者不是is-a关系 如今另一个问题，SquareMatrixBase::invert操作的数据在哪？它在參数中直到矩阵大小，可是矩阵数据derived class才知道。derived class和base class怎样联络？一个做法是能够为SquareMatrixBase::invert加入一个參数（比如一个指针）。 这个行得通，可是考虑到其它因素（比如，SquareMatrixBase内还有其它函数。也要操作这些数据），能够把这个指针加入到SquareMatrixBase类中 template\u003ctypename T\u003e class SquareMatrixBase{ protected: SquareMatirxBase(std::size_t n, T* pMem) : size(n), pData(pMem) { } void setDataPtr(T* ptr) { pData=ptr; } …… private: std::size_t size; T* pData; }; template\u003ctypename T, std::size_t n\u003e class SquareMatrix : private SquareMatrixBase\u003cT\u003e{ public: SquareMatrix() : SquareMatrixBase\u003cT\u003e(n, data) { } …… private: T data[n*n]; }; 这样的类型的对象不须要动态分配内存。可是对象自身可能非常大。另一个做法是把矩阵数据放到heap template\u003ctypename T, std::size_t n\u003e class SquareMatrix : private SquareMatrixBase\u003cT\u003e{ public: SquareMatrix() : SquareMatrixBase\u003cT\u003e (n, 0), pData(new T[n*n]) { this-\u003esetDataPtr(pData.get()); } …… private: boost::scoped_array\u003cT\u003e pData; }; 这样以来。类型同样的derived classes会共享base class。比如。SquareMatrix ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:4:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 原因是模板会根据具体类型具象化不同的代码，如果将与模板无关的代码也放入模板函数或者类中，那么就会生成重复的代码，就会导致代码膨胀的问题，函数模板中与参数无关的代码可以包装成单独的函数。类模板中与参数无关的模板可以放到父类中 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:4:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款45 运用成员函数模板接受全部兼容类型 隐式转化（前言） 该条款作者阐述自己的观点是通过智能指针的样例 所以我们复习一下隐式转化的问题，例如以下代码 #include\u003ciostream\u003e using namespace std; class A { public: explicit A(int i) : a(i) {}; A(const A\u0026 obj) : a(obj.a) {} private: int a; }; int main() { int value =0; A a = value; // 编译不通过。由于构造函数中有explicit限定符 return 0; } *我们知道由于explicit限定符的存在编译不通过* 2. *问题抛出* *既然复习完了，我们来看看书上另一段代码* ```cpp template\u003ctypename T\u003e class SmartPtr { public: explicit SmartPtr(T* realPtr); ... }; SmartPtr\u003cTop\u003e pt1 = SmartPtr\u003cMiddle\u003e(new Middle); SmartPrt\u003cTop\u003e pt2 = SmartPrt\u003cBottom\u003e(new Bottom); SmartPrt\u003cconst Top\u003e pt2=pt1; 我们能够知道，由于SmartPtr\u003cTop\u003e类型和SmartPtr\u003cMiddle\u003e类型不同，再加上explicit SmartPtr\u003cMiddle\u003e中的explicit限定符，SmartPtr\u003cTop\u003e pt1=SmartPtr\u003cMiddle\u003e(new Middle);这句代码编译不通过。 并且编译器并不觉得SmartPtr\u003cTop\u003e类型和SmartPtr\u003cMiddle\u003e类型存在继承关系 为了能够实现相互转化。能够加入本节的主旨技术去解决上面出现的问题 解决方法 template\u003ctypaname T\u003e class SmartPtr{ public: template\u003ctypename U\u003e SmartPrt(const SmartPrt\u003cU\u003e\u0026 other) : heldPrt(other.get()) { }; T* get() const{ return heldPrt; } …… private: T* heldPrt; }; SmartPtr\u003cTop\u003e pt1 = SmartPtr\u003cMiddle\u003e(new Middle); SmartPrt\u003cTop\u003e pt2 = SmartPrt\u003cBottom\u003e(new Bottom); SmartPrt\u003cconst Top\u003e pct2 = pt1; 我们加入了一个member function template函数。由于typename T和typename U 是两种类型，并且构造函数中没有explicit关键字，不会阻止heldPrt(other.get())的隐式转换 所以，以上代码能够通过编译 TR1规范中关于tr1::shared_ptr的一份摘录 template\u003cclass T\u003e class shared_ptr{ public: template\u003cclass Y\u003e explicit shared_ptr(Y* p); template\u003cclass Y\u003e shared_ptr(shared_ptr\u003cY\u003e const\u0026 r); template\u003cclass Y\u003e explicit shared_ptr(weak_ptr\u003cY\u003e const\u0026 r); template\u003cclass Y\u003e explicit shared_ptr(auto_ptr\u003cY\u003e const\u0026 r); template\u003cclass Y\u003e shared_ptr\u0026 operator=(shared_ptr\u003cY\u003e const\u0026 r); template\u003cclass Y\u003e shared_ptr\u0026 operator=(auto_ptr\u003cY\u003e const\u0026 r); …… }; 我们能够发现上面仅仅有泛化copy构造函数不是explicit，表示shared_ptr 的隐式转化被同意，而其它的智能指针转化不被同意 这里另一个须要注意的地方，在class类声明泛化copy构造函数（member template）。并不会阻止编译器生成它们自己的copy构造函数（non-template），换言之。假设程序中仅仅写了泛化的copy构造函数，那么编译器还是会自己主动生成一个非泛化的版本号出来，假设不想要这个缺省版本号，那一定不能偷懒。要两个版本号的copy构造函数都要写 template\u003ctypaname T\u003e class SmartPtr{ public: template\u003ctypename U\u003e SmartPrt(const SmartPrt\u003cU\u003e\u0026 other) : heldPrt(other.get()) {}; SmartPtr() {} // 假设不写自己的非泛化构造函数，编译器会自己主动生成自己的默认非泛化构造函数。 T* get() const{ return heldPrt; } …… private: T* heldPrt; }; ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:5:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 请使用member function templates（成员函数模板）生成“可接受全部兼容类型”的函数 假设你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是须要声明正常的copy构造函数和copy assignment操作符 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:5:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款46 需要类型转换时请为模板定义非成员函数 这个条款是在《Item24》的基础上，讲述有关非成员函数在模板类中的作用，所以忘了的要去复习下 想要在template实现Item24的功能，还得考虑其他问题 template\u003ctypename T\u003e class Rational{ public: Rational(const T\u0026 numerator=0,const T\u0026 denominator=1); const T numerator() const; const T denominator() const; …… }; template\u003ctypename T\u003e const Rational\u003cT\u003e operator*(const Rational\u003cT\u003e\u0026 lhs,const Rational\u003cT\u003e\u0026 rhs) { …… }; Rational\u003cint\u003e oneHalf(1,2); Rational\u003cint\u003e result = oneHalf*2; // 错误 无法通过编译 大家思考一下为什么oneHalf*2这句话不能通过编译 事实上，operator模板函数中參数有两个，所以它会分别对这两个参数进行匹配来确定函数模板类型，试想一下，函数模板在没有实例化之前是不存在的，不存在的函数怎么会实现參数的隐式转换？我们来判断一般模板函数的运行过程。首先，模板函数通过自身參数实例化，实例化之后才会被调用运行。然而。对于本例来说，两个參数的类型一个是Rational\u003cint\u003e，还有一个是2，在编译期间前者能够被判断出来类型是int的rational，后者却判断不出来。由于在template实參推导过程中从不将隐式类型转换考虑在内 为了能让编译通过，我们能够进行例如以下改变 template\u003ctypename T\u003e class Rational { public: …… friend const Rational operator*(const Rational\u0026 lhs,const Rational\u0026 rhs); { return Rational（lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } }; 将operator变成Rational类的友元函数。这样在定义一个Rational\u003cint\u003e对象的时候，operator模板函数事实上已经被实例化了，这时候再调用oneHalf*2这句话的时候，就是直接调用已经实例化的operator函数了，所以，此时，它支持隐式转换。将2转换为Rational\u003cint\u003e对象* 值得一提的是以上代码也可写成例如以下形式 template\u003ctypename T\u003e class Rational { public: …… friend const Rational\u003cT\u003e operator*(const Rational\u003cT\u003e\u0026 lhs,const Rational\u003cT\u003e\u0026 rhs); { return Rational\u003cT\u003e（lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } }; 也就是说Rational\u003cT\u003e和Rational的形式是一个意思，为了简化，我们能够用Rational的形式 由于这样将友元函数定义在Rational类中，也就默认是内联函数inline了，为了避免复杂的friend函数影响代码体积，我们利用另外的一种形式实现* *例如以下代码 template\u003ctypename T\u003e class Rational;//forward decelarion template\u003ctypename T\u003e const Rational\u003cT\u003e doMultiply(const Rational\u003cT\u003e\u0026 lhs,const Rational\u003cT\u003e\u0026 rhs); template\u003ctypename T\u003e class Rational{ public: …… friend const Rational operator*(const Rational\u0026 lhs,const Rational\u0026 rhs);//声明+定义 { return doMultiply(lhs,rhs); } }; template\u003ctypename T\u003e const Rational\u003cT\u003e doMultiply(const Rational\u003cT\u003e\u0026 lhs,const Rational\u003cT\u003e\u0026 rhs) { return Rational\u003cT\u003e（lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator()); } 我们又又一次定义了一个非类成员函数non-member，将此函数的声明和定义都放在类的外部，这样就能避免代码膨胀问题 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:6:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 当编写一个class template时，它所提供之“与此template相关的”函数支持“全部參数之隐式类型转换”时，请将那些函数定义为class template内部的friend函数 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:6:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款47 请使用traits classes表现类型信息 STL迭代器分类 input迭代器 只能一次一步向前移动,客户只可读取(不能涂写)且只能读取一次它们所指的东西,模仿指向输入文件的阅读指针.例如istream_iterators output迭代器 与input迭代器类似,但\"一切只为输出\",只能一次一步向前移动,客户只可涂写(不能读取)且只能涂写一次它们所指向的东西,模仿指向输出文件的涂写指针.例如ostream_iterators forward迭代器 具有input迭代器和output迭代器的所有功能:只能一次一步向前移动,可以读或写其所指物一次以上.STL并未提供单向linked list,但某些程序库有(通常名为slist),这种容器的迭代器就是forward迭代器 bidirectional迭代器 它除了可以向前移动,还可以向后移动,一步只能一次,并可以读或写所指物一次以上.STL的list,set,multiset,map和multimap的迭代器就属于这一类 random迭代器 除了bidirectional迭代器的所有功能以外,还可以执行\"迭代器算数\",即在常量时间内向前或向后移动任意距离.例如vector,deque和string的迭代器 针对这五种分类,C++标准库分别提供专属的 struct 加以区分 struct input_iterator_tag {}; struct output_iterator_tag {}; struct forward_iterator_tag : public input_iterator_tag {}; struct bidirectional_iterator_tag : public forward_iterator_tag {}; struct random_access_iterator_tag : public bidirectional_iterator_tag {}; traits STL主要由\"用以表现容器,迭代器和算法\"的templates组成,单也覆盖若干工具性templates,例如用于将迭代器移动到某个给定距离的advance函数模板.正如1所言,不同迭代器具有不同接口,因而advance需要根据不同迭代器所能进行的操作确定不同实现,例如对于random迭代器,advance可以直接进行+=操作,而对于其他迭代器,则可能反复使用++或–,因此advance的实现可能像这样 template\u003ctypename IterT,typename DisT\u003e void advance(Iter\u0026 iter,Dist d){ if(iter is a random access iterator) //伪代码 iter+=d; else if(d\u003e=0) while(d--) ++iter; else while(d++) --iter; } 这种做法必须首先判断iter是否为random迭代器,因此需要取得类型的有关信息,traits技术就是用来使STL的某些泛型算法能够在编译期取得某些类型信息. “Traits并不是C++关键字或一个预先定义好的构件;它们是一种技术,也是一个C++程序员共同遵守的协议.““这个技术的要求之一是,它对内置类型和用户自定义类型的表现必须一样好” “Traits能够施行于内置类型\"意味着通过在类型内嵌套信息实现类型判断不可行,因此类型的traits信息必须位于类型自身之外.标准技术是把它置入一个template及一个或多个特化版本中.“这样的templates在标准程序库中有若干个,其中针对迭代器的被被命名为iterator_traits” template\u003ctypename IterT\u003e struct iterator_traits; iterator_traits的运作方式是:针对每一个类型IterT,在struct iterator_traits内一定声明某个typedef名为iterator_catagory,这个typedef用于确定Iter的迭代器分类: 对于自定义类型,它要求每一个用户\"自定义的iterator类型\"必须嵌套一个typedef,名为iterator_catagory(实际上,要使自定义的iterator支持更多的STL泛型算法,还需要其他typedef,见第3条),这个typedef用来确认Iter的分类 ,因此针对一个的确迭代器设计的class可能回想这样 template\u003c...\u003e class deque{ public: class iterator{ public: typedef random_access_iterator_tag iterator_category; ... }; ... } list的迭代器可能像这样: template\u003c...\u003e class list{ public: class Iterator{ public: typedef bidirectional_iterator_tag iterator_category; ... }; ... }; 至于iterator_traits,只是用来表现iterator class的嵌套式typedef template\u003ctypename IterT\u003e struct iterator_traits{ typedef typename IterT::iterator_category iterator_category; ... }; 对于指针迭代器,由于指针不可能嵌套typedef,iterator_traits特别针对指针类型提供一个偏特化版本: template\u003ctypename Iter\u003e struct iterator_traits\u003cIterT*\u003e{ typedef random_access_iterator_tag iterator_category; ... }; 由以上实例,trait classes的设计与实现过程大体如下: ​ 1). 确认若干想取得的类型相关信息.(对于迭代器,包括其category) ​ 2). 为该信息选择一个名称(对于迭代器的category,名称为iterator_category) ​ 3). 提供一个template和一组特化版本(例如iterator_traits),内含希望支持的类型信息. 因此,最开始的伪代码可以实行 template\u003ctypename IterT,typename DisT\u003e void advance(Iter\u0026 iter,Dist d){ if(typeid(typename::std::iterator_traits\u003cIterT\u003e::iterator_category ==typeid(typename::std::random_access_iterator_tag)) ... } 此时还未结束,因为以上代码会存在编译问题:假设对advance作以下调用 std::list\u003cint\u003e::iterator iter; advance(iter,10); 那么advance将被特化为以下形式: void advance(std::list\u003cint\u003e::iterator iter,int d){ if(typeid(typename::std::iterator_traits\u003cstd::list\u003cint\u003e::iterator\u003e:iterator_category==typeid(typename::std::random_access_iterator_tag)) iter+=d; //错误,编译时不通过! else if(d\u003e=0) while(d--) ++iter; else while(d++) --iter; } 尽管测试typeid的那一行总会因为list::iterator而失败,因而iter+=d永远不会执行,但在此之前编译器必须确保所有的源码有效,纵使是不会执行的代码! 此外,由于iterator_traits::category在编译期即可确定,但if语句的判断却要在运行期核定,这不仅浪费时间,也会造成可执行文件膨胀. 实际上,C++提供了完成在编译期进行核定的方法:函数重载.合成两种重载函数,但接受不同的iterator_category对象,由它们完成advance的实际功能,因此advance的最终实现版本如下: template\u003ctypename IterT,typename DistT\u003e void doAdvance(IterT\u0026 iter,Dist d,std::random_access_iterator_tag){ iter+=d; } template\u003ctypename IterT,typename DistT\u003e void doAdvance(IterT\u0026 iter,Dist d,std::bidirectional_iterator_tag){ if(d\u003e=0) while(d--) ++iter; else while(d++) --iter; } template\u003ctypename IterT,typename DistT\u003e void doAdvance(IterT\u0026 iter,Dist d,std::input_iterator_tag){ if(d\u003c0) throw out_of_range(\"Negative distance\"); while(d--) ++iter; } template\u003ctypename ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:7:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款48 模板元编程 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:8:0","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"Summary 什么是模板元编程 模板元编程(template mataprogramming,TMP)是编写C++程序并执行于编译期的过程,“所谓template mataprogram(模板元程序),是以C++写成,执行于C++编译器内的程序.一旦TMP程序结束执行,其输出,也就是从templates具现出来的若干C++源码,便会一如往常地被编译 模板元编程的优点 它让某些事情变得更容易 template program执行于C++编译期的特性使得工作可以从编译期转移至执行期,这使得错误可以被提前检测,并产出具有较小可执行文件,较短运行期,较少内存需求的文件,代价就是编译时间变长了. Item47中的traits解法就是TMP，因为traits引发编译期发生于类型身上的if…else运算：用编译期的重载模板函数参数匹配行为代替执行期发生的if…else运算功能 TMP已经被证明是\"图灵完全\"的,使用TMP可以声明变量,执行循环,编写及调用函数……针对TMP设计的程序库(例如Boost’s MPL)提供更高层次的语法.“但这般构件相对于正常的C++对应物看起来很是不同,例如Item47展示的TMP if-else条件句是藉由templates及其特化体表现出来”,另外一个例子是循环,TMP是的循环是藉由递归完成 用TMP实现一个计算阶乘的函如下 template\u003cunsigned n\u003e struct Factorial{ enum{value=n*Factiroal\u003cn-1\u003e::value;}; } template\u003c\u003e struct Factorial\u003c0\u003e{ enum{ value=1}; } TMP的重要应用 确保量度单位正确 优化矩阵运算 生成客户定制之设计模式实现品(如Strategy，Observer，Visitor等) TMP的缺点 语法不直观 编译时间长 ","date":"2023-03-09","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/:8:1","tags":["Effective C++"],"title":"条款41~48 模板与泛型编程","uri":"/effective-c-%E6%9D%A1%E6%AC%BE41-48/"},{"categories":["Effective C++"],"content":"条款32~40 继承与面向对象设计","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款32~40 继承与面向对象设计 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:0:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"前言 这一大章条款 主要是说的继承与面向对象设计，说实话我觉得没有看这一大章的必要，去看本博客的《设计模式》章节 设计模式这个名字太高大上，其实他就是可复用的面向对象设计，没错，你在学设计模式其实就是相当于学面向对象 设计模式也是基于面向对象设计原则的，所以你不懂设计模式，不懂面向对象设计原则，我觉得你看完这一章作用也不大 懂设计模式的希望你看本章节会有一些新的体会，其实每个条款都是对应着面向对象设计原则，同时也有很多设计模式可以解决这些条款的问题 没有错，在本大章节，我就是设计模式吹!!! ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:1:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款32 确保public继承是is-a关系 “is-a\"的概念 以 C++进行面向对象编程，最重要的一个规则是：public inheritance（公开继承）意味 “is-a”（是一种）的关系 如果你令 class D以 public 形式继承 class B，你便是告诉编译器： 每一个类型为D的对象同时也是一个类型为B的对象，反之不是 B对象可使用的地方，D对象一样可以使用，反之不是 下面的Student类 public 继承 Person类 class Person {}; class Student :public Person {}; 任何获得类型为Person（pointer-to-Person或reference-to-Person）的实参，都可以接受一个Student（pointer-to-Student或reference-to-Student）对象 void eat(const Person\u0026 p); void study(const Student\u0026 s); int main() { Person p; Student s; eat(p); //正确 eat(s); //正确 study(s); //正确 study(p); //错误 return 0; } 上面的规则只对\"public\"继承才成立哦～，“private\"“protected\"不成立 设计正确的继承模型 鸟可以飞，企鹅也是一种鸟。于是我们可能设计下面错误的继承模型 企鹅虽然属于鸟类，但是企鹅不会飞 设计中，我们错误的将鸟类中的fly()虚函数派生给了Penguin类 //鸟类 class Bird { public: virtual void fly(); }; //企鹅，也继承了fly()虚函数 class Penguin : public Bird {}; 我们应该修改上面的代码，下面才是合适的模型，学过设计模式知道抽象思想的，其实就是基于抽象类再抽象了一层 //鸟类 class Bird { //无fly()函数 }; //会飞的鸟类 class FlyingBird :public Bird { public: virtual void fly(); }; //企鹅不会飞 class Penguin :public Bird { }; 以“编译期”确认关系代替“运行期”确认关系 还是基于上述 鸟和企鹅的例子 企鹅不会飞，但是我们仍然让Bird定义fly()函数，然后让Penguin继承于Bird，与上面不同的是，我们让Penguin在执行fly()函数的时候报出一个错误（运行期执行） class Bird { public: virtual void fly(); }; void error(const std::string\u0026 msg); class Penguin :public Bird { public: virtual void fly() { error(\"Attempt to make a penguin fly!\"); } }; 上面的代码是在运行期检查这种错误的，下面我们设计让编译器在编译的时候检查出企鹅不会飞这种错误 class Bird { //无fly()函数 }; class Penguin :public Bird { //… }; Penguin p; p.fly(); *这个问题的关键是：并不是所有的鸟都会飞，因此Bird不应该暴露Fly接口* *所以还是再抽象一个会飞的鸟类接口，我觉得是可以的，但是也随之暴露一个问题了，面向对象设计原则有一个**类应该是单一职责**，如果不是单一职责，那么子类的数目就会急剧膨胀了* *其实知道装饰模式和桥模式，这里就可以利用 **组合**去优化，但是那是设计模式的知识点了，大家可以看《[装饰模式](https://vlicecream.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/)》《[桥模式](https://vlicecream.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%A8%A1%E5%BC%8F/)》* 再考虑矩形和正方形，从几何角度讲，正方形是一种矩形。从软件设计角度讲，正方形是矩形吗？应该使用public继承吗？ 思考：对矩形可以单独设置宽度，而不影响高度。但是对于正方形，设置宽度，要求高度随之变化，否者就不是正方形了。因此不能使用public继承 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:2:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"Summary public继承意味is-a 适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个bass class 对象 在类的设计上 其实要蛮下一番心思的（这其实就是题外话了，推荐本博客《设计模式》专题） ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:2:1","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款33 避免遮掩继承而来的名称 C++基类和派生类的作用域为嵌套关系,同时存在作用域屏蔽规则,例如: class Base{ public: void fun(); ... private: int a; ... } class Derived:public Base{ ... } 那么Derived和Base之间的作用域关系就像这样 如果Derived中没有定义a和fun,那么对在Derived作用域内对a的fun的使用将会由内而外直至全局作用域逐层查找; 如果Derived中定义了a和fun,那么会使用Derived中的a和fun,但是如果Derived中a和fun的定义如果像这样: class Derived:public Base{ public: void fun(int); string a; ... private: ... } 此时如果在Derived内存在如下语句: a=1; fun(); 都会编译不通过,因为由于名字屏蔽,Base的a和fun在Derived中将不可见,这就是作用域屏蔽规则.因此派生类对基类函数的重写将不是overload \u0026 override,而是隐藏 在采用public继承时,如果派生类重写基类函数,名字屏蔽会使得基类中同名函数在派生类中不可见 如果使基类的同名函数在派生类中仍然可见,可以使用using声明式 class Derived:public Base{ public: using Base::fun; void fun(int); ... private: string a; ... } 如果并不想继承Base类所有的fun函数(private继承中可能出现),则可以使用\"转交函数”(forwarding function)的方法 class Derived:private Base{ public: void fun(){ Base::fun(); } void fun(int); ... private: string a; ... } 此条款主要讲的也是违反了面向对象原则之一（里氏替换原则-我们应该去重写，而不是隐藏） ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:3:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"Summary 我们要小心谨慎 不能隐藏了父类函数 可以使用类名作用域决定调用父类还是子类的函数 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:3:1","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款34 接口继承与实现继承 说实话 这个思想我是真觉得你应该去看设计模式，光看这一个条款你可能不理解接口继承与实现继承，说到底其实就是一个抽象接口的思想，但是实现起来可是有一番难度的 本条款其实就是介绍了三种虚函数的好坏而已，同时看到这里大家有没有想起来《条款31》呀~ 好，进入主题 继承中接口的处理方式 作为类的设计者，对于基类的成员函数可以大致做下面三种方式的处理： ​ ① 纯虚函数：基类定义一个纯虚函数，然后让派生类去实现 ​ ② 非纯虚的virtual虚函数：基类定义一个非纯虚的virtual虚函数，然后让派生类去重写覆盖(override) ​ ③ 普通的成员函数：基类定义一个普通的成员函数，并且不希望派生类去隐藏 本文依次介绍上面这三种设计的原理。下面定义一个类，作为本文讲解的基础： - class Shape { public: virtual void draw()const = 0; //纯虚函数 virtual void error(const std::string\u0026 msg); //非纯虚函数 int objectID()const; //普通成员函数 }; class Rectangle :public Shape {}; class Ellipse :public Shape {}; 纯虚函数 这是文章开始提到的第一种情况：派生类只继承基类的成员函数的接口（纯虚函数），派生类自己实现纯虚函数 纯虚函数的一些特征： ① 拥有纯虚函数的类不能实例化 ② 拥有纯虚函数的类，其派生类必须实现该纯虚函数 class Shape { public: virtual void draw()const = 0; //纯虚函数 }; class Rectangle :public Shape {}; class Ellipse :public Shape {}; 其中涉及纯虚函数的目的为： Shape是所有图形类的基类，其提供一个draw()的画图函数，但是由于其派生类（矩形、圆等）的画图方式都是不一样的，因此无法为draw()函数提供一种默认缺省行为，因此Shape将draw()定义为纯虚函数， 让其派生类去自动实现 class Shape { public: virtual void draw()const = 0; }; class Rectangle :public Shape { public: virtual void draw()const { std::cout \u003c\u003c \"Rectangle\" \u003c\u003c std::endl; } }; class Ellipse :public Shape { public: virtual void draw()const { std::cout \u003c\u003c \"Ellipse\" \u003c\u003c std::endl; } }; int main() { //Shape *ps = new Shape; //错误，不能实例化 Shape *ps1 = new Rectangle; Shape *ps2 = new Ellipse; ps1-\u003edraw(); //调用Rectangle::draw() ps2-\u003edraw(); //调用Ellipse::draw() return 0; } 非纯虚的virtual虚函数 先来看一个virtual函数的演示案例 假设某航天公司设计一个飞机继承体系，该公司现在只有A型和B型两种飞机，代码如下 class Airport {}; //机场 class Airplane { //飞机的基类 public: virtual void fly(const Airport\u0026 destination) { //飞机飞往指定的目的地(默认行为) } }; //A、B两个派生类 class ModelA :public Airplane {}; class ModelB :public Airplane {}; // ModelB 哈哈哈 让我想起最近的一个新车啥车型 主持人说 - \"ma de b\" 笑死 fly()函数被声明为virtual函数，因为A和B两个飞机具有相同的默认飞行行为，因此在Airplane类的fly()函数中定义这种默认飞行行为，然后让A和B继承。这样的好处是： ​ ① 将所有性质搬到到base class中，然后让两个class继承 ​ ② 避免代码重复，并提升未来的强化能力，减缓长期维护所需的成本 但是万一有一个ModelC，不使用这个fly()呢，吃瘪了吧，所以要把虚函数改成纯虚函数 ① 展示第一种修改方法 class Airport {}; //机场 class Airplane { public: virtual void fly(const Airport\u0026 destination) = 0; protected: void defaultFly(const Airport\u0026 destination) { //飞机飞往指定的目的地(默认行为) } }; class ModelA :public Airplane { public: virtual void fly(const Airport\u0026 destination) { defaultFly(destination); } }; class ModelB :public Airplane { public: virtual void fly(const Airport\u0026 destination) { defaultFly(destination); } }; class ModelC :public Airplane { public: virtual void fly(const Airport\u0026 destination) { //C型飞机不可以使用默认飞行行为，因此定义自己的飞行方式 } }; 现在C型飞机，或者别的添加的飞机就不会意外继承默认的飞行行为了（因为我们将默认的飞行行为封装到一个defualtFly函数中了），自己可以在fly()中定义飞行行为了 注意，在A和B的类的fly()函数中，对defaultFly()做了一个inline调用（见条款30，inline和virtual函数之间的交互关系） ② 第二种修改方法 上面我们将fly()接口和实现（defaultFly()函数）分开来实现，有些人可能会反对这样做，因为这样会因过度雷同的函数名称而引起class命名空间污染 如果不想将上述两个行为分开，那么可以为纯虚函数进行定义，在其中给出defaultFly()函数的相关内容。例如： class Airport {}; //机场 class Airplane { public: //实现纯虚函数 virtual void fly(const Airport\u0026 destination) = 0 { //飞机飞往指定的目的地(默认行为) } }; class ModelA :public Airplane { public: virtual void fly(const Airport\u0026 destination) { Airplane::fly(destination); } }; class ModelB :public Airplane { public: virtual void fly(const Airport\u0026 destination) { Airplane::fly(destination); } }; class ModelC :public Airplane { public: virtual void fly(const Airport\u0026 destination) { //定义自己的飞行方式 } }; 这个设计实现的功能和上面的演示案例是一样的，只不过在派生类的fly()函数中用纯虚函数Airplane::fly替换了独立函数Airplane::defaultFly 这种合并行为丧失了“让两个函数享有不同保护级别”的机会：例如上面的defaultFly()函数从protected变为了public 普通的成员函数 最后来看看Airplane的普通成员函数 class Shape { public: int objectID()const; //普通成员函数，不希望派生类隐藏 }; class Rectangle :public Shape {}; class Ellipse :public Shape {}; 设置普通的成员函数的目的： 意味着基类不希望派生类去隐藏这个成员函数 实际上一个普通的成员函数所表现的不变性凌驾其特异性，因为它表示不论派生类变得多特特异化，它的行为都不可以改变 在上面的代码中： 每个Shape对象都有一个用来产生对象识别码的函数 此识别码总是采用相同计算方法，该方法有Shape::objectID的定义式决定，任何派生类都不应该尝试改变其行为 由于普通成员函数代表的意义是不变性凌驾特异性，所以它绝不该在派生类中被重新定义（这也是条款36所讨论的一个重点） ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:4:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"Summery 接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口 pure virtual函数只具体hiding接口继承 impure virtaul函数具体指定接口继承及缺省实现继承 non-virtual函数具体指定接口继承以及强制性实现继承 题外话，是不是光看这个条款还是不懂接口继承和实现继承到底是啥，对吧 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:4:1","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款35 考虑virtual函数以外的选择 一般做法 我们都玩过游戏，在砍杀游戏中，我们假定使用成员函数healthValue，它会返回一个整数，表示人物的健康程度。将其设置为virtual似乎是再明白不过的做法 class GameCharacter { public: virtual int healthValue() const; ... } Non-Virtual Interface手法 实现 Template Method模式 这里是不是不懂Teamplate Method模式，这可不是c++的 template 哦，不懂就去看《设计模式-模板方法》 有一种流派，它主张virtual函数应该几乎总是private。这个流派的拥护者建议，较好的设计是保留healthValue为public成员函数，但让它成为non-virtual，并调用一个private virtual函数 class GameCharacter { public: int healthValue() const { ... int retValue = doHealthValue; ... return retValue; } ... private: virtual int doHealthValue() const { // derived classes 可重新定义它 ... // 缺省算法，计算健康指数 } } Function Pointers实现 Strategy 模式 这里是不是不懂Strategy模式，不懂就去看《设计模式-策略模式》 另一种流派设计主张”人物健康指数的计算与人物类型无关“，这样计算完全不需要”人物“这个成分 例如我们可能会要求每个人物的构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算 class Gamecharacter; // 前置声明 // 以下函数就是计算健康指数的缺省算法 int defaultHealthCalc(const GameCharacter\u0026 gc); class GameCharacter { public: typedef int (*HealthCalcFunc) (const GameCharacter\u0026); explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc) : healthFunc(hcf) { } int healthValue() const { return healthFunc(*this); } ... private: HealthCalcFunc healthFunc; } 相比于之前做法，该Strategy设计模式的简单应用，它提供了某些有趣弹性 ","date":"2023-03-08","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/:5:0","tags":["Effective C++"],"title":"条款32~40 继承与面向对象设计","uri":"/effective-c-%E6%9D%A1%E6%AC%BE32-40/"},{"categories":["Effective C++"],"content":"条款26～31 实现","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款26～31 实现 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:0:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款26 尽可能延后变量定义得时间 因为变量（对类而言）的定义，需要承担一次构造函数的时间，在函数结束后还可能承担一次析构函数的时间，假如该变量未被使用，那么构造函数和析构函数的时间就白白浪费了，尤其是在可能发生异常的函数中，假如你过早的定义变量，然后在你使用这个变量之前抛出了异常，那么这个变量的构造函数就没有意义而且降低效率。所以应该尽可能延后变量定义得时间，只有真正使用这个变量的时候才定义它 条款4讲过，copy construction的效率 \u003e default construction +assign function，所以最好的做法是直接调用copy construction函数对变量直接进行初始化，而不是先定义，再赋值 std::string encryptPassword(const std::string\u0026 password) { ... string encrypted; encrypted = password; ... } std::string encryptPassword(const std::string\u0026 password) { ... string encrypted(password) ... } 对于有循环的情况，假设一个n次的循环，如代码所示 方法A-定义于循环之外 此方法的代价 - 1次构造，1次析构，n次赋值 Widget w; for (int i = 0; i \u003c n; ++i) { w = \u003c取决于i的某个值\u003e; ... } 方法B-定义于循环内 此方法的代价 - n次构造，n次析构 for (int i = 0; i \u003c n; ++i) { Widget w(\u003c取决于i的某个值\u003e); ... } 如果n较大，那么应该选择方法A / 如果n较小，可以选择方法B ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:1:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary 尽可能延后变量定义得时间，只有真正使用这个变量的时候才定义它 直接调用copy construction函数对变量直接进行初始化，而不是先定义，再赋值 对于有循环的情况，如果n较大，那么应该选择方法A / 如果n较小，可以选择方法B ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:1:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款27 正确使用类型转换 const_cast：4个类型转换中唯一一个可以对const进行转换的类型转换符 static_cast：算是用的最多的一个类型转换符，明确指出类型转换，一般建议都将隐式转换都替换为显示转换，因为没有动态 类型检查，static_cast上行转换也就是 派生类-\u003e基类 安全，但是下行转换不安全，所以主要执行非多态的转换操作，其实基本上除了常量和非多态也就都用static_cast了 既然是最常用的，那我们来看看static_cast static_cast使用例子 class Widget { public: explicit Widget(int size); ... }; void doSomeWork(const Widget\u0026 w); doSomeWork(Widget(15)); // create Widget from int with function-style cast doSomeWork(static_cast\u003cWidget\u003e(15)); // create Widget from int with c++-style cast // 关于 function-style 大家可以看这个网址 // url: https://en.cppreference.com/w/cpp/language/explicit_cast static_cast转型分析 #include \u003cstdio.h\u003e class Base { public: int a; }; class Dervied : public Base { public: double c{}; virtual void bar() }; int main() { Dervied d; Base* base = static_cast\u003cBase*\u003e(\u0026d); } static_cast\u003cxxx\u003e(zzz)其实是一个临时对象 如下述代码，如果Window::onResize()中有修改成员变量的操作，那么在SpecialWindow中是修改不了的，因为转换后只是一个临时对象 class Window { public: virtual void onResize() { ... }; }; class SpecialWindow : public Window { public: virtual void onResize() { static_cast\u003cWindow\u003e(*this).onResize(); } } // 正确写法 class SpecialWindow : public Window { public: virtual void onResize() { Window::onResize(); } } dynamic_cast：专⻔用于派生类之间的转换，type-id 必须是类指针，类引用或 void，对于下行转换是安全的，当类型不一致时，转换过来的是空指针，而static_cast，当类型不一致时，转换过来的是错误意义的指针，可能造成非法访问等问题* 他的代价也比较高，因为其他的都是在编译时，这个是在运行时 dynamic_cast的开销有点大，所以能避免就避免 此解决方法1 很鸡肋 因为原本想用基类指针，这样方便扩展类 针对上述问题，我们可以这么改 reinterpret_cast：不到万不得已，不要使用这个转换符，高危操作 使用特点: 从底层 对数据进行重新解释，依赖具体的平台，可移植性差 可以将整形转换为指针，也可以把指针转换为数组; 可以在指针和引用之间进行肆无忌惮的转换 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:2:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary 最好使用C++4个新式的类型转换函数，因为这很容易辨识，代码可读性提高 尽量避免使用dynamic_cast，因为这种转换效率很低，一般用虚函数的方式来避免转型 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:2:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款28 避免返回一个指针、引用或者迭代器指向类内的成员 如果返回了成员的引用或者指针，就可以通过这个引用或者指针修改雷内的private成员，这样是不合理的（这样的话成员就相当于public的了），这一点可以通过给函数的返回类型加const修饰符来防止内部成员变量被修改 但是还有一种情况是，如果获得的类内的一个成员的引用或指针，但是在使用之前，对象被释放了，那么这个引用或指针就变成了野指针了，必然会导致core dump错误。所以应该避免返回类内成员的指针或引用 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:3:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款29 努力写一个异常安全的代码 这个条款的核心思路就是 发生异常时的处理主要分一下几类：资源不泄漏、数据不丢失、不抛出异常。反正就是考虑程序的各种可能的情况，如果异常了要尽可能保证你的程序某些功能或数据不丢失 RAII，不清楚RAII，可以去看《RAII是什么》 class PrettyMenu { public: void changeBackground(std::istream\u0026 imgSrc); private: Mutex mutex; Image *bgImage; int imageChanges; }; void PrettyMenu::changeBackground(std::istream\u0026 imgSrc) { lock(\u0026mutex); delete bgImage; ++imageChanges; bgImage = new Image(imgSrc); // 可能出现异常 unlock(\u0026mutex) } 如果在 bgImage = new Image(imgSrc);出现异常 那么你就会发现，数据已经出现修改并且锁也没有释放，我们称这种代码就是异常不安全代码 我们可以利用 RAII 这么修改 void PrettyMenu::changeBackground(std::istream\u0026 imgSrc) { lock_guard(\u0026mutex); // lock_guard就是c++11之后的一个RAII对象 delete bgImage; ++imageChanges; bgImage = new Image(imgSrc); // 可能出现异常 } 我们利用RAII能够成功的把锁给释放了，但是数据破坏还没有解决 智能指针 class PrettyMenu { ... std::shared_ptr\u003cImage\u003e bgImage; ... } void PrettyMenu::changeBackground(std::istream\u0026 imgSrc) { lock_guard(\u0026mutex); // lock_guard就是c++11之后的一个RAII对象 bgImage.reset(new Image(imgSrc)); ++imageChanges; } 这样这段代码就是一个基本异常安全的代码 异常安全也是分等级的，异常安全代码只需保证下面其一就可以说是异常安全代码 basic guarantee 基本异常安全，就如上述例子一样，不会数据破坏，资源泄漏 strong guarantee 强力异常安全，如果函数失败，此时状态还是执行函数之前的状态 nothrow guarantee 不会抛出异常的 怎么能做到强力异常安全 copy and swap 该策略是《Pimpl》的一种使用实现 struct PMImpl { std::shared_ptr\u003cImage\u003e bgImage; int imageChanges; } class PrettyMenu { ... private: Mutex mutex; std::shared_ptr\u003cPMImpl\u003e pImpl; } void PrettyMenu::changeBackground(std::istream\u0026 imgSrc) { using std::swap; Lock ml(\u0026mutex); std::shared_ptr\u003cPMImpl\u003e; pNew-\u003ebgImage.reset(new Image(imgSrc)); ++pNew-\u003eimageChanges; swap(pImpl, pNew); } 实现强异常安全还是比较有困难的，所以我们要保证一个基本的异常安全，但是如果能实现强力异常安全，那也还要去实现的 看下述代码，如果f1() f2()只是基本异常安全，然而我们想要把someFunc()实现为强异常安全，那代价将是非常高的 因为，我们要捕捉f1() 的所有异常，然后在f1()执行之前将函数目前状态都保存下来，如果异常了就要恢复，所以代价会很高 如果f1() f2()都是强力异常安全，那么行不行呢，也是不行的，因为f1执行成功，但是f2异常了，这时候f1该做的操作也都做了 void someFunc() { ... // make copy of local state f1(); f2(); ... // swap modified state into place } ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:4:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary 发生异常时的处理主要分一下几类：资源不泄漏、数据不丢失、不抛出异常。反正就是考虑程序的各种可能的情况，如果异常了要尽可能保证你的程序某些功能或数据不丢失 实现异常安全可以依靠下述办法，但不仅依靠下述办法 RAII 智能指针 PImpl - 这个是实现强力异常安全的思路 我们要做到基本异常安全，强力异常安全就佛系，但是能做到也最好 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:4:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款30 理解inline function inline function 会在符号表中以\"weak\"中存在 下述代码在链接的时候会报错，你这个全局其实有两个foo()函数 我们来看看上述代码的符号表，在符号表中其实foo(int)符号绑定类型是GLOBAL 我们用inline function来试试 c++17 之后静态成员直接类内inline就可以省去类外初始化的麻烦 inline static uint8_t selectone = 0; c++11之后inline可以修饰命名空间 下述代码 在libfoo_2022命名空间中会有一个模板foo，然后再libfoo命名空间中想来个模板特化，这样是会报错的 namespace libfoo { namespace libfoo_2022 { template \u003ctypename T\u003e T\u0026 foo(T\u0026); } using namespace libfoo_2022; } namespace libfoo { template \u003c\u003e float\u0026 foo\u003cfloat\u003e(float\u0026); } 可以在namespace中加入inline namespace libfoo { inline namespace libfoo_2022 { void foo1(Bar1); class Bar2 {}; template \u003ctypename T\u003e T\u0026 foo(T\u0026); } using namespace libfoo_2022; } namespace libfoo { template \u003c\u003e float\u0026 foo\u003cfloat\u003e(float\u0026); } 隐式 inline 下述场景是一个隐式inline class Person { public: ... int age() const { return theAge; } // 隐式inline ... private: int theAge; }; inline也可以修饰模板对吧，在符号表中，其实模板也是weak符号类型 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:5:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary inline function 会在符号表中以\"weak\"中存在 c++11之后inline可以修饰命名空间 c++17 之后静态成员直接类内inline就可以省去类外初始化的麻烦 隐式 inline，对于模板来说都是inline ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:5:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"条款31 最小化文件依赖 我们在项目里只修改了一个私有成员，然后编译就发现全部重新编译了，我们就需要构建一个\"编译防火墙\"，编译防火墙就是最小化文件依赖 我们来看看c++的一个特点，在下述代码中，如果我们修改了Date.h或者Address.h，那么只要包含了Person.h的文件就会重新编译 #include \u003cstring\u003e #include \"Date.h\" #include \"Address.h\" class Person { public: Person(const std::string\u0026 name, const Date\u0026 birthday, const Address\u0026 addr); std::string name const; Date birthDate() const; Address address() const; private: std::string theName; Date theBirthDate; Address theAddress; } 然后我们继续基于上述代码来看main() int main() { int x; Person p(params); ... } 在执行到Person p(params);这一行 编译器就必须看清楚Person是啥，特别是私有成员变量里的Date Address 但是我们如果定义成一个指针，编译器就不会去看清楚 int main() { int x; Person* p; ... } 还是《Pimpl》的设计，我们可以通过\"PImpl\"来最小化文件依赖 我们采用了PImpl设计，并且前置声明，但是有几个点一定要注意 如下述代码，Person::~Persion() = default;一定要写出来，如果不写，编译器默认会加，于是所有包含该头文件的编译单元都会inline编译这几个函数，然而又找不到数据类的实现，于是出现编译错误 Person构造函数如下述代码用智能指针写 除了\"PImpl\"，我们还可以用 抽象类接口 最小化文件依赖 类中全部都是pure virtual函数，这样的类在使用的时候只能是以指针的形式出现，这样就同样达到了减少编译依赖的效果 但是希望的能明白，这两种方式都可以最小化依赖，没有什么好与不好。因为PImpl他多出来指针，而且每次访问都是间接访问。虚函数也是靠虚表和虚指针，所以都会带来一定的开销，写的时候任意选一个熟悉的即可，本人是习惯抽象类接口 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:6:0","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["Effective C++"],"content":"Summary 我们可以通过\"PImpl\"来最小化文件依赖 要注意析构函数必须显示的写出来 我们还可以用 抽象类接口 最小化文件依赖 PImpl他多出来指针，而且每次访问都是间接访问。虚函数也是靠虚表和虚指针，所以都会带来一定的开销 ","date":"2023-03-07","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/:6:1","tags":["Effective C++"],"title":"条款26～31 实现","uri":"/effective-c-%E6%9D%A1%E6%AC%BE26-31/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了缓存中的一种 LRU","date":"2023-03-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/","tags":["LRU-Catch"],"title":"LRU-Catch","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/"},{"categories":["算法 \u0026 数据结构"],"content":"LRU Catch 什么是LRU Catch LRU是最近最少使用策略的缩写，是根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高” 我们可以用 双向链表去实现 LRU Catch LRU Catch 图示 golang 实现 LRU Catch type Node struct { Key int Value int pre *Node next *Node } type LRUCache struct { limit int HashMap map[int]*Node head *Node end *Node } func Constructor(capacity int) LRUCache{ lruCache := LRUCache{limit:capacity} lruCache.HashMap = make(map[int]*Node, capacity) return lruCache } func (l *LRUCache) Get(key int) int { if v,ok:= l.HashMap[key];ok { l.refreshNode(v) return v.Value }else { return -1 } } func (l *LRUCache) Put(key int, value int) { if v,ok := l.HashMap[key];!ok{ if len(l.HashMap) \u003e= l.limit{ oldKey := l.removeNode(l.head) delete(l.HashMap, oldKey) } node := Node{Key:key, Value:value} l.addNode(\u0026node) l.HashMap[key] = \u0026node }else { v.Value = value l.refreshNode(v) } } func (l *LRUCache) refreshNode(node *Node){ if node == l.end { return } l.removeNode(node) l.addNode(node) } func (l *LRUCache) removeNode(node *Node) int{ if node == l.end { l.end = l.end.pre l.end.next = nil }else if node == l.head { l.head = l.head.next l.head.pre = nil }else { node.pre.next = node.next node.next.pre = node.pre } return node.Key } func (l *LRUCache) addNode(node *Node){ if l.end != nil { l.end.next = node node.pre = l.end node.next = nil } l.end = node if l.head == nil { l.head = node } } ","date":"2023-03-07","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/:1:0","tags":["LRU-Catch"],"title":"LRU-Catch","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了动态规划的概念，思路，及例题","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"动态规划 动态规划 跟 “分治、递归、回溯”没有太大的区别，我们来看看动态规划的具体定义 simplifying a complicated problem by breaking it down into simpler sub-problems 这个是 wiki百科 对动态规划的解释，同时我感觉这是最好的解释 动态规划，个人觉得翻译成 “动态递推/动态推导” 是最好的，动态规划其实有点不直白 然后上述英文的意思则是 “把一个复杂的问题分解为更简单的子问题” 其实就是分治的思想，但是分治和动态规划只有小小的不一样，那就是第二点 动态规划 = 分治 + 最优子结构 一般来说 动态规划 会让你求 最优解 最大值 最小值，这也就是动态规划的应用场景 正因为，他有所谓的最优子结构，所以，你就不需要，将中间所有的状态都保存下来，只需要存最优的状态 重点总结 动态规划和 递归 分治 没有根本上的区别（关键是看有无最优子结构） 他们之间的共性就是 找到重复子问题 他们之间的差别就在于 动态规划有最优子结构，中途可以淘汰最优解 ","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:1:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"斐波那契数列 斐波那契额数列 我们都知道是可以用递归去解决，但是面试的时候，千万不能说用递归，傻递归的效率是极慢的 时间复杂度为指数级，也就是 O(2^n) 所以我们就得想办法来优化啦，我们可以加一个缓存，这个缓存可以用数组，这种叫做 “记忆化搜索” func fib(n int, memo []int) { // resursion terminator(递归终止条件) if (n \u003c= 1) { return 0 } if (memo[n] == 0) { memo[n] = fib(n - 1) + fib(n - 2) } return memo[n] } 在上述代码中我们通过增加数组实现的缓存，使得只要在数组出现的值就直接return，不让他参与遍历，把重复的节点直接砍掉，所以O(2^n) 变成了 O(n) 是不是贼棒，其实这个也是分治的思想，只不过加了个记忆化搜索 ","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:2:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"思想 - 自顶向下 我们在面对斐波那契时，当然可以用上述讲的 分治 + 记忆化搜索 来实现，其实这个思想就是 “自顶向下” 的思想 什么叫自顶向下呢？就是上述图片，我们一直从上面也就是fib(6)找到最下面的叶子结点 我要算 fib(6) 就得算fib(5) 和 fib(4) 我要算fib(5) 就得算fib(4) 和 fib(3) … 就如上述一直下去，中间算过的结果，我们可以用记忆化搜索，这种符合人脑的习惯，也是分治的思想 ","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:3:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"思想 - 自底向上 我们学习了自顶向下的方法，emmm，是不是感觉很不错，但是后来当我们遇到更难得dp也就是动态规划时，高手一般会直接用“自底向上”的思想 那么什么是自底向上呢 我们想算fib(6) 从fib(0) fib(1) 开始 然后一直用循环去递推 所以我们只需要了解自底向下思想即可，所以动态规划翻译成动态递推是不是很有道理 ","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:4:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"状态转移方程 状态转移方程也叫 dp方程 这个其实是要在例题1 例题2 后来讲的 这里为了工整性 提前说了 大家可以先看一下例题1 和例题2 的分析再来看 dp方程 和 关键点 思考步骤 两道例题 其实都有一个核心的关键方程 例题1 是 v[i] = v[i-1] + v[i-2] 例题2 是 v[i][j] = v[i-1][j] + v[i][j-1] 这类方程 我们叫状态转移方程 也叫dp方程 但是又回到 咬文嚼字上 这其实就是一个递推方程 ","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:5:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"dp 思考点 化繁为简，将复杂的问题 变成子问题，其实就是 找重复性（分治思想） 定义好状态空间 定义dp数组 \u0026\u0026 初始化dp数组 注意这里定义和初始化数组的长度一定要注意 有时候会是 “\u003e=” 或者其他的，如果定义错误，则会数组越界，或者答案错误 写好dp方程 ","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:6:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 爬楼梯 ","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:7:0","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["算法 \u0026 数据结构"],"content":"方法1 - 动态规划 URL 70. 爬楼梯 - 力扣（LeetCode） 代码示例 class Solution { public: int climbStairs(int n) { /* 定义dp数组 */ vector\u003cint\u003e dp(n+1); /* 初始化dp数组 */ dp[0] = 1; dp[1] = 1; /* dp方程 自底向上 */ for (int i = 2; i \u003c dp.size(); i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } }; ","date":"2023-03-06","objectID":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:7:1","tags":["动态规划"],"title":"动态规划","uri":"/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["缘起 在人群中 我看见你"],"content":"RAII","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"啥是RAII? ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:0:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"什么是RAII RAII是指C++语言中的一个惯用法（idiom），它是“Resource Acquisition Is Initialization”的首字母缩写。中文可将其翻译为“资源获取就是初始化” 虽然从某种程度上说这个名称并没有体现出该惯性法的本质精神，但是作为标准C++资源管理的关键技术，RAII早已在C++社群中深入人心 ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:1:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"思路推导 如果你有写过C++或者RUST，你也许听过Resource Acquisition Is Initialisation (RAII), 但是并不了解这名字的含义是什么，或者不知道这个机制有什么用处。在这篇文章中，笔者将详细阐述RAII的原理以及它在资源管理方面巨大的威力 RAII是一种使用在面向对象语言中的资源（内存，互斥锁，或者文件描述符）管理机制，使用RAII的语言中，最出名的当属c++ and rust，正是因为强制RAII机制使得rust拥有了绝对的内存安全 Resource Acquisition Is Initialisation, 顾名思义，意味着任何资源的获取都应该发生在类的构造函数中，但我个人认为这个名字不太完备，有另一半的意思没有解释到，那就是资源的释放应发生在析构函数中，这意味着所有资源的 life cycle都与一个 object紧紧绑定在一起 我将用几段代码来具体阐述RAII的应用场景 互斥锁 std::mutex mut; int write_to_a_file_descriptor(std::string content) { mut.lock(); // critical area below (might throw exception) // Writing content to a file descriptor... // Critical areas above mut.unlock(); } 以上代码展示了一个将字符串写进某个文件描述符的函数，并且这个函数会被很多线程并行调用（这种情况在高并发线上服务的logger中非常常见），因此这个共用的文件描述符必须用一个互斥锁保护起来，否则不同线程的字符串会混在一起 这段代码看起来仿佛没有问题，但是如果当写IO时是抛出异常，call stack会被直接释放，也就意味着unlock不会执行，造成永久的死锁，这个问题可以像java一样用一个try-catch语句来避免但是也会让代码变得臃肿和难看。并且在复杂的逻辑中，往往很可能会忘了解锁，或者花很多精力来管理锁的获得和释放(如果在一个函数调用中有多处返回，每个return statement之前都需要 unlock)。这就是RAII发挥其威力的时候了，下面一段代码将展示如何用 lock_guard来使我们的代码异常安全并且整洁 std::mutex mut; int write_to_a_file_descriptor(std::string content) { std::lock_guard\u003cstd::mutex\u003e lock(mut); // critical area below (might throw exception) // Writing content to a file descriptor... // Critical areas above } lock_guard保证在函数返回之后释放互斥锁，因此使得开发人员不需要为抛出异常的情况担心且不需手动释放锁。但是 lock_guard是如何做到的呢？笔者将尝试自己手动实现一个 lock_guard template \u003ctypename T\u003e class lock_guard { private: T _mutex; public: explicit lock_guard(T \u0026mutex) : _mutex(mutex) { _mutex.lock(); } ~lock_guard() { _mutex.unlock(); } }; 从实现上可以看出，lock_guard在构造函数中锁住了引用传入的mutext，并且在析构函数中释放锁。其异常安全的保障就是析构函数一定会在对象归属的scope退出时自动被调用 如果你用过golang的话会知道golang的defer机制，这与C++的析构函数十分相似，但是golang的defer只能保证在函数返回前执行，而C++的析构函数可以保证在当前scope退出前执行（个人感觉golang的defer相比之下比较鸡肋） ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:2:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"智能指针 C++中一个非常常见的应用场景就是调用一个函数来产生一个对象，然后消费这个对象，最后手动释放指针。如以下代码所示 class my_struct { public: my_struct() = default; }; template \u003ctypename T\u003e T* get_object() { return new T(); } int main() { auto obj = get_object\u003cmy_struct\u003e(); // consume the object // ... // consume finish delete obj; } 然而，在大型应用程序中，指针的产生和消费错综复杂，写到后面程序员根本不记得自己有没有释放指针，或者某处地方读取一个已经释放的指针直接导致segmentation fault程序崩溃。而这就是C/C++各种内存泄漏的万恶之源 而自从C++11推出智能指针后，其极大地减轻了C++开发者们内存管理的压力。通过在裸指针上包一层智能指针，再也不用通过手动 delete来释放内存了。下面的代码将展示如何用 std::unique_ptr来管理指针 class my_struct { public: my_struct() = default; }; template \u003ctypename T\u003e std::unique_ptr\u003cT\u003e get_object() { return std::unique_ptr\u003cT\u003e(new T()); } int main() { auto obj = get_object\u003cmy_struct\u003e(); // consume the object // ... // consume finish } 智能指针的方便之处在于它会在自己的析构函数中执行 delete操作而不需程序员手动释放 在上述代码中，当main函数退出时， std::unique_ptr在自己的析构函数中释放指针，而为了防止有别的 std::unique_ptr指向自己管理的对象而导致的提早释放与空指针访问， std::unique_ptr禁止了 copy constructor与 copy assignment。有人可能会疑惑，为什么 get_object函数创建的 unique_ptr为什么没有在函数返回前释放指针？这是因为 std::unique_ptr实现了 move constructor（一种可以将资源从另一个对象“偷”过来的构造函数）并在返回时将指针传给了main函数中 obj变量 如果不太理解发生了什么，可以看一下以下我自己尝试实现的 unique_ptr. template \u003ctypename T\u003e class unique_ptr { private: T* _ptr; public: // Construct from plain pointer explicit unique_ptr(T* ptr) : _ptr(ptr) { std::cout \u003c\u003c \"unique_ptr constructed\" \u003c\u003c std::endl; }; // Move constructor unique_ptr(unique_ptr \u0026\u0026ptr) noexcept : _ptr(ptr._ptr) { ptr._ptr = nullptr; std::cout \u003c\u003c \"unique_ptr move constructed\" \u003c\u003c std::endl; } // Copy constructor is forbidden unique_ptr(unique_ptr \u0026ptr) = delete; // Move assignment unique_ptr\u0026 operator=(unique_ptr \u0026\u0026ptr) noexcept { if (this == \u0026ptr) { return *this; } _ptr = ptr._ptr; ptr._ptr = nullptr; return *this; } // Copy assignment is forbidden unique_ptr\u0026 operator=(unique_ptr \u0026ptr) = delete; ~unique_ptr() { delete _ptr; std::cout \u003c\u003c \"unique_ptr destructed\" \u003c\u003c std::endl; } T* operator-\u003e() { return _ptr; } }; 代码看上去比较复杂，不过我将一个方法一个方法地和大家分析 第8行代码实现了最基本的构造函数：从一个裸指针开始构造 第13行实现了 move constructor，这个方法会用一个已有的 unique_ptr来构造一个新的对象，它将旧 unique_ptr的指针替换为 nullptr来防止多个指针指向相同对象 第19行禁止了 copy constructor的使用，因为不允许多个指针指向同一对象 第22行实现了 move assignment，原理与 move constructor相同 第32行禁止了 copy assignment，原理与 copy constructor相同 第34行是析构函数，将最终释放指针 第39行实现了 operatoroverload，使得我们可以像访问普通指针一样访问 unique_ptr 我们来用我们自己定义的 unique_ptr运行一下看会发生什么 class my_struct { public: std::string _name = \"name\"; my_struct() = default; explicit my_struct(std::string name) : _name(std::move(name)) { std::cout \u003c\u003c \"my_struct constructed\" \u003c\u003c std::endl; } ~my_struct() { std::cout \u003c\u003c \"my_struct destructed\" \u003c\u003c std::endl; } }; template\u003ctypename T\u003e unique_ptr\u003cT\u003eget_object() { return unique_ptr\u003cT\u003e(new T(\"struct name\")); } int main() { unique_ptr\u003cmy_struct\u003e obj = get_object\u003cmy_struct\u003e(); std::cout \u003c\u003c obj-\u003e_name \u003c\u003c std::endl; } // console output my_struct constructed unique_ptr constructed struct name my_struct destructed unique_ptr destructed 首先， my_struct被构造，然后 unique_ptr被构造，并且可以发现， my_struct的析构函数会在 unique_ptr的析构函数返回前执行，这意味着我们成功地将指针的life cycle绑定到了 unique_ptr上！不过，细心的同学可能发现了，全程 unique_ptr的 move constructor都没有被call过，但是我之前明确说了，main函数中的 obj是用 get_object函数中构造的 unique_ptr通过 move constructor构造的。可是为什么我们没有抓到 move constructor打印出来的东西呢？这是因为C++编译器做了一个叫做 copy elision的优化，来避免不必要的构造和析构，例如本例中，两个函数中的 unique_ptr对象其实是一个东西，因此他们之间的转换和赋值被优化掉了。如果我们通过 std::move来强制 move constructor发生，如下所示： 我们将看到这样的信息： my_struct constructed unique_ptr constructed unique_ptr move constructed unique_ptr destructed struct name my_struct destructed unique_ptr destructed 此时我们可以清晰地看到，main函数中的 obj是通过 move constructor构造的，并且在其构造完成之后， get_object函数中构造的 unique_ptr对象被析构了，因为我们已经提早将其内部指针替换成了 nullptr, 其析构函数什么都不会释放 智能指针中，除了 std::unique_ptr，还有其他类型，比如允许多个指针指向同一变量的 std::shared_ptr，其内存管理逻辑会复杂许多 ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:3:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["缘起 在人群中 我看见你"],"content":"技术总结 通过这篇文章，相信大家都体会到了RAII的威力，其将资源绑定到轻量级对象(比如智能指针，内存占用很少，可以像普通指针一样随意传递)的方法使得我们再也不需要关心在获取资源之后对资源的释放 ","date":"2023-03-06","objectID":"/%E7%BC%98%E8%B5%B7-raii/:4:0","tags":["RAII"],"title":"啥是RAII?","uri":"/%E7%BC%98%E8%B5%B7-raii/"},{"categories":["Effective C++"],"content":"条款18～25 设计与生命","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款18～25 设计与生命 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:0:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款18 让接口容易被正确使用，不易被误用 对class的参数类型进行抽象 我们普通的定义一个接口会有啥问题，如下述代码 class Date{ public: Date(int month, int day, int year); ... }; Date d(2, 30, 2021); // 传参容易出错 所以我们可以对class的参数类型进行抽象，如下述代码 struct Day{ int val; explicit Day(int d) : val(d) {} }; ... class Date{ public: Date(const Month\u0026 m, const Day\u0026 d, const Year\u0026 y); ... }; Date d(Month(3), Day(31), Year(2021)); // 传参可靠 尽量让自定义type行为与内置type一致 这边如果a和b是自定义类型，这边编译器就不会报错，如果a和b是内置类型，那么ab是临时对象-右值，所以编译器就会报错* 所以我们这边需要统一，行为与内置type一致，在前面的条款3也说了，直接加const即可 if (a * b = c) factory 函数返回智能指针* 了解设计模式的童鞋们就会知道有一个设计模式叫工厂模式，在这里推荐工厂函数返回一个智能指针，因为用裸指针就会增加用户的心智开销，避免忘记delete Investment* createInvestment(); -\u003e std::shared_ptr\u003cInvestment\u003e createInvestment(); shared_ptr\u003cInvestment\u003e createInvestment(){ shared_ptr\u003cInvestment\u003e retVal( static_cast\u003cInvestment*\u003e(0), // 初始化一个null shared_ptr指针， getRidOfInvestment); // 指定getRidOfInvestment函数为删除器， retVal = ...; // 令retVal指向正确的对象 return retVal; } ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:1:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 好的接口容易被正确使用，不容易被误用 “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容 “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任 shared_ptr 支持定制型删除器。可防范 DLL 问题，可被用来自动解除互斥锁（mutex）等 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:1:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款19 设计class犹如设计type ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:2:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 这个条款有12问帮你设计好一个class，当然class由于需求是会多变的，但是这个12问能够起到很好的辅助作用 自定义 type 的对象应该如何被创建和销毁 也就是他的构造和析构应该是怎么去写 对象的初始化和对象的赋值应该有什么样的差别？（不要混淆“初始化”和“赋值”） 新 type 的对象如果被 pass by value，意味着什么？（copy 构造函数定义） 什么是新 type 的“合法值”？（构造函数、赋值操作、setter 函数） 新 type 需要配合某个继承图系吗？（virtual 函数、virtual 析构函数） 新 type 需要什么样的转换？（条款15：显式转换：explicit 构造，隐式转换：operator Type、-\u003e） 什么样的操作符和函数对此新 type 而言是合理的？ 什么样的标准函数应该驳回？（条款06：明确拒绝copy 构造、copy assignment 操作符等） 谁该取用新 type 的成员？（访问规则：数据成员的封装，成员函数 API 的开放，是否友元） 什么是新 type 的“未声明接口”？ 你的新 type 有多么一般化？（class template） 你真的需要一个新 type 吗？（多个 non-member 函数或 template 是否可以达到目的） ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:2:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款20 以 pass by reference to const 替换 pass by value pass-by-reference-to-const 作为函数参数 效率高（没有构造和析构函数被调用），还能避免slicing（对象切割）问题 class Window{ public: ... string name() const; // 返回窗口名称 virtual void display() const; // 显示窗口和内容 }; class WindowWithScrollBars : public Window{ public: ... virtual void display() const; }; void printNameAndDisplay(Window w){ // 不正确！参数可能被切割。value是没有多态的特性的 cout \u003c\u003c w.name(); w.display(); } WindowWithScrollBars wwsb; printNameAndDisplay(wwsb); // 总是调用Window的display() void printNameAndDisplay(const Windows\u0026 w) { // 正确！引用本质上就是一个漂亮的指针 也具有多态特性 cout « w.name(); w.display(); } pass-by-value 经常适用于内置类型、STL迭代器和函数对象 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:3:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary pass-by-reference-to-const 作为函数参数，效率高（没有构造和析构函数被调用），还能避免slicing（对象切割）问题 pass-by-value 经常适用于内置类型、STL迭代器和函数对象 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:3:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款21 不要错误的返回对象的引用 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:4:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 不要返回一个临时对象的引用 不要返回在堆上分配的对象的引用，因为这违背了new和delete成对出现的原则，这样的方式是很不合理的，稍加不注意就会导致内存泄漏问题 也不要返回一个static对象的引用，因为static可能同时被很多地方需要，这样的话共享就存在问题 所以对于这种问题，最好的解决方法就是不返回引用就OK了 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:4:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款22 将成员变量声明为private ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:5:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 其实声明为private 带来的最大的好处就是 - 成员变量有更精细的访问控制 考虑一个 public 成员变量变更或消失时对用户代码的影响 考虑一个 protected 成员变量变更或消失时对 derived class 代码的影响 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:5:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款23 将non member \u0026 non friend 替换 member func 封装使我们能够改变事物而只影响有限客户 导致较大封装性的是 non-member、non-friend 函数（因为不增加“能够访问 class 内 private 成分”的函数数量） class WebBrowser{ public: ... void clearCache(); void clearHistory(); void removeCookies(); ... }; // non-member“便利函数” void clearBrowser(WebBrowser\u0026 wb){ wb.clearCache(); wb.clearHistory(); wb.removeCookies(); } 将所有便利函数放在多个头文件但隶属于同一个命名空间，意味客户可以轻松扩展这一组便利函数 // 头文件“webbrowser.h” namespace WebBrowserStuff{ class WebBrowser{...}; ... // 核心机能，几乎所有客户需要的non-member函数 } // 头文件“webbrowserbookmarks.h” namespace WebBrowserStuff{ ... // 与书签相关的便利函数 } // 头文件“webbrowsercookies.h” namespace WebBrowserStuff{ ... // 与cookie相关的便利函数 } ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:6:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 封装使我们能够改变事物而只影响有限客户 导致较大封装性的是 non-member、non-friend 函数（因为不增加“能够访问 class 内 private 成分”的函数数量） ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:6:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款24 若所有参数皆需类型转换，请为此采用 non-member 函数 隐式转换与 member 函数 class Rational{ private: ... public: Rational(int numerator = 0, // non-explicit int denominator = 1); // 允许int-to-Rational隐式转换 int numerator() const; // 分子访问函数 int denominator() const; // 分母访问函数 ... const Rantional operator*(const Rational\u0026 rhs) const; }; Rational result; Rational oneHalf(1, 2); result = oneHalf * 2; // 正确，oneHalf.operator*( 2 /* 隐式转换 */); result = 2 * oneHalf; // 错误，2.operator*(oneHalf); 隐式转换与 non-member 函数 class Rational{ private: ... public: Rational(int numerator = 0, // non-explicit int denominator = 1); // 允许int-to-Rational隐式转换 int numerator() const; // 分子访问函数 int denominator() const; // 分母访问函数 ... }; const Rantional operator*(const Rational\u0026 lhs, const Rational\u0026 rhs){ return Rational(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator()); } Rational result; Rational oneHalf(1, 2); result = oneHalf * 2; // 正确，operator*(oneHalf, 2 /* 隐式转换 */); result = 2 * oneHalf; // 正确，operator*(2, oneHalf); ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:7:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 若所有参数皆需类型转换，请为此采用 non-member 函数 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:7:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"条款25 考虑写出一个不抛异常的 swap 函数 我们标准库里面的swap函数是这么写的，无非就是一个中间值过渡，只要T支持copying(通过copy构造函数和assignment操作符完成)，默认的swap会实现代码就会将类型为T的对象进行置换 namespace std { template\u003ctypename T\u003e void swap(T\u0026 a, T\u0026 b) { T temp(a); a = b; b = temp; } } 这种方法对于内置类型没任何问题，内置类型上的赋值绝对不会抛出异常，并且效率很高。但是如果a,b不是内置类型，就会调用类的copy构造函数和assign函数，并且必须是深拷贝。这样如果类的成员较多就会造成交换的效率很低，特别是针对pimpl实现方法，即成员中包含指针（即资源）时。更好的做法就是直接交换指针就可以了，相当于交换了两个int(指针都是4字节的)，这就比拷贝这个指针指向的资源要快得多 关于pimpl可以查看本博客《C++ Pimpl》 如何实现呢？我们先用pimpl手法将Widget的数据成员封装到WidgetImpl中 class WidgetImpl {// class for Widget data; public:// details are unimportant... private: int a, b, c;// possibly lots of data — std::vector\u003cdouble\u003e v;// expensive to copy!... }; class Widget {// class using the pimpl idiom public: Widget(const Widget\u0026 rhs); Widget\u0026 operator=(const Widget\u0026 rhs)// to copy a Widget, copy its { // WidgetImpl object. For ...// details on implementing *pImpl = *(rhs.pImpl);// operator= in general, ...// see Items 10, 11, and 12. } ... private: WidgetImpl *pImpl;// ptr to object with this };// Widget’s data 设计问题 置换两个Widget对象过于复杂，浪费空间和效率(对于置换Widget对象值，我们只需要做的是置换impl指针，但默认的swap要交换Widget类更需要交换WidgetImpl) 可以直接交换指针的地址，改变指针指向的内存 我们可以置换其impl指针 namespace std{ template\u003c\u003e void swap\u003cWidget\u003e(Widget\u0026 a,Widget\u0026 b)//std::swap的全特化版本只能对 //\u003cWidget\u003e表示这一特例化版本只是针对指针交换而设计 { swap(a.pImpl,b.pImpl); } } 这个有个问题 pImpl是属于Widget的private成员因此此函数肯定是无法编译通过的，我们可以将其声明为friend函数但其封装性较弱，可以将swap声明为member函数如下 class Widget { // same as above, except for the public:// addition of the swap mem func ... void swap( Widget\u0026 other){ using std::swap;// the need for this declaration // is explained later in this Item swap(pImpl, other.pImpl);// to swap Widgets, swap their } // pImpl pointers ... }; namespace std { template\u003c\u003e// revised specialization of void swap\u003cWidget\u003e(Widget\u0026 a,// std::swap Widget\u0026 b) { a.swap(b);// to swap Widgets, call their }// swap member function } 这一段代码能够通过编译，并且具有STL容器的一致性，以为std::swap也提供了有pulic swap成员函数的和std::swap的特化版本 但是对于Widget class templates而非classes 将数据类型加以参数化 template\u003ctypename T\u003e class WidgetImpl { ... }; template\u003ctypename T\u003e class Widget { ... }; namespace std { template\u003ctypename T\u003e void swap\u003cWidget\u003cT\u003e \u003e(Widget\u003cT\u003e\u0026 a,// error! illegal code! Widget\u003cT\u003e\u0026 b) { a.swap(b); } } // 企图偏特化一个function template(std::swap)，但C++只能对class templates偏特化 // 在function templates身上时不能偏特化的。因此无法编译 所以我们得偏特化 function template namespace std {template\u003ctypename T\u003e// an overloading of std::swap void swap(Widget\u003cT\u003e\u0026 a,// (note the lack of “\u003c...\u003e” after Widget\u003cT\u003e\u0026 b)// “swap”), but see below for { a.swap(b); }// why this isn’t valid code} 这时候还是有个问题，重载function templates是没问题的，但std是一个特殊的命名空间 可以全特化std内的templates 不可以添加新的templates(class或function)到std里面 所以真正高效正确的做法就是 non member swap \u0026 member swap相结合 namespace WidgetStuff { ...// templatized WidgetImpl, etc. template\u003ctypename T\u003e// as before, including the swapclass Widget { ... };// member function ... template\u003ctypename T\u003e// non-member swap function; void swap(Widget\u003cT\u003e\u0026 a,// not part of the std namespace Widget\u003cT\u003e\u0026 b) { a.swap(b); } } swap实现效率不足的解决(class或template运用了pimpl手法) 提供一个public的swap函数，让它高效地置换你的类型的两个对象值，而其不能抛出异常 在你的class或template所在的命名空间提供一个non-member swap，并令他调用上述swap成员函数 如果编写一个class(而非class template)，为你的class特化一个std::swap，并令他调用你的swap的成员函数 必须使用using std::swap,以便其能够在函数类曝光可见，然后报价namspace修饰符 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:8:0","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["Effective C++"],"content":"Summary 当std::swap对你的类型无效时，提供一个swap成员函数。确保交换不会抛出异常 如果你提供了一个成员交换，也要提供一个调用成员的非成员交换。对于类(不是模板)，也要专门化std::swap 当调用swap时，对std::swap使用using声明，然后不带命名空间限定的调用swap 完全专门化用户定义类型的std模板是可以的，但永远不要尝试向std添加全新的东西 ","date":"2023-03-06","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/:8:1","tags":["Effective C++"],"title":"条款18～25 设计与生命","uri":"/effective-c-%E6%9D%A1%E6%AC%BE18-25/"},{"categories":["算法 \u0026 数据结构"],"content":"布隆过滤器","date":"2023-03-05","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/","tags":["布隆过滤器"],"title":"布隆过滤器","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"categories":["算法 \u0026 数据结构"],"content":"布隆过滤器 引出 对于hashtable，我们存放一个数据，会先进行哈希取模，然后决定放在哪一个桶，随后就会把这个数据放进🪣中，对于哈希表来说，存放的数据是准备完整的 我们再来想一个场景，如果我们不需要完整的数据，我们只是想判断一个这个数据到底存不存在，这个时候哈希表其实不太适合，其实可以做到的，但是终归不是完美适合这个场景 所以我们需要一个更高效的数据结构 布隆过滤器 他lei了 什么是布隆过滤器 他是一个很长的 二进制向量 和 一系列随机映射函数 布隆过滤器可以用于检索一个元素是否在一个集合中 布隆过滤器的优点 空间效率和时间效率是远远超过一般的数据结构 布隆过滤器的缺点 有一定的误别率和删除困难 布隆过滤器的图示 布隆过滤器的误别 布隆过滤器的 golang实现 package main import ( \"fmt\" \"github.com/bits-and-blooms/bitset\" ) //设置哈希数组默认大小为16 const DefaultSize = 16 //设置种子，保证不同哈希函数有不同的计算方式 var seeds = []uint{7, 11, 13, 31, 37, 61} //布隆过滤器结构，包括二进制数组和多个哈希函数 type BloomFilter struct { // 使用第三方库 set *bitset.BitSet // 指定长度为6 hashFuncs [6]func(seed uint, value string) uint } //构造一个布隆过滤器，包括数组和哈希函数的初始化 func NewBloomFilter() *BloomFilter { bf := new(BloomFilter) bf.set = bitset.New(DefaultSize) for i := 0; i \u003c len(bf.hashFuncs); i++ { bf.hashFuncs[i] = createHash() } return bf } //构造6个哈希函数，每个哈希函数有参数seed保证计算方式的不同 func createHash() func(seed uint, value string) uint { return func(seed uint, value string) uint { var result uint = 0 for i := 0; i \u003c len(value); i++ { result = result*seed + uint(value[i]) } //length = 2^n 时，X % length = X \u0026 (length - 1) return result \u0026 (DefaultSize - 1) } } //添加元素 func (b *BloomFilter) add(value string) { for i, f := range b.hashFuncs { //将哈希函数计算结果对应的数组位置1 b.set.Set(f(seeds[i], value)) } } //判断元素是否存在 func (b *BloomFilter) contains(value string) bool { //调用每个哈希函数，并且判断数组对应位是否为1 //如果不为1，直接返回false，表明一定不存在 for i, f := range b.hashFuncs { //result = result \u0026\u0026 b.set.Test(f(seeds[i], value)) if !b.set.Test(f(seeds[i], value)) { return false } } return true } func main() { filter := NewBloomFilter() filter.add(\"asd\") fmt.Println(filter.contains(\"asd\")) // true fmt.Println(filter.contains(\"2222\")) // fmt.Println(filter.contains(\"155343\")) } ","date":"2023-03-05","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/:1:0","tags":["布隆过滤器"],"title":"布隆过滤器","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"categories":["Effective C++"],"content":"条款13～17 资源管理","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款13～17 资源管理 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:0:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"知识点 RAII对象 本大章节-资源管理，需要弄懂什么是RAII，在本博客《什么是RAII》中有详解 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:1:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款13 以对象管理资源 前言 其实在本文中的auto_ptr已经被弃用了，建议去看《Effective Modern c++ Item18 ~ Item22》 但是在这里还是说一下该条款的一些思路点 思路点 在构造中获得资源并在析构函数中释放资源 两个常用的自动管理资源的类是shared_ptr和auto_ptr，其中auto_ptr的复制动作，会导致复制对象变为null，容易造成意外的错误，一般推荐使用shared_ptr，其使用引用计数的原理实现对象共享的目的，并且在计数为0时自动释放对象 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:2:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"Summary 已过时，建议去看《Effective Modern c++ Item18 ~ Item22》 思路点其实就是RAII原则 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:2:1","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款14 在资源管理类中小心copying行为 引言 上节是对资源的管理说明。有时候我们不能依赖于shared_ptr或者auto_ptr,所以我们须要自己建立一个资源管理类来管理自己的资源 假设我们使用C API函数处理Mutex互斥器对象： void lock(Mutex* pm); //锁定pm所指的互斥器 void unlock(Mutex* pm); //解除锁定 为了忘记释放锁，我们想要建立一个class来进行资源管理，这里class应该满足RAII守则，即\"资源在构造期间获得，在析构期间释放\" class Lock{ public: explicit Lock(Mutex* pm):mutexPtr(pm){ lock(mutexPtr);//获得资源 } ~Lock(){ unlock(mutexPtr); // 释放资源 } private: Mutex* mutexPtr; }; copying行为 上述例子写的这很不错，但是如果此时Lock对象被复制，会发生什么？ Lock ml1(\u0026m); // 锁定m Lock ml2(ml1); // 将ml1复制到ml2身上 这样做绝对不行，我们不能确定什么时候m2和m1会被析构，一旦被析构就会导致mutex解锁，mutex一旦解锁就会被别的进程所调用，程序将出现巨大的混乱 其实，这不是说一个特定例子，一般的情况是：当一个RAII对象被复制时，应该如何选择，有以下两种做法 禁止复制 如条款06所言：将copying操作声明为private，或者利用c++11新特性 = delete 引用计数 对底层资源使用”reference-count“ 有时候希望保有资源，直到它的最后一个使用者（某对象）被销毁。对Lock打算使用reference counting它可以改变mutexPtr类型，将Mutex*改为tr1::shared_ptr\u003cMutex\u003e，当然这不是我们想要的，我们只是想释放锁，而不是删除锁 幸运的是tr1::shared_ptr运行指定所谓的删除器，那是一个函数或对象，引用次数为0才被调用。删除器对tr1::shared_ptr构造函数而言是可有可无的第二参数，所以代码看起来像这样 class Lock { public: explicit Lock(mutex* pm) : mutexPtr(pm, unlock) { lock(mutexPtr.get()); } private: std::trl::shared_ptr\u003cMutex\u003e mutexPtr; } ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:3:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"Summary 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为 普遍常见的RAII class copying 行为是：禁止复制、施行引用计数法 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:3:1","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款15 资源管理类中提供对原始资源的访问 这里想要将RAIIclass对象进行转换为其内含之原始资源，有两种转换 示例代码 FontHandle getFont(); void releaseFont(FontHandle fh); class Font { public: explicit Font(FontHandle fh) : f(fh) { } ~Font() { releaseFont(f); } FontHanle get() const { return f; } // 显示转换 operator FontHandle() const { return f; } // 隐式转换 private: FontHandle f; }; Font f1(getFont()); FontHanle f2 = f1; 显示转换 提供get()函数得到原始指针 显示调用 很不错 没有啥问题 隐式转换 允许隐式转换，但是会有问题，在客户FontHanle f2 = f1;的时候，并不知道这还有一层隐式转换的逻辑，所以会增加错误率 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:4:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"Summary APIs往往要求访问原始资源，所以每一个RAII class应该提供一个”取得其所管理之资源“的方法 对原始资源的方法可能会经由显式转换或隐式转换 相对而言显式转换比较安全，但是频繁get()很烦人 但隐式转换对用户比较方便 个人觉得是显示调用要好，频繁调用get()又不会死，隐式调用用户如果不告诉他，或者他自己发现，也不会察觉到有一次隐式调用，会增加报错的几率 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:4:1","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款16 new和delete 要使用相同形式 在使用new delete需要使用一致的形势使用，否则会导致内存泄漏 std::string* stringPtr1 = new std::string; std::string* stringPtr2 = new std::string[100]; ... delete stringPtr1; delete[] stringPtr2; 要注意typedef自定义类型 typedef std::string AddressLines[4]; std::string* pal = new AddressLines; // new string[4] delete pal; // undefined!!! delete[] pal; // fine 这个规则对于使用typedef的程序员来说十分重要，因为它意味着typedef的作者必须说清楚：当程序员以new创建该种typedef类型对象是，该以哪一种delete形式删除之，考虑一下这个typedef: 为避免诸如此类错误，尽量不是对数组形式使用typedef操作。这容易达成，因为C++标准程序库含有string vector等templates,可以将数组的需求下降到0 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:5:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"Summary 在使用new delete需要使用一致的形势使用，否则会导致内存泄漏 在typedef自定义类型的时候，一定要注释写着哪一种delete形式删除 ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:5:1","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款17 以独立语句将newed对象置入智能指针 有些智能指针类(比如shared_ptr\u003cT\u003e)不支持隐式类型转换,假设存在这样两个函数 void fun(shared_ptr\u003cint\u003e lhs,int rhs); int foo(); 那么对于以下函数调用 fun(new int,foo()); 将不能通过编译,解决方法之一: fun(shared_ptr\u003cint\u003e(new int),foo()); 它共有三个步骤 执行new int 构造shared_ptr\u003cint\u003e 调用foo() 但是由于编译器对于同一语句的各项操作具有重新排列的自由,因此除了执行new int肯定在构造shared_ptr\u003cint\u003e之前外,调用foo(),可以发生在任何阶段,可能在最前,中间,最后,如果是按:执行new int→调用foo()→构造shared_ptr\u003cint\u003e的顺序执行,那么如果foo()发生异常,就会在shared_ptr\u003cint\u003e构造之前造成内存泄露. 对于1出现的问题,可以利用编译器对于\"跨越语句的各项操作\"没有重新排列的权力,以独立语句将newed对象置入智能指针,如下 shared_ptr\u003cint\u003e ptr(new int); fun(ptr,foo); 这样可以防止由于foo在new出的int被放入shared_ptr\u003cint\u003e之前抛出异常而导致内存泄露,但要注意: ptr不是临时对象,也就是说调用fun后ptr管理的内存没有被释放,而ptr的存在并不是为了要访问底层资源,而是为了防止出现异常而造成内存泄露存在的,所以如果不需要ptr所指向的内存,最好调用reset()将它释放.(个人认为这个条款有些鸡肋) ","date":"2023-03-05","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/:6:0","tags":["Effective C++"],"title":"条款13～17 资源管理","uri":"/effective-c-%E6%9D%A1%E6%AC%BE13-17/"},{"categories":["Effective C++"],"content":"条款5～12 构造/析构/赋值运算","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款5～12 构造/析构/赋值运算 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:0:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款5-了解c++默认生成的函数 前言 这本书其实有点老，该条款有很多东西过时了，所以该条款被 “Effective Modern C++” 条款17 特种成员函数的生成机制 替换 So? 直接去看这个条款吧 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:1:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款6-不想要的特种成员函数，明确禁止编译器自动生成 前言 该条款解决方法 分为两种，一个为\"c++11\"以后的解决方法，一个为\"c++98\" c++11 直接在不想要的特种成员函数 后面 加上 = delete 即可 class HomeForSale { public: HomeForSale(const HomeForSale\u0026) = delete; HomeForSale\u0026 operator=(const HomeForSale\u0026) = delete; } c++98 可以通过私有化 并且 只声明，而不去定义，具体如下述代码 class Uncopyable { protected: Uncopyable() { }; ~Uncopyable() { }; private: Uncopyable(const Uncopyable\u0026); Uncopyable\u0026 operator=(const Uncopyable\u0026); } class HomeForSale : private Uncopyable { ... }; ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:2:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 我们在不想要的特种成员函数，可以通过以下方法来禁止编译器自动生成 c++11 - 在成员函数后面 = delete c++98 - 放在私有数据里，只声明，不定义 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:2:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款7-为多态基类声明virtual析构函数 为多态基类声明virtual析构函数 如果不为多态基类声明virtual析构函数，那么在实例化派生类的时候，则会只调用基类的析构函数，就会造成内存泄漏 class TimeKeeper { public: TimeKeeper(); ~TimeKeeper(); // non-virtual }; class AtomicClock : public TimeKeeper { }; // getTimeKeeper(); 工厂函数，有可能实例化了AtomicClock，所以这时候一个父类的指针指向了子类 TimeKeeper* ptk = getTimeKeeper(); ... // use it delete ptk; // 这个就会出现问题，因为TimeKeeper的析构函数不是虚函数，所以只会用了TimeKeeper基类的析构函数 不是为了多态特性，不要随意声明virtual析构函数 如果不需要多态特性，还会析构函数声明了virtual，那么析构函数会变大，多了虚指针和虚表 类继承时小心父类析构函数不具有多态特性 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:3:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 为多态基类声明virtual析构函数 类继承时小心父类析构函数不具有多态特性 不是为了多态特性，不要随意声明virtual析构函数 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:3:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款8-析构函数不要抛出异常 析构函数不要抛出异常 析构函数抛出异常就代表这个析构函数并没有执行完，可能会造成内存泄漏 避免异常从析构函数抛出的方法 场景描述： class DBConnection { public: static DBConnection FactoryCreate(); // 工厂函数 void close(); // 抛出异常 }; class DBConn { public: ~DBConn() { db.close(); // 这样的话 其实close方法是可能会抛出异常的 } private: DBConnection db; } 发生异常直接终止程序（程序：你清高） DBConn::~DBConn() { try { db.Close(); } catch (...) { // 打印日志 std::abort(); //终止程序 } } 或者就是不终止程序了，直接把错误吞掉，打印好日志 DBConn::~DBConn() { try { db.Close(); } catch (...) { // 打印日志 } } 前两者都无法对\"抛出异常\"做出什么反应,另一个方法是避免异常函数在析构函数内执行,由客户来调用func函数,为避免客户忘记执行,需设立flag标记客户是否调用,如果客户没有调用,在析构函数内调用该函数 class DBConn { public: void close() { db.close(); closed = true; // 如果成功close 就设一个标识符 } ~DBConn() { if (!closed) { try { db.close(); } catch (...) { // make log } } } private: DBConnection db; } ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:4:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 析构函数不要抛出异常，因为抛出异常后，接下来的代码无法运行，就等于说析构没有全部执行，会造成内存泄漏 如果真的抛出异常了，有以下解决方法 记录log，并直接中止程序（想都不用想，其实不太可能） 记录log，直接无视错误，继续执行（其实有点不太好） 增加标志符，将抛出异常的函数交给用户去调用，如果用户没有调用，则在析构中调用，并记录log ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:4:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款9-不要再构造和析构函数中调用virtual函数 不要再构造和析构函数中调用virtual函数 如果在构造函数中调用了virtual函数，在实例化了派生类的时候，构造函数的执行顺序是从内到外，所以他会先调用父类的构造函数，但是父类的构造函数又调用了virtual函数，这时候派生类还没有初始化，所以调用的也只是父类的virtual函数 如果在析构函数中调用了virtual函数，在销毁派生类的时候，析构函数的执行顺序是从外到内的，所以他会先销毁子类，再是父类，但是父类的析构函数又调用了virtual函数，这时候派生类已经被干掉了，所以调用的也只是父类的virtual函数 class Base{ public: Base() { sayHello(); } virtual void sayHello() { std::cout \u003c\u003c \"Hello Base!\" \u003c\u003c std::endl; } virtual void sayBye() { std::cout \u003c\u003c \"Bye Base!\" \u003c\u003c std::endl; } virtual ~Base() { sayBye(); } } class Derived : public Base { Derived() { } void sayHello() override { std::cout \u003c\u003c \"Hello Derived\" \u003c\u003c std::endl; } void sayBye() override { std::cout \u003c\u003c \"Bye Derived\" \u003c\u003c std::endl; } } Derived derived; // 实例化派生类 // 结果 Hello Base! Bye Base! ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:5:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 不要再构造和析构函数中调用virtual函数 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:5:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款10 - operator=返回自身引用 如果不返回自身引用，那么在某些特殊场景 比如下述代码就会出现问题 class Widget { public: void operator=(const Widget\u0026 rhs) { } // return void } Widget w1(1), w2(2), w3(3); w2 = w1 // success w3 = w2 = w1 // 等同于 w3 = (w2 = w1) w3 = w2 = w1 这行先执行了 w2 = w1 然后 就会失败，因为传回来的是一个void 没有办法继续 w3 = 了 所以需要修改为返回自身引用，=要返回 其他的类似+= 也是同理 class Widget { public: Widget\u0026 operator=(const Widget\u0026 ths) { return *this; } Widget\u0026 operator=(int rhs) { return *this; } Widget\u0026 operator+=(const Widget\u0026 ths) { return *this; } } 这么做的目的就是因为要做一个统一的约定，因为w3 = w2 = w1确实是可以的，所以我要做成他们一样 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:6:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 要在 operator = 以及类似操作符 要返回自身引用 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:6:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款11-安全实现赋值运算符 潜在的自我赋值* 自我赋值一个bug：如果类里面有动态内存分配，那么在赋值的时候，需要先delete掉原来的，再new一个新的，最后赋值。但如果是自我赋值，那么在delete掉原来的内存的同时，需要赋的值也被delete了（因为都是同一块内存） 下面是个例子，假设我们有一个Bitmap类，一个Widget类。其中Widget有一个Bitmap的指针 class Bitmap{}; class Widget { public: Widget\u0026 operator=(const Widget\u0026 rhs); private: Bitmap* pb; }; // 防止自我赋值的 Widget\u0026 Widget::operator=(const Widget\u0026 rhs){ delete pb; pb = new Bitmap(*rhs.pb); return *this } 解决这个问题的方法就是在前面加个判断 class Bitmap{}; class Widget { public: Widget\u0026 operator=(const Widget\u0026 rhs); private: Bitmap* pb; }; // 防止自我赋值的 Widget\u0026 Widget::operator=(const Widget\u0026 rhs){ if (this == *rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this } 除此之外还有个问题。如果赋值的时候，new一块新的空间失败了，那么pb会指向一块被delete掉的空间。这样的指针是有害的 Widget\u0026 Widget::operator=(const Widget\u0026 rhs) { Bitmap *tmp = pb; pb = new Bitmap(*rhs.pb); delete tmp; return *this; } 首先上面这个版本申请了一个临时变量保存原始的对象。然后new一个Bitmap并赋值。如果这里出错了，还没到delete，其他的所有东西都保持原样。如果没有出错，则再将原始的空间，通过这个临时变量delete。这就解决了上面的问题 然后它还取消了自我赋值的检测。但是他依然可以处理自我检测问题，假如两个指针指向同一个对象，它也会先创建一个新的副本，赋值以后再删除原来的版本 copy and swap技术 这个技术需要保证swap函数是异常安全的 swap具体实现《条款25》会解释，这里只做了解 异常安全这个概念请去《条款29》深入理解 Widget\u0026 Widget::operator=(const Widget\u0026 rhs) { Widget tmp(rhs); swap(tmp); return this; } ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:7:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 我们在实现赋值运算符的时候 一定要去注意自我赋值 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:7:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"条款12-复制对象时勿忘其每一个成分 引言* 在深拷贝和浅拷贝的理解中，我们知道了\"拷贝构造函数\"，并且也了解了他的构成 因此，在pass by value的应用场景中，我们可以写出以下的拷贝构造函数 #include \u003ciostream\u003e #include\u003cstring\u003e using namespace std; class A { public: A(int i) : count(i) {}; A(const A\u0026 r) { // 拷贝构造函数 count = r.count; } ~A() {}; void out() { cout \u003c\u003c \"count:\" \u003c\u003c count \u003c\u003c endl; } private: int count; }; int main() { A a(1); A a1(a); // 将a的临时变量传递进去 a1.out(); return 0; } 不要忘记复制每一个成员 在引言的例子里，我们完整将count通过拷贝构造函数复制了过来。如果我们此时有了新需求，需要给类A增加一个成员x，那么在拷贝构造函数中，一定不要忘记拷贝x! #include \u003ciostream\u003e using namespace std; class A { public: A(int i, int j) : count(i),x(j) {}; A(const A\u0026 r) { count = r.count; x = r.x; // 不要忘记赋值成员x! } ~A() {}; void out() { cout \u003c\u003c \"count:\" \u003c\u003c count \u003c\u003c endl; cout \u003c\u003c \"x:\" \u003c\u003c x \u003c\u003c endl; } private: int count; int x; }; int main() { A a(1, 1); A a1(a); a1.out(); return 0; } 值得注意的是：如果我们遗漏了第9行代码，编译器是不会报错的，甚至也能正常运行，但是不会得出想要的结果1 拥有\"显示\"拷贝构造函数发生继承 在上面的A类中， 我们已经针对A写出了显示的拷贝构造函数。但是如果此时发生了继承会怎么样呢？ class B: public A { public: B(int x, int y) : b1(x),b2(y){}; B(const B\u0026 r){ b1 = r.b1; b2 = r.b2; }; ~B() {}; void out() { cout \u003c\u003c \"b1:\" \u003c\u003c b1 \u003c\u003c endl; cout \u003c\u003c \"b2:\" \u003c\u003c b2 \u003c\u003c endl; } private: int b1, b2; }; 简直跟class A一样有木有 于是我们开始编译 B b(2,2); B b1(b); ,会出现以下错误：error C2512: 'CPS' : no appropriate default constructor available 这是为什么呢 在类B的拷贝函数中看起来好像赋值了B中的每一个东西，但是它们复制的只是B声明的成员变量b1,b2;B继承A的成员变量附件完全木有得到复制啊 在创建对象时，会首先调用A类的构造函数。而在B的初始化列表中，并没有显示的对基类的构造函数进行调用。那么，系统会默认调用A的无参构造函数，但是你的A类并没有定义无参构造函数，所以出错了 改法如下 class B: public A { public: B(int x, int y) : b1(x),b2(y), A(x, y) {}; // 调用A的构造函数 B(const B\u0026 r) : A(r.b1, r.b2){ // 调用A的构造函数 b1 = r.b1; b2 = r.b2; }; ~B() {}; void out() { cout \u003c\u003c \"b1:\" \u003c\u003c b1 \u003c\u003c endl; cout \u003c\u003c \"b2:\" \u003c\u003c b2 \u003c\u003c endl; } private: int b1, b2; }; ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:8:0","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["Effective C++"],"content":"Summary 拷贝函数应该确保复制对象内的所有成员变量及所有的基类成分 不要尝试以某个拷贝函数实现另一个拷贝函数。应该将共同机能放进第三个函数中，并由两个拷贝函数共同调用 ","date":"2023-03-04","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/:8:1","tags":["Effective C++"],"title":"条款5～12 构造/析构/赋值运算","uri":"/effective-c-%E6%9D%A1%E6%AC%BE5-12/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了树的概念及种类","date":"2023-03-04","objectID":"/tree/","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"树 引出 当我们在刷算法的时候 当中有个思路就是空间换时间，因为在如今科技发达的社会 硬件已经很牛逼了，所以相比较，时间更为重要 还有个思路就是 升维这个思想，链表其实就是一维，跳表就是二维，将链表升维后 时间复杂度也从 O(n) 优化到了 O(logn) 树也是一样的 通过链表升维而诞生的一个数据结构 树的定义 二维数据结构 常见的二维数据结构 - 树 / 图 树和图的差别就是在于有没有环，环就是指 树有一个节点指向其他的节点 形成一个环 链表就是特殊的树，因为有树在极端的情况下 类似链表 树就是特殊的图，没有环的图就是树 树的实现代码 type TreeNode struct { val int left *TreeNode right *TreeNode } class TreeNode: def __init__(self, val): self.val = val self.left, self.right = None, None struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(NULL), right(NULL) } ","date":"2023-03-04","objectID":"/tree/:1:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"二叉树 什么是二叉树 二叉树就是每个节点都只有两个子节点 当然也会有三叉树这样的存在 ","date":"2023-03-04","objectID":"/tree/:2:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"二叉搜索树 什么是二叉搜索树 只需要满足以下特征的就是二叉搜索树 左子树所有节点都小于子树根节点 右子树所有节点大于子树根节点 以此类推，左右子树都分别满足这个性质 ","date":"2023-03-04","objectID":"/tree/:3:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"树的遍历 def preorder(self, root): # 前序遍历 if root: self traverse_path.append(root.val) self preorder(root.left) self preorder(root.right) def inorder(self, root): # 中序遍历 二叉搜索树中序遍历一定升序的 if root: self inorder(root.left) self traverse_path.append(root.val) self inorder(root.right) def postorder(self, root): if root: self postorder(root.left) self postorder(root.right) self traverse_path.append(root.val) func preorderTraversal(root *TreeNode) (res []int) { // 前序遍历 根-左-右 var preorder func(node *TreeNode) preorder = func(node *TreeNode) { if node == nil { return } res = append(res, node.Val) preorder(node.Left) preorder(node.Right) } preorder(root) return res } func inorderTraversal(root *TreeNode) (res []int) { // 中序遍历 左-根-右 var inorder func(node *TreeNode) inorder = func(node *TreeNode) { if node == nil { return } inorder(node.Left) res = append(res, node.Val) inorder(node.Right) } inorder(root) return res } func postorderTraversal(root *TreeNode) (res []int) { // 后序遍历 左-右-根 var postorder func(node *TreeNode) postorder = func(node *TreeNode) { if node == nil { return } postorder(node.Left) postorder(node.Right) res = append(res, node.Val) } postorder(root) return res } class Solution { // 前序遍历 public: void preorder(TreeNode* root, vector\u003cint\u003e \u0026res) { if (root == nullptr) return; res.push_back(root-\u003eval); preorder(root-\u003eleft, res); preorder(root-\u003eright, res); } vector\u003cint\u003e preorderTraversal(TreeNode* root) { vector\u003cint\u003e res; preorder(root, res); return res; } }; class Solution { // 中序遍历 public: void inorder(TreeNode* root, vector\u003cint\u003e \u0026res) { if (root == nullptr) return; inorder(root-\u003eleft, res); res.push_back(root-\u003eval); inorder(root-\u003eright, res); } vector\u003cint\u003e inorderTraversal(TreeNode* root) { vector\u003cint\u003e res; inorder(root, res); return res; } }; class Solution { // 后序遍历 public: void postorder(TreeNode* root, vector\u003cint\u003e\u0026 res) { if (root == nullptr) return; postorder(root-\u003eleft, res); postorder(root-\u003eright, res); res.push_back(root-\u003eval); } vector\u003cint\u003e postorderTraversal(TreeNode* root) { vector\u003cint\u003e res; postorder(root, res); return res; } }; ","date":"2023-03-04","objectID":"/tree/:4:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"树的遍历 - 题目推荐 /* https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/ 二叉树的前序遍历 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/ 二叉树的中序遍历 https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/ 二叉树的后序遍历 */ /* https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/ 验证二叉搜索树 https://leetcode-cn.com/problems/invert-binary-tree/submissions/ 翻转二叉树 */ ","date":"2023-03-04","objectID":"/tree/:5:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"平衡二叉搜索树 引出 树的时间复杂度经过升维的思想 从链表的O(n) 变成了 O(logn)，这个“n” 就是树的高度 但是在极端的树的情况会变成一个链表，时间复杂度会从O(logn) 退化成 O(n)，如下图 ***所以 维护一个树的平衡是很重要的，所以平衡二叉搜索树它lei了 *** 什么是平衡二叉搜索树 没有过深的左右子树 相对来说他们是平衡的 所以为了平衡 在insert delete操作要去动态的维持平衡 平衡二叉搜索树的种类 AVL / 红黑树 / b-tree / b+ tree ","date":"2023-03-04","objectID":"/tree/:6:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"AVL 什么是AVL树 AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis AVL 有一个概念是平衡因子（balance factor），是他的左子树高度减去右子树的高度（相反亦此） balance factor = { -1, 0, 1 } AVL又可以叫做 高度平衡二叉搜索树 他在insert delete操作时通过旋转来进行平衡 AVL的缺点 他的查询效率很快 但是他每个节点都要存储额外信息，且调整次数频繁 AVL示例图 AVL的四种旋转 ","date":"2023-03-04","objectID":"/tree/:7:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"红黑树 引出 我们已经了解了AVL这个高度平衡二叉搜索树，也已经知道他的缺点，所以红黑树又lei了 什么是红黑树 红黑树是一种近似平衡二叉搜索树 他的特点是保证任何一个节点的左右子树的高度差小于两倍 红黑树的五大特点 每个节点要么是黑色，要么是红色 根节点一定是黑色 每个叶节点（nil节点）是黑色 不能有相邻的两个红色节点 从任意节点出发到其每个叶节点的所有路径都包含相同数目的黑色节点 重点在于 不能有相邻的两个红色节点 从任意节点出发到其每个叶节点的所有路径都包含相同数目的黑色节点 保证了任何一个节点的左右子树的高度差小于两倍 红黑树图示 红黑树与AVL的对比 AVL更适合查询 因为他更平衡 / 红黑树只是近似平衡* 红黑树更适合插入 因为他插入的时候 不需要像avl那样时刻保持平衡 他只需要满足两倍差即可 ","date":"2023-03-04","objectID":"/tree/:8:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"字典树 什么是字典树 字典树 即trie树，又称前缀树，是一种树形结构 典型应用是用于统计和排序大量的字符串(但不仅限于字符串) 所以经常被搜索引擎系统用于文本词频统计 字典树的基本性质 节点本身不存完整的单词 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串 每个节点的所有子节点路径代表的字符都不相同 字典树图示 Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起，比如我们有[\"hello\",\"her\",\"hi\",\"how\",\"see\",\"so\"] 这个字符串集合 golang实现字典树 // Trie 树结构 type Trie struct { root *trieNode // 根节点指针 } // Trie 树节点 type trieNode struct { char string // Unicode 字符 isEnding bool // 是否是单词结尾 children map[rune]*trieNode // 该节点的子节点字典 } // 初始化 Trie 树 func NewTrie() *Trie { // 初始化根节点 trieNode := NewTrieNode(\"/\") return \u0026Trie{trieNode} } // 初始化 Trie 树节点 func NewTrieNode(char string) *trieNode { return \u0026trieNode{ char: char, isEnding: false, children: make(map[rune]*trieNode), } } // 往 Trie 树中插入一个单词 func (t *Trie) Insert(word string) { node := t.root // 获取根节点 for _, code := range word { // 以 Unicode 字符遍历该单词 value, ok := node.children[code] // 获取 code 编码对应子节点 if !ok { // 不存在则初始化该节点 value = NewTrieNode(string(code)) // 然后将其添加到子节点字典 node.children[code] = value } // 当前节点指针指向当前子节点 node = value } node.isEnding = true // 一个单词遍历完所有字符后将结尾字符打上标记 } // 在 Trie 树中查找一个单词 func (t *Trie) Find(word string) bool { node := t.root for _, code := range word { value, ok := node.children[code] // 获取对应子节点 if !ok { // 不存在则直接返回 return false } // 否则继续往后遍历 node = value } if node.isEnding == false { return false // 不能完全匹配，只是前缀 } return true // 找到对应单词 } ","date":"2023-03-04","objectID":"/tree/:9:0","tags":["树"],"title":"树","uri":"/tree/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了哈希表","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/","tags":["哈希表"],"title":"哈希表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/"},{"categories":["算法 \u0026 数据结构"],"content":"hashtable 什么叫hashtable 哈希表也叫做散列表，是根据关键码值而直接进行访问的数据结构 他通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度 这个映射函数叫做散列函数，存放的记录叫做哈希表 hashtable的时间复杂度 ***search：*O(1) ***Insertion：*O(1) ***Deletion：*O(1) 但是我们如果了解什么是哈希冲突 以及拉链法解决哈希冲突，那么在哈希表很小并且冲突很多的情况下，时间复杂度会退化成链表O(n) hashtable的原理和golang的map实现 图示 ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/:1:0","tags":["哈希表"],"title":"哈希表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/"},{"categories":["算法 \u0026 数据结构"],"content":"hashtable例题 // https://leetcode.cn/problems/reverse-linked-list/ // https://leetcode.com/problems/swap-nodes-in-pairs // https://leetcode.com/problems/linked-list-cycle // https://leetcode.com/problems/linked-list-cycle-ii ","date":"2023-03-03","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/:2:0","tags":["哈希表"],"title":"哈希表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/"},{"categories":["Effective C++"],"content":"条款1～4 让自己习惯c++","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款1～4 让自己习惯c++ ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:0:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款1-视c++为一个语言联邦 视c++为一个语言联邦 C Object-Oriented C++ Template C++ The STL ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:1:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"Summary 我们想要学习c++，一定就得学这4个，分别是c，c++的面向对象等特性，c++模板编程/泛型编程，STL ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:1:1","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款2-尽量不使用#define #define定义常量 #define定义常量的缺点 #define ASPECT_RATIO 1.653，#define是不会添加到符号表的，所以当跟ASPECT_RATIO有关报错的时候，不会提示ASPECT_RATIO出了问题，不利于报错排查 替换手段 可以拿const double AspectRatio = 1.653;来进行替换#define 在类中也可以拿static来定义\"常量\" class GamePlayer { private: static const int NumTurns = 5; int scores[NumTurns]; } 但是要注意 在编译的时候这个是通过的，但是如果你在后面对他有取地址之类的操作，链接就会报错，因为这里只是声明，并没有给他分配内存空间，所以还需要在cpp处理一下即可 const int GamePlayer::NumTurns; #define定义宏 #define定义宏的缺点 其实在inline专题有提到，#define定义宏，太麻烦了，只因他是直接替换的效果，最经典就是计算平方问题 #define CALL_WITH_MAX(a, b) f((a) \u003e (b) ? (a) : (b)) 替换手段 可以拿inline函数去进行替换 template\u003ctypename T\u003e inline void callWithMax(const T\u0026 a, const T\u0026 b) { f(a \u003e b ? a : b); } ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:2:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"Summary #define由于各个的因素，比如安全性，使用性，不太咋滴，所以尽量不使用#define 常量可以由const或者static替换 复杂的宏计算表达式就用inline替换 ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:2:1","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款3-尽量使用const 修饰指针 修饰指针一定要区分好，const pointer and const data char greeting[] = \"Hello\"; char* p = greeting; // non-const pointer, non-const data const char* p = greeting; // non-const pointer, const data char* const p = greeting; // const pointer, non-const data const char* const p = greeting; // const pointer, const data void f1(const Widget *pw); // f1 takes a pointer to a constant Widget object void f2(Widget const *pw); // so does f2 修饰 STL-iterator 修饰STL-iterator所带来的好处就是可以控制 iterator指向的值或者iterator本身是否被修改，同时这也是红黑树，map，set控制修改iterator指向的值的秘诀 std::vector\u003cint\u003e vec; // ... const auto iter = vec.begin(); // iter acts like a T* const *iter = 10; // OK, changes what iter pointer to ++iter; // error! iter is const auto cIter = vec.cbegin(); // cIter acts like a const T* *cIter = 10; // error! cIter is const ++cIter; // fine, changes cIter 将某些东西声明为const可以帮助编译器侦测出错误用法 在函数返回值修饰的好处就是可以保证一些低级的错误，如下述代码 class Rational { ... } const Rational operator * (const Rational\u0026 lhs, const Rational\u0026 rhs); Ration a, b, c; // ... (a * b) = c; // 这是没有错的，但是我们这么写很少 几乎没有 我们一般会把这个(a * b) = c; 加个 if判断，变成if (a * b == c) {...}，但是如果我们手抖，写成了if (a * b = c) 这个就是赋值了，但是编译器不会报错，但是我们在返回参数加了一个 const，就能够报错 将#define定义常量 修改为const也是可以帮助编译器侦测出错误类型 bitwise constness \u0026\u0026 logical constness 编译器强制实行bitwise constness(又称physical constness,物理上的常量性,即成员函数不更改对象的任何一个bit时才可以说是const),例如 class TextBlock{ public: ... char\u0026 operator [](std::size_t position) const{ return pText[position]; } private: char* pText; } 编译器认定它是bitwise constness的,但是它却允许以下代码的存在 const TextBlock cctb(\"Hello\"); char* pc=\u0026cctb[0]; *pc='J'; 这是由于只有pText是cctb的一部分,其指向的内存并不属于cctb 程序员编写程序时应该使用conceptual constness(概念上的常量性或logical constness,逻辑上的常量性,即一个const成员函数可以处理它所修改的对象的某些bits,但只有在客户端侦测不出的情况下才得如此) 例如对于某些特殊类,其中的某些成员的值注定是要改变的,因此可以用mutable关键字修饰,从而实现即使对象被设定为const,其特定成员的值仍然可以改变的效果.此时该类符合conceptual constness而不符合bitwise constness. 下述代码即就是上一句话的代码解释，在客户端的角度来说，他这个值是不修改的 class CTextBlock { public: std::size_t length() const; private: char* pText; mutable std::size_t textLength; mutable bool lengthThisVaild; }; std::size_t CTextBlock::length() const { if (!lengthThisVaild) { textLength = std::strlen(pText); lengthThisVaild = true; } return textLength; } 函数重载 如果参数是引用,可以基于参数是否为const实现函数重载(也可以基于指针是否为const实现函数重载),特殊的,对于成员函数,因为它存在一个隐含的this指针参数,因而可以基于函数是否为const实现重载 class TextBlock { public: const char\u0026 operator[](std::size_t position) const { return text[position]; } char\u0026 operator[](std::size_t position) { return text[position]; } private: std::string text; } TextBlock tb(\"hello\"); std:cout \u003c\u003c tb[0]; // calls non-const TextBlock::operator[] const TextBlock ctb(\"hello\"); std:cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[] 避免const和非const成员函数中的重复 class TextBlock { public: const char\u0026 operator[](std::size_t position) const { ... // 检查 ... // 打印日志 return text[position]; } char\u0026 operator[](std::size_t position) { ... // 检查 ... // 打印日志 return text[position]; } } 看上述代码 很明显 他们有重复代码，所以我们要抽出来，因为这样更好维护，代码如下 class TextBlock{ public: ... const char\u0026 operator[](std::size_t position) const{ ... return text[position]; } char operator[](std::size_t position){ return const_cast\u003cchar\u0026\u003e(static_cast\u003cconst TextBlock\u0026\u003e(*this)[position]); } ... }; 可以看出,经过了两次类型转换 第一次通过static_cast将*this转为const TextBlock\u0026，以确保调用的是operator[]的const版本，否则会调用非const版本导致递归调用造成栈溢出 第二次通过const_cast去掉const版本的opsrator[]返回的const char\u0026的const特性以与函数的返回类型相匹配 对于const_cast的行为之前存在一些误解,对于以下代码 #include\u003ciostream\u003e using std::cout; using std::endl; int main(){ const int a = 5; int\u0026 rta = const_cast \u003c int\u0026\u003e(a) ; rta = 6; cout \u003c\u003c \"a: \" \u003c\u003c a \u003c\u003c \" rtr: \" \u003c\u003c rta \u003c\u003c endl; cout \u003c\u003c \"\u0026a: \" \u003c\u003c \u0026a \u003c\u003c \" \u0026rta: \" \u003c\u003c \u0026rta; system(\"pause\"); return 0; } 输出结果如下 可见虽然const_cast表面上改变了变量的const性质,但a的值实际上还是没有改变(编译器仍然背着我们干了不少事),所以const_cast的实际用途并不是改变const对象的值,而是\"暂时\"去除对象的const属性使其可以作为参数传入非const函数,企图通过const_cast改变const对象的值可能会导致未预料的结果.因此个人认为5中的第二段代码(出自Effective C++ “条款3 尽可能用const”)存在一些错误,如有错误欢迎批评指正！ ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:3:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"Summary const可以修饰指针，要注意区分修饰指针 const int* i = 1; non-const-pointer / const-data int* const i = 1; const pointer / non-const-data const int* const i = 1; const pointer / const-data const可以用来修饰STL中的iterator 一定要知道红黑树下的map，set的key不可修改就是因为 const iterator const安全性比某些东西更高 没错 某些东西说的就是#define bitwise constness \u0026\u0026 logical constness 关于这个你只需要记住程序员编写程序时应该使用logical constness（概念上的常量性，逻辑上的常量性） 即一个const成员函数可以处理它所修改的对象的某些bits,但只有在客户端侦测不出的情况下才得如此 说简单点，就是在客户的角度上看，不需要修改其任何值，我们就必须使用const进行标注，但是在内部其实是修改了值的 如果参数是引用,可以基于参数是否为const实现函数重载(也可以基于指针是否为const实现函数重载),特殊的,对于成员函数,因为它存在一个隐含的this指针参数,因而可以基于函数是否为const实现重载 实现const重载时，我们可以利用static_cast const_cast来去除冗余代码 ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:3:1","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"条款4-对象使用前应该被初始化 class的成员变量总是以其声明的次序被初始化 在下述代码中，我们虽然在构造函数的初始化列表中先初始化了b_，再是a_，但是实际上是以声明的次序被初始化，也就是先初始化 a_，在初始化b_ class C { public: C(std::string aName, int bValue) : b_(bValue), a_(aName, b_.v_) { } private: A a_; // 不展示A class了 B b_; // 不展示B class了 } 类类型的构造函数对于成员按:基类成员→派生类类类型成员(按声明顺序)→派生类内置类型成员(按声明顺序)的顺序进行初始化. 构造函数成员初始化列表优于函数体赋值 Foo函数如下 随后我们来看看 不用构造函数的初始化列是什么情况 class Test { public: explicit Test(const Foo\u0026 foo) { foo_ = foo; } private: Foo foo_; } int main() { Foo foo(1, \"foo1\"); Test test(foo); return 0; } 我们来看看不用构造函数的初始化列 到底做了什么 最后我们再来看看用了构造函数的初始化列，形成一个对比 class Test { public: explicit Test(const Foo\u0026 foo) : foo_(foo) { } private: Foo foo_; } 我们也是很明显的发现 使用初始化列 明显性能要高于 不使用初始化列，不使用初始化列要先两次构造函数了，然后一步调用拷贝赋值，而使用初始化列只做了一个构造函数和一次拷贝构造函数 非局部变量的初始化顺序替换为函数运用结合 既然被替换了，那么肯定被替换者有什么问题，那我们来好好瞧瞧 接下来场景为多文件场景，有两个文件，分别是 “init_before_user.cpp”, “init_before_user1.cpp” // init_before_user.cpp #include \"foo.h\" Foo globalFoo(123, \"globalFoo\") int main() { printf(\"===main===\\n\"); } // init_before_user1.cpp #include \"foo.h\" extern Foo globalFoo; class Bar { public: explicit Bar(Foo \u0026foo) { printf(\"Bar(const Foo\u0026)foo.a=%d\\n\", foo.a); } }; Bar bar(globalFoo); 如果我们使用cmake add_executable(init_before_use init_before_use.cpp init_befor_user1.cpp ) 就会发现Bar的foo.a的值是不对的，这是因为初始化文件的顺序是会影响初始化的顺序的 add_executable(init_before_use init_befor_user1.cpp init_before_use.cpp ) 这样就正常了，但是这样我们肯定是不愿意看到的，坑非常大 通过函数运用去解决 // init_before_user.cpp #include \"foo.h\" Foo\u0026 globalFoo() { static Foo globalFoo(123, \"globalFoo\"); return globalFoo; } int main() { printf(\"===main===\\n\"); } // init_before_user1.cpp #include \"foo.h\" extern Foo\u0026 globalFoo(); class Bar { public: explicit Bar(Foo\u0026 foo) { printf(\"Bar(const Foo\u0026)foo.a=%d\\n\", foo.a); } }; Bar bar(globalFoo); 这样解决就不存在之前说的初始化的问题 ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:4:0","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["Effective C++"],"content":"Summery 类的成员变量的初始化顺序不是取决于初始化列表的顺序，而是声明的顺序 我们要尽量使用构造函数的初始化列表 因为这里才是真正的初始化，在函数体中那叫赋值 对于类类型,降低了程序效率，对于内置类型在初始化列表还是在函数体内初始化对于效率没有影响 在某些特殊情况(例如const变量和引用)必须在初始化列表进行初始化 非局部变量，比如全局变量，他会存在cmake的文件顺序来决定初始化顺序 所以使用函数来解决此问题 ","date":"2023-03-03","objectID":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/:4:1","tags":["Effective C++"],"title":"条款1～4 让自己习惯c++","uri":"/effective-c-%E6%9D%A1%E6%AC%BE1-4/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了双指针的概念及场景和例题","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"引言 对于数组和链表 来说 “双指针\"其实是一个常用的解法了 双指针也是有很多种类的 ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:1:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"普通双指针 什么是双指针 双指针模式指使用两个一前一后的指针遍历数据结构，直到某个指针触发停止条件 使用双指针的好处 单指针原本需要平方的时间复杂度，用了双指针便可优化到线性时间复杂度 ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:2:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"快慢指针 什么是快慢指针 两个速度不同的指针 比如 “fast指针” 跑两格 “slow指针” 跑一格 可以拿龟兔赛跑去想象，在一个圆形赛道，“兔子 -\u003e 快指针” 肯定会追上 “乌龟 -\u003e 慢指针”，龟兔赛跑也经常用在判断链表是否成环上面 ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:3:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"左右指针 来讲一讲题外话 其实 快慢指针 也有被说成 左右指针，但是本人认为这么说，其实是相当不合理，在此之上，我便有了一丝 朱光潜老先生的 “咬文嚼字” 的感觉，我始终认为 你给一个方法取名 其实就是代表了 你对这个方法的理解 比如了解什么是左右指针后 你把它叫做 “对撞指针” 也可以 这就是 “1000个读者有1000个哈姆雷特” 所以我也很推荐你们能拥有自己的想法 不要在意别人的命名 就好比 leetcode 题解 就有把快慢指针说为左右指针，你能说他错吗 其实快慢指针 也确实就是一个指针左 一个指针右 什么是左右指针 其实就是一个left指针从最左边向右跑，一个right指针从最右边向左跑 左右指针的代码模板 int left = 0, right = vector.size()-1; while (left \u003c= right) { ... } left, right := 0, len(array)-1 for left \u003c= right { ... } ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:4:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"滑动窗口 什么是滑动窗口 滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口 其实可以把它当成一个队列 如果 窗口要向后滑动 直接把开头去掉即可~ 这只是其中一个实现思想 滑动窗口的应用场景 滑动窗口可解决一系列字符串匹配问题 ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:5:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"双指针的应用场景 涉及 数组或链表，成对元素的集合、甚至是子数组 匹配一个「目标」值或是去除重复 ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:6:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"趣谈 - KMP 另起了一个专题 ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:7:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题1 - 数组 - 移动零 - 快慢指针 题目url 283. 移动零 - 力扣（LeetCode） 其他例题 26. 删除有序数组中的重复项 - 力扣（LeetCode） 88. 合并两个有序数组 - 力扣（LeetCode） ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:8:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题2 - 数组 - 盛最多水的容器 - 左右指针 题目url 11. 盛最多水的容器 - 力扣（LeetCode） 解题思路 这道题是 “求最优解”, 其实求最优解是 “贪心算法” 和 “动态规划\"的场景, 但是这里也可以用双指针 其他例题 189. 轮转数组 - 力扣（LeetCode） ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:9:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题3 - 链表 - 成环链表 - 快慢指针 题目url 141. 环形链表 - 力扣（LeetCode） 解题思路 成环链表 用 “快慢指针” 真的人人皆知 所以也要留个心眼 学个其他的解法 面试的时候 也是个亮点哦 其他例题 142. 环形链表 II - 力扣（LeetCode） ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:10:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题4 - 链表 - 反转链表 - 双指针 题目url 206. 反转链表 - 力扣（LeetCode） 解题思路 这道题我们可以这么看 1 -\u003e 2 -\u003e null 然后变成 null \u003c- 2 \u003c- 1 在遍历链表时，将当前节点的 next 指针改为指向前一个节点，由于节点没有引用其前一个节点，因此必须事先存储其前一个节点，在更改引用之前，还需要存储后一个节点。最后返回新的头引用 ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:11:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"例题5 - 字符串 - 无重复字符的最长字串 题目url 3. 无重复字符的最长子串 - 力扣（LeetCode） ","date":"2023-03-02","objectID":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/:12:0","tags":["双指针"],"title":"双指针","uri":"/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了二分查找的概念，思路，及例题","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的思想-减而治之 二分查找通过不断缩小区间的范围来查找目标元素，这种\"不断缩小区间\"就是减而治之的思想 减而治之听起来高大上，其实就是排除法，我们每一次查找就排除掉一些元素，每一次重复此操作，自然就找到了我们的目标元素 ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的应用范围 在有序数组中寻找一个目标值，有序和数组是重点 在整数范围内寻找一个目标值，也就是不一定是有序数组，旋转数组和山脉数组都可以用到二分法 ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的算法思路 ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"在循环体中查找元素 简介 此思路很简单，就是直接在数组中查找到目标元素 时间复杂度 O(log N)，这里的N是指数组的长度 空间复杂度：由于二分查找算法在执行的过程中只使用到常数个临时变量，因此空间复杂度是 O(1)。 代码模板 int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } } ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:1","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"在循环体中排除目标元素一定不存在的区间 简介 这种思路就是一直排除元素不存在的区间，然后剩下来最后一个数 也就是left = right的数，因为这里的循环条件就是while (left \u003c right) {}，最后进行这个数的判断是不是我们的目标数 时间复杂度 O(log N)，这里的N是指数组的长度 空间复杂度：由于二分查找算法在执行的过程中只使用到常数个临时变量，因此空间复杂度是 O(1)。 代码模板 int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } } ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:2","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"二分查找的重点 ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"循环条件 循环条件是一个很重要的东西，我们到底需要用left \u003c= right 还是使用left \u003c right，其实这就是跟思路有关了 ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:1","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"取中间数的代码 一般来说我们取中间数都是用(left + right) / 2这么使用如果两个数特别大的时候会造成溢出的，所以我们不能这么用 最好的我们是使用left + (right - left) / 2，这个计算方法很好的避免了溢出这个问题，故二分法要这么去写 其实还有一个利用位运算很帅的一个方法，int mid = (left + right) \u003e\u003e 1; 比如这个代码，大家做个了解即可这是因为整数右移 1 位和除以 2（向下取整）是等价的，这样写的原因是因为位运算比整除运算要快一点。但事实上，高级的编程语言，对于 / 2 和除以 2 的方幂的时候，在底层都会转化成为位运算，我们作为程序员在编码的时候没有必要这么做，就写我们这个逻辑本来要表达的意思即可，这种位运算的写法，在 C++ 代码里可能还需要注意优先级的问题 ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:2","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"中间数的代码要不要向上取整 int mid = left + (right - left) / 2中/ 2表示的含义其实是向下取整，如果最后区间位于中间的有两位数，那么只能取到左边的数，那么上取整和下取整有没有啥区别呢，其实是有的，这种区别我们可以在具体的题目中去感悟，哪一个 ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:4:3","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"案例一 - 二分查找 在循环体中查找元素 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c= right) { int mid = (left + right) / 2; if (nums[mid] == target) { return mid; } if (nums[mid] \u003c target) { left = mid + 1; } if (nums[mid] \u003e target) { right = mid - 1; } } return -1; } }; 在循环体中排除目标元素一定不存在区间 class Solution { public: int search(vector\u003cint\u003e\u0026 nums, int target) { int left = 0, right = nums.size()-1; while (left \u003c right) { int mid = (left + right) / 2; if (nums[mid] \u003c target) { left = mid + 1; } else { right = mid; } } if (nums[left] == target) { return left; } return -1; } }; ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:5:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"案例二 - 猜数字大小 在循环体中查找元素 class Solution { public: int guessNumber(int n) { int left = 1, right = n; while (left \u003c= right) { int mid = left + (right - left) / 2; if (0 == guess(mid)) { return mid; } if (-1 == guess(mid)) { right = mid - 1; } if (1 == guess(mid)) { left = mid + 1; } } return -1; } }; 在循环体中排除目标元素一定不存在区间 class Solution { public: int guessNumber(int n) { int left = 1, right = n; while (left \u003c right) { int mid = left + (right - left) / 2; if (1 == guess(mid)) { left = mid + 1; } else { right = mid; } } return left; } }; 课后习题 搜索插入位置 在排序数组中查找元素的第一个和最后一个位置 寻找旋转排序数组中的最小值 寻找旋转排序数组中的最小值 II 搜索旋转排序数组 搜索旋转排序数组 II 第一个错误的版本 山脉数组的峰顶索引 山脉数组中查找目标值 寻找两个正序数组的中位数 x 的平方根 寻找重复数 转变数组后最接近目标值的数组和 爱吃香蕉的珂珂 分割数组的最大值 在 D 天内送达包裹的能力 制作 m 束花所需的最少天数 小张刷题计划 ","date":"2023-03-01","objectID":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:6:0","tags":["二分查找"],"title":"二分查找","uri":"/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法 \u0026 数据结构"],"content":"栈\u0026队列","date":"2023-02-27","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"什么是队列 队列是一个 先进先出 的数据结构 先进来的元素 先被消费使用 好比排队 第一个排队的人肯定第一个出来 这就是先进先出 队列有两种重要的方法 - push（往队列的尾部塞入元素）/ pop（往队列的头部删除元素） ","date":"2023-02-27","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:1:0","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"什么是栈 栈是一个 先进后出 的数据结构 先进来的元素 最后一个被消费使用 / 最后进来的元素 第一个被消费使用 好比一个箱子 你往里面放书 第一个书本在最下面 你只能第一时间拿出最上面的书 也就是最后放进去的书 栈有两种重要的方法 - push（往栈的尾部塞入元素）/ pop（往栈的尾部删除元素） ","date":"2023-02-27","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:2:0","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"什么是双端队列 是一种具有队列和栈性质的数据类型 双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行 ","date":"2023-02-27","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:3:0","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"什么是优先级队列 依靠每个元素的优先级 来决定哪一个最先被消费使用 ","date":"2023-02-27","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:4:0","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"Golang实现队列 golang 如何实现队列 及其 他的时间复杂度是多少 insert：O(1) delete: O(1) // A FIFO queue. type Queue []int // 往队列的尾部塞入元素 func (q *Queue) Push(v int) { *q = append(*q, v) } // pop（往队列的头部删除元素） func (q *Queue) Pop() int { head := (*q)[0] *q = (*q)[1:] return head } // Returns if the queue is empty or not. func (q *Queue) IsEmpty() bool { return len(*q) == 0 } ","date":"2023-02-27","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:5:0","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"Golang实现栈 golang 如何实现栈 及其他的时间复杂度是多少 insert: O(1) delete: O(1) type Stack []interfice{} func (stack Stack) Len() int { return len(stack) } func (stack Stack) Cap() int { return cap(stack) } func (stack *Stack) Push(value interface{}) { *stack = append(*stack, value) } func (stack Stack) Top() (interface{}, error) { if len(stack) == 0 { return nil, errors.New(\"Out of index, len is 0\") } return stack[len(stack) - 1], nil } func (stack *Stack) Pop() (interface{}, error) { theStack := *stack if len(theStack) == 0 { return nil, errors.New(\"Out of index, len is 0\") } value := theStack[len(theStack) - 1] *stack = theStack[:len(theStack) - 1] return value, nil } func (stack Stack) IsEmpty() bool { return len(stack) == 0 } ","date":"2023-02-27","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:6:0","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"Tips 不要仅限于固定思想 实现栈 和 队列的方式千千万万 用两个栈实现队列 https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/ ","date":"2023-02-27","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:7:0","tags":["栈","队列"],"title":"栈\u0026队列","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["算法 \u0026 数据结构"],"content":"数组-链表-跳表","date":"2023-02-26","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"数组 数组的特点 当我们申请数组的时候，计算机会在内存开辟一段连续的内存地址，内存管理器可以直接访问每个内存地址，所以我们可以通过\" [ ] “去取值 数组的时间复杂度 select： O(1) insert： O(n) append： O(1) delete： O(n) 数组时间复杂度图示 ","date":"2023-02-26","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:1:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"链表 引出 研究数据结构的科学家们 看到数组的 “insert” “delete” 就会去想优化这个时间复杂度 随后 链表诞生了 何为链表 非连续的内存空间 有一个个的 节点（node） 组成 node 又是由 value next 组成 value 可以为int string 对象 … 等类型 next 则就是一个指针 指向下一个node 时间复杂度 select: O(n) Append: O(1) insert: O(1) delete: O(1) ps: 不结合实际场景的计算时间复杂度都是耍流氓 图示 ","date":"2023-02-26","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:2:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"单向链表 时间复杂度 select: O(n) 查询需要从head节点遍历 所以 O(n) insert: O(n) 插入需要从head节点遍历到 插入的前驱节点 所以O(n) delete: O(n) 删除跟插入同理 golang 实现单向链表 type Object interface{} type Node struct { Data Object next *Node } type List struct { size uint64 head *Node tail *Node } func (list *List) Init() { (*list).size = 0 (*list).head = nil (*list).tail = nil } // 向链表追加节点 func (list *List) Append(node *Node) bool { if node == nil { return false } (*node).next = nil // 新加节点在末尾，没有next if (*list).size == 0 { (*list).head = node } else { oldTail := (*list).tail // 取尾结点 (*oldTail).next = node // 尾结点的next指向新加节点 } (*list).tail = node // 新节点是尾结点 (*list).size++ return true } // 向第i个节点处插入节点 func (list *List) Insert(i uint64, node *Node) bool { if node == nil || i \u003e (*list).size || (*list).size == 0 { return false } if i == 0 { (*node).next = (*list).head (*list).head = node } else { preNode := (*list).head for j := uint64(1); j \u003c i; j++ { preNode = (*preNode).next } (*node).next = (*preNode).next // 新节点指向旧节点原来所指的next (*preNode).next = node // 原节点的next指向新节点 } (*list).size++ return true } // 移除指定位置的节点 func (list *List) Remove(i uint64) bool { if i \u003e= (*list).size { return false } if i == 0 { preHead := (*list).head // 取出旧的链表头 (*list).head = preHead.next // 旧链表头的next变为新的头 // 如果仅有一个节点，则头尾节点清空 if (*list).size == 1 { (*list).head = nil (*list).tail = nil } } else { preNode := (*list).head for j := uint64(1); j \u003c i; j++ { preNode = (*preNode).next } node := (*preNode).next // 找到当前要删除的节点 (*preNode).next = node.next // 把当前要删除节点的next赋给其父节点的next,完成后代转移 // 若删除的尾部，尾部指针需要调整 if i == ((*list).size - 1) { (*list).tail = preNode } } (*list).size-- return true } // 移除所有节点 func (list *List) RemoveAll() bool { (*list).Init() return true } // 获取指定位置的节点 func (list *List) Get(i uint64) *Node { if i \u003e= (*list).size { return nil } node := (*list).head for j := uint64(0); j \u003c i; j++ { node = (*node).next } return node } // 搜索某个数据的节点位置 func (list *List) IndexOf(data Object) int64 { pos := int64(-1) node := (*list).head if node.Data == data { return 0 } for j := uint64(1); j \u003c (*list).size; j++ { if node != nil { node = (*node).next if node != nil \u0026\u0026 node.Data == data { pos = int64(j) break } } } return pos } // 取得链表长度 func (list *List) GetSize() uint64 { return (*list).size } // 取得链表头 func (list *List) GetHead() *Node { return (*list).head } // 取得链表尾 func (list *List) GetTail() *Node { return (*list).tail } ","date":"2023-02-26","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:3:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"双向链表 时间复杂度 select: O(n) 查询需要从head节点遍历 所以 O(n) insert: O(n) 跟单项链表一样 都需要知道前驱node delete: O(n) 同上 append: O(1) golang 实现代码 // 节点数据 type DoubleObject interface{} // 双链表节点 type DoubleNode struct { Data DoubleObject Prev *DoubleNode Next *DoubleNode } // 双链表 type DoubleList struct{ mutex *sync.RWMutex Size uint Head *DoubleNode Tail *DoubleNode } // 双链表初始化 func (list *DoubleList)Init() { list.mutex = new(sync.RWMutex) list.Size = 0 list.Head = nil list.Tail = nil } // Get 获取指定位置的节点 func (list *DoubleList)Get(index uint) *DoubleNode { if list.Size == 0 || index \u003e list.Size - 1 { return nil } if index == 0{ return list.Head } node := list.Head var i uint for i = 1; i \u003c= index; i ++{ node = node.Next } return node } // Append 向双链表后面追加节点 func (list *DoubleList)Append(node *DoubleNode) bool { if node == nil{ return false } list.mutex.Lock() defer list.mutex.Unlock() if list.Size == 0 { list.Head = node list.Tail = node node.Next = nil node.Prev = nil } else { node.Prev = list.Tail node.Next = nil list.Tail.Next = node list.Tail = node } list.Size++ return true } // Insert 向双链表指定位置插入节点 func (list *DoubleList)Insert(index uint, node *DoubleNode) bool { if index \u003e list.Size || node == nil{ return false } if index == list.Size{ return list.Append(node) } list.mutex.Lock() defer list.mutex.Unlock() if index == 0{ node.Next = list.Head list.Head = node list.Head.Prev = nil list.Size++ return true } nextNode := list.Get(index) node.Prev = nextNode.Prev node.Next = nextNode nextNode.Prev.Next = node nextNode.Prev = node list.Size++ return true } // Delete 删除指定位置的节点 func (list *DoubleList) Delete (index uint) bool { if index \u003e list.Size - 1 { return false } list.mutex.Lock() defer list.mutex.Unlock() if index == 0 { if list.Size == 1{ list.Head = nil list.Tail = nil } else { list.Head.Next.Prev = nil list.Head = list.Head.Next } list.Size-- return true } if index == list.Size - 1{ list.Tail.Prev.Next = nil list.Tail = list.Tail.Prev list.Size-- return true } node := list.Get(index) node.Prev.Next = node.Next node.Next.Prev = node.Prev list.Size-- return true } ","date":"2023-02-26","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:4:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"跳表 引出 对于一组有序数据，我们想要在其中查找某个数，如果数据使用数组存储，显然二分法是再适合不过了，但是如果数据是用链表存储的呢？难道我们用从头遍历吗？这样时间复杂度会达到O（n）级别，相比二分法O（logn）级别简直天壤地别。那么如何提高效率呢 跳表 算法有两个很重要的思想 空间换时间 升维 跳表其实就是链表采用了升维的思想 如下图，对初始链表做一层“索引”，每两个节点提取一个节点到上一层，然后用down指针连接到下一层。 现在我们查询16这个节点。从第一级索引开始，找到13，并且下一个为17，显然16在这两个节点之间，利用down指针下降一层，这次我们遍历2次即可。利用索引后，遍历了5+2=7次，而原始链表需要10次，这里加一层索引遍历次数减少了，效率提高了一点，但还不够，我们继续往上添加索引层 ","date":"2023-02-26","objectID":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/:5:0","tags":["数组","链表","跳表"],"title":"数组-链表-跳表","uri":"/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/"},{"categories":["算法 \u0026 数据结构"],"content":"详述了时间\u0026空间复杂度的概念及计算","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"时间复杂度 \u0026 空间复杂度 时间复杂度 O(1) 常数复杂度 O(log n) 对数复杂度 O(n) 线性时间复杂度 O(nlogn) 线性对数时间复杂度 O(n ^ 2) 平方 O(n ^ 3) 立方 O(2 ^ n) 指数 O(n!) 阶乘 O(1) \u003c O(logn) \u003c O(n) \u003c O(nlogn) \u003c O(n ^ 2) \u003c O(n ^ 3) \u003c O(2 ^ n) \u003c O(n!) ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:0:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(1) n := 1000 fmt.Println(n) ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(logn) 时间复杂度 O(logn) —对数阶，当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标 代码 for i := 1; i \u003c n; i = i * 2 { fmt.Println(i) } ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n) for i := 0; i \u003c n; i++ { fmt.Println(i) } ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n + m) for i := 0; i \u003c n; i++ { fmt.Println(i) } for j := 0; j \u003c m; j++ { } // O(n + m) ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:4:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(nlogn) 线性对数阶O(nlogn)其实非常容易理解，将对数阶O(logn)的代码循环n遍的话，那么它的时间复杂度就是 n * O(logn)，也就是了O(nlogn)，归并排序的复杂度就是O(nlogn) for (int m = 1; m \u003c= n; m++) { int i = 1; while (i \u003c n) { i = i * 2; } } ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:5:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n ^ 2) for i := 0; i \u003c n; i++ { for j := 0; j \u003c n; j++ { fmt.Println(i) fmt.Println(j) } } ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:6:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(nm) for i := 0; i \u003c n; i++ { for j := 0; j \u003c m; j++ { fmt.Println(i) fmt.Println(j) } } ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:7:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(k ^ n) func fib(n int) int { if n \u003c= 0 { return 1 } return n * fib(n - 1) } ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:8:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"时间复杂度减少 计算: 1 + 2+ 3 + 4 + 5 + .. + n 方法1: y = 0 for i = 1; i \u003c= n; i++ { y += i } 方法2 求和公式: y = n * (n+1)/2 ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:9:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"图示总结 空间复杂度 ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:10:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"leetcode 常争论的一个点 func test(n int) []int { res := make([]int, 0) res = append(res, n) return res } ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:11:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(1) int i; ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:12:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n) int[] arr; ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:13:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["算法 \u0026 数据结构"],"content":"O(n ^ 2) int[][] arr; ","date":"2023-02-25","objectID":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:14:0","tags":["时间/空间复杂度"],"title":"时间 / 空间复杂度","uri":"/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["缘起 在人群中 我看见你"],"content":"如何理解协程","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"如何理解协程? ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:0:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"普通的函数 我们先来看看普通的函数，从简到繁嘛 def func(): print(\"a\") print(\"b\") print(\"c\") 这是一个简单的函数，当我们调用这个函数的时候会发生啥? 调用func func开始执行，直到return func执行完毕，返回函数A 是不是很简单，函数func执行直到返回，并打印出：“a, b, c” ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:1:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"从普通函数到协程 协程是可以有多个返回点的，这是什么意思呢？ void func() { print(\"a\") 暂停并返回 print(\"b\") 暂停并返回 print(\"c\") } 普通函数下，只有当执行完print(“c”)这句话后函数才会返回，但是在协程下当执行完print(“a”)后func就会因“暂停并返回”这段代码返回到调用函数 有的同学可能会一脸懵逼，这有什么神奇的吗？我写一个return也能返回，就像这样 void func() { print(\"a\") return print(\"b\") 暂停并返回 print(\"c\") } 直接写一个return语句确实也能返回，但这样写的话return后面的代码都不会被执行到了 协程之所以神奇就神奇在当我们从协程返回后还能继续调用该协程，并且是从该协程的上一个返回点后继续执行 这时我们就可以返回到调用函数，当调用函数什么时候想起该协程后可以再次调用该协程，该协程会从上一个返回点继续执行 这个暂停并返回 在编程语言中一般叫做yield(其它语言中可能会有不同的实现，但本质都是一样的) 需要注意的是，当普通函数返回后，进程的地址空间中不会再保存该函数运行时的任何信息，而协程返回后，函数的运行时信息是需要保存下来的，那么函数的运行时状态到底在内存中是什么样子呢，关于这个问题你可以参考这里 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:2:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"Show Me The Code 下面我们采用python来讲解一个例子，不用担心看不懂，在python中，同样使用yield，这样我们的函数就变成了 def func() { print(\"a\") yield print(\"b\") yield print(\"c\") } 注意，这时候这个函数就不再是简简单单的函数了，而是升级成为了协程，然后我们该怎么使用呢 def A(): co = func() # 得到该协程 next(co) # 调用协程 print(\"in function A\") # do something next(co) # 再次调用该协程 我们看到虽然func函数没有return代码，也就是说虽然没有返回任何值，但是我们依然可以写co = func()这样的代码，意思是说co就是我们拿到的协程了 我们来看一看这个代码做的事情 我们调用该协程，使用next(co)，运行A函数看看执行到第三行的结果是什么? a 显然，和我们预期的一样，协程在print(\"a\")后因执行yield而暂停并返回函数A 接下来是第4行，这个毫无疑问，A函数在做一些自己的事情，因此会打印 a in function A 接下来是重点的一行，当执行第5行再次调用协程时该打印什么呢 a in function A b 看到了吧，协程是一个很神奇的函数，它会自己记住之前的执行状态，当再次调用时会从上一次的返回点继续执行 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:3:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"图形化解释 为了让你更加彻底的理解协程，我们使用图形化的方式再看一遍，首先是普通的函数调用 在该图中，方框内表示该函数的指令序列，如果该函数不调用任何其它函数，那么应该从上到下依次执行，但函数中可以调用其它函数，因此其执行并不是简单的从上到下，箭头线表示执行流的方向 从图中我们可以看到，我们首先来到funcA函数，执行一段时间后发现调用了另一个函数funcB，这时控制转移到该函数，执行完成后回到main函数的调用点继续执行 这是普通的函数调用 接下来是协程 在这里，我们依然首先在funcA函数中执行，运行一段时间后调用协程，协程开始执行，直到第一个挂起点，此后就像普通函数一样返回funcA函数，funcA函数执行一些代码后再次调用该协程，注意，协程这时就和普通函数不一样了，协程并不是从第一条指令开始执行而是从上一次的挂起点开始执行，执行一段时间后遇到第二个挂起点，这时协程再次像普通函数一样返回funcA函数，funcA函数执行一段时间后整个程序结束 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:4:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"函数只是协程的一种特例 怎么样，神奇不神奇，和普通函数不同的是，协程能知道自己上一次执行到了哪里。 现在你应该明白了吧，协程会在函数被暂停运行时保存函数的运行状态，并可以从保存的状态中恢复并继续运行。 很熟悉的味道有没有，这不就是操作系统对线程的调度嘛，线程也可以被暂停，操作系统保存线程运行状态然后去调度其它线程，此后该线程再次被分配CPU时还可以继续运行，就像没有被暂停过一样。 只不过线程的调度是操作系统实现的，这些对程序员都不可见，而协程是在用户态实现的，对程序员可见 这就是为什么有的人说可以把协程理解为用户态线程的原因 也就是说现在程序员可以扮演操作系统的角色了，你可以自己控制协程在什么时候运行，什么时候暂停，也就是说协程的调度权在你自己手上。 在协程这件事儿上，调度你说了算。 当你在协程中写下yield的时候就是想要暂停该协程，当使用next()时就是要再次运行该协程。 现在你应该理解为什么说函数只是协程的一种特例了吧，函数其实只是没有挂起点的协程而已 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:5:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"协程是如何实现的 让我们从问题的本质出发来思考这个问题，协程的本质是什么 其实就是可以被暂停以及可以被恢复运行的函数 好比NBA比赛被暂停，但是也可以继续比赛，因为比赛状态被记录了下来，这里的状态就是上下文-context 协程之所以可以被暂停也可以继续，那么一定要记录下被暂停时的状态，也就是上下文，当继续运行的时候要恢复其上下文(状态)，那么接下来很自然的一个问题就是，函数运行时的状态是什么？ 这个关键的问题的答案就在《函数运行起来后在内存中是什么样子的》这篇文章中，函数运行时所有的状态信息都位于函数运行时栈中 函数运行时栈就是我们需要保存的状态，也就是所谓的上下文，如图所示： 从图中我们可以看出，该进程中只有一个线程，栈区中有四个栈帧，main函数调用了A，A调用了B，B调用了C，当C函数在运行时整个进程的状态就如图所示 现在我们已经知道了函数的运行时状态就保存在栈区的栈帧中，接下来重点来了哦 既然函数的运行时状态保存在栈区的栈帧中，那么如果我们想暂停协程的运行就必须保存整个栈帧的数据，那么我们该将整个栈帧中的数据保存在哪里呢？ 很显然，这就是堆区啊，heap，我们可以将栈帧保存在堆区中，那么我们该怎么在堆区中保存数据呢？希望你还没有晕，在堆区中开辟空间就是我们常用的C语言中的malloc或者C++中的new 我们需要做的就是在堆区中申请一段空间，让后把协程的整个栈区保存下，当需要恢复协程的运行时再从堆区中copy出来恢复函数运行时状态 再仔细想一想，为什么我们要这么麻烦的来回copy数据呢？ 实际上，我们需要做的是直接把协程的运行需要的栈帧空间直接开辟在堆区中，这样都不用来回copy数据了，如图所示 从图中我们可以看到，该程序中开启了两个协程，这两个协程的栈区都是在堆上分配的，这样我们就可以随时中断或者恢复协程的执行了 有的同学可能会问，那么进程地址空间最上层的栈区现在的作用是什么呢？ 这一区域依然是用来保存函数栈帧的，只不过这些函数并不是运行在协程而是普通线程中的 现在你应该看到了吧，在上图中实际上有3个执行流： 一个普通线程 两个协程 虽然有3个执行流但我们创建了几个线程呢？ 一个线程 现在你应该明白为什么要使用协程了吧，使用协程理论上我们可以开启无数并发执行流，只要堆区空间足够，同时还没有创建线程的开销，所有协程的调度、切换都发生在用户态，这就是为什么协程也被称作用户态线程的原因所在 因此即使你创建了N多协程，但在操作系统看来依然只有一个线程，也就是说协程对操作系统来说是不可见的 现在你应该对协程有一个清晰的认知了吧 ","date":"2023-02-17","objectID":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/:6:0","tags":["协程"],"title":"如何理解协程","uri":"/%E7%BC%98%E8%B5%B7-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%8F%E7%A8%8B/"},{"categories":["缘起 在人群中 我看见你"],"content":"PImpl","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"函数运行时在内存中是什么样子? ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:0:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"引言 在进入到本章的内容前，我们来思考思考几个问题 void f(int a) { if (a \u003e 10000000) return; int arr[100] = { 0 }; f(a+1); } 你能看出这段代码有啥问题吗 你知道协程的本质吗？有的同学可能会说是用户态线程，那么用户态线程是怎么实现的？ 函数运行起来后在内存中是什么样子？ 这几个问题看起来没什么关联，但是背后都指向一个东西，这就是所谓函数运行栈（run time stack） ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:1:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"从进程、线程到函数调用 举个小例子，汽车在高速上行驶时有很多信息，比如速度、位置，通过这些信息我们可以直观的感受汽车的运行时状态 同样的，程序在运行时也有很多信息，像有哪些程序正在运行、这些程序执行到了哪里等等，通过这些信息我们可以直观的感受系统中程序运行的状态 其中，我们创造了进程、线程这样的概念来记录有哪些程序正在运行 进程和线程的运行体现在函数执行上，函数的执行除了函数内部执行的顺序执行还有子函数调用的控制转移以及子函数执行完毕的返回。其中函数内部的顺序执行乏善可陈，重点是函数的调用 因此接下来我们的视角将从宏观的进程和线程拉近到微观下的函数调用，重点来讨论一下函数调用是怎样实现的 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:2:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"函数执行的活动轨迹：栈 也是一样，举个小例子，玩过游戏的同学应该知道，有时你为了完成一项主线任务不得不去打一些支线的任务，支线任务中可能还有支线任务，当一个支线任务完成后退回到前一个支线任务 主线任务A - 西天取经 支线任务B - 收服🐒 支线任务D - 拿到紧箍咒 支线任务C - 收服🐷 也就是说，我们必须支线任务B和支线任务C完成后，才能继续完成主线任务A 想要完成支线任务B 就必须完成支线任务D-拿到紧箍咒 整个任务的依赖关系如图所示： 然后，我们来模拟模拟任务完成过程 首先，我们来到任务A，执行主线任务 执行任务A的过程中我们发现任务A依赖任务B，这时我们暂停任务A去执行任务B 执行任务B的时候，我们又发现依赖任务D 执行任务D的时候我们发现该任务不再依赖任何其它任务，因此C完成后我们可以会退到前一个任务，也就是B 任务B除了依赖任务C外不再依赖其它任务，这样任务B完成后就可以回到任务A 现在我们回到了主线任务A，依赖的任务B执行完成，接下来是任务C 和任务D一样，C不依赖任何其它其它任务，任务C完成后就可以再次回到任务A，再之后任务A执行完毕，整个任务执行完成 让我们来看一下整个任务的活动轨迹 仔细观察，实际上你会发现这是一个 “First In Last Out” 的顺序，天然适用于栈这种数据结构来处理。 再仔细看一下栈顶的轨迹，也就是A、B、D、B、A、C、A，实际上你会发现这里的轨迹就是任务依赖树的遍历过程，是不是很神奇，这也是为什么树这种数据结构的遍历除了可以用递归也可以用栈来实现的原因。 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:3:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"A Box 函数调用也是同样的道理，你把上面的ABCD换成函数ABCD，本质不变 因此，我们知道了，使用栈这种结构就可以用来保存函数调用信息 和游戏中的每个任务一样，当函数在运行时每个函数也要有自己的一个\"小盒子\"，这个小盒子中保存了函数运行时的各种信息，这写小盒子通过栈这种结构组织起来，这个小盒子就被称为\"栈帧（stack frames）\"，也有的称之为 call stack 不管用什么命名，总之，就是这里所说的小盒子，这个小盒子就是函数运行起来后占用的内存，这些小盒子构成了我们通常所说的栈区 那么问题也就来了，函数调用时都有哪些信息呢 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:4:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"控制转移 我们知道当函数A调用函数B的时候，控制从A转移到了B，所谓控制其实就是指CPU执行属于哪个函数的指令，CPU从开始执行属于函数A的指令切换到执行属于函数B的指令，我们就说控制从函数A转移到了函数B 控制从函数A转移到了函数B，我们需要有这两个信息 我从哪里来（返回） 要到哪里去（跳转） 好比你出去旅游，你需要知道去哪里，还需要记住回家的路（写到这里我想起来 哲学的三大问题 我是谁，我从哪里来，要到哪里去。笑死，其实函数也一样要问自己这三个问题，人的智慧其实就是会仿生，无论什么东西都是充斥的模仿的艺术，好比tree数据结构，不是吗?） 好，回归正题，函数调用也是一样的道理，当函数A调用函数B，我们只要知道 函数A对于的机器指令执行到了哪里（我从哪里来） 函数B第一条机器指令所在的地址（要到哪里去） 那么这些信息是怎么获取并保持的呢，现在我们就可以打开这个小盒子，来看看怎么玩的 假设函数A调用函数B，如图所示 当前，CPU执行函数A的机器指令，该指令的地址为0x400564，接下来CPU将执行下一条机器指令也就是 call 0x400540 这条机器指令对应的就是我们在代码中所写的函数调用，注意call后有一条机器指令地址，注意观察上图你会看到，该地址就是函数B的第一条机器指令，从这条机器指令后CPU将跳转到函数B 现在我们已经解决了控制跳转的“要到哪里去”问题，当函数B执行完毕后怎么跳转回来呢？ 原来，call指令除了给出跳转地址之外还有这样一个作用，也就是把call指令的下一条指令的地址，也就是0x40056a push到函数A的栈帧中，如图所示 现在，函数A的小盒子变大了一些，因为装入了返回地址 现在CPU开始执行函数B对应的机器指令，注意观察，函数B也有一个属于自己的小盒子(栈帧)，可以往里面扔一些必要的信息 如果函数B中又调用了其它函数呢？道理和函数A调用函数B是一样的 让我们来看一下函数B最后一条机器指令ret，这条机器指令的作用是告诉CPU跳转到函数A保存在栈帧上的返回地址，这样当函数B执行完毕后就可以跳转到函数A继续执行了 至此，我们解决了控制转移中“我从哪里来”的问题 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:5:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"传递参数与获取返回值 函数调用与返回使得我们可以编写函数，进行函数调用。但调用函数除了提供函数名称之外还需要传递参数以及获取返回值，那么这又是怎样实现的呢？ 在x86-64中，多数情况下参数的传递与获取返回值是通过寄存器来实现的 假设函数A调用了函数B，函数A将一些参数写入相应的寄存器，当CPU执行函数B时就可以从这些寄存器中获取参数了 同样的，函数B也可以将返回值写入寄存器，当函数B之行结束后函数A从该寄存器中就可以读取到返回值了 但是，我们都知道寄存器的数量是有限的，当传递的参数多于寄存器的数量该怎么办 这时候，小盒子也就是栈帧，又是他发挥作用的时候到了 原来，当参数个数多于寄存器数量时剩下的参数直接放到栈帧中，这样被调函数就可以从前一个函数的栈帧中获取到参数了 现在栈帧的样子又可以进一步丰富了，如图所示： 从图中我们可以看到，调用函数B时有部分参数放到了函数A的栈帧中，同时函数A栈帧的顶部依然保存的是返回地址 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:6:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"局部变量 我们知道在函数内部定义的变量被称为局部变量，这些变量在函数运行时被放在了哪里呢 原来，这些变量同样可以放在寄存器中，但是当局部变量的数量超过寄存器的时候这些变量就必须放到栈帧中了 因此，我们的栈帧内容又一步丰富了 细心的同学可能会有这样的疑问，我们知道寄存器是共享资源可以被所有函数使用，既然可以将函数A的局部变量写入寄存器，那么当函数A调用函数B时，函数B的局部变量也可以写到寄存器，这样的话当函数B执行完毕回到函数A时寄存器的值已经被函数B修改过了，这样会有问题吧 这样的确会有问题，因此我们在向寄存器中写入局部变量之前，一定要先将寄存器中开始的值保存起来，当寄存器使用完毕后再恢复原值就可以了 那么我们要将寄存器中的原始值保存在哪里呢？ 没错 还是栈帧 最终，我们的小盒子就变成了如图所示的样子，当寄存器使用完毕后根据栈帧中保存的初始值恢复其内容就可以了 现在你应该知道函数在运行时到底是什么样子了吧，以上就是问题3的答案 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:7:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"Big Picture 需要再次强调的一点就是，上述讨论的栈帧就位于我们常说的栈区 栈区，属于进程地址空间的一部分，如图所示，我们将栈区放大就是图左边的样子 关于栈区详细的讲解你可以参考《深入理解操作系统：程序员应如何理解内存（未完待续）》这篇。 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:8:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"问题1 最后，让我们回到文章开始的这段简单代码 void func(int a) { if (a \u003e 100000000) return; int arr[100] = {0}; func(a + 1); } void main(){ func(0); } 想一想这段代码会有什么问题？ 原来，栈区是有大小限制的，当超过限制后就会出现著名的栈溢出问题，显然上述代码会导致这一问题的出现 因此我们要注意 不要创建过大的局部变量 函数栈帧，也就是调用层次不能太多 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:9:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"总结 本章我们从几个看似没什么关联的问题出发，详细讲解了函数运行时栈是怎么一回事，为什么我们不能创建过多的局部变量 细心的同学会发现第2个问题我们没有解答，这个问题的讲解可以在《如何理解协程》中理解 ","date":"2023-02-16","objectID":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/:10:0","tags":["函数","内存"],"title":"函数运行时在内存中是什么样子","uri":"/%E7%BC%98%E8%B5%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"线程共享了哪些进程资源","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"线程到底共享了哪些进程资源? ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:0:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"引言 鲁迅经常说这样一句话：“反过来想，总是反过来想”，如果你对线程之间共享了哪些进程资源这个问题想不清楚的话那么也可以反过来思考，那就是有哪些资源是线程私有的 鲁迅：我真的说过这一句话吗? ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:1:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"线程私有资源 线程运行的本质其实就是函数的执行，函数的执行总会有一个源头，这个源头就是所谓的入口函数，CPU从入口函数开始执行从而形成一个执行流，只不过我们人为的给执行流起一个名字，这个名字就叫线程 既然线程运行的本质就是函数的执行，那么函数执行都有哪些信息呢？ 在《函数运行时在内存中是什么样子》这篇文章中我们说过，函数运行时的信息保存在栈帧中，栈帧中保存了函数的返回值、调用其它函数的参数、该函数使用的局部变量以及该函数使用的寄存器信息 如图所示，假设函数A调用函数B 此外，CPU执行指令的信息保存在一个叫做程序计数器的寄存器中，通过这个寄存器我们就知道接下来要执行哪一条指令。由于操作系统随时可以暂停线程的运行，因此我们保存以及恢复程序计数器中的值就能知道线程是从哪里暂停的以及该从哪里继续运行了 由于线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此每个线程都有自己独立的、私有的栈区 同时函数运行时需要额外的寄存器来保存一些信息，像部分局部变量之类，这些寄存器也是线程私有的，一个线程不可能访问到另一个线程的这类寄存器信息 所以我们知道了什么是线程私有资源 栈区 程序计数器 栈指针 函数运行使用的寄存器 以上这些信息有一个统一的名字，就是线程上下文(thread context) 我们也说过操作系统调度线程需要随时中断线程的运行并且需要线程被暂停后可以继续运行，操作系统之所以能实现这一点，依靠的就是线程上下文信息 除此之外，剩下的都是线程间共享资源，我们来看一下剩下的资源 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:2:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"代码区 进程地址空间中的代码区，这里保存的是什么呢？从名字中有的同学可能已经猜到了，没错，这里保存的就是我们写的代码，更准确的是编译后的可执行机器指令 那么这些机器指令又是从哪里来的呢？答案是从可执行文件中加载到内存的，可执行程序中的代码区就是用来初始化进程地址空间中的代码区的 线程之间共享代码区，这就意味着程序中的任何一个函数都可以放到线程中去执行，不存在某个函数只能被特定线程执行的情况 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:3:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"数据区 进程地址空间中的数据区，这里存放的就是所谓的全局变量 char c; // 全局变量 void func() { } 在程序员运行期间，也就是run time，数据区中的全局变量有且仅有一个实例，所有的线程都可以访问到该全局变量 但是要注意，c/c++里面有static void func(){ static int a = 10; } 注意到，虽然变量a定义在函数内部，但变量a依然具有全局变量的特性，也就是说变量a放在了进程地址空间的数据区域，即使函数执行完后该变量依然存在，而普通的局部变量随着函数调用结束和函数栈帧一起被回收掉了，但这里的变量a不会被回收，因为其被放到了数据区 这样的变量对每个线程来说也是可见的，也就是说每个线程都可以访问到该变量 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:4:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"堆区 堆区是程序员比较熟悉的，我们在C/C++中用malloc或者new出来的数据就存放在这个区域，很显然，只要知道变量的地址，也就是指针，任何一个线程都可以访问指针指向的数据，因此堆区也是线程共享的属于进程的资源 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:5:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"栈区 唉，等等！刚不是说栈区是线程私有资源吗，怎么这会儿又说起栈区了？ 确实，从线程这个抽象的概念上来说，栈区是线程私有的，然而从实际的实现上看，栈区属于线程私有这一规则并没有严格遵守，这句话是什么意思？ 通常来说，注意这里的用词是通常，通常来说栈区是线程私有，既然有通常就有不通常的时候 不通常是因为不像进程地址空间之间的严格隔离，线程的栈区没有严格的隔离机制来保护，因此如果一个线程能拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说这些线程可以任意修改本属于另一个线程栈区中的变量 这从某种程度上给了程序员极大的便利，但同时，这也会导致极其难以排查到的bug。 试想一下你的程序运行的好好的，结果某个时刻突然出问题，定位到出问题代码行后根本就排查不到原因，你当然是排查不到问题原因的，因为你的程序本来就没有任何问题，是别人的问题导致你的函数栈帧数据被写坏从而产生bug，这样的问题通常很难排查到原因，需要对整体的项目代码非常熟悉，常用的一些debug工具这时可能已经没有多大作用了 说了这么多，那么同学可能会问，一个线程是怎样修改本属于其它线程的数据呢？ 接下来我们用一个代码示例讲解一下 void thread(void* var) { int* p = (int*)var; *p = 2; } int main() { int a = 1; pthread_t tid; pthread_create(\u0026tid, NULL, thread, (void*)\u0026a); return 0; } 这段代码是什么意思呢？ 首先我们在主线程的栈区定义了一个局部变量，也就是 int a= 1这行代码，现在我们已经知道了，局部变量a属于主线程私有数据，但是，接下来我们创建了另外一个线程 在新创建的这个线程中，我们将变量a的地址以参数的形式传给了新创建的线程，然后我来看一下thread函数 在新创建的线程中，我们获取到了变量a的指针，然后将其修改为了2，也就是这行代码，我们在新创建的线程中修改了本属于主线程的私有数据 现在你应该看明白了吧，尽管栈区是线程的私有数据，但由于栈区没有添加任何保护机制，一个线程的栈区对其它线程是可以见的，也就是说我们可以修改属于任何一个线程的栈区 就像我们上文说得到的，这给程序员带来了极大便利的同时也带来了无尽的麻烦，试想上面这段代码，如果确实是项目需要那么这样写代码无可厚非，但如果上述新创建线程是因bug修改了属于其它线程的私有数据的话，那么产生问题就很难定位了，因为bug可能距离问题暴露的这行代码已经很远了，这样的问题通常难以排查 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:6:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"动态链接库 进程地址空间中除了以上讨论的这些实际上还有其它内容，还有什么呢？ 这就要从可执行程序说起了。 什么是可执行程序呢？在Windows中就是我们熟悉的exe文件，在Linux世界中就是ELF文件，这些可以被操作系统直接运行的程序就是我们所说的可执行程序。 那么可执行程序是怎么来的呢？ 有的同学可能会说，废话，不就是编译器生成的吗？ 实际上这个答案只答对了一半。 假设我们的项目比较简单只有几个源码文件，编译器是怎么把这几个源代码文件转换为最终的一个可执行程序呢？ 原来，编译器在将可执行程序翻译成机器指令后，接下来还有一个重要的步骤，这就是链接，链接完成后生成的才是可执行程序。 完成链接这一过程的就是链接器。 其中链接器可以有两种链接方式，这就是静态链接和动态链接。 静态链接的意思是说把所有的机器指令一股脑全部打包到可执行程序中，动态链接的意思是我们不把动态链接的部分打包到可执行程序，而是在可执行程序运行起来后去内存中找动态链接的那部分代码，这就是所谓的静态链接和动态链接。 动态链接一个显而易见的好处就是可执行程序的大小会很小，就像我们在Windows下看一个exe文件可能很小，那么该exe很可能是动态链接的方式生成的。 而动态链接的部分生成的库就是我们熟悉的动态链接库，在Windows下是以DLL结尾的文件，在Linux下是以so结尾的文件。 说了这么多，这和线程共享资源有什么关系呢？ 原来如果一个程序是动态链接生成的，那么其地址空间中有一部分包含的就是动态链接库，否则程序就运行不起来了，这一部分的地址空间也是被所有线程所共享的。 也就是说进程中的所有线程都可以使用动态链接库中的代码 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:7:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["缘起 在人群中 我看见你"],"content":"文件 最后，如果程序在运行过程中打开了一些文件，那么进程地址空间中还保存有打开的文件信息，进程打开的文件也可以被所有的线程使用，这也属于线程间的共享资源 ","date":"2023-02-10","objectID":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/:8:0","tags":["线程","进程"],"title":"线程共享了哪些进程资源","uri":"/%E7%BC%98%E8%B5%B7-%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%BA%95%E5%85%B1%E4%BA%AB%E4%BA%86%E9%82%A3%E4%BA%9B%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90/"},{"categories":["网络原理"],"content":"TCP\u0026UDP","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP/UDP 传输层 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:0:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"传输层的定义 传输层是第一次在端对端也就是主机对主机的一层 专门负责处理上层的数据 负责可靠不可靠的传输 传输层下层是使用 mac 和 ip 地址来寻找到特定主机 但是光凭 mac ip 可不够,还要需要端口, 也是在这一层 有了端口的概念 这一层的数据单位称为数据段 TCP ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:1:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 概念 \u0026 流控制 TCP是 面向有链接 协议, 因为他是 流控制，也被称作流式协议 流控制： 接收端告诉发送端 我这边可以接收多少数据 发送端也跟接收端确认少数据 取最小值 将数据切割 TCP是可靠协议 他有一系列的方法来实现可靠性 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:2:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 序列号 \u0026 应答机制 引出： TCP是一个可靠协议 所以TCP需要各种方法来保证他的可靠性 解决： 发送端发送数据后 接收端接收成功 会发送一个ACK应答 缺点 万一ACK发送失败 发送端就会一直发送数据 这是一个问题 优化： 引入 序列号 机制 为每一个数据都打上一个序列号 ACK也算一个序列号 接收端收到数据后, 就会分析她下一次应该接收数据的序列号 然后以ACK应答出去 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:3:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 重发超时 RTT 与 RTO RTT 和 RTO的概念 TCP作为一个面向有连接型的协议，需要保证其可靠性 所以其内部实现了一个重传计时器 每发送一个数据包，就给这个数据设置一个重传计时器, 如果在计时器超时之前收到了针对这个数据包的ack，就取消这个计时器。如果没有收到，则开始发起重传。计时器超时的时间被称为RTO，这个时间的确定取决于RTT 关于两者详细的解释 RTT(Round Trip Time): 一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值 RTO(Retransmission Time Out): 重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传 RTT的测量 每发送一个分组 TCP就会对其采样，这个采样只会对同一时间的数据段进行采样, 随后用这个采样记录当作RTT 采样方法一般有两种 采用时间戳： 发送一个数据段时在TCP选项中记录下时间 收到数据段再记录下时间 随后计算出差值 就把这个差值作为RTT 但是需要发送端和接收端都需要支持这个选项 重传队列中数据包的TCP控制块： 每个数据包第一次发送出去后都会放到重传队列中，数据包中的TCP控制块包含着一个变量，tcp_skb_cb-\u003ewhen，记录了该数据包的第一次发送时间。如果没有时间戳选项，那么RTT就等于当前时间和when的差值 RTO的计算 为了避免单次RTT波动，计算RTO时新引入了变量SRTT，表示更加平滑的RTT数值，它的计算方法： SRTT = x(SRTT) + (1 - x)RTT; // x被称为平滑因子，一般建议设置在[0.8, 0.9]，意思是SRTT值百分之八十来自于之前的值，百分之二十来自于当前值。 计算RTO的方法为： RTO = min(ubound, max(lbound, y(SRTT))); // y 是时延离散因子，推荐值为[1.3, 2.0]，ubound是RTO的上边界，lbound是RTO的下边界 算法的缺点 在RTT波动较大时，RTO不能明显适应网络变化 标准方法 标准方法引入了平均偏差的概念，它类似于统计学里面的方差，但是因为方差的计算过程代价较大，对于快速TCP来说不太适合。假设rtt的值为M，RTO的计算方式为： srtt = (1 - g)srtt + g(M); rttval = (1 - h)rttval + h(|M - rttval|); RTO = srtt + 4(rttval); /* 其中`g`设置为1/8，`h`设置为`1/4` 对srtt而言，它有1/8取决于当前值，7/8取决于现有值 当RTT变化时，偏差增量越大，RTO的增量也越大 */ ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:4:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 三次握手 第一次握手 SYN = 1，seq = x 客户端发送一个 SYN标志为1，指明客户端打算连接的服务器端口，以及初始的序列号为随机生成的 x 的一个TCP包 发送完成后，客户端进入 SYN_SEND状态 第二次握手 SYN = 1，ACK = 1，seq = y，ACKNum = x+1 服务端发回 SYN=1 ACK=1，并且ACK也算一个序列号+1 所以ACKNum是 x+1，随后再把自己要发送的数据标上序列号，序列号变成了 y 的一个TCP包 服务端发送完毕后 进入 SYN_RECV状态 第三次握手 ACK = 1，ACKNum = y+1 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕 客户端进入 ESTABLISH状态，服务端接收到这个包后 也进入ESTABLISH状态，TCP握手结束 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:5:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 四次挥手 第一次挥手 FIN = 1, seq = x 假设客户端想要关闭连接，客户端发送一个FIN标志位置为1的包，表示自己像断开连接 没有数据可以发送了，但是仍然可以接收数据 发送完毕后，客户端进入 FIN_WAIT_1 状态 第二次挥手 ACK = 1 ACKNum = x + 1 服务端接受到了客户端想要断开的链接的请求，便发出了一个ACK标志位为1的TCP包，表明自己接收到了请求，但还没有准备好关闭连接 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到了这个确认包之后，进入 FIN_WAIT_2的状态，等待服务端关闭连接 第三次挥手 FIN=1，seq=y 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK 第四次挥手 ACK = 1，ACKNum = y + 1 客户端接收到来自服务器端的关闭请求，发送一个确认包 客户端发送完包并进入 TIME_WAIT 状态，等待可能出现的要求重传的ACK包 服务端接收到这个确认包后，关闭连接，进入CLOSED状态 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:6:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"为什么需要3次握手 挥手需要4次 3次握手目的是要确定客户端和服务端通信也就是两边的“收”“发”功能是否正常 第一次握手: 客户端发送网络包 服务器收到了 这个时候服务端就能确定客户端的\"发\" 和 服务端的 “收” 都没有问题 第二次握手: 服务端发送 这个时候客户端就能确定 客户端的 “发收” 服务端的 “收发” 是没有问题的 但是服务端还没有确定 第三次握手: 客户端发包 这个时候服务端就能确定 服务端的 “发收” 客户端的 “收发” 是没有的问题的 所以综上所述 两次握手是没有办法确定 双方的通信能力是否正常 至少也要三次 4次挥手目的是要数据接收完毕 不能在数据没有接受完全就直接关闭了连接TCP连接是双向传输的对等的模式, 就是说双方都可以同时向对方发送或接受数据 第一次挥手: 当有一方要关闭连接时，会发送指令告知对方 我们要close连接 第二次挥手: 对方回一个ack应答 此时一个方向的连接关闭 但是！另一个方向仍然可以继续传输数据 等到数据发送完 就进行第三次挥手 第三次挥手: 发送FIN段 第四次挥手: 回ACK应答 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:7:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 以段为单位发送数据 什么是段 在三次握手的期间发送端会告诉接受端 我一次性能发送多少数据接受端也会告诉发送端 我一次性能接受多少数据随后发送端就会把全部数据切割为最小值 发送出去 这个最小值为段 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:8:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 窗口控制 引出 当我们以段为单位 一次发送数据 随后又得等待ack 这样包的往返效率很慢 所以tcp采用了滑动窗口来优化 什么是窗口控制 滑动窗口就是我们设置窗口值 在没超够窗口值的前提下 不用等待ack的应答 就可以发送段数据 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:9:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 重发控制 引出 当我们利用窗口来发送数据 如果有数据丢失怎么办 ACK丢失 如有几个ack应答丢失是没有关系的 因为剩下的ack会到达发送端 所以一对比单个段发送的效率 窗口的性能还是蛮高的 段丢失 如果段数据丢失了 接受端会一直返回相对应的序列号的ack应答 如果发送端一直接受同样的ack三次 就会进行重发 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:10:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 拥塞窗口 引出 计算机网络都处在一个共享的环境。 因此也有可能会因为其他主机之间的通信会造成网络拥堵。如果在网络拥堵的时候 发送一个较大量的数据包 会可能导致整个网络的瘫痪 什么是拥塞窗口 TCP在通信一开始的时候会通过一个叫做慢启动的算法得出的数值，对发送数据量进行控制 首先，为了在发送端调节要发送数据的量,定义了一个叫做 “拥塞窗口” 的概念 在慢启动的时候，将这个窗口调节为1个数据段发送数据，随后没收到一个ack就进行+=1 在发送数据的时候 也会将其拥塞窗口的大小和接受端的窗口对比 取其最小值 然后发送比这个最小值还小一点的数据 上述解决办法会出现的问题 随着包的往返，拥塞窗口也会以 1 2 4 等指数函数增长，拥堵状况激增甚至导致拥塞的发生 慢启动阈值他也就来了 慢启动阈值 只要拥塞窗口的值超过这个范围，则每一次收到ack，只允许下面这种比例放大拥塞窗口 1个数据段的字节数 / 拥塞窗口(字节) X 1个数据段字节数 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:11:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 连接状态 CLOSED: 初始状态 LISTEN: 服务器处于监听状态 SYN_SEND: 客户端socket执行CONNECT连接，发送syn包 进入此状态 SYN_RECV: 服务端收到SYN包并发送服务端SYN包，进入此状态 ESTABLISH: 表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接 收到ACK包后进入此状态 FIN_WAIT_1: 终止连接的一方发送了FIN报文后进入,等待对方FIN CLOSE_WAIT: 假设服务器)接收到客户机FIN包之后等待关闭的阶段。在接收到 对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本 方是否立即断开连接(发送FIN包)取决于是否还有数据需要发送给客户端，若有， 则在发送FIN包之前均为此状态 FIN_WAIT_2: 此时是半连接状态, 既有一方要求关闭连接，等待另一方关闭，客户端接收到服务端的ACK包，但并没有接收到服务端的FIN包，进入FIN_WAIT_2状态 LAST_ACK: 服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。 TIME_WAIT: 客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之 后的2MSL时间称为TIME_WAIT状态。 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:12:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"TCP 首部格式 源端口号 发送方的应用端口 占16位 目标端口号 接受端的应用端口 占16位 序列号 占32位 发送端会在发送数据的每个字节上标上序号 不一定每一个序列号都是0, 1开始的 这个序列号是随机的 会在syn包也就是第一次握手 告诉接受端 syn包 \u0026 fin包 \u0026 ACK 都是一个字节 确认应答号 占32位 收到数据后 会返回下一次应该收到的序列号信息作为确认应答 这个确认应答也就代表着 前面的数据我都收到了的意思 偏移量 tcp首部长度 保留 占4位 主要是为了以后扩展用的 一般都是0 控制位 字段长为8位, 当它们对应位上的值为1 就会有特殊作用 三次握手, 四次挥手 ack 该位为1时, 确认应答的字段变为有效, tcp规定除了最开始的syn包外, 必须为1 syn 该位为1时, 代表希望建立连接, 并且序列号会随机生成 fin 该位为1时, 代表希望断开连接 英语全称(其实一开始作者看错了 以为都是p开头 结果阴差阳错发现了 然后就记住了 哈哈) =-= psh(push) 该位为1时，代表需要直接将数据传给上一层 / 该位为0时 需要先进行缓存在进行传送 rst(reset) 该位为1时，代表tcp连接出现异常 必须强制断开连接 比如对方突然断电 紧急指针相关 URG 该位为1时，代表包中有需要紧急处理的数据 拥塞窗口 cwr 该位为1时，则会通知对方拥塞窗口缩小 ece 该位为1时，通知对方，从对方到这里的网络有拥塞 窗口大小 长为16位 代表发送数据最多不能超过这个窗口大小 如果窗口大小为0 则就是代表可以窗口探测 去寻找最新的窗口大小 校验和 紧急指针 该字段长为16位, 只有在URG控制位为1时有效 数据的首位到紧急指针指向的位置 都是紧急数据 怎么处理紧急数据 就是应用层要实现的事情, 一般在暂停通信 或者中断通信的时候使用 选项 UDP ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:13:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"UDP 概念 \u0026 用途 UDP 是面向无连接协议 爆式协议 他不会去管数据到底有没有到达 所以想啥时候发数据就啥时候发数据经常用于广播 视频 音频等 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:14:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"UDP 首部格式 因为UDP简单 所以首部只有 源端口号 目标端口号 检验和 包长度 四个数据 ","date":"2023-01-03","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/:15:0","tags":["TCP","UDP"],"title":"TCP\u0026UDP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-tcpudp/"},{"categories":["网络原理"],"content":"IP","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP及其相关协议 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:0:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"网络层 网络层介绍 IP(IPv4 IPv6) 相当于OSI7层模型中的第三层-网络层 在这一层 IP和ICMP是主角 网络层的作用 实现点对点通信 在第二层 数据链路层中 我们知道了在同一链路中 是通过\"mac地址\"来确定目标主机 进行包传递 那在不同的链路中 就是通过第三层的\"IP地址\"来实现包传递 IP基础知识 IP总共分为三大作用模块 分别是 “寻址” “路由” “分片与组包” ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:1:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP地址的定义 ipv4由32位正整数来表示 TCP/IP要求将IP地址分配给每一个通讯的主机IP地址在计算机内部由二进制表示 但是人类社会并不习惯二进制 所以每8位分开 隔一个\".\" 将每组数以十进制来表示每一台主机上的每一张网卡都需要设置IP地址 所以IP地址越来越不够用 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:2:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP地址由网络和主机两部分标识组成 IP地址是由网络地址和主机地址两部分组成 实现了唯一性，网络地址在不同的数据链路中也是不相同的，如果网络地址相同则说明在同一个网段中，接下来就是通过主机地址来区分不同的主机 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:3:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP地址的分类 IP地址分为4类 分别为 A类 B类 C类 D类 它根据IP地址中从第1位到第4位的比特对其网络标识和主机标识进行区分 A类地址 A类地址是首位以 “0” 开头的地址，代表着从第1位到第8位是他的网络地址，后24位为主机地址 十进制表示为：0.0.0.0 - 127.0.0.0 是A类的网络地址 B类地址 B类地址是前两位为 “10” 的地址 代表着从第1位到第16位是他的网络地址 后16位为主机地址 十进制表示 128.0.0.0 - 191.255.0.0 是他的网络地址 C类地址 C类地址是前三位为 “110” 的地址 代表着从第1位到第24位是他的网络地址 后8位为主机地址 十进制表示 192.0.0.0 - 223.255.255.0 是他的网络地址 D类地址 D类地址是前4位为 “1110” 的地址 代表着从第1位到第32位是他的网络地址 十进制表示 224.0.0.0 - 239.255.255.255 是他的网络地址 D类地址没有主机标识 常被用于多播 PS：分配IP地址 要用比特位表示主机地址时 不能全为0 或者 全为1 全部为0 代表对应的网络地址或者IP地址不可获知的情况下使用 全部为1的主机地址通常作为广播地址 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:4:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"广播地址 什么是广播地址 广播地址用于在同一个数据链路层中的互相连接的主机之间发送数据包 怎么设置广播地址 将IP地址的主机位全部设置为1 就成了广播地址 比如 172.20.0.0/16 二进制：10101100.00010100.00000000.00000000 -\u003e 10101100.00010100.11111111.11111111 十进制：172.20.255.255 本地广播 在本网络的广播叫做本地广播 比如在172.20.0.0/24的情况下 广播地址为172.20.0.255 因为这个广播地址的IP会被路由器所屏蔽 所以不会到达172.20.0.0/24以外的其他链路上 直接广播 在不同的网络的广播叫做直接广播 但是由于直接广播具有安全性的问题 所以大多数不会采用直接广播 例如网络地址为 192.168.0.0/24的主机向 192.168.1.255/24的目标地址发送IP包 收到这个包的路由器，将数据转发给192.168.1.0/24 从而使得 192.168.1.1 ~ 192.168.1.254的主机都能收得到这个包 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:5:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"多播 什么是多播 多播用于将包发送给特定组的所有主机 因为是直接使用IP协议 所以也不存在可靠传输 为什么不使用广播 而使用多播 广播会将包发送给所有的终端主机 然后由主机的上一层去判断这个包是不是他要的 所以会造成不必要的流量 而且广播无法穿透路由,想给其他的网段发送同样的包 就不得不采取另一种机制 所以多播可以穿透路由器 又可以实现只给那些必要的组发送数据包的技术就成为必选之路了 多播的特点 多播采用D类地址 因此 如果前4位为\"1110\"的就可以认为是多播地址 而剩下的28位可以成为多播的组编号从 224.0.0.0 到 239.255.255.255 都是多播地址的可用范围 其中 224.0.0.0 ~ 224.0.0.255 的范围不需要路由控制 在同一个链路也可以实现多播而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包对于多播，所有的主机(路由器以外的主机和终端主机)必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组利用IP多播实现通信 除了地址之外 还需要IGMP等协议的支持 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:6:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"子网掩码 为什么需要子网掩码 一个IP地址只要确定了其分类 也就确定了他的网络标识和主机标识 网络标识相同肯定就代表着在同一个链路内 所以对于B类地址 允许有6多万台计算机连接 实属浪费 所以一个更为灵活的组合方式 子网掩码诞生了 子网掩码的优点 IP地址的网络地址和主机地址就并不是分的那么严格 而去由子网掩码去通过子网网络地址细分出比原来分类更小粒度的网络所以这种方式其实就是将原来的分类中的主机地址部分用作子网地址 可以讲原网络分为多个多个物理网络的一种机制 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:7:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"CIDR/VLSM ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:8:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"全局地址与私有地址 路由控制 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:9:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"路由控制表 引出 我们已经在前面学习了IP地址，并且知道了靠网络地址和主机地址让每个主机都具有唯一性，那么问题就来了，我们在传递数据的时候，我咋知道目标的IP在哪里，我怎么才能去找到目标IP地址？ 所以我们还需要一个类似于 “车票\"的东西，那就是路由控制表 什么是路由控制表 路由控制表记录者网络地址与下一步应该发送至路由器的地址 维护路由控制表的方法 静态路由控制： 由管理员手动去管理 动态路由控制： 依靠路由器与其他路由器相互交换信息时靠路由协议去自动更新自动去更新这张表(路由协议先不讲述) ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:10:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP地址与路由控制 在发送IP包的时候 首先要确定IP包首部的目标地址 然后在路由控制表中找到相同网络地址的记录 然后转发至下一个路由如果有多个相同 则找一个最相同的 随后转发至下一个路由 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:11:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"默认路由 引出 如果一张路由表存放着包含所有网络及其子网的信息 将会造成无端的浪费，如果只有部分 那么也有可能IP数据包的目的地址找不到 所以当我们找不到目的地址的时候 就会走默认路由 什么是默认路由 默认路由一般标记为 “0.0.0.0/0” 或者 “default” 注意 这里的 “0.0.0.0” 并不是IP地址 因为后面是 “/0” 所以并没有标识IP地址 “0.0.0.0\"的IP地址应该被标记为 “0.0.0.0/32” 而且默认路由的子网掩码也是 “0.0.0.0” ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:12:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"主机路由 “IP地址/32” 也被称为 主机路由，他的意思是整个IP地址的所有位都将参与路由主机路由，多用于不希望通过网络地址路由的情况 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:13:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"环回地址 这个就是老朋友了 127.0.0.1 或者是 localhost，环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址，数据包不会流向网络 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:14:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"路由控制表的聚合 利用网络地址的比特分布可以有效的进行分层配置对内，即使有多个子网掩码，对外呈现出的也是同一个网络地址，所以通过路由信息的聚合可以有效的减少路由表的数目 提升效率 IP分割处理与再构成处理 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:15:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"数据链路不同 MTU则相异 引出 在数据链路层，其实每次传过来的MTU是不一样的（因为每个不同类型的数据链路的使用目的不同），所以IP要为每一个数据链路还专门去适配吗? 所以IP就用了一个分割处理和再构成处理 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:16:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IP报文的分片与重组 引出 任何一台主机都需要将IP分片进行相应的处理 要不然在比较大的报文无法一下子发送出去 分片和重组的过程 在路由器上会将IP数据包分成分片发送出去，随后在目标主机而且也只能在目标主机上重组 为何只能在目标主机上重组 这么设计是有理由的：现实中无法保证IP数据报是否经由同一个路径传送，IP数据报拆分后是否会丢失，在当中路径中重组的话 可能在后面的路由器又会拆分，所以只能在目标主机上重组 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:17:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"路径MTU发现 引出 分片拆分是在路由器上面进行拆分 但是随着科技的发展 路由器要求性能越来越高 其次如果拆分的时候 其中一个分片丢失 则所有的数据报会作废 所以诞生了路径MTU发现 UDP 路径MTU发现工作原理 在发送端主机发送IP数据报时将其首部的分片禁止标志位设置为1 根据这个标志位, 途中的路由器即使遇到需要分片才能处理的大包也不要分片 而是直接丢弃，随后 通过一个ICMP的不可达消息将数据链路上MTU的值给发送主机 下一次 从发送的同一个目标主机的IP数据报获得ICMP所通知的MTU值以后 将它设置为当前MTU，然后对数据报进行分片处理 如此反复 直到没有收到ICMP 就认为MTU是一个合适的值 ps：MTU最多可以缓存10分钟 如果超过了 就会在去路径MTU发现 TCP 路径MTU发现 根据路径MTU的大小计算出最大段长度 然后再根据这些信息进行数据报的发送，所以在TCP上 IP不需要进行分片 IPv4首部 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:18:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"IPv4首部 教你如何通过理解去背诵 首先肯定要记录发送端主机和目标段主机IP地址 源地址 32bit构成，记录者发送端主机的地址 目标地址 32bit构成 记录者接收端主机的地址 IPv4首部长度肯定会有记录 首部长度 4bit构成 表明IP首部的大小 单位是4个字节(32bit) 对于没有可选项的IP包, 首部长度则设置为\"5” 也就是说 没有可选项的IP时 IP首部为20byte 总长度 16bit 标识IP首部与数据部分合起来的总字节数 所以说IP包最大长度 为 65536字节 记录不同的数字来标识一些不同的情况 版本 4bit 构成 标记IP的版本号 /“4 -\u003e ipv4” “5 -\u003e ST” “6 -\u003e ipv6”/ 等等 区分服务 8bit 构成 用来表明服务质量 一般这个值都是应用指定也应该是由应用指定，但是现在一般都无视这个字段 因为在符合质量的要求的情况下按其要求发送本身的功能实现起来非常的难，现在有人提出将这个字段分为两个字段 - DSCP \u0026 ECN 协议 8bit 构成 表示的是IP包传输层的上层协议编号，具体编号可以从特殊网站获取 分片重组相关 标识 由16bit组成，用于分片重组，同一个分片标识相同 不同的分片标识不同 通常 每发送一个IP包 他的值也逐渐递增，此外 即使ID相同 如果目标地址 源地址 协议不同 也会被认为是不同的分片 标志 3bit 组成 表示包被分片的相关信息 第0个bit -\u003e 未使用 现在必须是0 第1个bit -\u003e 表示是否进行分片 “0” 可以分片 / “1” 不能分片 第2个bit 包被分片的情况下 表示是否为最后一个包 “0” 最后一个分片的包 / “1” 分片中段的包 片偏移 由13bit组成 用来表示被分片的每一个分段相对于原始数据的位置 第一个分片对应的值为0 由于片偏移占13bit 所以最多可以表示8192个相对位置 单位为8字节 因此最大可以表示原始数据为 “8 x 8192 = 65536\"字节的位置 IP包的生命周期 生存时间 由8bit构成 他最初的意思是以秒为单位记录当前包在网络上应该生存的期限，然而 在实际中他是指可以中转多少个路由的意思 每经过一个路由 生存时间就会-1 直到变成0则丢弃该包 可以避免IP包在网络内无限传递的问题 校验和 首部校验和 由16bit构成 也就IP首部校验和 该字段不会校验数据部分 只会校验IP数据包不会被破坏 其他 可选项 长度可变 通常只在进行试验或诊断时使用 填充 再有可选项的情况下 首部长度可能不是32比特的整数倍 所以填充就是保证是整数倍的 数据 存入数据 将IP上层协议的首部也作为数据进行处理 ICMP ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:19:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"ICMP是个啥玩意 引出 我们在架构IP网络的时候 最注意两点: 1. 确认网络是否工作 2. 遇到异常时进行问题诊断ICMP正是提供这类功能解决这些问题的一种协议 ICMP的功能 确认IP包是否成功送达目标地址 通知在发送过程当中IP包被废弃的具体原因 改善网络设置 … ICMP所以其实就是一个传递消息的 在IP通信中如果某个IP包因为某种原因未能达到目标地址 那么这个具体的原因将由ICMP负责通知ICMP这种通知消息会使用IP进行发送ICMP的消息 大致可以分为两类 1. 通知出错原因的错误消息 2. 用于诊断的查询消息 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:20:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"主要的ICMP消息 ICMP目标不可达消息 IP路由器无法将IP数据包发送给目标地址时, 会给发送端主机返回一个不可达的ICMP消息 并在这个消息显示具体原因 ICMP重定向消息 如果路由器选择次优路径发送数据, 那么他会返回一个ICMP重定向的消息给这个主机 在这个消息中包含了最适合的路由信息和源数据 ICMP超时消息 在IP包字段中有一个记录着IP的生存周期的字段 如果这个字段为0 则会发送一个ICMP消息给发送端主机 表示该包已经丢弃 ICMP回送消息 用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息 “ping” 命令就是由ICMP实现的 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:21:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"其他的ICMP信息 ICMP原点抑制消息 在使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题 ICMP原点抑制消息可以缓和这种拥堵情况 但是会造成不公平的网络通信 所以一般不使用 ICMP路由器探索消息 主要用于发现与自己相连网络中的路由器 当一台主机发出ICMP路由器请求时 路由器则返回ICMP路由器公告消息给主机 ICMP地址掩码消息 主要用于主机或路由器想要了解子网掩码的情况 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:22:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"ICMPv6 引出 有了ICMP 为啥还要有一个ICMPv6 ICMPv6的作用 IPv4中的ICMP仅作为一个辅助作用支持IPv4 也就是说没有了ICMP 其实也是可以实现IP通信的 在IPv6中 ICMP的作用被扩大 如果没有ICMPv6 IPv6则就无法进行正常通信 ICMPv6的消息 错误消息 信息消息 邻居探索 邻居探索消息在ICMPv6中很重要 用于查询IPv6与MAC地址的关系 并由邻居宣告消息得知MAC地址 邻居探索消息利用IPv6的多播地址实现传播 ","date":"2023-01-02","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/:23:0","tags":["IP"],"title":"IP","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-ip/"},{"categories":["网络原理"],"content":"OSI","date":"2023-01-01","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/","tags":["OSI"],"title":"OSI","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/"},{"categories":["网络原理"],"content":"OSI OSI OSI 模型(Open System Interconnection Model)是一个由 ISO 提出得到概念模 型，试图提供一个使各种不同的的计算机和网络在世界范围内实现互联的标准框架。 虽然OSI参考模型在实际中的应用意义并不是很大，但是它对于理解网络协议内部的 运作很有帮助，为我们学习网络协议提供了一个很好的参考。它将计算机网络体系结 构划分为7层，每层都为上一层提供了良好的接口。以下将具体介绍各层结构及功 能。 ","date":"2023-01-01","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/:0:0","tags":["OSI"],"title":"OSI","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/"},{"categories":["网络原理"],"content":"OSI 7层模型 \u0026 作用 应用层: 这一层为操作系统或网络应用程序提供访问网络服务的接口。 表示层: 这一层主要解决用户信息的语法表示问题 比如发送邮件 可能这个软件是自己的独有的编码, 表示层需要将这个转化为通用编码 然后把这个软件独有和通用的编码格式放到数据首部 会话层: 这一层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话 比如现在有5封邮件, 你是一次建立连接 发送一封邮件 在建立一次连接 再发送一封邮件 还是 建立一次连接吧所有的邮件发送出去 这就是会话层的任务 决定哪一种传输方式 传输层: 首次的端对端,也就是主机对主机的层次 / 专门负责\"上层数据分段并提供到端对端 可靠与不可靠的传输\" / 数据单位称之为 “数据段” 网络层: 负责网路与另一个网络的连接发送数据 / 专门负责\"寻址\" “路由” “分片与组包” / 在这里数据单位称之为 “数据包” 数据链路层: 数据链路层(Data Link Layer)定义了在单个链路上如何传输数据 物理层: 物理层(Physical Layer)确保原始的数据可在各种物理媒体上传输 ","date":"2023-01-01","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/:1:0","tags":["OSI"],"title":"OSI","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/"},{"categories":["网络原理"],"content":"各层传输协议、传输单元、主要功能性设备比较 名称 传输协议 传输单元 主要功能设备/接口 物理层 IEEE 802.1A、IEEE 802.2 bit-flow 比特流 光纤，双绞线，中 继器，集线器，网 线接口 数据链路层 ARP、MAC、 FDDI frame 帧 网桥、二层交换机 网络层 IP、ICMP、ARP、RARP 数据包(packet) 路由器、三层交换 机 传输层 TCP、UDP 数据段 四层交换机 会话层 SMTP、DNS 报文 QoS 表示层 Telnet、SNMP 报文 应用层 FTP、TFTP、Telnet、HTTP、DNS 报文 ","date":"2023-01-01","objectID":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/:2:0","tags":["OSI"],"title":"OSI","uri":"/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-osi/"},{"categories":["操作系统"],"content":"操作系统的IO模型","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"IO模型 5种 IO模型 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:0:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"从TCP发送信息流程开始讲起 要深入的理解各种 I/O 模型，那么必须先了解下产生各种IO的原因是什么，要知道这其中的本质问题那么我们就必须要知道一条消息是如何从一个人发送到另外一个人的 以两个应用程序通讯为例，我们来了解一下当“A”向\"B\" 发送一条消息，简单来说会经过如下流程 应用A将数据发送到TCP发送缓冲区 TCP发送缓冲区再把数据发送出去，经过网络传递后，数据会发送到服务器B的TCP接收缓冲区 B再从TCP接收缓冲区去读取属于自己的数据 这个流程我们了解后 我们就开始来进入主题 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:1:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"阻塞/非阻塞 IO模型 我们先来思考一个问题： 因为发送信息肯定是间断 他不会一直都会有信息，一直在发送，所以如果B的TCP接收缓冲区没有数据，B发送了一个接收数据的读取请求，那么这时候是会直接告诉B没有可读消息，还是让B一直等待直到有可读消息呢 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:2:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"什么是阻塞IO 我们这个问题思考完 其实就已经明白了什么是阻塞IO 所谓阻塞IO就是当应用B发起读取数据申请时，在内核数据没有准备好之前，应用B会一直处于等待数据状态，直到内核把数据准备好了交给应用B才结束 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:2:1","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"什么是非阻塞IO 按照上面的思路，所谓非阻塞IO就是当应用B发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用B，不会让B在这里等待 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:2:2","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"IO复用模型 我们依旧先来思考一个问题： 我们还是从 服务器B 要去从缓冲区读取数据的问题，如果在并发的场景下，可能会有N个人向服务器B发送消息，这种情况一般我们会开多个线程去处理不同的消息，每个线程都会自己调用 recvfrom 去读取数据 并发情况下服务器很可能一瞬间会收到几十上百万的请求，这种情况下应用B就需要创建几十上百万的线程去读取数据，同时又因为应用线程是不知道什么时候会有数据读取，为了保证消息能及时读取到，那么这些线程自己必须不断的向内核发送recvfrom 请求来读取数据 那么问题来了，这么多的线程不断调用 recvfrom 请求数据，先不说服务器能不能扛得住这么多线程，就算扛得住那么很明显这种方式是不是太浪费资源了，线程是我们操作系统的宝贵资源，大量的线程用来去读取数据了，那么就意味着能做其它事情的线程就会少 有人就提出了一个思路，能不能提供一种方式，可以由一个线程监控多个网络请求（我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路 正如上图，IO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起recvfrom请求去读取数据 进程将一个fd或者多个fd传递给 select，阻塞在select操作上，select帮我们侦测多个fd是否准备就绪，当有fd准备就绪时，select返回数据可读状态，应用程序再调用recvfrom读取数据 复用IO的基本思路就是通过select或poll、epoll 来监控多fd ，来达到不必为每个fd创建一个对应的监控线程，从而减少线程资源创建的目的 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:3:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"信号驱动IO模型 我们继续来看一个问题： select会一直轮询 这就代表着绝大多数的轮询都是无意义的 那我们能不能发出请求后 也别去管他了 数据准备好直接来通知我呢? 所以就衍生了信号驱动 IO模型 于是信号驱动IO不是用循环请求询问的方式去监控数据就绪状态，而是在调用sigaction时候建立一个SIGIO的信号联系，当内核数据准备好之后再通过SIGIO信号通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起recvfrom读取数据的请求，因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个fd 首先开启套接口信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数，此时请求即刻返回，当数据准备就绪时，就生成对应进程的SIGIO信号，通过信号回调通知应用线程调用recvfrom来读取数据 IO复用模型里面的select虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:4:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"异步IO 还是老样子，我们来看一个问题： 也许你一开始就有一个疑问，为什么我们明明是想读取数据，而却非得要先发起一个select询问数据状态的请求，然后再发起真正的读取数据请求,能不能有一种一劳永逸的方式，我只要发送一个请求我告诉内核我要读取数据，然后我就什么都不管了，然后内核去帮我去完成剩下的所有事情? 当然既然你想得出来，那么就会有人做得到，有人设计了一种方案，应用只需要向内核发送一个read 请求,告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种一劳永逸的模式为异步IO模型 应用告知内核启动某个操作，并让内核在整个操作完成之后，通知应用，这种模型与信号驱动模型的主要区别在于，信号驱动IO只是由内核通知我们合适可以开始下一个IO操作，而异步IO模型是由内核通知我们操作什么时候完成 异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。 IO多路复用机制 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:5:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll V.S select 假想这么一个场景 你朋友来找你较量一场击剑，然后不知道寝室在哪 所以找了宿管 select宿管带着你的朋友挨家挨户找，直到找到你 epoll宿管，她会先记下每位同学的房间号，你的朋友来的时候只要告诉房间号即可 那如果来了10000个人 都要找你击剑，那么select效率更高还是epoll？ select 如一个保姆照顾一群孩子，如果把孩子尿尿这件事必做 IO，那保姆就相当于问每一个孩子需要尿尿不 epoll的机制下 保姆无需挨个询问孩子是否要尿尿，而是每个孩子若自己需要尿尿，主动站到事先约定好的地方，而保姆的职责就是看约定好的地方有无孩子。因此，epoll的这种机制，能够高效的处理成千上万的并发连接，而且性能不会随着连接数增加而下降 select epoll 性能 随着连接数的增加，急剧下降 随着连接数的增加，性能基本不会下降 连接数 连接数有限制-1024如果要处理超过1024，则需要修改FD_SETSIZE宏，并重新编译 连接数无限制 内在处理机制 轮询 回调callback 开发复杂性 低 中 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:6:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"select select 通过设置或检查存放fd标志位的数据结构进行下一步处理 这会带来问题： 单个进程可监控的fd数量被限制, 只允许1024，这些是由 FD_SETSIZE宏去控制的， 当然也可对其修改，然后重新编译内核，但性能可能受影响，这需要进一步测试。一般该数和系统内存关系很大 当 socket 较多的时候，每次select都要遍历FD_SETSIZE的socket，不管是否活跃都很浪费CPU的时间，若能给socket注册某个回调函数，当他们活跃时候，直接完成相关操作 即可避免轮询 这就是 epoll和 kqueue select 缺点 内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户控件和内核空间在传递该结构时复制开销大 每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大 每次调用select，都需在内核遍历传递进来的所有fd select支持的文件描述符数量太小，默认最大支持1024 主动轮询效率很低 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:7:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"poll 和select类似，只是描述fd集合的方式不同，poll使用 pollfd 结构而非select的 fd_set 结构 struct pollfd { int fd; short events; short revents;}; 管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll无最大文件描述符数量的限制 poll和select都有一个缺点 就是包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，其开销也随着文件描述符数量增大而线性增大 将用户态传入的数组拷贝到内核空间 然后查询每个fd对应设备状态 若设备就绪 在设备等待队列中加入一项继续遍历 若遍历完所有fd后，都没发现就绪的设备，挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义遍历 无最大连接数量限制 基于链表存储 缺点： 大量fd数组被整体复制于用户空间和内核空间中，而不管是否有意义 若报告了fd后，没有被处理，则下次poll时会再次报告该fd 链表查询时间复杂度为 O(n) 所以又有了 epoll ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:8:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理 可理解为event poll，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1) // 事件参数描述链接到文件描述符fd的对象 struct epoll_event { __u32 events; __u64 data;} EPOLL_PACKED; ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll触发模式 LT，默认的模式（水平触发）只要该fd还有数据可读，每次epoll_wait 都会返回他的事件，提醒用户程序去操作 ET，边缘触发 只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以ET模式下，read一个fd时，一定要把它的buffer读完，即读到read返回值小于请求值或遇到EAGAIN错误 epoll使用“事件”就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似回调机制激活该fd，epoll_wait便可收到通知 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:1","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"ET的意义 若用LT，系统中一旦有大量无需读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这大大降低处理程序检索自己关心的就绪文件描述符的效率。 而采用ET，当被监控的文件描述符上有可读写事件发生时，epoll_wait会通知处理程序去读写。若这次没有把数据全部读写完(如读写缓冲区太小)，则下次调用epoll_wait时，它不会通知你，即只会通知你一次，直到该文件描述符上出现第二次可读写事件才通知你。这比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:2","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll的优点 无最大并发连接的限制，能打开的FD上限远大于1024（1G内存能监听约10万个端口） 效率提升，不是轮询，不会随FD数目增加而效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大优点在于它只关心“活跃”连接，而跟连接总数无关，因此实际网络环境中，Epoll效率远高于select、poll 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。 epoll通过内核和用户空间共享一块内存而实现 表面上看epoll的性能最好，但在连接数少且都十分活跃情况下，select/poll性能可能比epoll好，毕竟epoll通知机制需要很多函数回调 epoll跟select都能提供多路I/O复用。在现在的Linux内核里有都能够支持，epoll是Linux所特有，而select则是POSIX所规定，一般os均有实现 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:3","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"epoll提供的函数 epoll_create 创建一个句柄 epoll_ctl 注册要监听的事件类型 对于第一个缺点，epoll的解决方案在epoll_ctl.c，每次注册新事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有fd拷贝进内核，而非在epoll_wait时重复拷贝。epoll保证每个fd在整个过程中只会拷贝一次！ EPOLL_CTL_ADD：在文件描述符epfd所引用的epoll实例上注册目标文件描述符fd，并将事件事件与内部文件链接到fd EPOLL_CTL_MOD：更改与目标文件描述符fd相关联的事件 EPOLL_CTL_DEL：从epfd引用的epoll实例中删除目标文件描述符fd。该事件将被忽略，并且可以为NULL epoll_wait 等待事件的产生 对于第二个缺点，epoll解决方案不像select/poll每次都把current流加入fd对应的设备等待队列，而只在epoll_ctl时把current挂一遍（这一遍必不可少），并为每个fd指定一个回调函数 当设备就绪，唤醒等待队列上的等待者时，就会调用该回调函数，而回调函数会把就绪fd加入一个就绪链表。 epoll_wait实际上就是在该就绪链表中查看有无就绪fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步类似）。 对于第三个缺点，epoll无此限制，其支持FD上限是最大可以打开文件的数目，一般远大于2048。1GB内存机器大约10万左右，具体数目可查看 cat /proc/sys/fs/file-max，这数目和系统内存关系很大 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:9:4","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"总结 select，poll，epoll都是I/O多路复用机制，即能监视多个fd，一旦某fd就绪（读或写就绪），能够通知程序进行相应读写操作。 但select，poll，epoll本质都是同步I/O，因为他们都需在读写事件就绪后，自己负责进行读写，即该读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O实现会负责把数据从内核拷贝到用户空间 select，poll需自己主动不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但它是设备就绪时，调用回调函数，把就绪fd放入就绪链表，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但select和poll在“醒着”时要遍历整个fd集合，而epoll在“醒着”的时候只需判断就绪链表是否为空，节省大量CPU时间，这就是回调机制带来的性能提升 select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，且把current往等待队列上挂也只挂一次（在epoll_wait开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少开销。 ","date":"2022-07-19","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/:10:0","tags":["IO模型"],"title":"IO模型","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-io%E6%A8%A1%E5%9E%8B/"},{"categories":["操作系统"],"content":"操作系统的进程管理","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程管理 进程与线程 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:0:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程的概念 进程的概念 指一个应用程序运行了起来, 进程是操作系统分配资源的一个最小单位 进程的结构 控制块（PCB）存放着进程的唯一ID，如果运行了多个微信进程，他们的ID也都是不一样的 数据块存放着进程的原始数据和中间数据 程序块多个进程共享 存放在文本区域 这个的多个进程是指如果开启了多个微信程序 则多个微信程序共享程序块 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:1:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"线程的概念 线程的概念 操作系统最小调度单位, 不能独立运行 被包含于进程, 一个进程可以有一个或多个进程 也被叫做轻量级进程 但是轻量级进程多用于内核级进程 而用户级线程成为线程 内核级线程 线程的控制块在操作系统的内核空间里 被称为内核级线程 但是线程的数据块和程序块还依然在用户控件 实现了真正意义上的线程并行 不需要运行时系统的参与 正因为数据块和程序块在用户空间，所以频繁的切换会导致内核开销大 用户级线程 线程的控制快在操作系统的用户控件里 被称为用户级线程 不依赖于操作系统 调度依赖于用户程序 在操作系统的视角里其实感觉不到用户级线程的存在 线程位于用户控件（不需要模式切换） 独立于操作系统（线程可以在不支持他们的操作系统上运行） 运行时系统可以切换用户控件中的本地阻塞线程（eg：等待另一个线程完成） 系统调用中，对一个线程的阻塞将会导致整个进程的阻塞 非真正意义的线程并行（一个进程安排在单个cpu上） 不存在时钟中断 更多的用户级线程的知识请看《如何理解协程?》 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:2:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程与线程的区别 进程是操作系统分配资源的最小单位 / 线程是操作系统最小调度单位 一个线程只属于一个进程 / 一个进程可以包括多个线程但最少有一个主线程 进程在执行过程中拥有独立的内存单元 / 而多个线程共享进程的内存 进程编程调试简单可靠性高，但是创建销毁开销大 / 线程正相反，开销小，切换速度快，但是编程调试相对复杂 进程间不会相互影响 / 线程一个线程挂掉将导致整个进程挂掉 进程适应于多核、多机分布 / 线程适用于多核 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、IO设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销 / 而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作 / 所以进程切换的开销也远大于线程切换的开销 由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:3:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"线程资源 详细文章请看《线程到底共享了哪些进程资源？》 线程共享的资源 线程私有的资源 堆区 寄存器 打开的文件 栈区 数据区（全局变量和static） 程序计数器 代码区（每一个函数） 栈指针 动态链接库 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:4:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"说一下 fork，wait，exec 函数 父进程产生子进程使用fork拷贝出一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读一块内存的 当有进程写的时候使用写时拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了 fork 从父进程返回子进程的 pid，从子进程返回 0，调用了 wait 的父进程将会发生阻塞，直到 有子进程状态改变，执行成功返回 0，错误返回 -1 exec 执行成功则子进程从新的程序开始运行，无返回值，执行失败返回 -1 fork()函数 #Fork:创建一个和当前进程映像一样的进程可以通过 fork() 系统调用: #include \u003csys/types.h\u003e #include \u003cunistd.h\u003e pid_t fork(void); 成功调用 fork() 会创建一个新的进程，它几乎与调用 fork() 的进程一模一样，这两个进程都会 继续运行 在子进程中，成功的 fork()调用会返回0。在父进程中 fork() 返回子进程的 pid，如果出现错误，fork() 返回一个负值 最常⻅的 fork() 用法是创建一个新的进程，然后使用 exec() 载入二进制映像，替换当前进程的 映像。这种情况下，派生(fork)了新的进程，而这个子进程会执行一个新的二进制可执行文 件的映像。这种“派生加执行”的方式是很常⻅的 在早期的 Unix 系统中，创建进程比较原始。当调用 fork 时，内核会把所有的内部数据结构复 制一份，复制进程的⻚表项，然后把父进程的地址空间中的内容逐⻚的复制到子进程的地址空 间中。但从内核⻆度来说，逐⻚的复制方式是十分耗时的。现代的 Unix 系统采取了更多的优 化，例如 Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:5:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"孤儿进程 V.S 僵尸进程 什么是孤儿进程 一般情况下，子进程是由父进程创建，而子进程和父进程的推出顺序是无序的，两者之间都不知道谁先退出。 正常情况下，父进程会先结束调用wait()或者waitpid()函数等到子进程完成后再退出，而一旦父进程不等待直接退出，则剩下的子进程会被init(pid=1)进程接收，成了孤儿进程（进程树中除了init都会有父进程） 什么是僵尸进程 如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的 状态信息，则子进程残留的状态信息( task_struct 结构和少资源信息)会变成僵尸进程 怎么处理僵尸进程 子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中 调用wait进行处理僵尸进程 原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:6:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"守护进程 什么是守护进程 守护进程(Daemon)是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。 守护进程是一种很有用的进程 守护进程特点 守护进程最重要的特性是后台运行 守护进程必须与其运行前的环境隔离开来。这些环境包括未关闭的文件描述符，控制终端，会话和进程组，工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的父进 程(特别是shell)中继承下来的 守护进程的启动方式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc.d中启 动，可以由作业规划进程crond启动，还可以由用户终端(shell)执行 实现一个守护进程 在父进程中执行fork并exit推出 在子进程中调用setsid函数创建新的会话 在子进程中调用chdir函数，让根目录 ”/” 成为子进程的工作目录 在子进程中调用umask函数，设置进程的umask为0 在子进程中关闭任何不需要的文件描述符 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:7:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程的创建过程，需要哪些函数，需要哪些数据结构 fork函数创造的子进程是父进程的完整副本，复制了父进程的资源，包括内存的内容task_struct内容 vfork创建的子进程与父进程共享数据段，而且由vfork创建的子进程将先于父进程运行 linux 上创建线程一般使用的就是pthead库，实际上linux也给我们提供了创建线程的系统调用，也就是clone ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:8:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程创建子进程，fork 详解 函数原型 pid_t fork(void) 除了0号进程(系统创建的)之外，linux系统中都是由其他进程创建的。创建新进程的进 程，即调用fork函数的进程为父进程，新建的进程为子进程 fork函数不需要任何参数，对于返回值有三种情况 对于父进程，fork函数返回新建子进程的pid; 对于子进程，fork函数返回 0; 如果出错， fork 函数返回 -1 int pid=fork(); if(pid \u003c 0){ //失败，一般是该用户的进程数达到限制或者内存被用光了 ........ } else if(pid == 0){ //子进程执行的代码 ...... } else{ //父进程执行的代码 ......... } 进程运行 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:9:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"五种基本状态 创建： 创建好一个进程 就绪：进程做好了执行的准备 就差分配处理机 运行：该进程正在执行 阻塞：等待某事件发生才能执行，如等待I/O完成 终止：进程被关闭 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:10:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程控制 什么是进程控制 即os对进程实现有效的管理 比如进程的创建、进程切换等动作 os 通过 原语 操作来实现进程控制 什么是原语 由若干条指令组成 具有原子性 原语的特点 原子操作 要么全部执行 要么全部失败 执行过程不会被终止 在管态/系统态/内核态下执行，常驻内存 是内核三大支撑功能之一(中断机制，时钟管理，原语操作) ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:11:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程是怎么运行的 创建原语：create 阻塞原语：block 唤醒原语：wakeup 撤销原语：destroy 挂起原语：suspend 激活原语：active ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:12:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"处理机 什么是处理机 根据一定的算法和原则将处理机资源进行重新分配的过程 前提：作业/进程数目一定远远大于处理机数目 目的：提高资源利用率 减少处理机空闲时间 处理机调度：调度的层次 高级调度/作业调度 把后备作业调入内存 只调入一次 调出一次 中级调度/内存调度 将进程调至外存 条件合适再调入内存 在内存 外存对换区进行进程对换 低级调度/进程调度 从就绪队列选取进程分配给处理机 最基本的调度 频率非常高（相当于一个时间片完成） 调度算法 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:13:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"先来先服务 算法内容：调度作业/就绪队列中最先入队者，等待操作完成和阻塞 算法原则：按作业/进程到达顺序服务 调度方式：非抢占调度 适用场景：作业/进程调度 优缺点 有利于CPU繁忙型作业 充分利用CPU资源 不利于I/O繁忙型作业 操作耗时 其他饥饿 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:14:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"短作业优先 算法内容：所需服务时间最短的作业/进程优先服务 算法原则：追求最小的平均周转时间 调度方式：非抢占式服务（除了服务时间最短 还有另一种方式-最短剩余时间优先） 适用场景：作业/进程调度 优缺点 平均等待/调度时间最少 长作业会增加或者饥饿 估计时间不准确 不能保证紧急任务及时处理 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:15:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"高响应比优先调度 算法内容：结合先来先服务\u0026短作业优先，综合考虑等待时间和服务时间计算响应比 高的响应比优先调度 算法原则：综合考虑作业/进程的等待时间和服务时间 调度方式：非抢占调度 适用场景：作业/进程调度 响应比计算 (等待时间 + 服务时间) / 服务时间 当前进程完成或者阻塞时重新计算所有的进程响应比 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:16:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"优先级调度 算法内容：又叫优先权调度，按作业/进程的优先级（紧迫程度）进行调度 算法原则：优先级最高的作业/进程先调度 调度方式：抢占（高优先级立即执行）/非抢占（高优先级等待当前进程让出后执行） 适用场景：作业/进程调度 优先级设置原则 静态/动态优先级 系统 \u003e 用户 / 交互型 \u003e 非交互型 / I/O型 \u003e 计算型 低优先级进程可能会饥饿 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:17:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"时间片轮转调度 算法内容：按进程到达就绪队列的顺序，轮流分配一个时间片去执行，时间用完则剥夺 算法原则：公平、轮流为每个进程服务，进程在一定时间内都能得到响应 调度方式：抢占式 由时钟中断确定时间 适用场景：进程调度 优缺点 公平，响应快，适用于分时系统 时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力 时间片太大，相当于 先来先服务 / 太小 处理机切换频繁 开销增大 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:18:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"多级反馈队列调度 算法内容 设置多个按优先级排序的就绪队列 优先级从高到低 时间片从小到大 新进程采用队列降级法 （1. 进入第一级队列 按先来后到分时间片 2. 没有执行完，移动到第二级） 前面队列不为空 不执行后续队列进程 算法原则：集中前几种算法的优点 调度方式：抢占式 适用场景：进程调度 优缺点 对各类型相对公平 可以快速响应 也实现了短作业优先 周转时间短 在前几个队列部分执行 进程通信 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:19:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"共享内存 共享内存，指两个或多个进程共享一个给定的存储区 共享内存是最快的一种进程通信方式，因为进程是直接对内存进行存取 因为多个进程可以同时操作 所以需要进行同步 信号量 + 共享内存通常结合在一起使用 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:20:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"管道通信 无名管道 半双工 具有固定的写端以及读端 管道就是一个 队列 是先进先出 无名管道只能用于具有亲属关系的进程之间的通信 管道其实可以看成一个特殊的文件, 对于他的读写也可以使用 read()/write() 但是管道不属于文件系统，他是用于内存中 当一个管道建立时，会创建两个文件文件描述符，要关闭管道只需将这两 个文件描述符关闭即可 Int pipe(int fd[2]); 有名管道（fifo） 有名管道可以用于无关的进程之间通信 有名管道有路径名与之相关联，她以一种特殊设备文件形式存在于文件系统中 Int mkfifo(const char* pathname, mode_t mode); ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:21:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"消息队列 消息队列，是消息的连接表，存放在内核中。一个消息队列有一个标识符来标识 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容不会被删除 消息队列可以实现消息的随机查询 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:22:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"信号量 什么是信号量 信号的数量 举例： 好比一个停车场，里面很多的停车位，停车位是任何车都可以停的，所以可以看成共享资源，那停车位满了，外面肯定就要排队 P/V 操作 P操作： wait原语，进程等待 V操作： signal原语，唤醒等待进程 信号量的工作机制 由一个 剩余资源数量 \u0026 进程等待队列 实现的结构体 如果有一个进程在执行 则剩余资源数量-1 如果剩余资源数量为负数，则让当前申请资源的进程进入等待队列并处于阻塞状态 如果一个进程执行完毕，则剩余资源数量+1，并且从等待队列唤醒一个进程 进程同步 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:23:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"进程同步 什么是进程同步 协调进程间的 相互制约关系, 使他们按照预期的方式执行的过程 两种相互制约形式 互斥： 进程排他性访问共享资源 同步： 进程间的合作，比如管道通信 互斥的实现 临界区： 比如打印机、音频设备等 通过对多个进程进程串行化来访问公共资源或一段代码 在任意时刻只允许一个进程访问 一个进程成功访问后就会加锁 直到释放锁 也唤醒其他的阻塞进程 互斥对象： 互斥对象和临界区很像，采用互斥对象机制，只有拥有互斥对象的进程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个进程同时访 问。当前拥有互斥对象的进程处理完任务后必须将进程交出，以便其他进程访问该资源 同步的实现 信号量： 上面已经介绍，在此不多赘述 事件对象： 通过通知操作的方式来保持进程的同步，还可以方便实现对多个进程的优先级 比较的操作 死锁 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:24:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"死锁 什么是死锁： 多个进程由于竞争资源而造成的阻塞现象，若无外力干预，这些进程都无法前进 死锁产生的原因 系统资源的竞争 进程推近顺序非法 死锁产生的必要条件 互斥条件： 共享资源的排他性访问 不剥夺条件： 访问时该共享资源不会被剥夺 请求并保持： 保持当前资源请求另一个资源 循环等待条件： 存在共享资源循环等待链 处理死锁的四大方法 预防死锁： 破坏死锁的四大必要条件 避免死锁： 在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生 检测死锁： 允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除 解除死锁： 当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来 预防死锁 与 避免死锁 的区别 预防死锁是破坏死锁的四个必要条件，严格的防止死锁的出现 避免死锁是不破坏死锁的四个必要条件，因为就算4个必要条件也可能不会出现死锁，他的角度是从系统运行中注意避免死锁的产生 死锁的预防 破坏互斥条件 将只能互斥访问的资源改为同时共享访问（可以在中间加一个缓冲队列） 将独占锁改为共享锁 不是所有资源都能改成可共享的 破坏不剥夺/不可抢占条件 请求新资源无法满足时必须释放已有资源 由OS协助强制剥夺某进程持有的资源 实现复杂，代价高 此操作过多导致原进程任务无法推进 破坏请求并保持条件 进程开始时一次性申请所需资源 阶段性请求和释放资源 破坏循环等待条件 对所有资源进行排序 对资源的编号应相对稳定，限制了新设备增加 进程使用资源的顺序可能与系统编号顺序不同 限制了用户编程 死锁的避免 银行家算法 系统预判进程请求是否导致不安全状态 是则拒绝请求，否则答应请求 死锁的检测 需要一种数据结构，保存有关资源的请求和分配信息 提供一种算法，利用这些信息监测是否形成了死锁 死锁的解除 资源剥夺： 挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态 撤销进程： 强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行 进程回退： 让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。 ","date":"2022-07-17","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/:25:0","tags":["进程"],"title":"进程管理","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"},{"categories":["操作系统"],"content":"操作系统概述","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"概念 用户空间与内核空间 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:0:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"用户空间与内核空间 什么是内核空间与用户空间 在操作系统分为用户空间和内核空间用户空间里运行着应用程序 用户程序不能直接操作内核 内核空间独立于普通的应用程序 可以访问受保存的内存空间,也可以访问底层硬件设备 为什么要区分内核空间和用户控件 很简单 为了安全 因为用户程序可能会有很多隐患 比如清空内存 清空寄存器 操作系统也分了特权指令和非特权指令，对于非常危险的指令 只允许操作系统及其相关的模块使用 也就是特权指令 用户程序的指令 就是非特权指令 这里要注意 中断指令也是非特权指令 intel的cpu分为4个特权等级 Ring0~Ring3 如果等级是Ring3则说明进程是运行在用户态 Ring0则说明是进程运行在内核态 时钟管理 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:1:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"时钟管理 什么是时钟管理 在操作系统里面有个非常重要的就是时钟 他还是一个硬件 作用 记录着系统时间 时钟中断 (用来进行 进程 or 线程 切换) 中断机制 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:2:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"中断机制 什么是中断 中断 是为了解决外部设备完成某些工作后通知CPU的一种机制(譬如硬盘完成读写操作后通过中断告知CPU已经完成) 中断的分类 中断可以分为同步中断和异步中断 同步中断是当指令执行时由 CPU 控制单元产生，之所以称为同步，是因为只有在一条指令执行完毕后 CPU 才会发出中断，而不是发生在代码指令执行期间 — 比如系统调用 异步中断是指由其他硬件设备依照 CPU 时钟信号随机产生，即意味着中断能够在指令之间发生 — 例如键盘中断 根据 Intel 官方资料，同步中断称为异常(exception)，异步中断被称为中断(interrupt)。中断可分为 可屏蔽中断(Maskable interrupt)和 非屏蔽中断(Nomaskable interrupt)。异常可分为 故障(fault)、陷阱(trap)、终止(abort)三类 从广义上讲，中断可分为四类：中断、故障、陷阱、终止 中断分类图示 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:3:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"中断的处理过程 关中断 进入不可再次响应中断的状态，由硬件实现 保存断点 为了在[中断处理]结束后能正确返回到中断点。由硬件实现 引出中断服务程序 将[中断服务程序]入口地址送PC，转向[中断服务程序]。可由硬件实现，也可由软件实现 保存现场和屏蔽字 保护现场、置屏蔽字、开中断，即保护CPU中某些寄存器的内容、设置[中断处理]次序、允 许更高级的中断请求得到响应，实现中断嵌套由软件实现 开中断 看 - 4 执行中断服务程序 实际上有效的中断处理工作是在此程序段中实现的。由软件程序实现 退出中断 在退出时，又应进入不可中断状态，即关中断、恢复屏蔽字、恢复现场、开中断、中断返回。由软件实现 流程图示 系统调用 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:4:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"执行一个系统调用时，OS 发生的过程 执行用户程序(如:fork) 根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断 进行地址空间的转换和堆栈的切换，执行SAVE_ALL。(进行内核模式) 进行中断处理，根据系统调用表调用内核函数 执行内核函数 执行 RESTORE_ALL 并返回用户模式 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:5:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"系统调用跟函数调用的区别 原语 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:6:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["操作系统"],"content":"原语 什么是原语 有若干条指令组成，是一个程序段, 用来完成某个特定功能 执行过程不会被中断具有原子性的叫做原语 原语运行在内核空间 ","date":"2022-07-16","objectID":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/:7:0","tags":["操作系统"],"title":"概述","uri":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0/"},{"categories":["MySQL"],"content":"MySQL的索引","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"索引的基本种类 Innodb 主键索引在建立主键的时候就会自动帮你创建一个主键索引，在Innodb引擎下主键索引是聚簇索引，可以不唯一 普通索引除主键外，任意一列创建的索引就叫做普通索引 普通索引可以有多个 唯一索引跟主键索引唯一的区别就是 该索引是唯一的，可以为null 联合索引一个索引包含多个列 MyISAM 全文索引全文索引类型为 FULLTEXT, 在定义索引的列上支持值的全文查找, 允许在这些索引列中插入重复值和空值 可以在 char varchar text类型列上创建 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:1:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"索引的优点缺点 优点 能够大大加快索引的查询速度 缺点 索引会占用磁盘空间 维护索引需要消耗数据库的资源 在 insert update delete操作下 会性能下降 因为要维护索引 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:2:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"最左匹配原则 现在有一个联合索引包含了 name age bir 三个列 name bir age 能否利用索引 - yes name age bir 能否利用索引 - yes age bir 能否利用索引 - no bir age name 能否利用索引 - yes age bir 能否利用索引 - no 面对上述问题 有两个要注意 最左匹配原则 也就是 “name” or “name age” or “name age bir” 就可以走索引 mysql 引擎在查询为了更好利用索引 在查询过程中会动态优化查询字段 a = 1 and b = 1 and c \u003e 1 and d = 1 联合索引 走到范围查询就会停止 所以这里d不会走到索引 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:3:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"索引的妙用 SELECT 如果有这样的char列，前10个字符都是唯一的，可以建立短索引（前缀索引）这样能加快查询效率 并且减少磁盘io WHERE != not in这些并不会使用索引，但是\u003c \u003e等 都可以使用索引 如果where子句使用到函数 则不会走索引 如果where子句已经使用过索引 orderby 并不会使用索引 所以真要使用orderby 最好建立联合索引 如果用 like %like% %like 不使用索引 like% 才会使用 如果用 or如果 or 前后的两个条件的列都是索引, 那么查询会使用索引， 如果前后两个条件有一个不是索引 则不会使用索引 JOIN 在需要join的列最好用索引 但是要注意 主键与外键的类型必须是相同的 要不然不走索引 使用索引建议性原则 在 查询中很少使用 或者参考的列不要创建索引。由于这些列很少使用到，增加索引反而会降低系统的维护速度和增大空间需求 只有很少数据值的列 也不应该增加索引，由于这些列的取值很少，区分度太低。例如人事表中的性别,在查询时,需要在表中搜索的数据行的比例很大, 增加索引，并不能明显加快检索速度 定义为 text、image 和 bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少 当 修改性能远远大于检索性能 时，不应该创建索引。这是因为，二者是相互矛盾的，当增加索引时，会提高检索性能，但是会降低修改性能 定义有 外键 的数据列一定要创建索引 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:4:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"B+ Tree B+ Tree导出过程 举个例子 现在有几条数据 在底层存储是这么存储的绿色: 主键 / 红色: 数据 / 蓝色: 指针 下一个数据(node) *但是这样随后问题就来了 数据量少就算了 如果有1000条数据 链表时间复杂度为O(n) 所以mysql采用了 **分页（升维）*的思路每一个数据都会存放着自己的那一页的第一条数据的逐渐 随后指针p指向自己的分页的下一级数据 然后我们把第一层的页目录再次提取一层，最终用了三层的结构 ![b+树 终极形态](/Users/ting/Library/Application Support/typora-user-images/image-20230302174409156.png) b+ tree总结 B+树本质上是一种多叉平衡二叉树，是由多个页组成的多层级结构，每个页16Kb，对于主键索引来说，最末级的叶子结点放行数据，非叶子结点放的则是索引信息(主键id和页号)，用于加速查询 B+树利用了空间换时间、升维的方式(构造了一批非叶子结点用于存放索引信息)，将查询时间复杂度从O(n)优化为O(lg(n)) ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:5:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"B+ Tree 和 跳表的区别 查询 B+树是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，所以扇出很高。三层左右就可以存储2kw左右的数据 / 跳表是链表结构，一条数据一个结点，如果最底层要存放2kw数据，且每次查询都要能达到二分查找的效果，2kw大概在2的24次方左右，所以，跳表大概高度在24层左右，所以得出结论 b+Tree的查询效率要比跳表高得多 写 B+树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此跳表的写入性能会比B+树要好 其实，mysql的存储引擎是可以换的，以前是myisam，后来才有的innodb，它们底层索引用的都是B+树。也就是说，你完全可以造一个索引为跳表的存储引擎装到mysql里。事实上，facebook造了个rocksDB的存储引擎，里面就用了跳表。直接说结论，它的写入性能确实是比innodb要好，但读性能确实比innodb要差不少 redis为什么使用跳表而不使用B+树或二叉树呢? 大家知道，redis 是纯纯的内存数据库。进行读写数据都是操作内存，跟磁盘没啥关系，因此也不存在磁盘IO了，所以层高就不再是跳表的劣势了。并且前面也提到B+树是有一系列合并拆分操作的，换成红黑树或者其他AVL树的话也是各种旋转，目的也是为了保持树的平衡。而跳表插入数据时，只需要随机一下，就知道自己要不要往上加索引，根本不用考虑前后结点的感受，也就少了旋转平衡的开销。因此，redis选了跳表，而不是B+树 总结 B+树是多叉平衡搜索树，扇出高，只需要3层左右就能存放2kw左右的数据，同样情况下跳表则需要24层左右，假设层高对应磁盘IO，那么B+树的读性能会比跳表要好，因此mysql选了B+树做索引 redis的读写全在内存里进行操作，不涉及磁盘IO，同时跳表实现简单，相比B+树、AVL树、少了旋转树结构的开销，因此redis使用跳表来实现ZSET，而不是树结构 存储引擎RocksDB内部使用了跳表，对比使用B+树的innodb，虽然写性能更好，但读性能属实差了些。在读多写少的场景下，B+树依旧YYDS ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:6:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"B Tree 与 B+ Tree的区别 B Tree 非叶子结点也会存储数据 这样会导致 树的高度比 b+ tree 高 查询磁盘io次数也会比 b+ tree高 这样会影响查询效率 B+ Tree 只有叶子节点会存储数据 非叶子节点只存储键值信息 注意 不是键值对哦~ 所有叶子节点之间都有一个键指针 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:7:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"聚簇索引 \u0026 非聚簇索引 聚簇索引 将数据与索引存放在一块 索引结构的叶子节点保存了行数据 非聚簇索引 将数据与索引分开存储 索引结构的叶子节点指向了数据对应的位置(注意 不是地址哦~) 注意事项 在Innodb中, 在聚簇索引之上创建的索引称之为辅助索引. 非聚簇索引都是辅助索引 像联合索引 唯一索引 前缀索引叶子节点存储的不再是行的物理位置，而是主键值 辅助索引访问数据总是二次查找 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:8:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"在不同引擎下的索引 Innodb Innodb使用的是聚簇索引，将主键组织到一颗b+树中，而行数据就储存到叶子节点 使用 WHERE id = 14这样的主键条件的查询过程 按照 b+ tree 的检索算法即可找到对应的叶节点，之后获得行数据 使用 非主键 WHERE name = 'Ame' 的条件查询过程 在辅助索引b+ tree中检索name，到达其叶子节点获取对应的主键 使用主键在主索引b+ tree中在执行一次b+ tree检索操作，最终到达叶子节点即可获取整行数据 聚簇索引默认是主键，如果表中没有定义主键，Innodb会选择一个唯一且非空的索引代替，如果还是没有这样的索引，Innodb会隐式定义一个主键来作为聚簇索引 如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可 MyISAM MYISAM使用的是非聚簇索引 非聚簇索引的两颗b+树看上去没什么不同 节点的结构一样 只是存储的内容不同 主键索引b+树的节点存储了主键, 辅助索引b+树存储了辅助键 这两颗b+树的叶子节点都使用一个地址指向真正的表数 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:9:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"使用聚簇索引的优势 引出 每次使用辅助索引都要经过两次 b+树查找, 看上去聚簇索引的效率明显要低于非聚簇索引, 所以使用聚簇索引优势在哪 由于行数据和聚簇索引的叶子节点存储在一起, 同一页会有多条数据, 访问同一数据页不同行记录时, 已经将页加载到了buffer 辅助索引的叶子节点, 存储主键值, 而不是数据的存放地址. 好处是当行数据发生变化时, 索引树的节点也需要变化 或者是我们需要查找的数据, 在上一次io读写的缓存中没有, 需要发生一次新的io操作时, 可以比避免对辅助索引的维护工作， 只需要维护聚簇索引树就好了 还有一个因为辅助索引存放的主键值 还少了辅助索引占用的存储空间大小 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:10:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"mysql的主键类型 mysql不推荐uuid为主键 uuid不适合排序且可能会出现新增加记录的uuid 会插入在索引树中间的位置 导致索引树调整复杂度变大 消耗更多的时间和资源 建议使用int bigint类型, 方便排序并且默认会在索引树的末尾增加主键值 ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:11:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"参考资料 《MYSQL内核：INNODB存储引擎 卷1》 《RocksDB和Innodb引擎性能PK胜负难料?》 https://cloud.tencent.com/developer/article/1813695 https://www.51cto.com/article/706701.html ","date":"2021-07-30","objectID":"/mysql-%E7%B4%A2%E5%BC%95/:12:0","tags":["索引"],"title":"索引","uri":"/mysql-%E7%B4%A2%E5%BC%95/"},{"categories":["MySQL"],"content":"详述了MySQL的事务","date":"2021-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"事务 事务是什么 事务就是要么全部完成 要么全部失败 目的是为了保证数据的一致性 事务的ACID 原子性保证全部完成 要么全部失败 没有中间状态 他是靠 undo日志来实现的 持久性事务修改后的数据会一直存在 他是靠 redo日志来实现的 隔离性多个事务之间不会互相影响，他是靠MVCC也就是undo log来实现的 一致性多个事务修改数据后 数据都是一致的 事务的隔离级别（InnoDB引擎中, 定义了四种隔离级别供我们使用 级别越高性能越低 而隔离性是由mysql的各种锁和MVCC机制来实现的） 读未提交我们可以去读事务未提交的数据，会带来 脏读，不可重复读，幻读的问题 读已提交我们只可以去读事务已经提交的数据，会带来不可重复读，幻读的问题 可重复读一个事务不管读取多少次，读的都是以第一次读的快照为标准，会带来幻读的问题 串行化直接串行，一个事务一个事务来，这样效率就会及其低下 事务当中存在的可能问题 脏读事务A正在修改数据，事务B去读了，随后A发生了问题callback，B读取的数据就会无效 不可重复读事务A正在更新数据，事务B去读数据了，随后事务A更新完毕，事务B再去读取，发现前后数据不一致 幻读事务A正在插入数据，事务B读取全部数据，在事务A插入前后读取数据不一致 发现数据多了一行 事务4大隔离级别实现原理 串行化 排他锁和共享锁来实现的 读锁（共享锁，S锁） select ... lock in share mode; 读锁是共享的，多个事务可以同时读取同一个资源，但不允许其他事务修改 写锁（排他锁，X锁） select ... for update; 写锁是排他的，会阻塞其他的写锁和读锁，update、delete、insert都会加锁 可重复读 \u0026 读已提交 他们俩是靠MVCC机制来实现的 ","date":"2021-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:1:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"Copy On Write 什么是COW 写入时复制 当有写入操作时 将原表copy一份 专门供来修改 如果此时有查询操作 则就查询原表，等新表写入完成在替换原表 经常用于 读多写少 高并发的场景下，但是不单单只用于该场景 ","date":"2021-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:2:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"MVCC 什么是MVCC 多版本控制链 他跟COW还是很像的，都是在并发下保证数据安全 并且提高效率 MVCC如何实现的 在我们的undo-log记录的数据表中 其实是有两个字段 一个是记录着事务的唯一ID，一个是回滚指针指向上一个事务 比如我们现在update一个数据 那么这个更新后的数据的回滚指针就会指向之前的数据，后面也是一样的道理 所以就形成了一个多版本控制链 ","date":"2021-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:3:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"小谈阿里面试题 - 查询操作方法需要使用事务吗 这种题其实大部分都要视情况而定, 如果你在查询的时候只有一条sql语句 那肯定是没必要开启事务的 但是如果你在导出的场景下 而且隔离级别是可重复读的情况下 导出的数据肯定是需要同一个时间维度的数据 所以这时候需要开启事务，否则就会导致导出的数据中 数据其实不是同一个时间维度的数据 ","date":"2021-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:4:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"MySQL执行过程与BufferPool缓存机制 mysql为何要如此设计 因为mysql要为其性能考虑，kafka为何吞吐量这么高，因为他的写入数据是顺序写，顺序写的性能是相当高 mysql写入 redo-log的时候就是顺序写，但是通过IO线程写入ibd确实随机写，虽然可以优化，但是性能肯定是比不过顺序写 redo-log 为何可以顺序写，ibd确实随机写 redo-log他是记录日志 记录日志本来就可以直接添加在文件末尾的，不会插入或者写在开头 ibd却不一样 我们有多个ibd 因为表有多个，随后我们写数据可能会插入，开头也插入一个数据，所以这里就必须随机写 ","date":"2021-07-25","objectID":"/mysql-%E4%BA%8B%E5%8A%A1/:5:0","tags":["事务"],"title":"事务","uri":"/mysql-%E4%BA%8B%E5%8A%A1/"},{"categories":["MySQL"],"content":"详述了MySQL的CMD命令","date":"2021-07-21","objectID":"/mysql-cmd/","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"存储数据的演变过程 随意的存到一个文件中、数据格式也是千差万别的完全取决于我们自己 # 小李 jason|123|NB # 小王 egon-123-DBJ # 小红 tank~123~hecha 软件开发目录规范 限制了存储数据的具体位置 bin conf core db lib readme 如何将单机变成连网 假设上述是一个单机游戏，那么每个人的游戏记录只会在自己的计算机上面保存，注册登录的账号也只能在自己的计算机上有效 这样是不行的 所以我们可以， 将数据库保存部分全部统一起来，所有人操作数据都来一个地方操作 ","date":"2021-07-21","objectID":"/mysql-cmd/:1:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"数据库的本质 ","date":"2021-07-21","objectID":"/mysql-cmd/:2:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"数据库的本质与分类 数据库本质上就是一款基于网络通信的应用程序。 这也意味着数据库软件其实有很多很多，主要可以分为两大类： 关系型数据库 (Relational Database) MySQL、Oracle、DB2、Access、SQL Server 非关系型数据库 (Non-Relational Database / NoSQL) Redis、MongoDB、Memcached ","date":"2021-07-21","objectID":"/mysql-cmd/:2:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"关系型数据库的特点 数据之间彼此有关系或约束 例如：男生表 和 前女友表 之间可以通过某个字段建立关联。 以表格（Table）的形式存储数据 数据以行和列的结构进行组织。 示例表格: name password hobby jason 123 学习 egon 123321 女教练 tank 12323 吃生蚝 字段有严格的类型限制 例如，姓名字段（name）只能存储字符串类型的数据，年龄字段只能存储数字等。 ","date":"2021-07-21","objectID":"/mysql-cmd/:2:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"非关系型数据库的特点 以键值对（Key-Value）的形式存储数据 ","date":"2021-07-21","objectID":"/mysql-cmd/:2:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"MYSQL ","date":"2021-07-21","objectID":"/mysql-cmd/:3:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"管理系统 (Management System) MySQL 不仅仅是一个数据仓库，它更是一个功能强大的*“图书管理员”**。这个“管理员”负责：* 定义数据结构: 规定每张表有哪些列，每个列应该存什么类型的数据（数字、文字、日期等）。 数据操作 (CRUD) 增 (Create): 往表里添加新的记录 查 (Read/Retrieve): 按照各种条件快速查询想要的数据。 改 (Update): 修改表里已有的数据。 删 (Delete): 删除表里的数据。 用户和权限管理: 控制谁可以访问数据库，谁有权限进行读写操作。 数据备份与恢复: 防止数据丢失。 保证数据一致性和完整性: 确保存入的数据是有效、不矛盾的。 ","date":"2021-07-21","objectID":"/mysql-cmd/:3:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"为什么 MySQL 如此流行？ 开源免费: 个人和大部分企业可以免费使用，大大降低了成本。 性能卓越: 读写速度快，能够处理大量并发请求。 稳定可靠: 经过了长时间和大规模应用的考验，非常成熟稳定。 跨平台: 可以在 Windows, Linux, macOS 等多种操作系统上运行。 社区强大: 拥有庞大的开发者社区，遇到问题很容易找到解决方案和文档。 生态系统丰富: 有大量的第三方工具、库和框架支持，开发非常方便。 ","date":"2021-07-21","objectID":"/mysql-cmd/:3:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"总结 简单来说，MySQL 就是一个功能强大、免费开源的“数据管家”，它使用表格来整理数据，我们通过 SQL 语言来指挥它完成数据的存储、查询和管理工作。 它是当今世界上最受欢迎的数据库之一，是构建网站、App 和各种软件系统的基石。 ","date":"2021-07-21","objectID":"/mysql-cmd/:3:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"重要概念介绍 任何基于网络通信的应用程序底层用的都是socket。 服务端 基于socket通信 收发消息 SQL语句 客户端 基于socket通信 收发消息 SQL语句 MySQL不单单支持MySQL自己的客户端app，还支持其他编程语言来充当客户端操作。 如何解决语言沟通的障碍？ 让服务端兼容所有的语言（一个人精通多国语言）。 采用统一的语言（SQL语句）。 库 »\u003e 文件夹 表 »\u003e 文件 记录 »\u003e 文件内一行行的数据 name password hobby jason 123 学习 egon 123 女教练 tank 123 吃生蚝 表头 表格的第一行 字段 name、password、hobby ","date":"2021-07-21","objectID":"/mysql-cmd/:4:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"MYSQL的安装 在IT界，一般都不会轻易地使用最新版本的软件，因为新版本可能会出现各种问题（你原本项目跑得好好的，非要画蛇添足更新版本，然后项目崩溃）。 小段子： 更新完没事，那么你还是一个普通员工。 更新完出事，那么你就是一名“烈士”。 截止到本博客 MySQL有很多版本（5.6、5.7、8.0），目前企业里面用得比较多的还是5.6左右。 参考网站：https://www.mysql.com/ 下载5.6版本即可，如果你下载了其他版本问题也不大，因为SQL语句是一样的。 按照教学方式下载，会将服务端和客户端一并下载到本地。 为了学习方便，我们将服务端和客户端都在本地启动，后期到了公司，服务端会专门跑在一台服务器上，所有人基于网络连接服务端操作。 ","date":"2021-07-21","objectID":"/mysql-cmd/:5:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"MYSQL服务端与客户端 ","date":"2021-07-21","objectID":"/mysql-cmd/:6:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"exe 文件名 服务端: mysqld.exe 客户端: mysql.exe ","date":"2021-07-21","objectID":"/mysql-cmd/:6:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"注意 在前期配置MySQL的时候，cmd终端尽量以管理员的身份运行。 windows+r 输入cmd 进入的是普通用户终端，有一些命令是无法执行的。 应该搜索cmd，然后右键以管理员身份运行。 ","date":"2021-07-21","objectID":"/mysql-cmd/:6:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"启动 先切换到mysqld所在的bin目录下，然后输入mysqld即可。 保留原来的cmd窗口，重新打开一个。 ","date":"2021-07-21","objectID":"/mysql-cmd/:6:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"常见软件的默认端口号 MySQL: 3306 redis: 6379 mongodb: 27017 django: 8000 flask: 5000 MySQL第一次以管理员身份进入是没有密码的，直接回车即可。 客户端连接服务端完整命令 mysql -h 127.0.0.1 -P 3306 -uroot -p ","date":"2021-07-21","objectID":"/mysql-cmd/:6:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"MYSQL语句初识 MySQL结束是以分号(;)为标志。 基本命令 show databases; -- 查看全部的库名 (注：原文为#，在SQL标准中--是更通用的注释符) MySQL连接精简版命令 mysql -uroot -p 省去了默认ip和端口 当你输入的命令不对的时候，不想让他继续执行和报错，输入\\c即可(不用分号)。 客户端退出 quit exit 不用加分号 当你在连接服务端的时候，直接输入mysql，就可以登录进去，但是是游客模式，只会给你展示一部分内容。 ","date":"2021-07-21","objectID":"/mysql-cmd/:7:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"环境变量\u0026系统服务制作 ","date":"2021-07-21","objectID":"/mysql-cmd/:8:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"Windowes 设置环境变量 找到MySQL的bin文件夹绝对路径。 右键“我的电脑”，点击“属性”，再点击“高级系统设置”，然后点击“环境变量”。 在系统变量中找到path，双击它，新建一个条目，把bin文件夹的绝对路径输入进去。 设置完成后，就可以直接在cmd中输入mysqld了，不用再切换路径。 ","date":"2021-07-21","objectID":"/mysql-cmd/:8:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"安装为Windows服务 环境变量弄好后，以管理员身份运行cmd，输入以下命令： mysqld --install 如果显示 Service successfully installed 就表示成功了。 这时候再打开任务管理器，点击“服务”，找到mysql，右键点击“开始”。 完成以上步骤后，MySQL服务端就被设置成了开机自动启动的服务。 之后，直接打开cmd连接客户端就好了。 小知识点补充—如何查看当前进程\u0026如何杀死当前进程 如何查看当前进程 tasklist |findstr mysql 如何杀死进程 taskkill /F /PID PID号 ","date":"2021-07-21","objectID":"/mysql-cmd/:8:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"设置密码 mysqladmin -uroot -p\u003c原密码\u003e password \u003c新密码\u003e 直接在cmd输入，不用打开mysql。 示例: mysqladmin -uroot -p123 password 123456 (注意: -p 和原密码之间没有空格) ","date":"2021-07-21","objectID":"/mysql-cmd/:9:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"重置密码 你可以将MySQL获取用户名和密码校验的功能看成是一个装饰器，装饰在了客户端请求访问的功能上。 我们如果将该装饰器移除，那么MySQL服务端就不会校验用户名和密码了。 1. 先关闭当前MySQL服务端，以命令行的方式启动（让MySQL跳过用户名密码验证功能）： mysqld --skip-grant-tables 2. 直接以无密码的方式连接： mysql -uroot -p （然后直接回车） 3. 修改当前用户的密码： update mysql.user set password=password('123456') where user='root' and host='localhost'; 真正存储用户表的密码字段，存储的肯定是密文，只有用户自己知道明文是什么，其他人都不知道，这样更加的安全。密码比对也只能比对密文。 4. 立刻将修改数据刷到硬盘： flush privileges; 5. 关闭当前服务端，然后以正常校验授权表的形式启动。 ","date":"2021-07-21","objectID":"/mysql-cmd/:10:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"MYSQL配置文件修改—–统一编码 我们来打开my-default.ini的文件，ini为结尾的文件一般都是配置文件，程序启动会先加载配置文件再真正启动。 [mysqld] # 一旦服务端启动立刻加载下面的配置 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [mysql] # 一旦客户端启动立刻加载下面的配置 ... [client] # 其他客户端... 我们来新建一个ini文件——my.ini。 我们在这里来写个统一编码的文件，然后我们还可以偷个懒，把用户名和密码也写进去，实现自动登录，代码如下： [mysqld] character-set-server=utf8 collation-server=utf8_general_ci [client] default-character-set=utf8 [mysql] user=\"root\" password=123456 default-character-set=utf8 我们修改后，要去重启服务端，然后再去登陆。 ","date":"2021-07-21","objectID":"/mysql-cmd/:11:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"MYSQL的基本语句 ","date":"2021-07-21","objectID":"/mysql-cmd/:12:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"库的增删改查(文件夹) 增 create database ame; create database yuki charset='gbk'; 查 show databases; show create database yuki; 改 alter database ame charset='gbk'; 删 drop database ame; ","date":"2021-07-21","objectID":"/mysql-cmd/:12:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"表的增删改查(文件) 查看当前库所在 select database(); 切换库 use ame; 增 create table t1(id int, name char(4)); -- 里面4的意思就是最大数据4个 查 show tables; -- 查看所有表 show create table t1; -- 查看t1表 describe t1; -- 查看t1表 简写 desc t1 改 alter table t1 modify name char(16); 删 drop table t1; create table ame.t1(id int, name char(16)); 使用绝对路径也是可以增加的，用来操做不同的库 ","date":"2021-07-21","objectID":"/mysql-cmd/:12:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"数据的增删改查 增 insert into t1 values(1, 'Ame'); insert into t1 values(2, 'yuki'),(3, 'ori'); 查 select * from t1; select name from t1; 改 update t1 set name='DSB' where id \u003e 1; 删 delete from t1 where id \u003e 1; delete from t1 where name='Ame'; 将表所有的数据清空 delete from t1; ","date":"2021-07-21","objectID":"/mysql-cmd/:12:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"存储引擎 MySQL 主要的存储引擎 1. Innodb 是MySQL5.5版本之后默认的存储引擎。 存储数据更加的安全。 2. myisam 是MySQL5.5版本之前默认的存储引擎。 速度要比Innodb更快，但是我们更加注重的是数据的安全。 3. memory 内存引擎(数据全部存放在内存中)，断电数据丢失。 4. blackhole 无论存什么，都立刻消失(黑洞)。 查看所有的存储引擎 show engines; 不同的存储引擎在存储表的时候 异同点 create table t1(id int) engine=innodb; create table t2(id int) engine=myisam; create table t3(id int) engine=blackhole; create table t4(id int) engine=memory; 存数据 insert into t1 values(1); insert into t2 values(1); insert into t3 values(1); insert into t4 values(1); ","date":"2021-07-21","objectID":"/mysql-cmd/:13:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"创建表的完整语法 语法 create table 表名( 字段名1 类型(宽度) 约束条件, 字段名2 类型(宽度) 约束条件, 字段名3 类型(宽度) 约束条件 ); 注意 1. 在同一张表中字段名不能重复。 2. 宽度和约束条件是可选的(可写可不写)，而字段名和字段类型是必须的。 约束条件写的话，也支持写多个。 字段名1 类型(宽度) 约束条件1 约束条件2...; create table t5(id); -- 报错 3. 最后一行不能有逗号。 create table t6( id int, name char, ); -- 报错 补充 宽度 一般情况下指的是对存储数据的限制。 create table t7(name char); -- 默认宽度是1 insert into t7 values('jason'); insert into t7 values(null); -- 关键字NULL 针对不同的版本会出现不同的效果： 5.6版本：默认没有开启严格模式。规定只能存一个字符，你给了多个字符，那么会自动帮你截取。 5.7版本及以上：或者开启了严格模式，那么规定只能存几个就不能超，一旦超出范围立刻报错 Data too long for .... 严格模式到底开不开呢？ 使用数据库的准则: 能尽量少的让数据库干活就尽量少，不要给数据库增加额外的压力。 约束条件 null / not null not null 不能插入 null。 create table t8(id int, name char not null); 宽度和约束条件到底是什么关系？ 宽度是用来限制数据的存储。 约束条件是在宽度的基础之上增加的额外的约束。 ","date":"2021-07-21","objectID":"/mysql-cmd/:14:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"基本数据类型 ","date":"2021-07-21","objectID":"/mysql-cmd/:15:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"整形 1. 分类 tinyint, smallint, mediumint, int, bigint 2. 作用 存储年龄、等级、id、号码… 以tinyint为例 是否有符号 默认情况下是带符号的。*\r超出会如何 超出限制只存最大可接受值。*\rcreate table t9(id tinyint); insert into t9 values(-129),(256); 约束条件之unsigned (无符号) create table t10(id tinyyint unsigned); int默认也是带符号的 整形默认情况下都是带有符号的 create table t11(id int); 针对整形，括号内的宽度到底是干嘛的？ create table t12(id int(8)); insert into t12 values(123456789); 特例：只有整形括号里面的数字不是表示限制位数。 id int(8) 如果数字没有超出8位，那么默认用空格填充至8位。 如果数字超出了8位，那么有几位就存几位（但是还是要遵守最大范围）。 create table t13(id int(8) unsigned zerofill); – 用0填充到8位 总结 针对整形字段，括号内无需指定宽度，因为它默认的宽度已经足够显示所有的数据了。 ","date":"2021-07-21","objectID":"/mysql-cmd/:15:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"严格模式(小插曲) 如何查看严格模式 show variables like '%mode%'; 模糊匹配/查询 关键字 like %: 匹配任意多个字符 _: 匹配任意单个字符 修改严格模式 set session: 只在当前窗口有效 set global: 全局有效 set global sql_mode = 'STRICT_TRANS_TABLES'; 修改完之后，重新进入服务端即可。 ","date":"2021-07-21","objectID":"/mysql-cmd/:15:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"浮点型 1. 分类 FLOAT, DOUBLE, DECIMAL 2. 作用 身高、体重、薪资 存储限制 float(255,30) – 总共255位，小数部分占30位 double(255,30) – 总共255位，小数部分占30位 decimal(65,30) – 总共65位，小数部分占30位 精确度验证 create table t15(id float(255,30)); create table t16(id double(255,30)); create table t17(id decimal(65,30)); 你们在前期不要给我用方向键，所有的命令全部手敲！！！增加熟练度 insert into t15 values(1.111111111111111111111111111111); insert into t16 values(1.111111111111111111111111111111); insert into t17 values(1.111111111111111111111111111111); float \u003c double \u003c decimal 要结合实际应用场景，三者都能使用。 ","date":"2021-07-21","objectID":"/mysql-cmd/:15:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"字符类型 1. 分类 char 定长 char(4): 数据超过四个字符直接报错，不够四个字符空格补全。 varchar 变长 varchar(4): 数据超过四个字符直接报错，不够有几个存几个。 create table t18(name char(4)); create table t19(name varchar(4)); insert into t18 values('a'); insert into t19 values('a'); 介绍一个小方法 char_length 统计字段长度 select char_length(name) from t18; select char_length(name) from t19; 首先可以肯定的是，char在硬盘上存的绝对是真正的数据，带有空格的。 但是在显示的时候，MySQL会自动将多余的空格剔除。 再次修改sql_mode让MySQL不要做自动剔除操作 set global sql_mode = 'STRICT_TRANS_TABLES,PAD_CHAR_TO_FULL_LENGTH'; char 与 varchar对比 char 缺点: 浪费空间 优点: 存取都很简单 直接按照固定的字符存取数据即可。 jason, egon, alex, wusir, tank 存按照五个字符存，取也直接按照五个字符取。 varchar 优点: 节省空间 缺点: 存取较为麻烦 1bytes+jason, 1bytes+egon, 1bytes+alex, 1bytes+tank 存的时候需要制作报头。 取的时候也需要先读取报头，之后才能读取真实数据。 以前基本上都是用的char，其实现在用varchar的也挺多。 ","date":"2021-07-21","objectID":"/mysql-cmd/:15:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"时间类型 1. 分类 date: 年月日 (e.g., 2020-5-4) datetime: 年月日时分秒 (e.g., 2020-5-4 11:11:11) time: 时分秒 (e.g., 11:11:11) Year: 年 (e.g., 2020) 2. 具体使用 create table student( id int, name varchar(16), born_year year, birth date, study_time time, reg_time datetime ); insert into student values(1,'egon','1880','1880-11-11','11:11:11','2020-11-11 11:11:11'); ","date":"2021-07-21","objectID":"/mysql-cmd/:15:5","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"枚举与集合类型 1. 分类 枚举(enum): 多选一 集合(set): 多选多 2. 具体使用 create table user( id int, name char(16), gender enum('male','female','others') ); insert into user values(1,'jason','male'); – 正常 insert into user values(2,'egon','xxxxooo'); – 报错 枚举字段，后期在存数据的时候只能从枚举里面选择一个存储。 create table teacher( id int, name char(16), gender enum('male','female','others'), hobby set('read','DBJ','hecha') ); insert into teacher values(1,'jason','male','read'); – 正常 insert into teacher values(2,'egon','female','DBJ,hecha'); – 正常 insert into teacher values(3,'tank','others','生蚝'); – 报错 集合可以只写一个，但是不能写没有列举的。 ","date":"2021-07-21","objectID":"/mysql-cmd/:15:6","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"约束条件 ","date":"2021-07-21","objectID":"/mysql-cmd/:16:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"DEFAULT 默认值 default 默认值 补充知识点：插入数据的时候可以指定字段。 create table t1( id int, name char(16) ); insert into t1(name,id) values('ame',1); create table t2( id int, name char(16), gender enum('male','female','others') default 'male' ); insert into t2(id, name) values(1,'jason'); insert into t2 values(2, 'egon', 'female'); ","date":"2021-07-21","objectID":"/mysql-cmd/:16:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"UNIQUE唯一 unique 唯一 # 单列唯一 create table t3( id int unique, name char(16) ); insert into t3 values(1,'jason'),(1,'egon'); insert into t3 values(1,'jason'),(2,'egon'); # 联合唯一 ip和port 单个都可以重复，但是加在一起必须是唯一的。 create table t4( id int, ip char(16), port int, unique(ip,port) ); insert into t4 values(1,'127.0.0.1',8080); insert into t4 values(2,'127.0.0.1',8081); insert into t4 values(3,'127.0.0.2',8080); insert into t4 values(4,'127.0.0.1',8080); -- 报错 ","date":"2021-07-21","objectID":"/mysql-cmd/:16:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"PRIMARY KEY 主键 1. 单单从约束效果上来看，primary key 等价于 not null + unique (非空且唯一!!!) create table t5(id int primary key); insert into t5 values(null); -- 报错 insert into t5 values(1),(1); -- 报错 insert into t5 values(1),(2); 2. 它除了有约束效果之外，他还是Innodb存储引擎组织数据的依据。 Innodb存储引擎在创建表的时候必须要有primary key，因为它类似于书的目录，能够帮助提升查询效率，并且也是建表的依据。 2.1 一张表中有且只有一个主键。如果你没有设置主键，那么会从上往下搜索，直到遇到一个非空且唯一的字段，将它自动升级为主键。 create table t6( id int, name char(16), age int not null unique, addr char(32) not null unique ); 2.2 如果表中没有主键，也没有其他任何的非空且唯一的字段，那么Innodb会采用自己内部提供的一个隐藏字段作为主键。隐藏意味着你无法使用到它，就无法提升查询速度。 3.3 一张表中通常都应该有一个主键字段，并且通常将id/uid/sid字段作为主键。 单个字段主键 create table t5( id int primary key, name char(16) ); 联合主键 (多个字段联合起来作为表的主键，本质还是一个主键) create table t7( ip char(16), port int, primary key(ip, port) ); 也意味着，以后我们在创建表的时候，id字段一定要加primary key。 ","date":"2021-07-21","objectID":"/mysql-cmd/:16:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"AUTO_INCREMENT 自增 当编号特别多的时候，人为地去维护太麻烦。 create table t8( id int primary key auto_increment, name char(16) ); insert into t8(name) values('jason'),('egon'),('kevin'); 注意：auto_increment通常都是加在主键上的，不能给普通字段加。 create table t9( id int primary key auto_increment, name char(16), cid int auto_increment ); ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key ","date":"2021-07-21","objectID":"/mysql-cmd/:16:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"表与表之间建关系 ","date":"2021-07-21","objectID":"/mysql-cmd/:17:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"问题引出 定义一张员工表，表中有很多字段：id, name, gender, dep_name, dep_desc。 1. 该表的组织结构不是很清晰 (可忽视) 2. 浪费硬盘空间 (可忽视) 3. 数据的扩展性极差 (无法忽视的) 如何优化？ 上述问题就类似于你将所有的代码都写在一个py文件中。 将员工表拆分：员工表和部门表。 ","date":"2021-07-21","objectID":"/mysql-cmd/:17:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"外键 外键就是用来帮助我们建立表与表之间关系的foreign key ","date":"2021-07-21","objectID":"/mysql-cmd/:17:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"表关系 表与表之间最多只有四种关系 一对多关系 一对多、多对一 都叫一对多！！！ 多对多关系 一对一关系 没有关系 ","date":"2021-07-21","objectID":"/mysql-cmd/:17:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"一对多关系 判断表与表之间关系的时候，前期不熟悉的情况下，一定要按照我给你的建议换位思考，分别站在两张表的角度考虑。 以员工表与部门表为例： 先站在员工表 *思考一个员工能否对应多个部门(一条员工数据能否对应多条部门数据)*\r*不能！！！*\r*(不能直接得出结论，一定要两张表都考虑完全)*\r再站在部门表 *思考一个部门能否对应多个员工(一个部门数据能否对应多条员工数据)*\r*能！！！*\r得出结论 *员工表与部门表示单向的一对多*\r*所以表关系就是一对多*\rforeign key 1. 一对多表关系，外键字段建在多的一方。 2. 在创建表的时候，一定要先建被关联表。 3. 在录入数据的时候，也必须先录入被关联表。 SQL语句建立表关系 create table dep( id int primary key auto_increment, dep_name char(16), dep_desc char(32) ); create table emp( id int primary key auto_increment, name char(16), gender enum('male','female','others') default 'male', dep_id int, foreign key(dep_id) references dep(id) ); insert into dep(dep_name,dep_desc) values('教学部','教书育人'),('外交部','多人外交'),('nb技术部','技术能力有限部门'); insert into emp(name,dep_id) values('jason',2),('egon',1),('tank',1),('kevin',3); 修改dep表里面的id字段 update dep set id=200 where id=2; -- 不行 删除dep表里面的数据 delete from dep; -- 不行 1. 先删除教学部对应的员工数据，之后再删除部门。 操作太过繁琐。 2. 真正做到数据之间有关系。 更新就同步更新。 删除就同步删除。 级联更新 »\u003e 同步更新 级联删除 »\u003e 同步删除 create table dep( id int primary key auto_increment, dep_name char(16), dep_desc char(32) ); create table emp( id int primary key auto_increment, name char(16), gender enum('male','female','others') default 'male', dep_id int, foreign key(dep_id) references dep(id) on update cascade -- 同步更新 on delete cascade -- 同步删除 ); insert into dep(dep_name,dep_desc) values('sb教学部','教书育人'),('外交部','多人外交'),('nb技术部','技术能力有限部门'); insert into emp(name,dep_id) values('jason',2),('egon',1),('tank',1),('kevin',3); ","date":"2021-07-21","objectID":"/mysql-cmd/:17:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"多对多表关系 图书表和作者表 create table book( id int primary key auto_increment, title varchar(32), price int, author_id int, foreign key(author_id) references author(id) on update cascade -- 同步更新 on delete cascade -- 同步删除 ); create table author( id int primary key auto_increment, name varchar(32), age int, book_id int, foreign key(book_id) references book(id) on update cascade -- 同步更新 on delete cascade -- 同步删除 ); 按照上述的方式创建，一个都别想成功！！！其实我们只是想记录书籍和作者的关系。针对多对多字段表关系，不能在两张原有的表中创建外键，需要你单独再开设一张专门用来存储两张表数据之间的关系。 create table book( id int primary key auto_increment, title varchar(32), price int ); create table author( id int primary key auto_increment, name varchar(32), age int ); create table book2author( id int primary key auto_increment, author_id int, book_id int, foreign key(author_id) references author(id) on update cascade -- 同步更新 on delete cascade, -- 同步删除 foreign key(book_id) references book(id) on update cascade -- 同步更新 on delete cascade -- 同步删除 ); ","date":"2021-07-21","objectID":"/mysql-cmd/:17:5","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"一对一 id, name, age, addr, phone, hobby, email… 如果一个表的字段特别多，每次查询又不是所有的字段都能用得到，可以将表一分为二。 用户表 用户表: id, name, age 用户详情表: id, addr, phone, hobby, email… 站在用户表 一个用户能否对应多个用户详情？ 不能！！！ 站在详情表 一个详情能否属于多个用户？ 不能！！！ 结论: 单向的一对多都不成立，那么这个时候两者之间的表关系就是一对一，或者没有关系(好判断)。 客户表和学生表 在你们报名之前，你们是客户。 报名之后是学生 (期间有一些客户不会报名)。 一对一，外键字段建在任意一方都可以，但是推荐你建在查询频率比较高的表中。 create table authordetail( id int primary key auto_increment, phone int, addr varchar(64) ); create table author( id int primary key auto_hundred, name varchar(32), age int, authordetail_id int unique, foreign key(authordetail_id) references authordetail(id) on update cascade -- 同步更新 on delete cascade -- 同-同步删除 ); ","date":"2021-07-21","objectID":"/mysql-cmd/:17:6","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"总结 表关系的建立需要用到foreign key 一对多 外键字段建在多的一方。 多对多 自己开设第三张表存储关系。 一对一 建在任意一方都可以，但是推荐你建在查询频率较高的表中。 判断表之间关系的方式 换位思考！！！ 员工与部门 图书与作者 作者与作者详情 ","date":"2021-07-21","objectID":"/mysql-cmd/:17:7","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"修改表 MySQL对大小写是不敏感的。 1. 修改表名 alter table 表名 rename 新表名; 2. 增加字段 alter table 表名 add 字段名 字段类型(宽度) 约束条件; alter table 表名 add 字段名 字段类型(宽度) 约束条件 first; alter table 表名 add 字段名 字段类型(宽度) 约束条件 after 字段名; 3. 删除字段 alter table 表名 drop 字段名; 4. 修改字段 alter table 表名 modify 字段名 字段类型(宽度) 约束条件; alter table 表名 change 旧字段名 新字段名 字段类型(宽度) 约束条件; ","date":"2021-07-21","objectID":"/mysql-cmd/:17:8","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"复制表 我们sql语句查询的结果其实也是一张虚拟表。 create table 表名 select * from 旧表; – 不能复制主键、外键 … create table new_dep2 select * from dep where id \u003e 3; ","date":"2021-07-21","objectID":"/mysql-cmd/:17:9","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"前期表准备 create table emp( id int not null unique auto_increment, name varchar(20) not null, sex enum('male','female') not null default 'male', -- 大部分是男的 age int(3) unsigned not null default 28, hire_date date not null, post varchar(50), post_comment varchar(100), salary double(15,2), office int, -- 一个部门一个屋子 depart_id int ); #插入记录 #三个部门：教学，销售，运营 insert into emp(name,sex,age,hire_date,post,salary,office,depart_id) values ('jason','male',18,'20170301','张江第一帅形象代言',7300.33,401,1), -- 以下是教学部 ('tom','male',78,'20150302','teacher',1000000.31,401,1), ('kevin','male',81,'20130305','teacher',8300,401,1), ('tony','male',73,'20140701','teacher',3500,401,1), ('owen','male',28,'20121101','teacher',2100,401,1), ('jack','female',18,'20110211','teacher',9000,401,1), ('jenny','male',18,'19000301','teacher',30000,401,1), ('sank','male',48,'20101111','teacher',10000,401,1), ('哈哈','female',48,'20150311','sale',3000.13,402,2), -- 以下是销售部门 ('呵呵','female',38,'20101101','sale',2000.35,402,2), ('西西','female',18,'20110312','sale',1000.37,402,2), ('乐乐','female',18,'20160513','sale',3000.29,402,2), ('拉拉','female',28,'20170127','sale',4000.33,402,2), ('僧龙','male',28,'20160311','operation',10000.13,403,3), -- 以下是运营部门 ('程咬金','male',18,'19970312','operation',20000,403,3), ('程咬银','female',18,'20130311','operation',19000,403,3), ('程咬铜','male',18,'20150411','operation',18000,403,3), ('程咬铁','female',18,'20140512','operation',17000,403,3); 当表字段特别多，展示的时候错乱，可以使用\\G分行展示。 select * from emp\\G; 个别同学的电脑在插入中文的时候还是会出现乱码或者空白的现象，你可以将字符编码统一设置成GBK。 ","date":"2021-07-21","objectID":"/mysql-cmd/:18:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"几个重要关键字的执行顺序 书写顺序 select id,name from emp where id \u003e 3; 执行顺序 from where select 虽然执行顺序和书写顺序不一致，你在写sql语句的时候可能不知道怎么写，你就按照书写顺序的方式写sql：select * 先用*号占位，之后去补全后面的sql语句，最后将*号替换成你想要的具体字段。这里先理解。 ","date":"2021-07-21","objectID":"/mysql-cmd/:19:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"WHERE筛选条件 作用:是对整体数据的一个筛选操作 1. 查询id大于等于3小于等于6的数据 select id,name,age from emp where id\u003e=3 and id\u003c=6; select id,name from emp where id between 3 and 6; -- 两者等价 2. 查询薪资是20000或者18000或者17000的数据 select * from emp where salary=20000 or salary=18000 or salary=17000; select * from emp where salary in (20000,18000,17000); 3. 查询员工姓名中包含字母o的员工的姓名和薪资 模糊查询 like *`%`: 匹配任意多个字符*\r*`_`: 匹配任意单个字符*\rselect name,salary from emp where name like '%o%'; 4. 查询员工姓名是由四个字符组成的 姓名和薪资 char_length() / _ select name,salary from emp where name like '____'; select name,salary from emp where char_length(name) = 4; 5. 查询id小于3或者id大于6的数据 select * from emp where id not between 3 and 6; 6. 查询薪资不在20000,18000,17000范围的数据 select * from emp where salary not in (20000,18000,17000); 7. 查询岗位描述为空的员工姓名和岗位名 (针对null不用等号，用is) select name,post from emp where post_comment = NULL; select name,post from emp where post_comment is NULL; ","date":"2021-07-21","objectID":"/mysql-cmd/:20:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"GROUP BY分组 分组实际应用场景，分组应用场景非常的多 男女比例 部门平均薪资 部门秃头率 国家之间数据统计 1. 按照部门分组 select * from emp group by post; 分组之后，最小可操作单位应该是组，还不再是组内的单个数据。 上述命令在你没有设置严格模式的时候是可正常执行的，返回的是分组之后每个组的第一条数据，但是这不符合分组的规范：分组之后不应该考虑单个数据，而应该以组为操作单位(分组之后，没办法直接获取组内单个数据)。 如果设置了严格模式，那么上述命令会直接报错。 set global sql_mode = 'strict_trans_tables,only_full_group_by'; 设置严格模式之后，分组默认只能拿到分组的依据。 select post from emp group by post; 按照什么分组就只能拿到分组，其他字段不能直接获取，需要借助于一些方法(聚合函数)。 什么时候需要分组啊？？？ 关键字：每个、平均、最高、最低 聚合函数：max、min、sum、count、avg 1. 获取每个部门的最高薪资 select post,max(salary) from emp group by post; select post as '部门',max(salary) as '最高薪资' from emp group by post; select post '部门',max(salary) '最高薪资' from emp group by post; as可以给字段起别名，也可以直接省略不写，但是不推荐，因为省略的话语意不明确，容易错乱。 2. 获取每个部门的最低薪资 select post,min(salary) from emp group by post; 3. 获取每个部门的平均薪资 select post,avg(salary) from emp group by post; 4. 获取每个部门的工资总和 select post,sum(salary) from emp group by post; 5. 获取每个部门的人数 select post,count(id) from emp group by post; -- 常用，符合逻辑 select post,count(salary) from emp group by post; select post,count(age) from emp group by post; select post,count(post_comment) from emp group by post; -- null不行 6. 查询分组之后的部门名称和每个部门下所有的员工姓名 group_concat不单单可以支持你获取分组之后的其他字段值，还支持拼接操作。 select post,group_concat(name) from emp group by post; select post,group_concat(name,'_DSB') from emp group by post; select post,group_concat(name,':',salary) from emp group by post; concat不分组的时候用 select concat('NAME:',name),concat('SAL:',salary) from emp; 补充: as语法不单单可以给字段起别名，还可以给表临时起别名。 select emp.id,emp.name from emp; select emp.id,emp.name from emp as t1; -- 报错 select t1.id,t1.name from emp as t1; 查询每个人的年薪 (12薪) select name,salary*12 from emp; ","date":"2021-07-21","objectID":"/mysql-cmd/:21:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"分组注意事项 关键字where和group by同时出现的时候，group by必须在where的后面。 where先对整体数据进行过滤，之后再分组操作。 where筛选条件不能使用聚合函数。 select id,name,age from emp where max(salary) \u003e 3000; select max(salary) from emp; -- 不分组，默认整体就是一组 统计各部门年龄在30岁以上的员工平均薪资 1. 先求所有年龄大于30岁的员工 select * from emp where age\u003e30; 2. 再对结果进行分组 select * from emp where age\u003e30 group by post; select post,avg(salary) from emp where age\u003e30 group by post; ","date":"2021-07-21","objectID":"/mysql-cmd/:22:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"HAVING分组之后的筛选条件 having的语法跟where是一致的，只不过having是在分组之后进行的过滤操作，即having可以直接使用聚合函数。 统计各部门年龄在30岁以上的员工平均工资，并且保留平均薪资大于10000的部门。 select post,avg(salary) from emp where age\u003e30 group by post having avg(salary) \u003e 10000 ; ","date":"2021-07-21","objectID":"/mysql-cmd/:23:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"DISTINCT去重 一定要注意，必须是完全一样的数据才可以去重！！！一定不要将主键忽视了，有主键存在的情况下，是不可能去重的。[{'id':1,'name':'jason','age':18},{'id':2,'name':'jason','age':18},{'id':3,'name':'egon','age':18}] ORM: 对象关系映射，让不懂SQL语句的人也能够非常牛逼地操作数据库。 表 -\u003e 类 一条条的数据 -\u003e 对象 字段对应的值 -\u003e 对象的属性 你再写类，就意味着在创建表；用类生成对象，就意味着再创建数据；对象点属性，就是在获取数据字段对应的值。目的就是减轻python程序员的压力，只需要会python面向对象的知识点就可以操作MySQL。 select distinct id,age from emp; select distinct age from emp; ","date":"2021-07-21","objectID":"/mysql-cmd/:24:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"ORDER BY排序 select * from emp order by salary; select * from emp order by salary asc; select * from emp order by salary desc; order by默认是升序asc，该asc可以省略不写，也可以修改为降序desc。 select * from emp order by age desc,salary asc; – 先按照age降序排，如果碰到age相同，则再按照salary升序排。 统计各部门年龄在10岁以上的员工平均工资，并且保留平均薪资大于1000的部门,然后对平均工资降序排序。 select post,avg(salary) from emp where age\u003e10 group by post having avg(salary) \u003e 1000 order by avg(salary) desc ; ","date":"2021-07-21","objectID":"/mysql-cmd/:25:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"LIMIT限制展示条数 select * from emp; 针对数据过多的情况，我们通常都是做分页处理。 select * from emp limit 3; – 只展示三条数据 select * from emp limit 0,5; select * from emp limit 5,5; 第一个参数是起始位置。 第二个参数是展示条数。 ","date":"2021-07-21","objectID":"/mysql-cmd/:26:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"正则 select * from emp where name regexp '^j.*(n|y)$'; ","date":"2021-07-21","objectID":"/mysql-cmd/:27:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"多表操作 ","date":"2021-07-21","objectID":"/mysql-cmd/:28:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"前期表准备 建表 create table dep( id int, name varchar(20) ); create table emp( id int primary key auto_increment, name varchar(20), sex enum('male','female') not null default 'male', age int, dep_id int ); 插入数据 insert into dep values (200,'技术'), (201,'人力资源'), (202,'销售'), (203,'运营'); insert into emp(name,sex,age,dep_id) values ('jason','male',18,200), ('egon','female',48,201), ('kevin','male',18,201), ('nick','male',28,202), ('owen','male',18,203), ('jerry','female',18,204); ","date":"2021-07-21","objectID":"/mysql-cmd/:28:1","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"表查询 select * from dep,emp; – 结果: 笛卡尔积 了解即可，不知道也没关系。 select * from emp,dep where emp.dep_id = dep.id; MySQL也知道，你在后面查询数据过程中，肯定会经常用到拼表操作，所以特地给你开设了对应的方法: inner join: 内连接 left join: 左连接 right join: 右连接 union: 全连接 inner join 内连接 select * from emp inner join dep on emp.dep_id = dep.id; – 只拼接两张表中公有的数据部分 left join 左连接 select * from emp left join dep on emp.dep_id = dep.id; – 左表所有的数据都展示出来，没有对应的项就用NULL right join 右连接 select * from emp right join dep on emp.dep_id = dep.id; – 右表所有的数据都展示出来，没有对应的项就用NULL union 全连接 – 左右两表所有的数据都展示出来 select * from emp left join dep on emp.dep_id = dep.id union select * from emp right join dep on emp.dep_id = dep.id; ","date":"2021-07-21","objectID":"/mysql-cmd/:28:2","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"子查询 子查询就是我们平时解决问题的思路。 分步骤解决问题 *第一步*\r*第二步*\r*...*\r将一个查询语句的结果当做另外一个查询语句的条件去用。 查询部门是技术或者人力资源的员工信息 1. 先获取部门的id号 2. 再去员工表里面筛选出对应的员工 select id from dep where name='技术' or name = '人力资源'; select name from emp where dep_id in (200,201); select * from emp where dep_id in (select id from dep where name='技术' or name = '人力资源'); ","date":"2021-07-21","objectID":"/mysql-cmd/:28:3","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"总结 表的查询结果可以作为其他表的查询条件也可以通过起别名的方式把它作为一个张虚拟表根其他表关联 多表查询就两种方式 先拼接表再查 子查询 ","date":"2021-07-21","objectID":"/mysql-cmd/:28:4","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"},{"categories":["MySQL"],"content":"小知识：mysql-arm 安装 1. 安装MySQL brew install mysql@5.7 2. 安装brew服务 brew tap homebrew/services 3. 加载和启动MySQL服务 brew services start mysql@5.7 4. 检查MySQL服务是否已加载 brew services list 5. 创建软链接 ln -s /opt/homebrew/Cellar/mysql@5.7/5.7.38/bin/mysql /usr/local/bin/mysql 6. 验证安装MySQL是否成功 mysql -v 7. 进入brew安装目录 cd /opt/homebrew/Cellar/mysql@5.7/5.7.38/bin 8. 初始化密码，更改你自己的密码 ./mysqladmin -u root password 'yourpassword' ","date":"2021-07-21","objectID":"/mysql-cmd/:29:0","tags":["MySQL"],"title":"CMD","uri":"/mysql-cmd/"}]