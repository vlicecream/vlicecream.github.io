<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Ame</title>
        <link>https://example.com/</link>
        <description>一个艺术世界</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ame)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ame)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 12 Feb 2025 21:34:00 &#43;0800</lastBuildDate>
            <atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>绘制3D立方体</title>
    <link>https://example.com/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93/</link>
    <pubDate>Wed, 12 Feb 2025 21:34:00 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/direct3d-%E7%BB%98%E5%88%B63d%E7%AB%8B%E6%96%B9%E4%BD%93/</guid>
    <description><![CDATA[<h1 id="绘制3d立方体"><em><strong>绘制3D立方体</strong></em></h1>
<h2 id="顶点与输入布局"><em><strong>顶点与输入布局</strong></em></h2>
<p><em>除了空间位置，Direct3D 中的顶点还可以存储其他属性数据</em></p>]]></description>
</item>
<item>
    <title>渲染流水线</title>
    <link>https://example.com/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</link>
    <pubDate>Mon, 10 Feb 2025 22:44:00 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</guid>
    <description><![CDATA[<h1 id="渲染流水线"><em><strong>渲染流水线</strong></em></h1>
<h2 id="3d-视觉即错觉"><em><strong>3D 视觉即错觉？</strong></em></h2>
<p><em>我们都知道物体重叠（object overlap）的概念，即不透明物体能够遮挡住其后侧物体的局部（或整 体），如图 5.4 所示。这是一个重要的概念，它传达了不同物体在场景中的深度顺序关系。而我们在第 4 章 中也已经讨论过如何在 Direct3D 中借助深度缓冲区来确定那些应当受到遮蔽而不是绘制出来的像素。</em></p>]]></description>
</item>
<item>
    <title>DirectX3D的初始化</title>
    <link>https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
    <pubDate>Mon, 10 Feb 2025 22:00:00 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
    <description><![CDATA[<h1 id="direct3d的初始化"><em><strong>Direct3D的初始化</strong></em></h1>
<h2 id="预备知识"><em><strong>预备知识</strong></em></h2>
<p><em>通过 Direct3D 这种底层图形应用程序编程接口（Application Programming Interface，API），即可在 在应用程序中对图形处理器（Graphics Processing Unit，GPU）进行控制和编程。我们能够借此以硬件加 速的方式渲染出虚拟的 3D 场景</em></p>]]></description>
</item>
<item>
    <title>变换矩阵</title>
    <link>https://example.com/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/</link>
    <pubDate>Thu, 06 Feb 2025 22:00:00 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/</guid>
    <description><![CDATA[<h1 id="变换"><em><strong>变换</strong></em></h1>
<h2 id="变换矩阵"><em><strong>变换矩阵</strong></em></h2>
<h3 id="定义"><em><strong>定义</strong></em></h3>
<p><em>先来研究一下数学函数 $ \tau(\vec{v}) = \tau(x, y, z) = (x&rsquo;, y&rsquo;, z&rsquo;) $。此函数的输入和输出都是 3D 向量。</em></p>]]></description>
</item>
<item>
    <title>矩阵</title>
    <link>https://example.com/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/</link>
    <pubDate>Tue, 24 Dec 2024 11:05:00 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%9F%A9%E9%98%B5/</guid>
    <description><![CDATA[<h1 id="矩阵"><em><strong>矩阵</strong></em></h1>
<h2 id="矩阵的定义"><em><strong>矩阵的定义</strong></em></h2>
<p><em>一个规模为 m × n  的矩阵（matrix）M，是由 m 行 n 列实数所构成的矩形阵列。行数和列数的乘积表示了矩阵的维度。</em></p>]]></description>
</item>
<item>
    <title>向量</title>
    <link>https://example.com/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/</link>
    <pubDate>Mon, 23 Dec 2024 22:00:00 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%90%91%E9%87%8F/</guid>
    <description><![CDATA[<h1 id="向量"><em><strong>向量</strong></em></h1>
<h2 id="向量的定义"><em><strong>向量的定义</strong></em></h2>
<p><em>向量（vector）是一种兼具大小（也称为模，magnitude）和方向的量。具有这两种属性的量皆 称为向量值物理量（vector-valued quantity）</em></p>]]></description>
</item>
<item>
    <title>Unreal HLSL</title>
    <link>https://example.com/unreal-hlsl/</link>
    <pubDate>Sun, 22 Dec 2024 13:31:00 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/unreal-hlsl/</guid>
    <description><![CDATA[<h1 id="hlsl"><em><strong>HLSL</strong></em></h1>
<h2 id="数据类型"><em><strong>数据类型</strong></em></h2>
<p><em><strong>代码基于以下蓝图</strong></em></p>

<h3 id="bool"><em><strong>bool</strong></em></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-hlsl" data-lang="hlsl"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="int"><em><strong>int</strong></em></h3>
<p><em>数据范围为 &ldquo;-2147483648 ~ 2147483647&rdquo;</em></p>]]></description>
</item>
<item>
    <title>Steam Deck</title>
    <link>https://example.com/index_zh-cn/</link>
    <pubDate>Tue, 23 Jan 2024 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/index_zh-cn/</guid>
    <description><![CDATA[<h1 id="steamdeck">SteamDeck</h1>
<p><em>最近在折腾steam deck 放一个博客存一些命令，以防格式化或者啥的，又得重弄</em></p>
<p><em>但是专门为deck弄一个分类不太好，所以放生活吧~</em></p>]]></description>
</item>
<item>
    <title>备忘录</title>
    <link>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/</link>
    <pubDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95/</guid>
    <description><![CDATA[<h1 id="备忘录">备忘录</h1>
<h2 id="状态变化模式">状态变化模式</h2>
<ol>
<li><em><strong>什么是状态变化</strong></em>
<ul>
<li><em>在组件构建过程中, 某些对象的状态面临变化, 如何对这些变化进行有效的管理? 同时又保证高层的稳定?</em></li>
</ul>
</li>
<li><em><strong>典型模式</strong></em>
<ul>
<li><em>Memento</em></li>
<li><em>State</em></li>
</ul>
</li>
</ol>
<h2 id="动机">动机</h2>
<ol>
<li><em>在软件构建过程中, 某些对象的状态在转换过程中, 可能由于某种需要, 要求程序能够回溯到对象之前的状态</em></li>
<li><em>如果使用一些公有接口来让其他对象得到对象的状态, 便会暴露对象的细节实现</em></li>
<li><em>如何实现对象状态的良好保存与恢复? 但同时又不会因此而破坏对象本身的封装性</em></li>
</ol>
<h2 id="模式定义">模式定义</h2>
<ol>
<li><em>在不破坏封装性的的前提下, 捕获一个对象的内部状态, 并在该对象之外保存此状态，这样以后就可以将该对象恢复到原先保存的状态</em></li>
</ol>
<h2 id="要点总结">要点总结</h2>
<ol>
<li><em>备忘录(Memento)存储原发器对象的内部状态 在需要时恢复原发器状态</em></li>
<li><em>Memento模式的核心是信息隐藏, 即原发器需要向外接隐藏信息, 保持其封装性，但同时有需要将状态保持到外界 (Memento)</em></li>
<li><em>由于现代语言运行时都具有相当的对象序列化支持, 因此往往采用效率高、又较容器正确实现的序列化方案来实现Memento模式</em></li>
</ol>]]></description>
</item>
<item>
    <title>策略模式</title>
    <link>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Fri, 21 Jul 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[<h1 id="策略模式">策略模式</h1>
<h2 id="组件协作模式"><em><strong>组件协作模式</strong></em></h2>
<ol>
<li><em><strong>什么是组件协作模式</strong></em>
<ul>
<li><em>现代软件专业分工之后的第一个结果就是 <strong>框架与应用程序的划分</strong></em></li>
<li><em><strong>组件协作</strong></em> <em>模式通过晚绑定，来实现框架和应用之间的松耦合，是二者之间协作时常用的模式</em></li>
</ul>
</li>
<li><em><strong>典型模式</strong></em>
<ul>
<li><em>Template Method</em></li>
<li><em>Observer / Event</em></li>
<li><em>Strategy</em></li>
</ul>
</li>
</ol>
<h2 id="使用策略模式的动机"><em><strong>使用策略模式的动机</strong></em></h2>
<ol>
<li><em>在软件构建的过程中，某些对象使用的算法可能多种多样的，经常改变，如果将这种算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担</em></li>
<li><em>如何在运行时根据需要透明的更改对象的算法? 将算法与对象本身解藕 从而避免上述问题</em></li>
</ol>
<h2 id="静态代码">静态代码</h2>
<ol>
<li>
<p><em><strong>场景</strong></em></p>]]></description>
</item>
</channel>
</rss>
