<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>算法 &amp; 数据结构 - 分类 - Ame</title>
        <link>https://example.com/categories/%E7%AE%97%E6%B3%95--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <description>算法 &amp; 数据结构 - 分类 - Ame</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ame)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ame)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 05 Mar 2023 16:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/categories/%E7%AE%97%E6%B3%95--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="self" type="application/rss+xml" /><item>
    <title>动态规划</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <pubDate>Sun, 05 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
    <description><![CDATA[<h1 id="动态规划">动态规划</h1>
<h2 id="动态规划-1"><em><strong>动态规划</strong></em></h2>
<ol>
<li>
<p><em>动态规划 跟 “分治、递归、回溯”没有太大的区别，我们来看看动态规划的具体定义</em></p>]]></description>
</item>
<item>
    <title>位运算</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
    <pubDate>Sun, 05 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
    <description><![CDATA[<h1 id="位运算">位运算</h1>
<h2 id="前言">前言</h2>
<p><em>本文分三个部分</em></p>
<ol>
<li>
<p><em>有趣的位运算</em></p>
</li>
<li>
<p><em>算法比较常用的 n &amp; (n - 1)</em></p>
</li>
<li>
<p><em>算法例题</em></p>
</li>
</ol>
<h1 id="位运算的基本概念">位运算的基本概念</h1>
<h2 id="位运算符">位运算符</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pr]]></description>
</item>
<item>
    <title>二分查找</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
    <pubDate>Sat, 04 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
    <description><![CDATA[<h1 id="二分查找"><em><strong>二分查找</strong></em></h1>
<h2 id="二分查找的思想-减而治之"><em><strong>二分查找的思想-减而治之</strong></em></h2>
<ol>
<li>
<p><em>二分查找通过不断缩小区间的范围来查找目标元素，这种&quot;不断缩小区间&quot;就是减而治之的思想</em></p>]]></description>
</item>
<item>
    <title>双指针</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <pubDate>Sat, 04 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
    <description><![CDATA[<h1 id="双指针">双指针</h1>
<h2 id="引言"><em><strong>引言</strong></em></h2>
<p><em><strong>对于数组和链表 来说 &ldquo;双指针&quot;其实是一个常用的解法了</strong></em></p>
<p><em><strong>双指针也是有很多种类的</strong></em></p>]]></description>
</item>
<item>
    <title>时间/空间复杂度</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
    <pubDate>Fri, 03 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
    <description><![CDATA[<h1 id="时间复杂度--空间复杂度">时间复杂度 &amp; 空间复杂度</h1>
<h1 id="时间复杂度"><em><strong>时间复杂度</strong></em></h1>
<ol>
<li><em><strong>O(1) 常数复杂度</strong></em></li>
<li><em><strong>O(log n) 对数复杂度</strong></em></li>
<li><em><strong>O(n) 线性时间复杂度</strong></em></li>
<li><em><strong>O(nlogn) 线性对数时间复杂度</strong></em></li>
<li><em><strong>O(n ^ 2) 平方</strong></em></li>
<li><em><strong>O(n ^ 3) 立方</strong></em></li>
<li><em><strong>O(2 ^ n) 指数</strong></em></li>
<li><em><strong>O(n!) 阶乘</strong></em></li>
<li><em><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n ^ 2) &lt; O(n ^ 3) &lt; O(2 ^ n) &lt; O(n!)</strong></em></li>
</ol>
<h2 id="o1"><em><strong>O(1)</strong></em></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pr]]></description>
</item>
<item>
    <title>数组-链表-跳表</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/</link>
    <pubDate>Fri, 03 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/</guid>
    <description><![CDATA[<h1 id="数组-链表-跳表">数组-链表-跳表</h1>
<h2 id="数组"><em><strong>数组</strong></em></h2>
<ol>
<li><em><strong>数组的特点</strong></em>
<ul>
<li><em>当我们申请数组的时候，计算机会在内存开辟一段连续的内存地址，内存管理器可以直接访问每个内存地址，所以我们可以通过&quot; [  ] &ldquo;去取值</em></li>
</ul>
</li>
<li><em><strong>数组的时间复杂度</strong></em>
<ul>
<li><em><strong>select：</strong></em> <em>O(1)</em></li>
<li><em><strong>insert：</strong></em> <em>O(n)</em></li>
<li><em><strong>append：</strong></em> <em>O(1)</em></li>
<li><em><strong>delete：</strong></em> <em>O(n)</em></li>
</ul>
</li>
<li><em><strong>数组时间复杂度图示</strong></em>
<ul>
<li></li>
</ul>
</li>
</ol>
<h2 id="链表"><em><strong>链表</strong></em></h2>
<ol>
<li>
<p><em><strong>引出</strong></em></p>]]></description>
</item>
<item>
    <title>栈&amp;队列</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</link>
    <pubDate>Fri, 03 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</guid>
    <description><![CDATA[<h1 id="栈队列双端队列优先队列">栈/队列/双端队列/优先队列</h1>
<ol>
<li>
<p><em><strong>什么是队列</strong></em></p>
<ul>
<li><em>队列是一个 <strong>先进先出</strong> 的数据结构</em></li>
<li><em>先进来的元素 先被消费使用</em></li>
<li><em>好比排队 第一个排队的人肯定第一个出来 这就是先进先出</em></li>
<li><em>队列有两种重要的方法 - push（往队列的尾部塞入元素）/ pop（往队列的头部删除元素）</em></li>
</ul>
</li>
<li>
<p><em><strong>什么是栈</strong></em></p>]]></description>
</item>
<item>
    <title>布隆过滤器</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
    <pubDate>Thu, 02 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
    <description><![CDATA[<h1 id="布隆过滤器">布隆过滤器</h1>
<h2 id="布隆过滤器-1"><em><strong>布隆过滤器</strong></em></h2>
<ol>
<li>
<p><em><strong>引出</strong></em></p>
<ul>
<li><em>对于<code>hashtable</code>，我们存放一个数据，会先进行哈希取模，然后决定放在哪一个桶，随后就会把这个数据放进🪣中，<strong>对于哈希表来说，存放的数据是准备完整的</strong></em></li>
<li><em>我们再来想一个场景，如果我们不需要完整的数据，我们只是想判断一个这个数据到底存不存在，这个时候哈希表其实不太适合，其实可以做到的，但是终归不是完美适合这个场景 所以我们需要一个更高效的数据结构</em></li>
<li><em>布隆过滤器 他lei了</em></li>
</ul>
</li>
<li>
<p><em><strong>什么是布隆过滤器</strong></em></p>]]></description>
</item>
<item>
    <title>树</title>
    <link>https://example.com/tree/</link>
    <pubDate>Thu, 02 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/tree/</guid>
    <description><![CDATA[<h1 id="树">树</h1>
<h2 id="树-1"><em><strong>树</strong></em></h2>
<ol>
<li>
<p><em><strong>引出</strong></em></p>
<ul>
<li><em>当我们在刷算法的时候 当中有个思路就是空间换时间，因为在如今科技发达的社会 硬件已经很牛逼了，所以相比较，时间更为重要</em></li>
<li><em>还有个思路就是 <strong>升维</strong>这个思想，链表其实就是一维，跳表就是二维，将链表升维后 时间复杂度也从 O(n) 优化到了 O(logn)</em></li>
<li><em>树也是一样的 通过链表升维而诞生的一个数据结构</em></li>
</ul>
</li>
<li>
<p><em><strong>树的定义</strong></em></p>]]></description>
</item>
<item>
    <title>LRU-Catch</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/</link>
    <pubDate>Wed, 01 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/</guid>
    <description><![CDATA[<h1 id="lru-catch">LRU Catch</h1>
<h2 id="lru-catch-1"><em><strong>LRU Catch</strong></em></h2>
<ol>
<li>
<p><em><strong>什么是LRU Catch</strong></em></p>
<ul>
<li><em>LRU是最近最少使用策略的缩写，是根据数据的历史访问记录来进行淘汰数据，其核心思想是“<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>”</em></li>
<li><em>我们可以用 <strong>双向链表</strong>去实现 <code>LRU Catch</code></em></li>
</ul>
</li>
<li>
<p><em><strong>LRU Catch 图示</strong></em></p>]]></description>
</item>
</channel>
</rss>
