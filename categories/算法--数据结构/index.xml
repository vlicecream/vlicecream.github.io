<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>算法 &amp; 数据结构 - 分类 - Ting</title>
        <link>https://example.com/categories/%E7%AE%97%E6%B3%95--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
        <description>算法 &amp; 数据结构 - 分类 - Ting</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ting)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ting)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 10 Mar 2023 20:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/categories/%E7%AE%97%E6%B3%95--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="self" type="application/rss+xml" /><item>
    <title>位运算</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
    <pubDate>Fri, 10 Mar 2023 20:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
    <description><![CDATA[<h2 id="前言"><em><strong>前言</strong></em></h2>
<p><em>本文分三个部分</em></p>
<ol>
<li>
<p><em>有趣的位运算</em></p>
</li>
<li>
<p><em>算法比较常用的 n &amp; (n - 1)</em></p>
</li>
<li>
<p><em>算法例题</em></p>
</li>
</ol>
<h2 id="位运算符"><em><strong>位运算符</strong></em></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pr]]></description>
</item>
<item>
    <title>LRU-Catch</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/</link>
    <pubDate>Tue, 07 Mar 2023 14:21:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-lru-catch/</guid>
    <description><![CDATA[<h2 id="lru-catch"><em><strong>LRU Catch</strong></em></h2>
<ol>
<li>
<p><em><strong>什么是LRU Catch</strong></em></p>
<ul>
<li><em>LRU是最近最少使用策略的缩写，是根据数据的历史访问记录来进行淘汰数据，其核心思想是“<strong>如果数据最近被访问过，那么将来被访问的几率也更高</strong>”</em></li>
<li><em>我们可以用 <strong>双向链表</strong>去实现 <code>LRU Catch</code></em></li>
</ul>
</li>
<li>
<p><em><strong>LRU Catch 图示</strong></em></p>]]></description>
</item>
<item>
    <title>动态规划</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <pubDate>Mon, 06 Mar 2023 18:25:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
    <description><![CDATA[<h2 id="动态规划"><em><strong>动态规划</strong></em></h2>
<ol>
<li>
<p><em>动态规划 跟 “分治、递归、回溯”没有太大的区别，我们来看看动态规划的具体定义</em></p>
<ul>
<li>
<p><em><strong>simplifying a complicated problem by breaking it down into simpler sub-problems</strong></em></p>]]></description>
</item>
<item>
    <title>布隆过滤器</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
    <pubDate>Sun, 05 Mar 2023 20:09:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
    <description><![CDATA[<h2 id="布隆过滤器"><em><strong>布隆过滤器</strong></em></h2>
<ol>
<li>
<p><em><strong>引出</strong></em></p>
<ul>
<li><em>对于<code>hashtable</code>，我们存放一个数据，会先进行哈希取模，然后决定放在哪一个桶，随后就会把这个数据放进🪣中，<strong>对于哈希表来说，存放的数据是准备完整的</strong></em></li>
<li><em>我们再来想一个场景，如果我们不需要完整的数据，我们只是想判断一个这个数据到底存不存在，这个时候哈希表其实不太适合，其实可以做到的，但是终归不是完美适合这个场景 所以我们需要一个更高效的数据结构</em></li>
<li><em>布隆过滤器 他lei了</em></li>
</ul>
</li>
<li>
<p><em><strong>什么是布隆过滤器</strong></em></p>]]></description>
</item>
<item>
    <title>树</title>
    <link>https://example.com/tree/</link>
    <pubDate>Sat, 04 Mar 2023 12:01:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/tree/</guid>
    <description><![CDATA[<h2 id="树"><em><strong>树</strong></em></h2>
<ol>
<li>
<p><em><strong>引出</strong></em></p>
<ul>
<li><em>当我们在刷算法的时候 当中有个思路就是空间换时间，因为在如今科技发达的社会 硬件已经很牛逼了，所以相比较，时间更为重要</em></li>
<li><em>还有个思路就是 <strong>升维</strong>这个思想，链表其实就是一维，跳表就是二维，将链表升维后 时间复杂度也从 O(n) 优化到了 O(logn)</em></li>
<li><em>树也是一样的 通过链表升维而诞生的一个数据结构</em></li>
</ul>
</li>
<li>
<p><em><strong>树的定义</strong></em></p>]]></description>
</item>
<item>
    <title>哈希表</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/</link>
    <pubDate>Fri, 03 Mar 2023 23:22:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hashtable/</guid>
    <description><![CDATA[<h2 id="hashtable"><em><strong>hashtable</strong></em></h2>
<ol>
<li><em><strong>什么叫hashtable</strong></em>
<ul>
<li><em>哈希表也叫做散列表，是根据关键码值而直接进行访问的数据结构</em></li>
<li><em>他通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度</em></li>
<li><em>这个映射函数叫做散列函数，存放的记录叫做哈希表</em></li>
</ul>
</li>
<li><em><strong>hashtable的时间复杂度</strong></em>
<ul>
<li>***search：*<em>O(1)</em></li>
<li>***Insertion：*<em>O(1)</em></li>
<li>***Deletion：*<em>O(1)</em></li>
<li><em><strong>但是我们如果了解什么是哈希冲突 以及拉链法解决哈希冲突，那么在哈希表很小并且冲突很多的情况下，时间复杂度会退化成链表O(n)</strong></em></li>
</ul>
</li>
<li><em><strong>hashtable的原理和golang的map实现 图示</strong></em>
<ul>
<li></li>
</ul>
</li>
</ol>
<h2 id="hashtable例题"><em><strong>hashtable例题</strong></em></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pr]]></description>
</item>
<item>
    <title>双指针</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</link>
    <pubDate>Thu, 02 Mar 2023 21:12:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
    <description><![CDATA[<h2 id="引言"><em><strong>引言</strong></em></h2>
<p><em><strong>对于数组和链表 来说 &ldquo;双指针&quot;其实是一个常用的解法了</strong></em></p>
<p><em><strong>双指针也是有很多种类的</strong></em></p>
<h2 id="普通双指针"><em><strong>普通双指针</strong></em></h2>
<ol>
<li><em><strong>什么是双指针</strong></em>
<ul>
<li><em>双指针模式指使用两个一前一后的指针遍历数据结构，直到某个指针触发停止条件</em></li>
</ul>
</li>
<li><em><strong>使用双指针的好处</strong></em>
<ul>
<li><em>单指针原本需要平方的时间复杂度，用了双指针便可优化到线性时间复杂度</em></li>
</ul>
</li>
</ol>
<h2 id="快慢指针"><em><strong>快慢指针</strong></em></h2>
<ol>
<li><em><strong>什么是快慢指针</strong></em>
<ul>
<li><em>两个速度不同的指针 比如 &ldquo;fast指针&rdquo; 跑两格 &ldquo;slow指针&rdquo; 跑一格</em></li>
<li><em>可以拿龟兔赛跑去想象，在一个圆形赛道，&ldquo;兔子 -&gt; 快指针&rdquo; 肯定会追上 &ldquo;乌龟 -&gt; 慢指针&rdquo;，龟兔赛跑也经常用在判断链表是否成环上面</em></li>
</ul>
</li>
</ol>
<h2 id="左右指针"><em><strong>左右指针</strong></em></h2>
<ol>
<li>
<p><em><strong>来讲一讲题外话</strong></em></p>]]></description>
</item>
<item>
    <title>二分查找</title>
    <link>https://example.com/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
    <pubDate>Wed, 01 Mar 2023 20:31:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
    <description><![CDATA[<h2 id="二分查找的思想-减而治之"><em><strong>二分查找的思想-减而治之</strong></em></h2>
<ol>
<li>
<p><em>二分查找通过不断缩小区间的范围来查找目标元素，这种&quot;不断缩小区间&quot;就是减而治之的思想</em></p>]]></description>
</item>
<item>
    <title>栈&amp;队列</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</link>
    <pubDate>Mon, 27 Feb 2023 12:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</guid>
    <description><![CDATA[<h2 id="什么是队列"><em><strong>什么是队列</strong></em></h2>
<ul>
<li><em>队列是一个 <strong>先进先出</strong> 的数据结构</em></li>
<li><em>先进来的元素 先被消费使用</em></li>
<li><em>好比排队 第一个排队的人肯定第一个出来 这就是先进先出</em></li>
<li><em>队列有两种重要的方法 - push（往队列的尾部塞入元素）/ pop（往队列的头部删除元素）</em></li>
</ul>
<h2 id="什么是栈"><em><strong>什么是栈</strong></em></h2>
<ul>
<li><em>栈是一个 <strong>先进后出</strong> 的数据结构</em></li>
<li><em>先进来的元素 最后一个被消费使用 / 最后进来的元素 第一个被消费使用</em></li>
<li><em>好比一个箱子 你往里面放书 第一个书本在最下面 你只能第一时间拿出最上面的书 也就是最后放进去的书</em></li>
<li><em>栈有两种重要的方法 - push（往栈的尾部塞入元素）/ pop（往栈的尾部删除元素）</em></li>
</ul>
<h2 id="什么是双端队列"><em><strong>什么是双端队列</strong></em></h2>
<ul>
<li><em>是一种具有队列和栈性质的数据类型</em></li>
<li><em>双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行</em></li>
</ul>
<h2 id="什么是优先级队列"><em><strong>什么是优先级队列</strong></em></h2>
<ul>
<li><em>依靠每个元素的优先级 来决定哪一个最先被消费使用</em></li>
</ul>
<h2 id="golang实现队列"><em><strong>Golang实现队列</strong></em></h2>
<p><em><strong>golang 如何实现队列 及其 他的时间复杂度是多少</strong></em></p>]]></description>
</item>
<item>
    <title>数组-链表-跳表</title>
    <link>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/</link>
    <pubDate>Sun, 26 Feb 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84%E4%B8%89%E5%85%84%E5%BC%9F/</guid>
    <description><![CDATA[<h2 id="数组"><em><strong>数组</strong></em></h2>
<ol>
<li><em><strong>数组的特点</strong></em>
<ul>
<li><em>当我们申请数组的时候，计算机会在内存开辟一段连续的内存地址，内存管理器可以直接访问每个内存地址，所以我们可以通过&quot; [  ] &ldquo;去取值</em></li>
</ul>
</li>
<li><em><strong>数组的时间复杂度</strong></em>
<ul>
<li><em><strong>select：</strong></em> <em>O(1)</em></li>
<li><em><strong>insert：</strong></em> <em>O(n)</em></li>
<li><em><strong>append：</strong></em> <em>O(1)</em></li>
<li><em><strong>delete：</strong></em> <em>O(n)</em></li>
</ul>
</li>
<li><em><strong>数组时间复杂度图示</strong></em>
<ul>
<li></li>
</ul>
</li>
</ol>
<h2 id="链表"><em><strong>链表</strong></em></h2>
<ol>
<li>
<p><em><strong>引出</strong></em></p>]]></description>
</item>
</channel>
</rss>
