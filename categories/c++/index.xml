<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - 分类 - Ting</title>
        <link>https://example.com/categories/c&#43;&#43;/</link>
        <description>C&#43;&#43; - 分类 - Ting</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ting)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ting)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 26 Mar 2023 16:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/categories/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>friend</title>
    <link>https://example.com/c-friend/</link>
    <pubDate>Sun, 26 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-friend/</guid>
    <description><![CDATA[友元 什么是友元 Friend 的意义在于打开封装的大门，可以直接从私有区域拿取数据 好比借钱，陌生人不可能借钱给他，但是朋友是可以的，但是朋友太多借太多钱也]]></description>
</item>
<item>
    <title>inline</title>
    <link>https://example.com/c-inline/</link>
    <pubDate>Sat, 25 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-inline/</guid>
    <description><![CDATA[什么是内联函数-inline 引出 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被]]></description>
</item>
<item>
    <title>lambda</title>
    <link>https://example.com/c-lambda/</link>
    <pubDate>Fri, 24 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-lambda/</guid>
    <description><![CDATA[lambda 怎么去定义一个lambda 1 2 3 [] { std::cout &lt;&lt; &#34;hello lambdas&#34; &lt;&lt; std::endl; } 对于上述代码，我们可以写成这个样子 1 2 3 [] { std::cout &lt;&lt; &#34;hello lambdas&#34; &lt;&lt; std::endl; } (); // prints &#34;hello lambdas&#34; 那我们改进后 看着也有]]></description>
</item>
<item>
    <title>static</title>
    <link>https://example.com/c-static/</link>
    <pubDate>Thu, 23 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-static/</guid>
    <description><![CDATA[static 什么是static 下述代码括号里面传的就是this pointer 当不是静态方法的时候 c1, c2, c3调用同一个函数 那么就是靠this point区分到底是c1 还]]></description>
</item>
<item>
    <title>value &amp; poionter &amp; reference</title>
    <link>https://example.com/c-value-pointer-reference/</link>
    <pubDate>Wed, 22 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-value-pointer-reference/</guid>
    <description><![CDATA[引用 什么是引用 reference 其实就是一个漂亮的 pointer 引用的代码 1 2 3 4 5 6 7 int x = 0; int* p = &amp;x; // p is a pointer to x int&amp; p = x; // r is a reference to x int x2 = 5; r = x2; int&amp; r2= r; int*]]></description>
</item>
<item>
    <title>编写头文件的思路流程(reference)</title>
    <link>https://example.com/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/</link>
    <pubDate>Tue, 21 Mar 2023 17:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/</guid>
    <description><![CDATA[class内 编写防卫式声明 1 2 3 #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 #endif 编写class head 1 2 3 4 5 6 7 8 #ifndef __STRING__ // __STRING__ 自由取 #define __STRING__ // __STRING__ 自由取 class String { }; #endif 编写数据]]></description>
</item>
<item>
    <title>编写头文件的思路流程(value)</title>
    <link>https://example.com/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/</link>
    <pubDate>Tue, 21 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/</guid>
    <description><![CDATA[class内 编写防卫式声明 1 2 3 #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 #endif 编写class head 1 2 3 4 5 6 7 8 #ifndef __COMPLEX__ // __COMPLEX__ 自由取 #define __COMPLEX__ // __COMPLEX__ 自由取 class complex { }; #endif 编写数据]]></description>
</item>
<item>
    <title>操作符重载</title>
    <link>https://example.com/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
    <pubDate>Mon, 20 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
    <description><![CDATA[!!!本文基于这个一个 complex的类去讲解 操作符重载 1 2 3 4 5 6 7 8 9 10 11 12 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex&amp; operator+=(const complex&amp;); double real() const { return re; } double imag() const {]]></description>
</item>
<item>
    <title>模版</title>
    <link>https://example.com/c-%E6%A8%A1%E7%89%88/</link>
    <pubDate>Sun, 19 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E6%A8%A1%E7%89%88/</guid>
    <description><![CDATA[模板 class template 类模板的作用就是可变类型 1 2 3 4 5 6 7 8 9 10 11 12 13 template&lt;typename T&gt; class complex { public: complex(T r = 0, T i = 0) : re(r), im(i) {} complex &amp;operator+=(const complex &amp;); T real() const { return re; } T imag() const { return im; } private: T re, im; friend]]></description>
</item>
<item>
    <title>虚函数</title>
    <link>https://example.com/c-%E8%99%9A%E5%87%BD%E6%95%B0/</link>
    <pubDate>Sun, 19 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E8%99%9A%E5%87%BD%E6%95%B0/</guid>
    <description><![CDATA[虚函数 虚函数的种类 non-virtual： 你不希望派生类重新定义 virtual：你希望派生类重新定义，且他有默认定义 pure virtual：你希望]]></description>
</item>
</channel>
</rss>
