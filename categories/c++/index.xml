<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - 分类 - Ame</title>
        <link>https://example.com/categories/c&#43;&#43;/</link>
        <description>C&#43;&#43; - 分类 - Ame</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>vlicecream520@gmail.com (Ame)</managingEditor>
            <webMaster>vlicecream520@gmail.com (Ame)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 26 Mar 2023 16:29:59 &#43;0800</lastBuildDate><atom:link href="https://example.com/categories/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>friend</title>
    <link>https://example.com/c-friend/</link>
    <pubDate>Sun, 26 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-friend/</guid>
    <description><![CDATA[<h2 id="友元"><em><strong>友元</strong></em></h2>
<ol>
<li>
<p><em><strong>什么是友元</strong></em></p>
<ul>
<li>
<p><em>Friend 的意义在于打开封装的大门，可以直接从私有区域拿取数据</em></p>
</li>
<li>
<p><em>好比借钱，陌生人不可能借钱给他，但是朋友是可以的，但是朋友太多借太多钱也不太好，所以你自己选择，如果不设置friend，绕个弯从函数拿，也是可以的</em></p>]]></description>
</item>
<item>
    <title>inline</title>
    <link>https://example.com/c-inline/</link>
    <pubDate>Sat, 25 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-inline/</guid>
    <description><![CDATA[<h2 id="什么是内联函数-inline"><em><strong>什么是内联函数-inline</strong></em></h2>
<ol>
<li>
<p><em>引出</em></p>
<ul>
<li><em>函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行</em></li>
<li><em>一个 C/C++程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如<code>return 0;</code>）来结束自己的生命，从而结束整个程序</em></li>
<li><em>函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码</em></li>
<li><em>如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视</em></li>
<li><em>为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数</em></li>
</ul>
</li>
<li>
<p><em>怎么定义内联函数</em></p>]]></description>
</item>
<item>
    <title>lambda</title>
    <link>https://example.com/c-lambda/</link>
    <pubDate>Fri, 24 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-lambda/</guid>
    <description><![CDATA[<h2 id="lambda"><em><strong>lambda</strong></em></h2>
<ol>
<li>
<p><em>怎么去定义一个<code>lambda</code></em></p>
<ul>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">[]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;hello lambdas&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pr]]></description>
</item>
<item>
    <title>static</title>
    <link>https://example.com/c-static/</link>
    <pubDate>Thu, 23 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-static/</guid>
    <description><![CDATA[<h2 id="static"><em><strong>static</strong></em></h2>
<ol>
<li>
<p><em>什么是static</em></p>
<ul>
<li>
<p><em>下述代码括号里面传的就是<code>this pointer</code></em></p>
<p><em>当不是静态方法的时候 c1, c2, c3调用同一个函数 那么就是靠this point区分到底是c1 还是 c2 的</em></p>]]></description>
</item>
<item>
    <title>value &amp; poionter &amp; reference</title>
    <link>https://example.com/c-value-pointer-reference/</link>
    <pubDate>Wed, 22 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-value-pointer-reference/</guid>
    <description><![CDATA[<h2 id="引用"><em><strong>引用</strong></em></h2>
<ol>
<li>
<p><em><strong>什么是引用</strong></em></p>
<ul>
<li><em>reference 其实就是一个漂亮的 pointer</em></li>
</ul>
</li>
<li>
<p><em><strong>引用的代码</strong></em></p>
<ul>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="c1">// p is a pointer to x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// r is a reference to x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">x2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;</span> <span class="n">r2</span><span class="o">=</span> <span class="n">r</span><span class="p">;</span>
</span></span></code></pr]]></description>
</item>
<item>
    <title>编写头文件的思路流程(reference)</title>
    <link>https://example.com/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/</link>
    <pubDate>Tue, 21 Mar 2023 17:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Breference/</guid>
    <description><![CDATA[<h2 id="class内"><em><strong>class内</strong></em></h2>
<ol>
<li>
<p><em><strong>编写防卫式声明</strong></em></p>
<ul>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#ifndef __STRING__  </span><span class="c1">// __STRING__    自由取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define __STRING__  </span><span class="c1">// __STRING__    自由取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span></code></pr]]></description>
</item>
<item>
    <title>编写头文件的思路流程(value)</title>
    <link>https://example.com/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/</link>
    <pubDate>Tue, 21 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E7%BC%96%E5%86%99%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%B7%AF%E6%B5%81%E7%A8%8Bvalue/</guid>
    <description><![CDATA[<h2 id="class内"><em><strong>class内</strong></em></h2>
<ol>
<li>
<p><em><strong>编写防卫式声明</strong></em></p>
<ul>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#ifndef __COMPLEX__  </span><span class="c1">// __COMPLEX__    自由取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define __COMPLEX__  </span><span class="c1">// __COMPLEX__    自由取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span></code></pr]]></description>
</item>
<item>
    <title>操作符重载</title>
    <link>https://example.com/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</link>
    <pubDate>Mon, 20 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</guid>
    <description><![CDATA[<p><em><strong>!!!本文基于这个一个 <code>complex</code>的类去讲解 操作符重载</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pr]]></description>
</item>
<item>
    <title>模版</title>
    <link>https://example.com/c-%E6%A8%A1%E7%89%88/</link>
    <pubDate>Sun, 19 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E6%A8%A1%E7%89%88/</guid>
    <description><![CDATA[<h2 id="模板"><em><strong>模板</strong></em></h2>
<ol>
<li>
<p><em><strong>class template</strong></em></p>
<ul>
<li>
<p><em>类模板的作用就是可变类型</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pr]]></description>
</item>
<item>
    <title>虚函数</title>
    <link>https://example.com/c-%E8%99%9A%E5%87%BD%E6%95%B0/</link>
    <pubDate>Sun, 19 Mar 2023 16:29:59 &#43;0800</pubDate>
    <author>Ame</author>
    <guid>https://example.com/c-%E8%99%9A%E5%87%BD%E6%95%B0/</guid>
    <description><![CDATA[<h2 id="虚函数"><em><strong>虚函数</strong></em></h2>
<ol>
<li>
<p><em>虚函数的种类</em></p>
<ul>
<li>
<p><em>non-virtual： 你不希望派生类重新定义</em></p>
</li>
<li>
<p><em>virtual：你希望派生类重新定义，且他有默认定义</em></p>]]></description>
</item>
</channel>
</rss>
