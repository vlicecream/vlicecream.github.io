# 绘制3D立方体(下)


## ***帧资源***

*在上篇，我们的演示程序在绘制每一帧时 都会将 CPU 和 GPU 进行一次同步，这样做的原因当然是确保数据安全。这种解决方案虽然奏效却效率低下*

*解决此问题的一种方案是：以 CPU 每帧都需更新的资源作为基本元素，创建一个环形数组。我们称这些资源为帧资源，而这种循环数组通常是由 3 个帧资源元素所构成的。该方案的思路是：在处理第 n 帧的时候，CPU 将周而复始地从帧资源数组中获取下一个可用的（即没被 GPU 使用中的）帧资源。趁着 GPU 还在处理此前帧之时，CPU 将为第 n 帧更新 资源，并构建和提交对应的命令列表。随后，CPU 会继续针对第 n+1 帧执行同样的工作流程，并不断重复下去。如果帧资源数组共有 3 个元素，则令 CPU 比 GPU 提前处理两帧，以确保 GPU 可持续工作。*

*不难看出，这种解决方案还是无法完全避免等待情况的发生。**但是如果CPU执行的比GPU快，那么就可以保证GPU不会浪费任何性能，并且CPU等GPU的时候可以去执行不依赖GPU，比如AI以及游戏业务逻辑一些的任务***

## ***渲染项***

*绘制一个物体需要设置多种参数，例如绑定顶点缓冲区和索引缓冲区、绑定与物体有关的常量数据、 设定图元类型以及指定 DrawIndexedInstanced 方法的参数。随着场景中所绘物体的逐渐增多，如果我们能创建一个轻量级结构来存储绘制物体所需的数据，那真是极好的；由于每个物体的特征不同，绘制过程中所需的数据也会有所变化，因此该结构中的数据也会因具体程序而异。我们把单次绘制调用过程中，需要向渲染流水线提交的数据集称为渲染项。*

## ***渲染过程中所用到的常量数据***

*随着演示代码复杂度的不断增加，该缓冲区中存储的数据内容（例如观察位置、观察矩阵与投影矩阵以 及与屏幕（渲染目标）分辨率等相关的信息）会根据特定的渲染过程（rendering pass）而确定下来。其中也包含了与游戏计时有关的信息，它们是着色器程序中要访问的极有用的数据。*

*就目前的情况而言，为了绘制物体，与之唯一相关的常量就是它的世界矩阵：*

*我们做出上述调整的思路为：基于资源的更新频率对常量数据进行分组。在每次渲染过程中，只需将本次所用的常量（cbPass）更新一次；而每当某个物体的世界矩阵发生改变时，只需更新该物体的相关常量（cbPerObject）即可。如果场景中有一个静态物体，比如一棵树，则只需对它的物体常量缓冲区设置一次（树的）世界矩阵，而后就再也不必对它进行更新了。*

*现在，着色器所期望的输入资源已发生了改变，因此我们需要相应地调整根签名来使之获取所需的 两个描述符表（此时，我们的着色器程序需要获取两个描述符表，因为这两个 CBV（常量缓冲区视图） 有着不同的更新频率——渲染过程 CBV 仅需在每个渲染过程中设置一次，而物体 CBV 则要针对每一个 渲染项进行配置）*

## ***不同形状的几何体***

*我们将展示如何创建不同形状的几何体，如椭球体、球体、柱体（通过调整圆柱体的上下两底即可创建出圆台和圆锥体）。这些几何体对于绘制天空穹顶（sky dome，即描述游戏中玩家头顶的天空部分，也有译作天空穹、天穹等）、图形程序调试、碰撞检测的可视化以及延迟渲染（deferred rendering） 是有极大裨益的。比如说，我们可以先将正在制作中的游戏角色简化渲染成球体，以供调试检测。*

