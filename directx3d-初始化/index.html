<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Direct3D的初始化 - Ame</title><meta name="Description" content="Direct3D的初始化"><meta property="og:url" content="https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/">
  <meta property="og:site_name" content="Ame">
  <meta property="og:title" content="Direct3D的初始化">
  <meta property="og:description" content="Direct3D的初始化">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-10T22:00:00+08:00">
    <meta property="article:modified_time" content="2025-02-11T22:13:00+08:00">
    <meta property="article:tag" content="Unreal">
    <meta property="article:tag" content="3D图形学">
    <meta property="article:tag" content="Direct3D">
    <meta property="og:image" content="https://example.com/logo.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://example.com/logo.png">
  <meta name="twitter:title" content="Direct3D的初始化">
  <meta name="twitter:description" content="Direct3D的初始化">
<meta name="application-name" content="Ame林汀">
<meta name="apple-mobile-web-app-title" content="Ame林汀"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" /><link rel="prev" href="https://example.com/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/" /><link rel="next" href="https://example.com/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Direct3D的初始化",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/example.com\/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96\/"
        },"image": ["https:\/\/example.com\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "Unreal, 3D图形学, Direct3D","wordcount":  10229 ,
        "url": "https:\/\/example.com\/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96\/","datePublished": "2025-02-10T22:00:00+08:00","dateModified": "2025-02-11T22:13:00+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "xxxx","logo": "https:\/\/example.com\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Ame"
            },"description": "Direct3D的初始化"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('dark' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'dark' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Ame"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Ame林汀</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/categories/documentation/"> 文档 </a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a><a href="javascript:void(0);" class="menu-item language" title="选择语言">
                    <i class="fa fa-globe" aria-hidden="true"></i>                      
                    <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" selected>简体中文</option></select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Ame"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Ame林汀</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/categories/documentation/" title="">文档</a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="选择语言">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" selected>简体中文</option></select>
                </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Direct3D的初始化</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Ame</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/direct3d/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Direct3D</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2025-02-10">2025-02-10</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 10229 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 21 分钟&nbsp;<span id="/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" class="leancloud_visitors" data-flag-title="Direct3D的初始化">
                        <i class="far fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#预备知识"><em><strong>预备知识</strong></em></a>
      <ul>
        <li><a href="#组件对象模型"><em><strong>组件对象模型</strong></em></a></li>
        <li><a href="#纹理格式"><em><strong>纹理格式</strong></em></a></li>
        <li><a href="#交换链和页面翻转"><em><strong>交换链和页面翻转</strong></em></a></li>
        <li><a href="#深度缓冲"><em><strong>深度缓冲</strong></em></a></li>
        <li><a href="#资源与描述符"><em><strong>资源与描述符</strong></em></a></li>
        <li><a href="#多重采样技术的原理"><em><strong>多重采样技术的原理</strong></em></a></li>
        <li><a href="#利用-direct3d-进行多重采样"><em><strong>利用 Direct3D 进行多重采样</strong></em></a></li>
        <li><a href="#功能级别"><em><strong>功能级别</strong></em></a></li>
        <li><a href="#功能支持的检测"><em><strong>功能支持的检测</strong></em></a></li>
        <li><a href="#资源驻留"><em><strong>资源驻留</strong></em></a></li>
      </ul>
    </li>
    <li><a href="#cpu-与-gpu-间的交互"><em><strong>CPU 与 GPU 间的交互</strong></em></a>
      <ul>
        <li><a href="#命令队列和命令列表"><em><strong>命令队列和命令列表</strong></em></a></li>
        <li><a href="#cpu-与-gpu-间的同步"><em><strong>CPU 与 GPU 间的同步</strong></em></a></li>
        <li><a href="#资源转换"><em><strong>资源转换</strong></em></a></li>
        <li><a href="#命令与多线程"><em><strong>命令与多线程</strong></em></a></li>
      </ul>
    </li>
    <li><a href="#初始化direct3d"><em><strong>初始化Direct3D</strong></em></a>
      <ul>
        <li><a href="#创建设备d3d12createdevice"><em><strong>创建设备（D3D12CreateDevice）</strong></em></a></li>
        <li><a href="#创建围栏并获取描述符的大小createfence"><em><strong>创建围栏并获取描述符的大小（CreateFence）</strong></em></a></li>
        <li><a href="#检测对-4x-msaa-质量级别的支持d3d12_feature_data_multisample_quality_levels"><em><strong>检测对 4X MSAA 质量级别的支持（D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS）</strong></em></a></li>
        <li><a href="#创建命令队列和命令列表"><em><strong>创建命令队列和命令列表</strong></em></a></li>
        <li><a href="#描述并创建交换链dxgi_swap_chain_desc"><em><strong>描述并创建交换链（DXGI_SWAP_CHAIN_DESC）</strong></em></a></li>
        <li><a href="#创建描述符堆id3d12descriptorheap"><em><strong>创建描述符堆（ID3D12DescriptorHeap）</strong></em></a>
          <ul>
            <li><a href="#id3d12descriptorheapgetcpudescriptorhandleforheapstart"><em><strong>ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart</strong></em></a></li>
          </ul>
        </li>
        <li><a href="#创建渲染目标视图"><em><strong>创建渲染目标视图</strong></em></a>
          <ul>
            <li><a href="#id3d12devicecreaterendertargetview"><em><strong>ID3D12Device::CreateRenderTargetView</strong></em></a></li>
          </ul>
        </li>
        <li><a href="#创建深度--模板缓冲区及其视图"><em><strong>创建深度 / 模板缓冲区及其视图</strong></em></a>
          <ul>
            <li><a href="#d3d12_resource_desc"><em><strong>D3D12_RESOURCE_DESC</strong></em></a></li>
            <li><a href="#id3d12devicecreatecommittedresource"><em><strong>ID3D12Device::CreateCommittedResource</strong></em></a></li>
            <li><a href="#创建深度模板纹理及相应的深度模板视图"><em><strong>创建深度/模板纹理及相应的深度/模板视图</strong></em></a></li>
          </ul>
        </li>
        <li><a href="#设置视口"><em><strong>设置视口</strong></em></a>
          <ul>
            <li><a href="#d3d12_viewport"><em><strong>D3D12_VIEWPORT</strong></em></a></li>
            <li><a href="#id3d12graphicscommandlistrssetviewports"><em><strong>ID3D12GraphicsCommandList::RSSetViewports</strong></em></a></li>
          </ul>
        </li>
        <li><a href="#设置裁剪矩形"><em><strong>设置裁剪矩形</strong></em></a>
          <ul>
            <li><a href="#d3d12_rect"><em><strong>D3D12_RECT</strong></em></a></li>
            <li><a href="#id3d12graphicscommandlistrssetscissorrects"><em><strong>ID3D12GraphicsCommandList::RSSetScissorRects</strong></em></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#计时与动画"><em><strong>计时与动画</strong></em></a>
      <ul>
        <li><a href="#性能计时器"><em><strong>性能计时器</strong></em></a></li>
        <li><a href="#游戏计时器类"><em><strong>游戏计时器类</strong></em></a></li>
        <li><a href="#帧与帧之间的时间间隔"><em><strong>帧与帧之间的时间间隔</strong></em></a></li>
        <li><a href="#总时间"><em><strong>总时间</strong></em></a></li>
      </ul>
    </li>
    <li><a href="#应用程序框架示例"><em><strong>应用程序框架示例</strong></em></a>
      <ul>
        <li><a href="#d3dapp-类"><em><strong>D3DApp 类</strong></em></a></li>
        <li><a href="#非框架方法"><em><strong>非框架方法</strong></em></a></li>
        <li><a href="#框架方法"><em><strong>框架方法</strong></em></a></li>
        <li><a href="#帧的统计信息"><em><strong>帧的统计信息</strong></em></a></li>
        <li><a href="#消息处理函数"><em><strong>消息处理函数</strong></em></a></li>
        <li><a href="#初始化-direct3d-演示程序"><em><strong>初始化 Direct3D 演示程序</strong></em></a></li>
      </ul>
    </li>
    <li><a href="#调试-direct3d-应用程序"><em><strong>调试 Direct3D 应用程序</strong></em></a></li>
    <li><a href="#小结"><em><strong>小结</strong></em></a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="direct3d的初始化"><em><strong>Direct3D的初始化</strong></em></h1>
<h2 id="预备知识"><em><strong>预备知识</strong></em></h2>
<p><em>通过 Direct3D 这种底层图形应用程序编程接口（Application Programming Interface，API），即可在 在应用程序中对图形处理器（Graphics Processing Unit，GPU）进行控制和编程。我们能够借此以硬件加 速的方式渲染出虚拟的 3D 场景</em></p>
<h3 id="组件对象模型"><em><strong>组件对象模型</strong></em></h3>
<p><em>组件对象模型（Component Object Model，COM）是一种令 DirectX 不受编程语言束缚，并且使之向后兼 容的技术。</em></p>
<p><em>我们通常将 COM 对象视为一种接口，但考虑当前编程的目的，遂将它当作一个 C++类来使用。</em></p>
<p><em>用 C++语言编写 DirectX 程序时，COM 帮我们隐藏了大量底层细节。</em></p>
<p><em>我们只需知道：要获取指向某 COM 接 口的指针，需借助特定函数或另一COM 接口的方法——而不是用C++语言中的关键字new 去创建一个COM 接口。</em></p>
<p><em>另外，COM 对象会统计其引用次数；因此，在使用完某接口时，我们便应调用它的 Release 方法（COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的，包括 Release 方法在内），而不是用 delete 来删除——当 COM 对象的引用计数为 0 时，它将自行释放自己所占用的内存。</em></p>
<h3 id="纹理格式"><em><strong>纹理格式</strong></em></h3>
<p><em>2D 纹理（2D texture）是一种由数据元素构成的矩阵（可将此“矩阵”看作 2D 数组）。</em></p>
<p><em>它的用途之 一是存储 2D 图像数据，在这种情况下，纹理中每个元素存储的都是一个像素的颜色。然而，纹理的 用处并非仅此而已。</em></p>
<p><em>例如，有种称作法线贴图（normal mapping）的高级技术，其纹理内的每个元素存 储的就是一个 3D 向量而不是颜色信息。</em></p>
<p><em>因此，尽管纹理给人的第一印象通常是用来存储图像数据，但 其实际用途却十分广泛。</em></p>
<p><em>简单来讲，1D、2D、3D 纹理就相当于特定数据元素所构成 1D、2D、3D 数 组。但随着后续章节中对纹理讨论的逐渐深入，我们便会知道，纹理其实还不只是像“数据数组”那 样简单。它们可能还具有多种 mipmap 层级，而 GPU 则会据此对它们进行特殊的处理，例如运用过 滤器（filter）和进行多重采样（multisample）。另外，并不是任意类型的数据元素都能用于组成纹理， 它只能存储 DXGI_FORMAT 枚举类型中描述的特定格式的数据元素</em></p>
<h3 id="交换链和页面翻转"><em><strong>交换链和页面翻转</strong></em></h3>
<p><em>为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为后台缓冲区的离屏 （off-screen，即不可直接呈现在显示设备上之意）纹理内。</em></p>
<p><em>只要将指定动画帧的整个场景绘到后台缓冲区 中，它就会以一个完整的帧画面展现在屏幕上；</em></p>
<p><em>依照此法，观者便不会察觉出帧的绘制过程——而只会 观赏到完整的动画帧。</em></p>
<p><em>为此，需要利用由硬件管理的两种纹理缓冲区：即所谓的前台缓冲区（front buffer） 和后台缓冲区（back buffer）。</em></p>
<p><em>前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被 绘制在后台缓冲区里。</em></p>
<p><em>当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换：后台缓冲区变 为前台缓冲区呈现新一帧的画面，而前台缓冲区则为了展示动画的下一帧转为后台缓冲区，等待填充数 据。前后台缓冲的这种互换操作称为呈现（presenting，亦有译作提交、显示等）。</em></p>
<p><em>呈现是一种高效的操 作，只需交换指向当前前台缓冲区和后台缓冲区的两个指针即可实现。</em></p>
<h3 id="深度缓冲"><em><strong>深度缓冲</strong></em></h3>
<p><em>深度缓冲区（depth buffer）这种纹理资源存储的并非图像数据，而是特定像素的深度信息。</em></p>
<p><em>深度值 的范围为 0.0～1.0。0.0 代表观察者在视锥体（view frustum， 亦有译作视域体、视景体、视截体或视体等，意即观察者 能看到的空间范围，形如从四棱锥中截取的四棱台，常称 该形为平截头体（frustum，见图 4.3，后文亦有详述））中 能看到离自己最近的物体，1.0 则代表观察者在视锥体中能 看到离自己最远的物体。</em></p>
<p><em>深度缓冲区中的元素与后台缓冲 区内的像素呈一 一对应关系（即后台缓冲区中第 i 行第 j 列 的元素对应于深度缓冲区内第 i 行第 j 列的元素）。所以， 如果后台缓冲区的分辨率为1280 × 1024  ，那么深度缓冲区 中就应当有1280 × 1024 个深度元素</em></p>
<h3 id="资源与描述符"><em><strong>资源与描述符</strong></em></h3>
<p><em>在渲染处理的过程中，GPU 可能会对资源进行读（例如，从描述物体表面样貌的纹理或者存有 3D 场景中几何体位置信息的缓冲区中读取数据）和写（例如，向后台缓冲区或深度/模板缓冲区写入数据） 两种操作。</em></p>
<p><em>在发出绘制命令之前，我们需要将与本次绘制调用（draw call）相关的资源绑定（bind 或称 链接，link）到渲染流水线上。</em></p>
<p><em>部分资源可能在每次绘制调用时都会有所变化，所以我们也就要每次按 需更新绑定。</em></p>
<p><em>但是，GPU 资源并非直接与渲染流水线相绑定，而是要通过一种名为描述符（descriptor） 的对象来对它间接引用，我们可以把描述符视为一种对送往 GPU 的资源进行描述的轻量级结构。</em></p>
<p><em>从本质上来讲，它实际上即为一个中间层；若指定了资源描述符，GPU 将既能获得实际的资源数据，也能了解到 资源的必要信息。</em></p>
<p><em>因此，我们将把绘制调用需要引用的资源，通过指定描述符的方式绑定到渲染流水线。</em></p>
<h3 id="多重采样技术的原理"><em><strong>多重采样技术的原理</strong></em></h3>
<p><em>由于屏幕中显示的像素不可能是无穷小的，所以并不是任意一条直线都能在显示器上“平滑”而 完美地呈现出来。</em></p>
<p>*图 4.4 所示的，即为以像素矩阵（matrix of pixels，可以理解为“像素 2D 数组”）逼近 直线的方法所产生的“阶梯”（aliasing，锯齿状走样）效果。类似地，显示器中呈现的三角形之边也存 在着不同程度的锯齿效应。 *</p>
<p>*通过提高显示器的分辨率就能够缩小像素的大小， 继而使上述问题得到显著地改善，使阶梯效应在很大 程度上不易被用户所察觉。 *</p>
<p><em>在不能提升显示器分辨率，或在显示器分辨率受 限的情况下，我们就可以运用各种反走样（antialiasing， 也有译作抗锯齿、反锯齿、反失真等）技术。</em></p>
<p><em>有一种 名为超级采样（supersampling，可简记作 SSAA，即 Super Sample Anti-Aliasing）的反走样技术，它使用 4 倍于屏幕分辨率大小的后台缓冲区和深度缓冲区。3D 场景将以这种更大的分辨率渲染到后台缓冲区中。当 数据要从后台缓冲区调往屏幕显示的时候，会将后台 缓冲区按 4 个像素一组进行解析（resolve，或称降采 样，downsample。把放大的采样点数降低回原采样点数）：每组用求平均值的方法得到一种相对平滑 的像素颜色。因此，超级采样实际上是通过软件的方式提升了画面的分辨率。</em></p>
<p><em>超级采样是一种开销高昂的操作，因为它将像素的处理数量和占用的内存大小都增加到之前的 4 倍。 对此，Direct3D 还支持一种在性能与效果等方面都较为折中的反走样技术，叫作多重采样（multisampling，可简记作 MSAA，即 MultiSample Anti-Aliasing）。</em></p>
<p><em>这种技术通过跨子像素①共享一些计算信息，从而使它比 超级采样的开销更低。现假设采用 4X 多重采样（即每个像素中都有 4 个子像素），并同样使用 4 倍于屏幕 分辨率的后台缓冲区和深度缓冲区。</em></p>
<p><em>值得注意的是，这种技术并不需要对每一个子像素都进行计算，而是仅 计算一次像素中心处的颜色，再基于可视性（每个子像素经深度/模板测试的结果）和覆盖性（子像素的中心 在多边形的里面还是外面？）将得到的颜色信息分享给其子像素</em></p>
<h3 id="利用-direct3d-进行多重采样"><em><strong>利用 Direct3D 进行多重采样</strong></em></h3>
<h3 id="功能级别"><em><strong>功能级别</strong></em></h3>
<h3 id="功能支持的检测"><em><strong>功能支持的检测</strong></em></h3>
<h3 id="资源驻留"><em><strong>资源驻留</strong></em></h3>
<h2 id="cpu-与-gpu-间的交互"><em><strong>CPU 与 GPU 间的交互</strong></em></h2>
<h3 id="命令队列和命令列表"><em><strong>命令队列和命令列表</strong></em></h3>
<h3 id="cpu-与-gpu-间的同步"><em><strong>CPU 与 GPU 间的同步</strong></em></h3>
<h3 id="资源转换"><em><strong>资源转换</strong></em></h3>
<h3 id="命令与多线程"><em><strong>命令与多线程</strong></em></h3>
<h2 id="初始化direct3d"><em><strong>初始化Direct3D</strong></em></h2>
<p><em>我们对 Direct3D 进行初始化的过程可以分为以下几个步骤</em></p>
<ol>
<li><em>用 D3D12CreateDevice 函数创建 ID3D12Device 接口实例。</em></li>
<li><em>创建一个 ID3D12Fence 对象，并查询描述符的大小。</em></li>
<li><em>检测用户设备对 4X MSAA 质量级别的支持情况。</em></li>
<li><em>依次创建命令队列、命令列表分配器和主命令列表。</em></li>
<li><em>描述并创建交换链</em></li>
<li><em>创建应用程序所需的描述符堆</em></li>
<li><em>调整后台缓冲区的大小，并为他创建渲染目标视图</em></li>
<li><em>创建深度 / 模板缓冲区及与之关联的深度 / 模板视图</em></li>
<li><em>设置视口（viewport）和裁剪矩形（scissor rectangle）</em></li>
</ol>
<h3 id="创建设备d3d12createdevice"><em><strong>创建设备（D3D12CreateDevice）</strong></em></h3>
<p><em>要初始化 Direct3D，必须先创建 Direct3D 12 设备（ID3D12Device）通过下面的函数就可以创建 Direct3D 12 设备：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">HRESULT</span> <span class="n">WINAPI</span> <span class="n">D3D12CreateDevice</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">_In_opt_</span> <span class="n">IUnknown</span><span class="o">*</span> <span class="n">pAdapter</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D_FEATURE_LEVEL</span> <span class="n">MinimumFeatureLevel</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">_In_</span> <span class="n">REFIID</span> <span class="n">riid</span><span class="p">,</span> <span class="c1">// Expected: ID3D12Device
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_COM_Outptr_opt_</span> <span class="kt">void</span><span class="o">**</span> <span class="n">ppDevice</span> <span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><em>pAdapter：指定在创建设备时所用的显示适配器。若将此参数设定为空指针，则使用主显示适配器。我们在本书的示例中总是采用主适配器</em></li>
<li><em>MinimumFeatureLevel: 应用程序需要硬件所支持的最低功能级别。如果适配器不支持此功能级别，则设备创建失败。支持 Direct3D 11 的特性的话 指定的是 D3D_FEATURE_LEVEL_11_0</em></li>
<li><em>riid：所建 ID3D12Device 接口的 COM ID</em></li>
<li><em>ppDevice：返回所创建的 Direct3D 12 设备</em></li>
</ol>
<p><em>以下是此函数的调用示例</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#if defined(DEBUG) || defined(_DEBUG) 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>	<span class="c1">// 启用 D3D12 的调试层
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12Debug</span><span class="o">&gt;</span> <span class="n">debugController</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">D3D12GetDebugInterface</span><span class="p">(</span><span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">debugController</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">	<span class="n">debugController</span><span class="o">-&gt;</span><span class="n">EnableDebugLayer</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">CreateDXGIFactory1</span><span class="p">(</span><span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mdxgiFactory</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 尝试创建硬件设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">HRESULT</span> <span class="n">hardwareResult</span> <span class="o">=</span> <span class="n">D3D12CreateDevice</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">nullptr</span><span class="p">,</span>             <span class="c1">// default adapter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">D3D_FEATURE_LEVEL_11_0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md3dDevice</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 回退至 WARP 设备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hardwareResult</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">IDXGIAdapter</span><span class="o">&gt;</span> <span class="n">pWarpAdapter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">mdxgiFactory</span><span class="o">-&gt;</span><span class="n">EnumWarpAdapter</span><span class="p">(</span><span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pWarpAdapter</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">D3D12CreateDevice</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">pWarpAdapter</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="n">D3D_FEATURE_LEVEL_11_0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">md3dDevice</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p><em>可以看到，为了进入调试模式，我们首先开启了调试层（debug layer）。</em></p>
</li>
<li>
<p><em>随后，Direct3D 便会开启额 外的调试功能，并在错误发生时向 VC++的输出窗口发送类似于下面的调试信息</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">D3D12</span> <span class="nl">ERROR</span><span class="p">:</span> <span class="n">ID3D12CommandList</span><span class="o">::</span><span class="nl">Reset</span><span class="p">:</span> <span class="n">Reset</span> <span class="n">fails</span> <span class="n">because</span> <span class="n">the</span> <span class="n">command</span> <span class="n">list</span> <span class="n">was</span> <span class="n">not</span> <span class="n">closed</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="err">（</span><span class="n">D3D12</span> <span class="nl">ERROR</span><span class="p">:</span> <span class="n">ID3D12CommandList</span><span class="o">::</span><span class="nl">Reset</span><span class="p">:</span> <span class="err">由于没有关闭命令列表因此重置失败。）</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><em>还可以发现，当调用 D3D12CreateDevice 失败后，程序将回退到一种软件适配器：WARP 设备</em></p>
<p><em>WARP意为 Windows Advanced Rasterization Platform（Windows 高级光栅化平台）。
在 Windows 7 及以下版本的操作系统中，WARP 设备支持的最高功能级别是 10.1；在 Windows 8 系统中，WARP 设备支持的最高功能级别是11.1。
为了创建 WARP 适配器，需要先创建一个 IDXGIFactory4 对象，并通过它来枚举 WARP 适配器：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">mdxgiFactory</span><span class="o">-&gt;</span><span class="n">CreateSwapChain</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">mCommandQueue</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="n">mSwapChain</span><span class="p">.</span><span class="n">GetAddressOf</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>作为 DXGI 的一部分，mdxgiFactory 对象也可用于创建交换链。</em></p>
</li>
</ol>
<h3 id="创建围栏并获取描述符的大小createfence"><em><strong>创建围栏并获取描述符的大小（CreateFence）</strong></em></h3>
<p><em>一旦创建好设备，便可以为 CPU/GPU 的同步而创建围栏了。</em></p>
<p><em>另外，若用描述符进行工作，还需要了解它们的大小，但描述符在不同的CPU平台上大小各异</em></p>
<p><em>随后我们会把描述符的大小缓存起来，需要时即可直接引用</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateFence</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">D3D12_FENCE_FLAG_NONE</span><span class="p">,</span> <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mFence</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mRtvDescriptorSize</span> <span class="o">=</span> <span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">GetDescriptorHandleIncrementSize</span><span class="p">(</span><span class="n">D3D12_DESCRIPTOR_HEAP_TYPE_RTV</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">mDsvDescriptorSize</span> <span class="o">=</span> <span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">GetDescriptorHandleIncrementSize</span><span class="p">(</span><span class="n">D3D12_DESCRIPTOR_HEAP_TYPE_DSV</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">mCbvSrvUavDescriptorSize</span> <span class="o">=</span> <span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">GetDescriptorHandleIncrementSize</span><span class="p">(</span><span class="n">D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="检测对-4x-msaa-质量级别的支持d3d12_feature_data_multisample_quality_levels"><em><strong>检测对 4X MSAA 质量级别的支持（D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS）</strong></em></h3>
<p><em>这里选择 4X，是因为借此采样数量就可以获 得开销不高却性能不凡的效果。而且，在一切支持 Direct3D 11 的设备上，所有的渲染目标格式就皆已支 持 4X MSAA 了。因此，凡是支持 Direct3D 11 的硬件，都会保证此项功能的正常开启，我们也就无须再 对此进行检验了。但是，对质量级别的检测还是不可或缺，为此，可采取下列方法加以实现：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS</span> <span class="n">msQualityLevels</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">msQualityLevels</span><span class="p">.</span><span class="n">Format</span> <span class="o">=</span> <span class="n">mBackBufferFormat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">msQualityLevels</span><span class="p">.</span><span class="n">SampleCount</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">msQualityLevels</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">msQualityLevels</span><span class="p">.</span><span class="n">NumQualityLevels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CheckFeatureSupport</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="o">&amp;</span><span class="n">msQualityLevels</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">sizeof</span><span class="p">(</span><span class="n">msQualityLevels</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">m4xMsaaQuality</span> <span class="o">=</span> <span class="n">msQualityLevels</span><span class="p">.</span><span class="n">NumQualityLevels</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">assert</span><span class="p">(</span><span class="n">m4xMsaaQuality</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;Unexpected MSAA quality level.&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>由于我们所用的平台必能支持 4X MSAA 这一功能，其返回值应该也总是大于 0，所以对此而做出上述断言</em></p>
<h3 id="创建命令队列和命令列表"><em><strong>创建命令队列和命令列表</strong></em></h3>
<p><em><strong>ID3D12CommandQueue 接口表示命令队列</strong></em></p>
<p><em><strong>ID3D12CommandAllocator 接 口代表命令分配器</strong></em></p>
<p><em><strong>ID3D12GraphicsCommandList 接口表示命令列表</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">D3D12_COMMAND_QUEUE_DESC</span> <span class="n">queueDesc</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="n">queueDesc</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">D3D12_COMMAND_LIST_TYPE_DIRECT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">queueDesc</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">D3D12_COMMAND_QUEUE_FLAG_NONE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateCommandQueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queueDesc</span><span class="p">,</span> <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mCommandQueue</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateCommandAllocator</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_COMMAND_LIST_TYPE_DIRECT</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="n">mDirectCmdListAlloc</span><span class="p">.</span><span class="n">GetAddressOf</span><span class="p">())));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateCommandList</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_COMMAND_LIST_TYPE_DIRECT</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">mDirectCmdListAlloc</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span>  <span class="c1">// 关联命令分配器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">nullptr</span><span class="p">,</span>                   <span class="c1">// 初始化流水线状态对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="n">mCommandList</span><span class="p">.</span><span class="n">GetAddressOf</span><span class="p">())));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 首先要将命令列表置于关闭状态。这是因为在第一次引用命令列表时，我们要对它进行重置，而在调用
</span></span></span><span class="line"><span class="cl"><span class="c1">// 重置方法之前又需先将其关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mCommandList</span><span class="o">-&gt;</span><span class="n">Close</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="描述并创建交换链dxgi_swap_chain_desc"><em><strong>描述并创建交换链（DXGI_SWAP_CHAIN_DESC）</strong></em></h3>
<p><em>初始化流程的下一步是创建交换链</em></p>
<p><em>首先，要填写一份 DXGI_SWAP_CHAIN_DESC 结构体实例，用 它来描述欲创建交换链的特性。此结构体的定义如下：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DXGI_SWAP_CHAIN_DESC</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_MODE_DESC</span> <span class="n">BufferDesc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_SAMPLE_DESC</span> <span class="n">SampleDesc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_USAGE</span> <span class="n">BufferUsage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT</span> <span class="n">BufferCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">HWND</span> <span class="n">OutputWindow</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">BOOL</span> <span class="n">Windowed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_SWAP_EFFECT</span> <span class="n">SwapEffect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT</span> <span class="n">Flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 	<span class="n">DXGI_SWAP_CHAIN_DESC</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p><em>BufferDesc：这个结构体描述了待创建后台缓冲区的属性。在这里我们仅关注它的宽度、高 度和像素格式属性</em></p>
<p><em>其中的 DXGI_MODE_DESC 类型则是另一种结构体，它的定义为：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">DXGI_MODE_DESC</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT</span> <span class="n">Width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT</span> <span class="n">Height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_RATIONAL</span> <span class="n">RefreshRate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_FORMAT</span> <span class="n">Format</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_MODE_SCANLINE_ORDER</span> <span class="n">ScanlineOrdering</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_MODE_SCALING</span> <span class="n">Scaling</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">DXGI_MODE_DESC</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><em>SampleDesc：多重采样的质量级别以及对每个像素的采样次数。对于单次采 样来说，我们要将采样数量指定为 1，质量级别指定为 0</em></p>
</li>
<li>
<p><em>BufferUsage：由于我们要将数据渲染至后台缓冲区（即用它作为渲染目标），因此将此参数 指定为 DXGI_USAGE_RENDER_TARGET_OUTPUT</em></p>
</li>
<li>
<p><em>BufferCount：交换链中所用的缓冲区数量。我们将它指定为 2，即采用双缓冲</em></p>
</li>
<li>
<p><em>OutputWindow：渲染窗口的句柄。</em></p>
</li>
<li>
<p><em>Windowed：若指定为 true，程序将在窗口模式下运行；如果指定为 false，则采用全屏模式。</em></p>
</li>
<li>
<p><em>SwapEffect：指定为 DXGI_SWAP_EFFECT_FLIP_DISCARD。</em></p>
</li>
<li>
<p><em>Flags：可选标志。如果将其指定为 DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH，那 么，当程序切换为全屏模式时，它将选择最适于当前应用程序窗口尺寸的显示模式。如果没有 指定该标志，当程序切换为全屏模式时，将采用当前桌面的显示模式</em></p>
</li>
</ol>
<p><em>描述完交换链之后，我们用 IDXGIFactory::CreateSwapChain 方法来创建它：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">HRESULT</span> <span class="n">STDMETHODCALLTYPE</span> <span class="n">CreateSwapChain</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* [annotation][in] */</span> 
</span></span><span class="line"><span class="cl">    <span class="n">IUnknown</span> <span class="o">*</span><span class="n">pDevice</span><span class="p">,</span>  <span class="c1">// 指向 ID3D12CommandQueue 接口的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/* [annotation][in] */</span> 
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_SWAP_CHAIN_DESC</span> <span class="o">*</span><span class="n">pDesc</span><span class="p">,</span>  <span class="c1">// 指向描述交换链的结构体的指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/* [annotation][out] */</span> 
</span></span><span class="line"><span class="cl">    <span class="n">IDXGISwapChain</span> <span class="o">**</span><span class="n">ppSwapChain</span>  <span class="c1">// 返回所创建的交换链接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>研究此函数的代码就会发现，我 们是按照可以对它进行多次调用来设计的。</em></p>
<p><em>即，在创建新的交换链之前，先要销毁旧的交换链。这样一来，我们就可以用不同的设置来重新创建交换链，借此在运行时修改多重采样的配置。</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">DXGI_FORMAT</span> <span class="n">mBackBufferFormat</span> <span class="o">=</span> <span class="n">DXGI_FORMAT_R8G8B8A8_UNORM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">D3DApp</span><span class="o">::</span><span class="n">CreateSwapChain</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Release the previous swapchain we will be recreating.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mSwapChain</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_SWAP_CHAIN_DESC</span> <span class="n">sd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferDesc</span><span class="p">.</span><span class="n">Width</span> <span class="o">=</span> <span class="n">mClientWidth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferDesc</span><span class="p">.</span><span class="n">Height</span> <span class="o">=</span> <span class="n">mClientHeight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferDesc</span><span class="p">.</span><span class="n">RefreshRate</span><span class="p">.</span><span class="n">Numerator</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferDesc</span><span class="p">.</span><span class="n">RefreshRate</span><span class="p">.</span><span class="n">Denominator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferDesc</span><span class="p">.</span><span class="n">Format</span> <span class="o">=</span> <span class="n">mBackBufferFormat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferDesc</span><span class="p">.</span><span class="n">ScanlineOrdering</span> <span class="o">=</span> <span class="n">DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferDesc</span><span class="p">.</span><span class="n">Scaling</span> <span class="o">=</span> <span class="n">DXGI_MODE_SCALING_UNSPECIFIED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">SampleDesc</span><span class="p">.</span><span class="n">Count</span> <span class="o">=</span> <span class="n">m4xMsaaState</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">SampleDesc</span><span class="p">.</span><span class="n">Quality</span> <span class="o">=</span> <span class="n">m4xMsaaState</span> <span class="o">?</span> <span class="p">(</span><span class="n">m4xMsaaQuality</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferUsage</span> <span class="o">=</span> <span class="n">DXGI_USAGE_RENDER_TARGET_OUTPUT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">BufferCount</span> <span class="o">=</span> <span class="n">SwapChainBufferCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">OutputWindow</span> <span class="o">=</span> <span class="n">mhMainWnd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">Windowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">sd</span><span class="p">.</span><span class="n">SwapEffect</span> <span class="o">=</span> <span class="n">DXGI_SWAP_EFFECT_FLIP_DISCARD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sd</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Note: Swap chain uses queue to perform flush.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">mdxgiFactory</span><span class="o">-&gt;</span><span class="n">CreateSwapChain</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="n">mCommandQueue</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="o">&amp;</span><span class="n">sd</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">		<span class="n">mSwapChain</span><span class="p">.</span><span class="n">GetAddressOf</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="创建描述符堆id3d12descriptorheap"><em><strong>创建描述符堆（ID3D12DescriptorHeap）</strong></em></h3>
<p><em>我们需要通过创建描述符堆来存储程序中要用到的描述符/视图</em></p>
<p><em>Direct3D 12 以 ID3D12DescriptorHeap 接口表示描述符堆，并用 ID3D12Device::CreateDescriptorHeap 方法来 创建它</em></p>
<p><em>我们将为交换链中 SwapChainBufferCount 个用于渲染数据的缓冲区 资源创建对应的渲染目标视图（Render Target View，RTV），并为用于深度测试（depth test）的深度/模 板缓冲区资源创建一个深度/模板视图（Depth/Stencil View，DSV）。</em></p>
<p><em>所以，我们此时需要创建两个描述符 堆，其一用来存储 SwapChainBufferCount 个 RTV，而那另一个描述堆则用来存储那 1 个 DSV</em></p>
<p><em>现通过下述代码来创建这两个描述符堆：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Microsoft</span><span class="o">::</span><span class="n">WRL</span><span class="o">::</span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12DescriptorHeap</span><span class="o">&gt;</span> <span class="n">mRtvHeap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Microsoft</span><span class="o">::</span><span class="n">WRL</span><span class="o">::</span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12DescriptorHeap</span><span class="o">&gt;</span> <span class="n">mDsvHeap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">D3DApp</span><span class="o">::</span><span class="n">CreateRtvAndDsvDescriptorHeaps</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_DESCRIPTOR_HEAP_DESC</span> <span class="n">rtvHeapDesc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtvHeapDesc</span><span class="p">.</span><span class="n">NumDescriptors</span> <span class="o">=</span> <span class="n">SwapChainBufferCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtvHeapDesc</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">D3D12_DESCRIPTOR_HEAP_TYPE_RTV</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtvHeapDesc</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">D3D12_DESCRIPTOR_HEAP_FLAG_NONE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">rtvHeapDesc</span><span class="p">.</span><span class="n">NodeMask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateDescriptorHeap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtvHeapDesc</span><span class="p">,</span> <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="n">mRtvHeap</span><span class="p">.</span><span class="n">GetAddressOf</span><span class="p">())));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_DESCRIPTOR_HEAP_DESC</span> <span class="n">dsvHeapDesc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dsvHeapDesc</span><span class="p">.</span><span class="n">NumDescriptors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dsvHeapDesc</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">D3D12_DESCRIPTOR_HEAP_TYPE_DSV</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dsvHeapDesc</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">D3D12_DESCRIPTOR_HEAP_FLAG_NONE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">dsvHeapDesc</span><span class="p">.</span><span class="n">NodeMask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateDescriptorHeap</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="o">&amp;</span><span class="n">dsvHeapDesc</span><span class="p">,</span> <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="n">mDsvHeap</span><span class="p">.</span><span class="n">GetAddressOf</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>创建描述符堆之后，还要能访问其中所存的描述符。</em></p>
<h4 id="id3d12descriptorheapgetcpudescriptorhandleforheapstart"><em><strong>ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart</strong></em></h4>
<p><em>在程序中，我们是通过句柄来引用描述符的， 并以 ID3D12DescriptorHeap::GetCPUDescriptorHandleForHeapStart 方法来获得描述符堆中第一个描述符的句柄</em></p>
<p><em>借助下列函数即可获取当前后台缓冲区的 RTV 与 DSV：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">D3D12_CPU_DESCRIPTOR_HANDLE</span> <span class="n">D3DApp</span><span class="o">::</span><span class="n">CurrentBackBufferView</span><span class="p">()</span><span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">CD3DX12_CPU_DESCRIPTOR_HANDLE</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="n">mRtvHeap</span><span class="o">-&gt;</span><span class="n">GetCPUDescriptorHandleForHeapStart</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="n">mCurrBackBuffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="n">mRtvDescriptorSize</span>
</span></span><span class="line"><span class="cl">	<span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">D3D12_CPU_DESCRIPTOR_HANDLE</span> <span class="n">D3DApp</span><span class="o">::</span><span class="n">DepthStencilView</span><span class="p">()</span><span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">mDsvHeap</span><span class="o">-&gt;</span><span class="n">GetCPUDescriptorHandleForHeapStart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>通过这段示例代码，我们就能够看出描述符大小的用途了。为了用偏移量找到当前后台缓冲区的 RTV 描述符①，我们就必须知道 RTV 描述符的大小</em></p>
<h3 id="创建渲染目标视图"><em><strong>创建渲染目标视图</strong></em></h3>
<p><em>资源不能与渲染流水线中的阶段直接绑定，所以我们必须先为资源创建视图（描述符）并将其绑定到流水线阶段</em></p>
<p><em>为了将后台缓冲区绑定到流水线的输出合并阶段（output merger stage，这样 Direct3D 才能向其渲染），便需要为该后台缓冲区创建一个渲染目标视图。而这第一个步骤就是要获得存 于交换链中的缓冲区资源</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">HRESULT</span> <span class="n">STDMETHODCALLTYPE</span> <span class="n">GetBuffer</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">    <span class="cm">/* [in] */</span> 
</span></span><span class="line"><span class="cl">    <span class="n">UINT</span> <span class="n">Buffer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* [annotation][in] */</span>   
</span></span><span class="line"><span class="cl">    <span class="n">_In_</span>  <span class="n">REFIID</span> <span class="n">riid</span><span class="p">,</span>    
</span></span><span class="line"><span class="cl">    <span class="cm">/* [annotation][out][in] */</span> 
</span></span><span class="line"><span class="cl">    <span class="n">_COM_Outptr_</span>  <span class="kt">void</span> <span class="o">**</span><span class="n">ppSurface</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><em>Buffer：希望获得的特定后台缓冲区的索引（有时后台缓冲区并不只一个，所以需要用索引来 指明）</em></li>
<li><em>riid：希望获得的 ID3D12Resource 接口①的 COM ID。</em></li>
<li><em>ppSurface：返回一个指向 ID3D12Resource 接口的指针，这便是希望获得的后台缓冲区。</em></li>
</ol>
<p><em>调用 IDXGISwapChain::GetBuffer 方法会增加相关后台缓冲区的 COM 引用计数，所以在每次使用后一定要将其释放。通过 ComPtr 便可以自动做到这一点。</em></p>
<h4 id="id3d12devicecreaterendertargetview"><em><strong>ID3D12Device::CreateRenderTargetView</strong></em></h4>
<p><em>接下来，使用 ID3D12Device::CreateRenderTargetView 方法来为获取的后台缓冲区创建渲染目标视图。</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">STDMETHODCALLTYPE</span> <span class="n">CreateRenderTargetView</span><span class="p">(</span> 
</span></span><span class="line"><span class="cl">    <span class="n">ID3D12Resource</span> <span class="o">*</span><span class="n">pResource</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">D3D12_RENDER_TARGET_VIEW_DESC</span> <span class="o">*</span><span class="n">pDesc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_CPU_DESCRIPTOR_HANDLE</span> <span class="n">DestDescriptor</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><em>pResource：指定用作渲染目标的资源。在上面的例子中是后台缓冲区（即为后台缓冲区创建 了一个渲染目标视图</em></li>
<li><em>pDesc：指向 D3D12_RENDER_TARGET_VIEW_DESC 数据结构实例的指针。该结构体描述了资源中元素的数据类型（格式）。如果该资源在创建时已指定了具体格式（即此资源不是无类型 格式，not typeless），那么就可以把这个参数设为空指针，表示采用该资源创建时的格式，为它的第一个 mipmap 层级（后台缓冲区只有一种 mipmap 层级）创建一个视图。由于已经指定了后台缓冲区的格式，因此就将这个参数设置为空指针。</em></li>
<li><em>DestDescriptor：引用所创建渲染目标视图的描述符句柄</em></li>
</ol>
<p><em>下面的示例通过调用这两种方法为交换链中的每一个缓冲区都创建了一个 RTV：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Microsoft</span><span class="o">::</span><span class="n">WRL</span><span class="o">::</span><span class="n">ComPtr</span><span class="o">&lt;</span><span class="n">ID3D12Resource</span><span class="o">&gt;</span> <span class="n">mSwapChainBuffer</span><span class="p">[</span><span class="n">SwapChainBufferCount</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">CD3DX12_CPU_DESCRIPTOR_HANDLE</span> <span class="nf">rtvHeapHandle</span><span class="p">(</span><span class="n">mRtvHeap</span><span class="o">-&gt;</span><span class="n">GetCPUDescriptorHandleForHeapStart</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">UINT</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SwapChainBufferCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">mSwapChain</span><span class="o">-&gt;</span><span class="n">GetBuffer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mSwapChainBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">])));</span>
</span></span><span class="line"><span class="cl">    <span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateRenderTargetView</span><span class="p">(</span><span class="n">mSwapChainBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Get</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">rtvHeapHandle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtvHeapHandle</span><span class="p">.</span><span class="n">Offset</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mRtvDescriptorSize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="创建深度--模板缓冲区及其视图"><em><strong>创建深度 / 模板缓冲区及其视图</strong></em></h3>
<p><em>深度缓冲区其实就是一种 2D 纹理， 它存储着离观察者最近的可视对象的深度信息（如果使用了模板，还会附有模板信息）</em></p>
<h4 id="d3d12_resource_desc"><em><strong>D3D12_RESOURCE_DESC</strong></em></h4>
<p><em>纹理是一种 GPU 资源，因此我们要通过填写 D3D12_RESOURCE_DESC 结构体来描述纹理资源，再用 ID3D12Device:: CreateCommittedResource 方法来创建它</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">D3D12_RESOURCE_DESC</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_RESOURCE_DIMENSION</span> <span class="n">Dimension</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT64</span> <span class="n">Alignment</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT64</span> <span class="n">Width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT</span> <span class="n">Height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT16</span> <span class="n">DepthOrArraySize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT16</span> <span class="n">MipLevels</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_FORMAT</span> <span class="n">Format</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_SAMPLE_DESC</span> <span class="n">SampleDesc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_TEXTURE_LAYOUT</span> <span class="n">Layout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_RESOURCE_FLAGS</span> <span class="n">Flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 	<span class="n">D3D12_RESOURCE_DESC</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p><em>Dimension：资源的维度，即为下列枚举类型中的成员之一。</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">D3D12_RESOURCE_DIMENSION</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_RESOURCE_DIMENSION_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_RESOURCE_DIMENSION_BUFFER</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_RESOURCE_DIMENSION_TEXTURE1D</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_RESOURCE_DIMENSION_TEXTURE2D</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_RESOURCE_DIMENSION_TEXTURE3D</span> <span class="o">=</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">D3D12_RESOURCE_DIMENSION</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><em>Width：以纹素为单位来表示的纹理宽度。对于缓冲区资源来说，此项是缓冲区占用的字节数</em></p>
</li>
<li>
<p><em>Height：以纹素为单位来表示的纹理高度。</em></p>
</li>
<li>
<p><em>DepthOrArraySize：以纹素为单位来表示的纹理深度，或者（对于 1D 纹理和 2D 纹理来说） 是纹理数组的大小。注意，Direct3D 中并不存在 3D 纹理数组的概念</em></p>
</li>
<li>
<p><em>MipLevels：mipmap 层级的数量。。对于深度 / 模板缓冲区而言，只能有一个 mipmap 级别</em></p>
</li>
<li>
<p><em>Format：DXGI_FORMAT 枚举类型中的成员之一，用于指定纹素的格式</em></p>
</li>
<li>
<p><em>SampleDesc：多重采样的质量级别以及对每个像素的采样次数</em></p>
</li>
<li>
<p><em>Layout：D3D12_TEXTURE_LAYOUT 枚举类型的成员之一，用于指定纹理的布局。我们暂时还不用考虑这个问题，在此将它指定为D3D12_TEXTURE_LAYOUT_UNKNOWN 即可</em></p>
</li>
<li>
<p><em>Flags：与资源有关的杂项标志。对于一个深度/模板缓冲区资源来说，要将此项指定为 D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</em></p>
</li>
</ol>
<h4 id="id3d12devicecreatecommittedresource"><em><strong>ID3D12Device::CreateCommittedResource</strong></em></h4>
<p><em>GPU 资源都存于堆（heap）中，其本质是具有特定属性的 GPU 显存块</em></p>
<p><em>ID3D12Device:: CreateCommittedResource 方法将根据我们所提供的属性创建一个资源与一个堆，并把该资源提交 到这个堆中。</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">HRESULT</span> <span class="n">ID3D12Device</span><span class="o">::</span><span class="n">CreateCommittedResource</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">D3D12_HEAP_PROPERTIES</span> <span class="o">*</span><span class="n">pHeapProperties</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="n">D3D12_HEAP_FLAGS</span> <span class="n">HeapFlags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">D3D12_RESOURCE_DESC</span> <span class="o">*</span><span class="n">pDesc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="n">D3D12_RESOURCE_STATES</span> <span class="n">InitialResourceState</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">D3D12_CLEAR_VALUE</span> <span class="o">*</span><span class="n">pOptimizedClearValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="n">REFIID</span> <span class="n">riidResource</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="kt">void</span> <span class="o">**</span><span class="n">ppvResource</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p><em>pHeapProperties：（资源欲提交至的）堆所具有的属性,有一些属性是针对高级用法而设。</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">D3D12_HEAP_PROPERTIES</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_HEAP_TYPE</span> <span class="n">Type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_CPU_PAGE_PROPERTY</span> <span class="n">CPUPageProperty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_MEMORY_POOL</span> <span class="n">MemoryPoolPreference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT</span> <span class="n">CreationNodeMask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">UINT</span> <span class="n">VisibleNodeMask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">D3D12_HEAP_PROPERTIES</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>目前只需关心 D3D12_HEAP_PROPERTIES 中的 D3D12_HEAP_TYPE 枚举类型这一主要属性， 其中的成员列举如下</em></p>
<ul>
<li><em>D3D12_HEAP_TYPE_DEFAULT：默认堆（default heap）。向这堆里提交的资源，唯独 GPU 可以访问。举一个有关深度/模板缓冲区的例子：GPU 会读写深度 / 模板缓冲区，而 CPU 从不需要访问它，所以深度/模板缓冲区应被放入默认堆中</em></li>
<li><em>D3D12_HEAP_TYPE_UPLOAD：上传堆（upload heap）。向此堆里提交的都是需要经 CPU 上传至 GPU 的资源</em></li>
<li><em>D3D12_HEAP_TYPE_READBACK：回读堆（read-back heap）。向这种堆里提交的都是需要由 CPU 读取的资源</em></li>
<li><em>D3D12_HEAP_TYPE_CUSTOM：此成员应用于高级场景</em></li>
</ul>
</li>
<li>
<p><em>HeapFlags：与（资源欲提交至的）堆有关的额外选项标志。通常将它设为 D3D12_HEAP_ FLAG_NONE</em></p>
</li>
<li>
<p><em>pDesc：指向一个 D3D12_RESOURCE_DESC 实例的指针，用它描述待建的资源</em></p>
</li>
<li>
<p><em>InitialResourceState：不管何时，每个资源都会处于一种特定的使用状态。在资源创建时，需要用此参数来设置它的初始状态。对于深度/模板缓冲 区来说，通常将其初始状态设置为 D3D12_RESOURCE_STATE_COMMON ，再利用 ResourceBarrier 方法辅以 D3D12_RESOURCE_ STATE_DEPTH_WRITE 状态，将其转换 为可以绑定在渲染流水线上的深度/模板缓冲区</em></p>
</li>
<li>
<p><em>pOptimizedClearValue：指向一个 D3D12_CLEAR_VALUE 对象的指针，它描述了一个用于 清除资源的优化值。选择适当的优化清除值，可提高清除操作的执行速度。若不希望指定优化 清除值，可把此参数设为 nullptr</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">D3D12_CLEAR_VALUE</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DXGI_FORMAT</span> <span class="n">Format</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">FLOAT</span> <span class="n">Color</span><span class="p">[</span> <span class="mi">4</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">D3D12_DEPTH_STENCIL_VALUE</span> <span class="n">DepthStencil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">D3D12_CLEAR_VALUE</span><span class="p">;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><em>riidResource：我们希望获得的 ID3D12Resource 接口的 COM ID</em></p>
</li>
<li>
<p><em>ppvResource：返回一个指向 ID3D12Resource 的指针，即新建的资源</em></p>
</li>
</ol>
<p><em>另外，在使用深度/模板缓冲区之前，一定要创建相关的深度/模板视图，并将它绑定到渲染流水线 上。这个流程类似于创建渲染目标视图</em></p>
<h4 id="创建深度模板纹理及相应的深度模板视图"><em><strong>创建深度/模板纹理及相应的深度/模板视图</strong></em></h4>
<p><em>下面的代码演示了该如何创建深度/模板纹理及相应的深度/模 板视图：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 创建深度/模板缓冲区及其视图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">D3D12_RESOURCE_DESC</span> <span class="n">depthStencilDesc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">Dimension</span> <span class="o">=</span> <span class="n">D3D12_RESOURCE_DIMENSION_TEXTURE2D</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">Alignment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">Width</span> <span class="o">=</span> <span class="n">mClientWidth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">Height</span> <span class="o">=</span> <span class="n">mClientHeight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">DepthOrArraySize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">MipLevels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">Format</span> <span class="o">=</span> <span class="n">mDepthStencilFormat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">SampleDesc</span><span class="p">.</span><span class="n">Count</span> <span class="o">=</span> <span class="n">m4xMsaaState</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">SampleDesc</span><span class="p">.</span><span class="n">Quality</span> <span class="o">=</span> <span class="n">m4xMsaaState</span> <span class="o">?</span> <span class="p">(</span><span class="n">m4xMsaaQuality</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">Layout</span> <span class="o">=</span> <span class="n">D3D12_TEXTURE_LAYOUT_UNKNOWN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">depthStencilDesc</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">D3D12_CLEAR_VALUE</span> <span class="n">optClear</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">optClear</span><span class="p">.</span><span class="n">Format</span> <span class="o">=</span> <span class="n">mDepthStencilFormat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">optClear</span><span class="p">.</span><span class="n">DepthStencil</span><span class="p">.</span><span class="n">Depth</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">optClear</span><span class="p">.</span><span class="n">DepthStencil</span><span class="p">.</span><span class="n">Stencil</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ThrowIfFailed</span><span class="p">(</span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateCommittedResource</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="o">&amp;</span><span class="n">CD3DX12_HEAP_PROPERTIES</span><span class="p">(</span><span class="n">D3D12_HEAP_TYPE_DEFAULT</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_HEAP_FLAG_NONE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="o">&amp;</span><span class="n">depthStencilDesc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">D3D12_RESOURCE_STATE_COMMON</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="o">&amp;</span><span class="n">optClear</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">IID_PPV_ARGS</span><span class="p">(</span><span class="n">mDepthStencilBuffer</span><span class="p">.</span><span class="n">GetAddressOf</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 利用此资源的格式，为整个资源的第 0 mip 层创建描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">md3dDevice</span><span class="o">-&gt;</span><span class="n">CreateDepthStencilView</span><span class="p">(</span><span class="n">mDepthStencilBuffer</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">DepthStencilView</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 将资源从初始状态转换为深度缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">mCommandList</span><span class="o">-&gt;</span><span class="n">ResourceBarrier</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CD3DX12_RESOURCE_BARRIER</span><span class="o">::</span><span class="n">Transition</span><span class="p">(</span><span class="n">mDepthStencilBuffer</span><span class="p">.</span><span class="n">Get</span><span class="p">(),</span><span class="n">D3D12_RESOURCE_STATE_COMMON</span><span class="p">,</span> <span class="n">D3D12_RESOURCE_STATE_DEPTH_WRITE</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>注意，刚刚采用了 CD3DX12_HEAP_PROPERTIES 辅助构造函数来创建堆的属性结构体，它的具体实现如下</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">explicit</span> <span class="nf">CD3DX12_HEAP_PROPERTIES</span><span class="p">(</span><span class="n">D3D12_HEAP_TYPE</span> <span class="n">type</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">creationNodeMask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">nodeMask</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CPUPageProperty</span> <span class="o">=</span> <span class="n">D3D12_CPU_PAGE_PROPERTY_UNKNOWN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MemoryPoolPreference</span> <span class="o">=</span> <span class="n">D3D12_MEMORY_POOL_UNKNOWN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CreationNodeMask</span> <span class="o">=</span> <span class="n">creationNodeMask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">VisibleNodeMask</span> <span class="o">=</span> <span class="n">nodeMask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>CreateDepthStencilView 方法的第二个参数是指向 D3D12_DEPTH_STENCIL_VIEW_DESC 结构体的指针</em></p>
<p><em>这个结构体描述了资源中元素的数据类型（格式）。如果资源在创建时已指定了具体格式（即 此资源不是无类型格式），那么就可以把该参数设为空指针，表示以该资源创建时的格式为它的第一个 mipmap 层级创建一个视图（在创建深度/模板缓冲区时就只有一个 mipmap 层级）。由于我们已经为深度/模板缓冲区设置了具体格式，所以向此参数传入空指针</em></p>
<h3 id="设置视口"><em><strong>设置视口</strong></em></h3>
<p><em>我们通常会将 3D 场景绘制到与整个屏幕（在全屏模式下）或整个窗口工作区大小相当的后台缓冲 区中。但是，有时只是希望把 3D 场景绘制到后台缓冲区的某个矩形子区域当中</em></p>
<h4 id="d3d12_viewport"><em><strong>D3D12_VIEWPORT</strong></em></h4>
<p><em>我们把后台缓冲区中的这种矩形子区域叫作视口（viewport），并通过下列结构体来描述它：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">D3D12_VIEWPORT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">FLOAT</span> <span class="n">TopLeftX</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">FLOAT</span> <span class="n">TopLeftY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">FLOAT</span> <span class="n">Width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">FLOAT</span> <span class="n">Height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">FLOAT</span> <span class="n">MinDepth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">FLOAT</span> <span class="n">MaxDepth</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 	<span class="n">D3D12_VIEWPORT</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p><em>结构体中的前 4 个数据成员定义了视口矩形（viewport rectangle）相对于后台缓冲区的绘制范围（由于数据成员是用 float 类型表示的，所以我们能够以小数精度来指定像素坐标）</em></p>
</li>
<li>
<p><em>在 Direct3D 中，存储在深度缓冲区中的数据都是范围在 0～1 的归一化深度值。</em></p>
<p><em>MinDepth 和 MaxDepth 这两个成员负责 将深度值从区间[0, 1]转换到区间[MinDepth, MaxDepth]</em></p>
<p><em>通过对深度范围进行转换即可实现某些特效， 例如，我们可以依次设置 MinDepth=0 和 MaxDepth=0，用此视口绘制的物体其深度值都为 0，它们将比场景中其他物体的位置都更靠前。</em></p>
<p><em>然而，在大多数情况下通常会把 MinDepth 与 MaxDepth 分别设置为 0 与 1，也就是令深度值保持不变</em></p>
</li>
</ol>
<h4 id="id3d12graphicscommandlistrssetviewports"><em><strong>ID3D12GraphicsCommandList::RSSetViewports</strong></em></h4>
<p><em>只要填写好D3D12_VIEWPORT 结构体，便可以用ID3D12GraphicsCommandList::RSSetViewports 方法来设置 Direct3D 中的视口了。</em></p>
<p><em>下面的示例是通过创建并设置一个视口，将场景绘至整个后台缓冲区：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">D3D12_VIEWPORT</span> <span class="n">vp</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vp</span><span class="p">.</span><span class="n">TopLeftX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vp</span><span class="p">.</span><span class="n">TopLeftY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vp</span><span class="p">.</span><span class="n">Width</span>    <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mClientWidth</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vp</span><span class="p">.</span><span class="n">Height</span>   <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mClientHeight</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">vp</span><span class="p">.</span><span class="n">MinDepth</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vp</span><span class="p">.</span><span class="n">MaxDepth</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mCommandList</span><span class="o">-&gt;</span><span class="n">RSSetViewports</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><em>第一个参数是要绑定的视口数量（有些高级效果需要使用多个视口）</em></li>
<li><em>第二个参数是一个指向视口数组的指针。</em></li>
</ol>
<p><em>事实上，还可以用视口技术来实现双人游戏的分屏（split screen）模式。首先创建两个视口，一个占屏幕左半部，另一个占右半部。接下来，在左视口中以玩家 1 的视角来绘制 3D 场景，再在右视口中以 玩家 2 的视角来绘制 3D 场景即可。</em></p>
<h3 id="设置裁剪矩形"><em><strong>设置裁剪矩形</strong></em></h3>
<p><em>我们可以相对于后台缓冲区定义一个裁剪矩形（scissor rectangle），在此矩形外的像素都将被剔除（即 这些图像部分将不会被光栅化（rasterize）至后台缓冲区）。</em></p>
<p><em>这个方法能用于优化程序的性能。例如，假设已知有一个矩形的 UI（user interface，用户界面）元素覆于屏幕中某块区域的最上层，那么我们也就无须对 3D 空间中那些被它遮挡的像素进行处理了</em></p>
<h4 id="d3d12_rect"><em><strong>D3D12_RECT</strong></em></h4>
<p><em>裁剪矩形由类型为 RECT 的 D3D12_RECT 结构体（typedef RECT D3D12_RECT;）定义而成</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagRECT</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LONG</span> <span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LONG</span> <span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LONG</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LONG</span> <span class="n">bottom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">RECT</span><span class="p">;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="id3d12graphicscommandlistrssetscissorrects"><em><strong>ID3D12GraphicsCommandList::RSSetScissorRects</strong></em></h4>
<p><em>在 Direct3D 中，要用 ID3D12GraphicsCommandList::RSSetScissorRects 方法来设置裁剪矩形。下面的示例将创建并设置一个覆盖后台缓冲区左上角 1/4 区域的裁剪矩形：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">mScissorRect</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mClientWidth</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">mClientHeight</span><span class="o">/</span><span class="mi">2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">mCommandList</span><span class="o">-&gt;</span><span class="n">RSSetScissorRects</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mScissorRect</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><em>类似于 RSSetViewports 方法，RSSetScissorRects 方法的第一个参数是要绑定的裁剪矩形数量（为了实现一些高级效果有时会采用多个裁剪矩形）</em></li>
<li><em>第二个参数是指向一个裁剪矩形数组的指针。</em></li>
</ol>
<h2 id="计时与动画"><em><strong>计时与动画</strong></em></h2>
<p><em>为了制作出精准的动画效果就需要精确地计量时间，特别是要准确地度量出动画每帧画面之间的时间间隔。</em></p>
<p><em>如果帧率（frame rate，也有作帧速率、帧频等，每秒刷新的帧数）较高，那么帧与帧之间的间隔就会比较短，此时我们就要用到高精度的计时器。</em></p>
<h3 id="性能计时器"><em><strong>性能计时器</strong></em></h3>
<p><em>为了精确地度量时间，我们将采用性能计时器（performance timer。或称性能计数器，performance counter）。如果希望调用查询性能计时器的 Win32 函数，我们必须引入头文件 #include &lt;windows.h&gt;</em></p>
<p><em>性能计时器所用的时间度量单位叫作计数（count）。</em></p>
<p><em>可调用 QueryPerformanceCounter 函数来 获取性能计时器测量的当前时刻值（以计数为单位）：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">__int64</span> <span class="n">currTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">QueryPerformanceCounter</span><span class="p">((</span><span class="n">LARGE_INTEGER</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">currTime</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>观察可知，此函数通过参数返回的当前时刻值是个 64 位的整数。再用 QueryPerformanceFrequency 函数来获取性能计时器的频率（单位：计数/秒）：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">__int64</span> <span class="n">countsPerSec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">QueryPerformanceFrequency</span><span class="p">((</span><span class="n">LARGE_INTEGER</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">countsPerSec</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>因此，只需将读取的时刻计数值 valueInCounts 乘以转换因子 mSecondsPerCount ，就可以将其单位转换为秒：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">valueInSecs</span> <span class="o">=</span> <span class="n">valueInCounts</span> <span class="o">*</span> <span class="n">mSecondsPerCount</span><span class="p">;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>对我们而言，单次调用 QueryPerformanceCounter 函数所返回的时刻值并没有什么特别的意义。如果隔一小段时间，在调用一次该函数，并得到此时的时刻值，我们就会发现这两次调用的时刻间隔即为两个返回值的差。因此，我们总是以两个时间戳的相对差值，而非性能计数器单词返回的实际值来度量时间。</em></p>
<p><em>通过下面的代码来明确这一想法：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">__int64</span> <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">QueryPerformanceCounter</span><span class="p">((</span><span class="n">LARGE_INTEGER</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 执行预定的逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">__int64</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">QueryPerformanceCounter</span><span class="p">((</span><span class="n">LARGE_INTEGER</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">B</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>利用 (B-A) 即可获得代码执行期间的计数值，或以 (B - A) * mSecondsPerCount 获取代码运行期间所花费的秒数。</em></p>
<h3 id="游戏计时器类"><em><strong>游戏计时器类</strong></em></h3>
<p><em>在接下来的两小节中，我们将讨论以下 GameTimer 类的实现：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"></code></pre></td></tr></table>
</div>
</div><h3 id="帧与帧之间的时间间隔"><em><strong>帧与帧之间的时间间隔</strong></em></h3>
<h3 id="总时间"><em><strong>总时间</strong></em></h3>
<h2 id="应用程序框架示例"><em><strong>应用程序框架示例</strong></em></h2>
<h3 id="d3dapp-类"><em><strong>D3DApp 类</strong></em></h3>
<h3 id="非框架方法"><em><strong>非框架方法</strong></em></h3>
<h3 id="框架方法"><em><strong>框架方法</strong></em></h3>
<h3 id="帧的统计信息"><em><strong>帧的统计信息</strong></em></h3>
<h3 id="消息处理函数"><em><strong>消息处理函数</strong></em></h3>
<h3 id="初始化-direct3d-演示程序"><em><strong>初始化 Direct3D 演示程序</strong></em></h3>
<h2 id="调试-direct3d-应用程序"><em><strong>调试 Direct3D 应用程序</strong></em></h2>
<h2 id="小结"><em><strong>小结</strong></em></h2>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2025-02-11</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" data-title="Direct3D的初始化" data-hashtags="Unreal,3D图形学,Direct3D"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" data-hashtag="Unreal"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" data-title="Direct3D的初始化"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" data-title="Direct3D的初始化"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://example.com/directx3d-%E5%88%9D%E5%A7%8B%E5%8C%96/" data-title="Direct3D的初始化" data-ralateuid="xxxx"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/unreal/">Unreal</a>,&nbsp;<a href="/tags/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6/">3D图形学</a>,&nbsp;<a href="/tags/direct3d/">Direct3D</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/" class="prev" rel="prev" title="变换矩阵"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>变换矩阵</a>
            <a href="/direct3d-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" class="next" rel="next" title="渲染流水线">渲染流水线<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.134.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Ame</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.5.0/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI","appKey":"WBmoGyJtbqUswvfLh6L8iEBr","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@14.0.0/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-CN","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"serverURLs":"https://leancloud.hugoloveit.com","visitor":true}},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.zh-cn","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
