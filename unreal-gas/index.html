<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Unreal - GAS - Ting</title><meta name="Description" content="Unreal - GAS 架构"><meta property="og:url" content="https://example.com/unreal-gas/">
  <meta property="og:site_name" content="Ting">
  <meta property="og:title" content="Unreal - GAS">
  <meta property="og:description" content="Unreal - GAS 架构">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-26T21:34:00+08:00">
    <meta property="article:modified_time" content="2026-02-26T17:50:15+08:00">
    <meta property="article:tag" content="Unreal">
    <meta property="article:tag" content="GAS">
    <meta property="og:image" content="https://example.com/logo.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://example.com/logo.png">
  <meta name="twitter:title" content="Unreal - GAS">
  <meta name="twitter:description" content="Unreal - GAS 架构">
<meta name="application-name" content="林汀">
<meta name="apple-mobile-web-app-title" content="林汀"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://example.com/unreal-gas/" /><link rel="prev" href="https://example.com/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/" /><link rel="next" href="https://example.com/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Unreal - GAS",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/example.com\/unreal-gas\/"
        },"image": ["https:\/\/example.com\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "Unreal, GAS","wordcount":  17674 ,
        "url": "https:\/\/example.com\/unreal-gas\/","datePublished": "2025-12-26T21:34:00+08:00","dateModified": "2026-02-26T17:50:15+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Ting","logo": "https:\/\/example.com\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Ame"
            },"description": "Unreal - GAS 架构"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('dark' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'dark' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Ting"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>林汀</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/categories/documentation/"> 文档 </a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a><a href="javascript:void(0);" class="menu-item language" title="选择语言">
                    <i class="fa fa-globe" aria-hidden="true"></i>                      
                    <select class="language-select" id="language-select-desktop" onchange="location = this.value;"><option value="/unreal-gas/" selected>简体中文</option></select>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Ting"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>林汀</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/categories/documentation/" title="">文档</a><a class="menu-item" href="https://github.com/dillonzq/LoveIt" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a><a href="javascript:void(0);" class="menu-item" title="选择语言">
                    <i class="fa fa-globe fa-fw" aria-hidden="true"></i>
                    <select class="language-select" onchange="location = this.value;"><option value="/unreal-gas/" selected>简体中文</option></select>
                </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Unreal - GAS</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Ame</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/unreal/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Unreal</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2025-12-26">2025-12-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 17674 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 36 分钟&nbsp;<span id="/unreal-gas/" class="leancloud_visitors" data-flag-title="Unreal - GAS">
                        <i class="far fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#什么是gas"><em><strong>什么是GAS</strong></em></a></li>
    <li><a href="#iabilitysysteminterface"><em><strong>IAbilitySystemInterface</strong></em></a></li>
    <li><a href="#uabilitysystemglobals"><em><strong>UAbilitySystemGlobals</strong></em></a></li>
    <li><a href="#元数据与逻辑"><em><strong>元数据与逻辑</strong></em></a>
      <ul>
        <li><a href="#fgameplaytag--fgameplaytagcontainer"><em><strong>FGameplayTag / FGameplayTagContainer</strong></em></a></li>
        <li><a href="#uabilitysystemblueprintlibrary"><em><strong>UAbilitySystemBlueprintLibrary</strong></em></a></li>
      </ul>
    </li>
    <li><a href="#gas调试"><em><strong>GAS调试</strong></em></a></li>
    <li><a href="#abilitysystemcomponent"><em><strong>AbilitySystemComponent</strong></em></a>
      <ul>
        <li><a href="#一些重要接口"><em><strong>一些重要接口</strong></em></a></li>
        <li><a href="#fpredictionkey"><em><strong>FPredictionKey</strong></em></a></li>
      </ul>
    </li>
    <li><a href="#能力系统"><em><strong>能力系统</strong></em></a>
      <ul>
        <li><a href="#ugameplayabilityga"><em><strong>UGameplayAbility(GA)</strong></em></a></li>
        <li><a href="#ga蓝图属性"><em><strong>GA蓝图属性</strong></em></a></li>
        <li><a href="#重要接口"><em><strong>重要接口</strong></em></a></li>
        <li><a href="#重要接口里面的参数"><em><strong>重要接口里面的参数</strong></em></a>
          <ul>
            <li><a href="#fgameplayabilityspec"><em><strong>FGameplayAbilitySpec</strong></em></a></li>
            <li><a href="#fgameplayabilityspechandle"><em><strong>FGameplayAbilitySpecHandle</strong></em></a></li>
            <li><a href="#fgameplayabilityactivationinfo"><em><strong>FGameplayAbilityActivationInfo</strong></em></a></li>
            <li><a href="#fgameplayabilityactorinfo"><em><strong>FGameplayAbilityActorInfo</strong></em></a></li>
            <li><a href="#fgameplayabilitytargetdata"><em><strong>FGameplayAbilityTargetData</strong></em></a></li>
            <li><a href="#fgameplayabilitytargetdatahandle"><em><strong>FGameplayAbilityTargetDataHandle</strong></em></a></li>
          </ul>
        </li>
        <li><a href="#一些其他的杂项"><em><strong>一些其他的杂项</strong></em></a>
          <ul>
            <li><a href="#uabilitytask"><em><strong>UAbilityTask</strong></em></a></li>
            <li><a href="#agameplayabilitytargetactor"><em><strong>AGameplayAbilityTargetActor</strong></em></a></li>
            <li><a href="#ugameplayabilityworldreticle"><em><strong>UGameplayAbilityWorldReticle</strong></em></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#效果系统"><em><strong>效果系统</strong></em></a>
      <ul>
        <li><a href="#ugameplayeffect"><em><strong>UGameplayEffect</strong></em></a></li>
        <li><a href="#ge-蓝图属性相关"><em><strong>GE 蓝图属性相关</strong></em></a>
          <ul>
            <li><a href="#fattributebasedfloat"><em><strong>FAttributeBasedFloat</strong></em></a></li>
            <li><a href="#ugameplaymodmagnitudecalculation"><em><strong>UGameplayModMagnitudeCalculation</strong></em></a></li>
            <li><a href="#ugameplayeffectexecutioncalculation"><em><strong>UGameplayEffectExecutionCalculation</strong></em></a></li>
            <li><a href="#ugameplayeffectcomponent"><em><strong>UGameplayEffectComponent</strong></em></a></li>
          </ul>
        </li>
        <li><a href="#ge-重要函数"><em><strong>GE 重要函数</strong></em></a></li>
        <li><a href="#ge-重要函数里的参数"><em><strong>GE 重要函数里的参数</strong></em></a>
          <ul>
            <li><a href="#fgameplayeffectspec"><em><strong>FGameplayEffectSpec</strong></em></a></li>
            <li><a href="#fgameplayeffectspechandle"><em><strong>FGameplayEffectSpecHandle</strong></em></a></li>
            <li><a href="#factivegameplayeffect"><em><strong>FActiveGameplayEffect</strong></em></a></li>
            <li><a href="#factivegameplayeffecthandle"><em><strong>FActiveGameplayEffectHandle</strong></em></a></li>
            <li><a href="#fgameplayeffectcontext"><em><strong>FGameplayEffectContext</strong></em></a></li>
            <li><a href="#fgameplayeffectcontexthandle"><em><strong>FGameplayEffectContextHandle</strong></em></a></li>
            <li><a href="#ugameplayeffectcontextpayloadbase"><em><strong>UGameplayEffectContextPayloadBase</strong></em></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#表现层"><em><strong>表现层</strong></em></a>
      <ul>
        <li><a href="#核心路由ugameplaycuemanager"><em><strong>核心路由：UGameplayCueManager</strong></em></a></li>
        <li><a href="#静态处理器ugameplaycuenotify_static"><em><strong>静态处理器：UGameplayCueNotify_Static</strong></em></a></li>
        <li><a href="#动态载体agameplaycuenotify_actor"><em><strong>动态载体：AGameplayCueNotify_Actor</strong></em></a></li>
        <li><a href="#数据包fgameplaycueparameters"><em><strong>数据包：FGameplayCueParameters</strong></em></a>
          <ul>
            <li><a href="#哪些参数会被自动传进去"><em><strong>哪些参数会被自动传进去</strong></em></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#uattributeset"><em><strong>UAttributeSet</strong></em></a>
      <ul>
        <li><a href="#几个重要的宏"><em><strong>几个重要的宏</strong></em></a>
          <ul>
            <li><a href="#attribute_accessors"><em><strong>ATTRIBUTE_ACCESSORS</strong></em></a></li>
            <li><a href="#doreplifetime_condition_notify"><em><strong>DOREPLIFETIME_CONDITION_NOTIFY</strong></em></a></li>
            <li><a href="#gameplayattribute_repnotify"><em><strong>GAMEPLAYATTRIBUTE_REPNOTIFY</strong></em></a></li>
          </ul>
        </li>
        <li><a href="#fgameplayattribute"><em><strong>FGameplayAttribute</strong></em></a></li>
        <li><a href="#fgameplayattributedata"><em><strong>FGameplayAttributeData</strong></em></a></li>
        <li><a href="#fgameplayattribute-1"><em><strong>FGameplayAttribute</strong></em></a></li>
        <li><a href="#fgameplayattributedata-1"><em><strong>FGameplayAttributeData</strong></em></a></li>
        <li><a href="#重要函数"><em><strong>重要函数</strong></em></a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="什么是gas"><em><strong>什么是GAS</strong></em></h2>
<p><em>GAS 全称 Gameplay Ability System，是虚幻引擎提供的一套高度模块化、且原生支持网络同步的玩法逻辑框架。它将“技能逻辑”、“数值计算”和“表现效果”彻底解耦，是构建大型 RPG 或动作游戏的工业级标准。</em></p>
<p><em>GAS 的核心组成部分：</em></p>
<p><em>1. Ability System Component (ASC) —— 心脏与中枢</em></p>
<p><em>它是 GAS 的核心组件，所有需要使用 GAS 的对象都必须挂载它。它负责持有和管理所有的能力、效果和标签，并且是网络同步的权威中心。</em></p>
<p><em>2. Gameplay Abilities (GA) —— 技能逻辑</em></p>
<p><em>它定义了技能“具体要做什么”。包含技能的释放顺序、激活条件、消耗以及冷却。它是一段逻辑代码块，比如“闪避”、“火球术”或“打开宝箱”。</em></p>
<p><em>3. Attribute Set —— 属性仓库</em></p>
<p><em>它是专门存放数值的地方。比如 Health、Mana、Strength。它不仅存储浮点数，还负责处理属性变动时的限制逻辑，比如血量不能超过最大上限。</em></p>
<p><em>4. Gameplay Effects (GE) —— 技能效果</em></p>
<p><em>它是改变属性的载体。它不包含代码逻辑，只包含数据。比如“每秒扣 10 点血”、“永久增加 5 点力量”或者“给目标附加一个眩晕状态”。</em></p>
<p><em>5. Gameplay Tags ——  标签</em></p>
<p><em>它是层级化的字符串标签。它是 GAS 系统判断逻辑的灵魂，比如通过检查角色是否有“State.Dead”标签来决定是否允许释放技能。</em></p>
<p><em>6. Gameplay Cues (GC) —— 表现层</em></p>
<p><em>它专门处理非数值的表现效果，比如粒子特效、音效、震动。它将视觉反馈从复杂的逻辑计算中剥离出来，从而大幅提升性能和网络带宽利用率。</em></p>
<p><em>7. Ability Tasks —— 异步处理机</em></p>
<p><em>因为技能通常是持续的过程，它允许技能在运行中“等待”特定事件。比如“等待动画播放到某个节点”、“等待玩家再次输入”或“等待 2 秒钟”。</em></p>
<p><em>总结：</em></p>
<p><em>你可以把 GAS 想象成一个自动化的流程：一般来说玩家按下按键触发“能力(GA)”，能力检查“标签(Tags)”确认状态，通过“任务(Tasks)”执行异步过程，产生“效果(GE)”去修改“属性集(Attribute Set)”中的数值，最后触发“提示(GC)”播放华丽的特效。</em></p>
<h2 id="iabilitysysteminterface"><em><strong>IAbilitySystemInterface</strong></em></h2>
<p><em>一个契约。确保引擎和 GAS 内部（如 GameplayCue）无论在哪个 Actor 身上，都能通过一个统一的接口 GetAbilitySystemComponent() 找到它的心脏。</em></p>
<h2 id="uabilitysystemglobals"><em><strong>UAbilitySystemGlobals</strong></em></h2>
<p><em>存储能力系统（GAS）的全局数据。</em></p>
<p><em>可以通过“项目设置”（Project Settings）中的“游戏玩法能力设置”（Game -&gt; Gameplay Abilities Settings）进行配置。</em></p>
<p><em>（注意，如果Unreal版本低于5.5，则 ProjectSetting 找不到，只能去 DefaultGame.ini 里面手动配置）</em></p>
<h2 id="元数据与逻辑"><em><strong>元数据与逻辑</strong></em></h2>
<h3 id="fgameplaytag--fgameplaytagcontainer"><em><strong>FGameplayTag / FGameplayTagContainer</strong></em></h3>
<p><em>GAS 的 “神经递质”。</em></p>
<p><em>GAS 几乎所有的判断（能不能放技能、能不能吃 Buff、触发什么特效）全部依赖 Tag。没有标签，GAS 只是普通的属性库；有了标签，它才真正拥有了“逻辑”。</em></p>
<h3 id="uabilitysystemblueprintlibrary"><em><strong>UAbilitySystemBlueprintLibrary</strong></em></h3>
<p><em>GAS 的“万能工具箱”。</em></p>
<p><em>提供了一系列静态函数，让你在蓝图中能轻松地获取 ASC、应用 GE、判断 Tag。它是 C++ 底层与蓝图表现层之间的快速通道。</em></p>
<h2 id="gas调试"><em><strong>GAS调试</strong></em></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cmd" data-lang="cmd"><span class="line"><span class="cl">showdebug abilitysystem
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>在控制台输入 showdebug abilitysystem。这个命令显示的界面，本质上就是把上面提到的所有 <strong>Spec</strong>、<strong>ActiveGE</strong>、<strong>Tags</strong> 的实时状态可视化给你看。</em></p>
<h2 id="abilitysystemcomponent"><em><strong>AbilitySystemComponent</strong></em></h2>
<p><em>GAS 的心脏。用于与玩法能力系统 (GameplayAbilities System) 对接的核心 Actor 组件。</em></p>
<p><em>更加通俗的理解就是：它是连接你的角色（Actor）与技能系统（GAS）的桥梁/核心入口</em></p>
<p><em>它负责所有 Gameplay Ability 的赋予与激活，管理 Attribute 的聚合修改，处理 Gameplay Effect 的生命周期，并作为 Gameplay Tags 的宿主来驱动状态逻辑，同时在底层处理所有相关数据的网络同步与动作预测。</em></p>
<h3 id="一些重要接口"><em><strong>一些重要接口</strong></em></h3>
<ol>
<li>
<p><em>设置该 ASC 的“主人”（Owner）和“化身”（Avatar）。</em></p>
<p><code>virtual void InitAbilityActorInfo(AActor* InOwnerActor, AActor* InAvatarActor);</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>OwnerActor：逻辑上的所有者（通常是 PlayerState 或 Pawn）。</em></li>
<li><em>AvatarActor：表现上的物理实体（通常是 Character）。</em></li>
</ul>
</li>
<li><em>核心逻辑：这是 ASC 的启动开关。如果不调用它，技能放不出来、属性同步不了、UI 也会报错。</em></li>
</ul>
</li>
</ol>
<h3 id="fpredictionkey"><em><strong>FPredictionKey</strong></em></h3>
<p><em><strong>FPredictionKey</strong> 是 GameplayAbility 系统中支持“客户端预测”的一种通用方式。它本质上是一个 <strong>ID</strong>，用于标识客户端所执行的预测动作及其产生的“副作用”（Side Effects）。UAbilitySystemComponent（ASC）负责在客户端和服务器之间同步这个预测键及其关联的副作用。</em></p>
<p><em>本质上，任何行为都可以与一个预测键关联，例如“激活技能”。</em></p>
<ol>
<li><em><strong>流程开始</strong>：客户端生成一个全新的预测键，并在调用 ServerTryActivateAbility 时将其发送给服务器。</em></li>
<li><em><strong>服务器响应</strong>：服务器会确认或拒绝该请求（触发 ClientActivateAbilitySucceed 或 Failed）。</em></li>
<li><em><strong>本地预测阶段</strong>：在客户端预测技能运行期间，它会产生各种</em><em>副作用</em>*（如应用 GameplayEffects、触发事件、播放动画等）。每产生一个副作用，客户端都会将其与启动时生成的那个预测键关联起来。*</li>
<li><em><strong>结果处理</strong>：</em>
<ul>
<li><em><strong>如果激活被拒绝</strong>：客户端可以立即回滚（撤销）这些关联的副作用</em>。</li>
<li><em><strong>如果激活被接受</strong>：客户端必须等待服务器同步真实的副作用数据。</em>
<ul>
<li><em>（ClientActivatbleAbilitySucceed 远程调用会立即发送，但属性同步可能晚几帧到达）。</em></li>
<li><em>一旦服务器版本的副作用同步完成，客户端就会撤销本地预测的临时副作用（并以服务器同步过来的权威数据为准）。</em></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><em>一般并不会将伤害数值客户端会预测，只会预测技能特效这些表现效果</em></p>
<p><em><strong>FPredictionKey 本身主要提供以下功能：</strong></em></p>
<ul>
<li><em><strong>唯一 ID 系统</strong>：支持“当前”和“基础”整数构成的依赖链系统。</em></li>
<li><em><strong>特殊的网络序列化（NetSerialize）实现</strong>：<strong>该预测键只会序列化给发起预测的那个客户端</strong>。</em>
<ul>
<li><em>这一点至关重要：它允许我们将预测键存在同步状态中，但只有给服务器发送过该键的客户端才能真正看到它（其他客户端不会收到多余的预测数据）</em></li>
</ul>
</li>
</ul>
<h2 id="能力系统"><em><strong>能力系统</strong></em></h2>
<h3 id="ugameplayabilityga"><em><strong>UGameplayAbility(GA)</strong></em></h3>
<p><em>能力 (Abilities) 定义了自定义的玩法逻辑，这些逻辑可以由玩家或外部游戏逻辑激活。</em></p>
<p><em>它包含技能的释放逻辑、CD、消耗、标签要求。</em></p>
<h3 id="ga蓝图属性"><em><strong>GA蓝图属性</strong></em></h3>
<p><em>Tags 标签属性组</em></p>
<ul>
<li>
<p><em>Ability Tags 用于标识技能本身的标签 能够让其他逻辑或系统识别出此技能的类别</em></p>
</li>
<li>
<p><em>Cancel Abilities With Tag 当此技能激活时 会自动寻找并取消掉当前角色身上正在运行且带有这些标签的其他技能</em></p>
</li>
<li>
<p><em>Block Abilities With Tag 当此技能处于激活状态时 会阻止任何带有这些标签的新技能被触发激活</em></p>
</li>
<li>
<p><em>Activation Owned Tags 技能在激活期间 技能持有者（ASC）会自动获得这些标签 技能结束时标签随之移除</em></p>
</li>
<li>
<p><em>Activation Required Tags 激活的前提条件 只有当技能持有者（ASC）已经具备了这些标签时 技能才允许被开启</em></p>
</li>
<li>
<p><em>Activation Blocked Tags 激活的排除条件 如果技能持有者（ASC）身上带有这些标签 那么该技能将被锁定无法激活</em></p>
</li>
<li>
<p><em>Source Required Tags 检查技能的发起者 只有当发起者（Source Object）具备这些标签时 技能才能成功触发</em></p>
</li>
<li>
<p><em>Source Blocked Tags 检查技能的发起者 如果发起者（Source Object）具备这些标签 技能将无法被成功激活</em></p>
</li>
<li>
<p><em>Target Required Tags 检查技能的目标 只有当目标对象具备这些标签时 技能才会对该目标产生效果</em></p>
</li>
<li>
<p><em>Target Blocked Tags 检查技能的目标 如果目标对象具备这些标签 技能将无法对该目标产生任何效果</em></p>
</li>
</ul>
<p><em>Input 输入属性组</em></p>
<ul>
<li><em>Replicate Input Directly 勾选后会将玩家的原始按键输入直接同步给服务器 而不是通过常规的技能指令流</em></li>
</ul>
<p><em>Advanced 高级属性组</em></p>
<ul>
<li>
<p><em>Replication Policy 决定了技能的状态和变量是否在网络上进行同步的策略枚举</em></p>
<ul>
<li>
<p><em>Do Not Replicate 技能不进行网络同步 仅在各自触发的那一端运行</em></p>
</li>
<li>
<p><em>Replicate 技能的内部状态和变量会从服务器同步给所有相关的客户端</em></p>
</li>
</ul>
</li>
<li>
<p><em>Instancing Policy 决定了技能在内存中如何创建实例对象的策略枚举</em></p>
<ul>
<li>
<p><em>Non Instanced 技能不产生实例 所有角色共享一个类定义 内存效率最高但不能存储个体状态</em></p>
</li>
<li>
<p><em>Instanced Per Actor 每个角色在首次使用该技能时创建一个持久实例 适合存储角色的连招段数等</em></p>
</li>
<li>
<p><em>Instanced Per Execution 每次按下技能都会创建一个全新的独立实例 适合处理复杂的独立逻辑</em></p>
</li>
</ul>
</li>
<li>
<p><em>Server Respects Remote Ability Cancellation 决定了当客户端尝试主动取消技能时 服务器是否听从该请求</em></p>
</li>
<li>
<p><em>Retrigger Instanced Ability 对于实例化技能 如果在运行中再次触发 是否停止当前运行并从头重新开始</em></p>
</li>
<li>
<p><em>Net Execution Policy 决定了技能在客户端和服务器之间执行顺序和同步关系的策略枚举</em></p>
<ul>
<li>
<p><em>Local Predicted 本地预测模式 客户端立即执行并在服务器端进行验证 这种模式下的操作感最流畅</em></p>
</li>
<li>
<p><em>Local Only 仅本地模式 技能只在本地客户端运行 不会与服务器进行任何通信</em></p>
</li>
<li>
<p><em>Server Only 仅服务器模式 技能只在服务器运行 客户端不运行任何逻辑 适合安全性高的数值逻辑</em></p>
</li>
<li>
<p><em>Server Initiated 服务器启动模式 必须由服务器决定何时启动技能并通知客户端同步执行</em></p>
</li>
</ul>
</li>
<li>
<p><em>Net Security Policy 决定了技能激活权限等级以防止客户端作弊的策略枚举</em></p>
<ul>
<li><em>Client Or Server 客户端或服务器模式 允许客户端请求激活 灵活但安全性一般</em></li>
<li><em>Server Only Execution 即使客户端请求 也要等服务器确认指令传回后才允许开始执行</em></li>
<li><em>Server Only Termination 客户端无权主动停止技能 必须由服务器判定结束后发送指令</em></li>
<li><em>Server Only 技能的启动和停止完全由服务器掌控 具有最高的防作弊安全性</em></li>
</ul>
</li>
</ul>
<p><em>Costs 消耗属性组</em></p>
<ul>
<li><em>Cost Gameplay Effect Class 指定一个 Gameplay Effect 类 用于定义释放技能需要消耗的属性如法力或体力</em></li>
</ul>
<p><em>Triggers 触发属性组</em></p>
<ul>
<li>
<p><em>Ability Triggers 定义了触发技能的各种外部条件数组 包含触发源类型和对应的触发标签</em></p>
</li>
<li>
<p><em>Trigger Source 决定了技能响应何种外部逻辑变化来尝试自动激活的策略枚举</em></p>
<ul>
<li>
<p><em>Gameplay Event 监听并响应特定的游戏事件标签 通常由其他逻辑发送事件及其数据载荷来精准触发</em></p>
</li>
<li>
<p><em>Owned Tag Added 当技能持有者（ASC）获得并新增了匹配的标签时 立即触发技能尝试自动激活</em></p>
</li>
<li>
<p><em>Owned Tag Present 状态检查触发 只要技能持有者（ASC）当前正持有匹配的标签 技能便满足自动激活前提</em></p>
</li>
</ul>
</li>
</ul>
<p><em>Cooldowns 冷却属性组</em></p>
<ul>
<li><em>Cooldown Gameplay Effect Class 指定一个 Gameplay Effect 类 用于通过标签和持续时间定义技能的冷却逻辑</em></li>
</ul>
<h3 id="重要接口"><em><strong>重要接口</strong></em></h3>
<ol>
<li>
<p><em>ASC里的函数：让角色拥有一项技能</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">	FGameplayAbilitySpec AbilitySpec(AbilityCDO, AbilityLevel);
</span></span></span><span class="line"><span class="cl"><span class="cm">	AbilitySpec.SourceObject = SourceObject;
</span></span></span><span class="line"><span class="cl"><span class="cm">	AbilitySpec.DynamicAbilityTags.AddTag(InputTag);
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">FGameplayAbilitySpecHandle</span> <span class="nf">GiveAbility</span><span class="p">(</span><span class="k">const</span> <span class="n">FGameplayAbilitySpec</span><span class="o">&amp;</span> <span class="n">AbilitySpec</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><em>ASC里的函数：尝试去激活一个技能。为什么说尝试？因为它里面会触发 <code>CanActivateAbility</code>等一系列检查</em></p>
<p><code>bool TryActivateAbility(FGameplayAbilitySpecHandle AbilityToActivate, bool bAllowRemoteActivation = true);</code></p>
<p><em>bAllowRemoteActivation：</em></p>
<ul>
<li><em>（True）当你在客户端调用此函数时，如果该技能被配置为“在服务器上运行”，客户端会自动向服务器发送一个 RPC 请求，告诉服务器：“我要放这个技能了</em></li>
<li><em>（False）激活请求只会留在本地。如果该技能需要服务器确认，而你禁用了远程激活，那么激活就会失败。</em></li>
</ul>
</li>
<li>
<p><em>K2_CanActivateAbility：K2_ 是 Kismet 2 的缩写（虚幻蓝图系统的代号）。带有 K2_ 前缀的函数通常是 C++ 内部使用的“蓝图版本”。</em></p>
<p><em>在 CanActivateAbility 的逻辑中就会调用 K2_CanActivateAbility，K2_CanActivateAbility就是在蓝图里面专门写的函数</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">CanActivateAbility</span><span class="p">(</span><span class="k">const</span> <span class="n">FGameplayAbilitySpecHandle</span> <span class="n">Handle</span><span class="p">,</span> <span class="k">const</span> <span class="n">FGameplayAbilityActorInfo</span><span class="o">*</span> <span class="n">ActorInfo</span><span class="p">,</span> <span class="k">const</span> <span class="n">FGameplayTagContainer</span><span class="o">*</span> <span class="n">SourceTags</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">FGameplayTagContainer</span><span class="o">*</span> <span class="n">TargetTags</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">OUT</span> <span class="n">FGameplayTagContainer</span><span class="o">*</span> <span class="n">OptionalRelevantTags</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">UFUNCTION</span><span class="p">(</span><span class="n">BlueprintImplementableEvent</span><span class="p">,</span> <span class="n">Category</span> <span class="o">=</span> <span class="n">Ability</span><span class="p">,</span> <span class="n">DisplayName</span><span class="o">=</span><span class="s">&#34;CanActivateAbility&#34;</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">ScriptName</span><span class="o">=</span><span class="s">&#34;CanActivateAbility&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">K2_CanActivateAbility</span><span class="p">(</span><span class="n">FGameplayAbilityActorInfo</span> <span class="n">ActorInfo</span><span class="p">,</span> <span class="k">const</span> <span class="n">FGameplayAbilitySpecHandle</span> <span class="n">Handle</span><span class="p">,</span> <span class="n">FGameplayTagContainer</span><span class="o">&amp;</span> <span class="n">RelevantTags</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><em>判断技能当前能否激活。</em></li>
<li><em>入参：</em>
<ul>
<li><em>SourceTags/TargetTags：来源方和目标方的标签容器。</em></li>
</ul>
</li>
<li><em>核心逻辑：系统在调用 TryActivateAbility 时会先运行这个函数。它会检查技能配置里的各种标签要求（比如：处于晕眩状态不能放技能）。你也可以重写它来增加自定义的限制条件。</em></li>
</ul>
</li>
<li>
<p><em>激活技能后的逻辑</em></p>
<p><code>virtual void ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData);</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>TriggerEventData：如果是通过事件触发的技能，这里包含了触发时的详细数据。</em></li>
</ul>
</li>
<li><em>核心逻辑：这是技能逻辑的总入口。所有的播放动画、产生特效、发射子弹等逻辑都从这里开始编写。</em></li>
<li><em>老司机提醒：此为技能逻辑，如果想释放一个技能，还得调用 <code>TryActivateAbility</code></em></li>
</ul>
</li>
<li>
<p><em>提交技能。</em></p>
<p><code>virtual bool CommitAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr);</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>与激活函数的入参基本一致。</em></li>
<li><em>OptionalRelevantTags：如果提交失败，可以用来返回失败的具体原因标签。</em></li>
</ul>
</li>
<li><em>核心逻辑：这个函数会自动去检查技能的消耗（Cost）和冷却（Cooldown）。只有这两个检查都通过了，它才会扣除资源并开始计算冷却。如果返回 false，说明资源不足或冷却没好。</em></li>
</ul>
</li>
<li>
<p><em>结束技能后的逻辑</em></p>
<p><code>virtual void EndAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateEndAbility, bool bWasCancelled);</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>bReplicateEndAbility：是否需要将结束信号同步给其他端。</em></li>
<li><em>bWasCancelled：技能是正常播放完结束的，还是被外部逻辑强行打断的。</em></li>
</ul>
</li>
<li><em>核心逻辑：这是最重要的清理接口。如果你不调用它，技能会永远处于“运行中”状态，导致角色可能无法再次释放技能，或者标签一直挂在身上不消失。</em></li>
</ul>
</li>
<li>
<p><em>取消/打断当前技能后的逻辑</em></p>
<p><code>virtual void CancelAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, bool bReplicateCancelAbility);</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>bReplicateCancelAbility：是否需要将取消信号同步到其他端。</em></li>
</ul>
</li>
<li><em>核心逻辑：这是技能响应“被强行中止”时的处理函数。它的内部实现通常会自动调用 EndAbility，并显式地将 bWasCancelled 参数设为 true。</em></li>
<li><em>开发提示：它与 EndAbility 的区别在于，CancelAbility 专门用于非自愿的打断（比如被敌人眩晕、被沉默或玩家按了另一个会互斥掉当前技能的操作）。当你需要针对“被动中断”写一些特殊逻辑（比如中断施法后进入更长的冷却）时，会关注这个流程。</em></li>
</ul>
</li>
<li>
<p><em>ASC里的函数：根据标签强行取消/打断技能。</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CancelAbility</span><span class="p">(</span><span class="n">UGameplayAbility</span><span class="o">*</span> <span class="n">Ability</span><span class="p">);</span>	
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CancelAbilityHandle</span><span class="p">(</span><span class="k">const</span> <span class="n">FGameplayAbilitySpecHandle</span><span class="o">&amp;</span> <span class="n">AbilityHandle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CancelAbilities</span><span class="p">(</span><span class="k">const</span> <span class="n">FGameplayTagContainer</span><span class="o">*</span> <span class="n">WithTags</span><span class="o">=</span><span class="k">nullptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">FGameplayTagContainer</span><span class="o">*</span> <span class="n">WithoutTags</span><span class="o">=</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">UGameplayAbility</span><span class="o">*</span> <span class="n">Ignore</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">CancelAllAbilities</span><span class="p">(</span><span class="n">UGameplayAbility</span><span class="o">*</span> <span class="n">Ignore</span><span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><em>入参：</em>
<ul>
<li><em>WithTags：匹配这些标签的技能将被关闭。</em></li>
<li><em>WithoutTags：不包含这些标签的技能才会被关闭。</em></li>
<li><em>Ignore：不会关闭的技能</em></li>
</ul>
</li>
<li><em>核心逻辑：用于实现硬控逻辑，比如眩晕时取消所有正在读条的技能。</em></li>
</ul>
</li>
<li>
<p><em>获取技能相关的 Actor 信息。</em></p>
<p><code>FGameplayAbilityActorInfo GetActorInfo() const;</code></p>
<ul>
<li><em>核心逻辑：在技能内部使用。通过它可以直接获取到 AvatarActor（当前的肉体小人）、OwnerActor（逻辑上的所有者）以及 ASC 组件。这是技能内部寻找“我是谁”的最快方式。</em></li>
</ul>
</li>
<li>
<p><em>发送游戏事件。</em></p>
</li>
</ol>
<p><code>void SendGameplayEvent(FGameplayTag EventTag, FGameplayEventData Payload);</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>EventTag：标识事件的标签。</em></li>
<li><em>Payload：携带的各种数据包。</em></li>
</ul>
</li>
<li><em>核心逻辑：用于技能内部的主动通信。比如你的技能在某一时刻达成了一个特殊条件，可以发送一个事件来触发角色身上的其他被动技能或特定的特效表现。</em></li>
</ul>
<ol start="11">
<li>
<p><em>ASC里的函数：发送/触发一个游戏事件。</em></p>
<p><code>virtual int32 HandleGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload);</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>EventTag：触发事件的标签，比如 Event.OnHit。</em></li>
<li><em>Payload：携带的数据包，包含受击者、攻击者、位置等丰富信息。</em></li>
</ul>
</li>
<li><em>核心逻辑：用于触发那些不需要按键、而是由特定行为激发的技能（例如受击反击、暴击回血）。</em></li>
</ul>
</li>
</ol>
<h3 id="重要接口里面的参数"><em><strong>重要接口里面的参数</strong></em></h3>
<h4 id="fgameplayabilityspec"><em><strong>FGameplayAbilitySpec</strong></em></h4>
<p><em>技能的“说明书实例”。</em></p>
<p><em>当你调用 GiveAbility 时，系统会把 GA 类封装成一个 Spec。它存储了技能的等级、输入绑定 ID、以及谁是这个技能的原始所有者。它是技能在内存中真实存在的“户口本”。</em></p>
<h4 id="fgameplayabilityspechandle"><em><strong>FGameplayAbilitySpecHandle</strong></em></h4>
<p><em>技能在内存中的“唯一身份证”。</em></p>
<ul>
<li><em><strong>定义</strong>：一个全局唯一的整数标识符，指向 ASC 中的 FGameplayAbilitySpec。</em></li>
<li><em><strong>应用场景</strong>：当你需要手动结束技能（EndAbility）或者取消特定技能（CancelAbilityHandle）时，系统会认这个 ID。</em></li>
</ul>
<p><em>它的存在主要有以下两个核心目的：</em></p>
<ul>
<li><em><strong>性能优化</strong>：避免我们在蓝图中不得不频繁地拷贝整个完整的目标数据结构体。</em></li>
<li><em><strong>支持多态性</strong>：允许我们在目标数据结构中使用多态特性（即一个句柄可以指向不同类型的具体子类数据）。</em></li>
<li><em><strong>网络同步支持</strong>：允许我们实现 NetSerialize（网络序列化），从而在客户端和服务器之间实现“按值同步（Replication by value）”。</em></li>
</ul>
<h4 id="fgameplayabilityactivationinfo"><em><strong>FGameplayAbilityActivationInfo</strong></em></h4>
<p><em>技能的“网络状态快照”。</em></p>
<ul>
<li><em><strong>定义</strong>：存储在技能实例中的结构体，记录了当前技能是如何启动的。</em></li>
<li><em><strong>作用</strong>：它是处理网络同步（Replication）和预测（Prediction）时的重要依据。</em></li>
<li><em><strong>核心状态</strong>：</em>
<ul>
<li><em>ActivationMode：标识当前是“本地预测（Predicting）”、“服务器权威（Authority）”还是“远程非权威（Non-Authoritative）”。</em></li>
</ul>
</li>
<li><em><strong>价值</strong>：在技能内部逻辑中，你可以通过它判断：“我现在是在客户端先行播放特效吗？”或者是“我现在是在服务器做最后的数值结算吗？”</em></li>
</ul>
<h4 id="fgameplayabilityactorinfo"><em><strong>FGameplayAbilityActorInfo</strong></em></h4>
<p><em>技能的“环境快照”。</em></p>
<p><em>记录了技能相关的 Owner、Avatar（化身）、SkeletalMesh、甚至 MovementComponent。它能让技能内部快速获取这些组件，避免频繁调用 GetComponent 造成的性能损耗。</em></p>
<h4 id="fgameplayabilitytargetdata"><em><strong>FGameplayAbilityTargetData</strong></em></h4>
<p><em>这是一个用于处理目标数据的通用结构体。目标是让通用的函数能够生成这些数据，并由其他通用函数来消费/处理这些数据。</em></p>
<p><em>该结构能够同时持有特定的 Actor/对象引用，以及通用的位置（Location）/ 方向（Direction）/ 源点（Origin）信息。</em></p>
<h4 id="fgameplayabilitytargetdatahandle"><em><strong>FGameplayAbilityTargetDataHandle</strong></em></h4>
<p><em>用来包装 FGameplayAbilityTargetData 的句柄</em></p>
<p><em>它的存在主要有以下两个核心目的：</em></p>
<ul>
<li><em><strong>性能优化</strong>：避免我们在蓝图中不得不频繁地拷贝整个完整的目标数据结构体。</em></li>
<li><em><strong>支持多态性</strong>：允许我们在目标数据结构中使用多态特性（即一个句柄可以指向不同类型的具体子类数据）。</em></li>
<li><em><strong>网络同步支持</strong>：允许我们实现 NetSerialize（网络序列化），从而在客户端和服务器之间实现“按值同步（Replication by value）”。</em></li>
</ul>
<h3 id="一些其他的杂项"><em><strong>一些其他的杂项</strong></em></h3>
<h4 id="uabilitytask"><em><strong>UAbilityTask</strong></em></h4>
<p><em>异步处理机。技能是瞬时启动的，Task 允许技能“等待”某事发生（如：等待动画结束、等待一个碰撞、等待一段时间）</em></p>
<h4 id="agameplayabilitytargetactor"><em><strong>AGameplayAbilityTargetActor</strong></em></h4>
<p><em>3D 世界的“选择器”。</em></p>
<p><em>用于在场景中生成视觉辅助（如圆形范围、直线射线）。它负责捕捉玩家选中的目标，并将其打包成 TargetData 发送给服务器。</em></p>
<p><em>警告：</em></p>
<ul>
<li>
<p><em>这些角色在每次能力激活时都会生成一次，并且在默认形式下效率不高</em></p>
</li>
<li>
<p><em>对于大多数游戏，您需要子类化并大量修改此 actor，或者您需要在特定于游戏的 actor 或蓝图中实现类似的功能，以避免 actor 生成成本</em></p>
</li>
<li>
<p><em>这个类没有经过内部游戏的充分测试，但它是一个有用的类，可以用来了解目标复制是如何发生的</em></p>
</li>
</ul>
<h4 id="ugameplayabilityworldreticle"><em><strong>UGameplayAbilityWorldReticle</strong></em></h4>
<p><em>目标的“反馈准心”。</em></p>
<p><em>专门用于显示目标确认的反馈效果，比如选中的敌人脚下的红圈，或者技能预判的虚影。</em></p>
<h2 id="效果系统"><em><strong>效果系统</strong></em></h2>
<h3 id="ugameplayeffect"><em><strong>UGameplayEffect</strong></em></h3>
<p><em>数据容器。它不包含逻辑代码，只包含“修改什么属性、持续多久、有什么标签”。</em></p>
<p><em>GE 表达了 GAS 架构中一个极其重要的原则：数据与逻辑的彻底分离。</em></p>
<ol>
<li>
<p><em>“驱动一切”的数据资产：</em></p>
<p><em>在 GAS 中，UGameplayEffect 本质上是一个“复杂的结构体”。它就像一张处方单，上面写着：加多少血、持续多久、带什么标签。所有的属性改变（Attributes）和状态切换（Tags）都必须通过它来驱动。</em></p>
</li>
<li>
<p><em>为什么不让写蓝图逻辑？</em></p>
<ul>
<li><em>性能开销：GE 在游戏中会被高频触发、叠加和同步。如果每个 GE 内部都有复杂的蓝图逻辑，性能会迅速崩溃。</em></li>
<li><em>可预测性：GE 的作用应该是确定的。逻辑应该写在 Ability (GA) 里，或者写在 Execution Calculation（重型计算器）里，而不是写在 GE 这个“数据包”里。</em></li>
<li><em>网络优化：纯数据的同步比同步一段逻辑要高效得多。</em></li>
</ul>
</li>
<li>
<p><em>所谓的“模板”：</em></p>
<p><em>你在编辑器里右键创建 Gameplay Effect 蓝图时，你其实只是在利用蓝图的界面来填表（设置数值）。这被称为“模板化”。你只是在给这个资产设置初始值，而不是在给它写程序。</em></p>
</li>
</ol>
<h3 id="ge-蓝图属性相关"><em><strong>GE 蓝图属性相关</strong></em></h3>
<p><em><strong>Status（状态）</strong></em></p>
<ul>
<li><em>Editor Status Text</em>
<ul>
<li><em>说明: 纯编辑器的备注文本。</em></li>
<li><em>作用: 不影响游戏逻辑，仅用于开发者在蓝图列表中写备注，方便识别这个 GE 的作用。</em></li>
</ul>
</li>
</ul>
<p><em><strong>Duration（持续时间策略）</strong></em></p>
<ul>
<li><em>Duration Policy: 定义该效果如何在时间维度上存在。</em>
<ul>
<li><em>Instant (瞬时) 效果应用后立即修改属性的“基础值”（Base Value），然后立即销毁。常用于扣血、加金钱。</em></li>
<li><em>Infinite (永久) 效果永久挂在目标身上，除非手动移除或被标签（Tags）清除。常用于被动技能。</em></li>
<li><em>Has Duration (限时): 效果持续一段时间后自动移除。选择此项后会多出一个 Duration Magnitude 用于设置具体的秒数。常用于眩晕 3 秒、增加攻击力 10 秒。</em></li>
</ul>
</li>
</ul>
<p><em><strong>Gameplay Effect（核心变更逻辑）</strong></em></p>
<ul>
<li>
<p><em>Components (组件)</em></p>
<ul>
<li><em>说明: UE5.3之后 新增的模块化功能。点击 + 号可以添加不同的逻辑块。</em></li>
<li><em>可选组件举例 (你也可以自定义组件)</em>
<ul>
<li><em>Grant Tags to Target Actor: 给该GE贴上标签。</em></li>
</ul>
</li>
</ul>
</li>
<li>
<p><em>Modifiers (属性修改器)</em></p>
<ul>
<li>
<p><em>说明: 最常用的功能，通过数学运算直接改属性。</em></p>
</li>
<li>
<p><em>内部选项</em></p>
<ul>
<li>
<p><em>Attribute: 选择你要修改的属性（如 Health, Mana）。</em></p>
</li>
<li>
<p><em>Modifier Op: 运算方式，包括 Add (加减)、Multiply (乘)、Divide (除)、Override (覆盖/强行设为某值)。</em></p>
<p>最终值 = ((基础值 + 所有加法总和) * 所有乘法总和 / 所有除法总和) -&gt; 最后执行 Override</p>
<table>
<thead>
<tr>
<th><em>操作符 (ModOp)</em></th>
<th><em>数学公式</em></th>
<th><em>典型使用场景</em></th>
<th><em>备注</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><em><strong>Additive (Add)</strong></em></td>
<td><em>新值 = 旧值 + 修正值</em></td>
<td><em>生命值上限 +100，攻击力 +5</em></td>
<td><em>最常用的修改方式。</em></td>
</tr>
<tr>
<td><em><strong>Multiplicitive (Multiply)</strong></em></td>
<td>新值 = 旧值 * 修正值</td>
<td><em>攻击力提升 20% (修正值为 1.2)</em></td>
<td><em>多个乘法通常是加法堆叠。</em>（100 * (1.0 + 0.1 + 0.1) = 120）</td>
</tr>
<tr>
<td><em><strong>Division (Divide)</strong></em></td>
<td><em>新值 = 旧值 / 修正值</em></td>
<td><em>技能冷却缩减，防御力减半</em></td>
<td><em>通常用于负面效果或特殊缩放。</em></td>
</tr>
<tr>
<td><em><strong>Override (Override)</strong></em></td>
<td><em>新值 = 修正值</em></td>
<td><em>强制移动速度变为 0，强制无敌</em></td>
<td><em>霸道总裁。无视之前的任何计算，直接覆盖</em></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><em>Magnitude: 数值来源。可以是固定值，也可以是根据另一个属性计算出的值（Attribute Based）。</em></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><em>Executions (执行计算)</em></p>
<ul>
<li><em>说明: 关联 C++ 或蓝图编写的 GameplayEffectExecutionCalculation 类。</em></li>
<li>作用: 用于处理极其复杂的伤害公式（例如：伤害 = 攻击力 * 技能倍率 - 敌方护甲，且涉及暴击随机数时)</li>
</ul>
</li>
</ul>
<p><em><strong>Gameplay Cues（视觉与音效表现）</strong></em></p>
<ul>
<li><em>Require Modifier Success to Trigger Cues</em>:
<ul>
<li><em>作用: 如果勾选，只有当上面的 Modifiers 成功修改了属性（没被免疫或失效）时，才会播放特效。</em></li>
</ul>
</li>
<li><em>Suppress Stacking Cues</em>
<ul>
<li><em>作用: 如果该 GE 正在堆叠（Stacking），勾选此项后，增加层数时不会重复播放特效，只在第一层播一次。</em></li>
</ul>
</li>
<li><em>Gameplay Cues</em>
<ul>
<li><em>说明: 特效标签数组。</em></li>
<li><em>作用: 在这里填入标签（如 GameplayCue.Character.Hit），系统会自动寻找对应的 GameplayCueNotify 蓝图并播放。</em></li>
<li><em>Magnitude Attribute 数值来源属性：在特效蓝图（Gameplay Cue Notify）中，你可以获取这个数值。例如，你可以根据这个数值的大小来缩放爆炸粒子的大小，或者改变音效的音量。如果设为 None，则只发送基础的触发信号</em></li>
<li><em>Min Level 最小等级限制：如果当前施放的 Gameplay Effect 等级低于这个值，该特效将不会播放。这允许你为同一个技能在不同等级配置不同的表现。例如：1-5 级播放小火球特效，6 级以上播放大火球特效。</em></li>
<li><em>Max Level 最大等级限制：配合 Min Level 使用。如果GE等级超过了这个值，该特效将停止触发。如果设置为 0.0 且 Min Level 也是 0.0，通常表示不进行等级过滤，全等级触发</em></li>
</ul>
</li>
</ul>
<p><em><strong>Stacking（堆叠策略）</strong></em></p>
<ul>
<li><em>Stacking Type</em>
<ul>
<li><em>None: 不堆叠。每次应用都会创建一个新的独立 GE 实例。</em></li>
<li><em>Aggregate by Source (按来源堆叠): 记录施法者。如果 A 给目标上两次 GE，层数增加；如果 A 给一次，B 给一次，目标身上会有两个独立的 GE。</em></li>
<li><em>Aggregate by Target (按目标堆叠): 不管是谁施放的，只要是同类 GE，在目标身上就只算一个，层数往上加</em></li>
</ul>
</li>
</ul>
<p><em>注意： 一旦你将 Stacking Type 设置为非 None，下方会出现更多详细枚举：</em></p>
<ul>
<li><em>Stack Limit Count: 最大堆叠层数。</em></li>
<li><em>Stack Duration Refresh Policy (时长刷新策略)</em>:
<ul>
<li><em>Refresh on Successful Application: 每次叠新层数，持续时间重置。</em></li>
<li><em>Never Refresh: 叠层不影响计时，时间到期全消失。</em></li>
</ul>
</li>
<li><em>Stack Period Reset Policy (周期重置策略)</em>
<ul>
<li><em>如果 GE 是周期性触发的（比如每 1 秒扣一次血），新层到来时，这个 1 秒的间隔要不要重置？</em></li>
<li><em>Reset on Successful Application: 重置。如果你快要掉血了，此时中了一箭，掉血的时机往后推 1 秒。</em></li>
<li><em>Never Reset: 不重置。无论中多少箭，掉血的频率始终固定。</em></li>
</ul>
</li>
<li><em>Stack Expiration Policy (到期策略)</em>
<ul>
<li><em>Clear Entire Stack: 时间到，所有层数瞬间全没。</em></li>
<li><em>Remove Single Stack and Refresh Duration: 时间到，只减一层，然后重新开始倒计时（逐层掉落）。</em></li>
<li><em>Refresh Duration：这个 GE 永远不会因为时间到期而自动消失。使用场景：在某些 UI 设计中，你希望玩家看到一个进度条不断地转圈（比如“战斗状态”），而不是消失</em></li>
</ul>
</li>
<li><em>Overflow Effects (溢出效果)</em>
<ul>
<li><em>这是一个 GE 数组。当层数已满且再次触发该 GE 时，系统会额外触发这里配置的 GE。</em></li>
<li><em>典型应用：比如“灼烧”堆满 10 层后，触发一个“爆炸” GE。</em></li>
</ul>
</li>
<li><em>Deny Overflow Application (拒绝溢出应用)</em>
<ul>
<li><em>如果不打勾（默认）：即使层数满了，新的应用虽然不加层数，但依然会触发上面的“刷新时长”或“重置周期”逻辑。</em></li>
<li><em>如果打勾：层数满了以后，后续的所有应用直接被忽略，不会刷新时间，也不会触发溢出效果。</em></li>
</ul>
</li>
</ul>
<h4 id="fattributebasedfloat"><em><strong>FAttributeBasedFloat</strong></em></h4>
<p><em>1. BackingAttribute（支撑属性捕获定义）</em>
<em>数据类型：FGameplayEffectAttributeCaptureDefinition</em>
<em>介绍：这是整个计算的“传感器”。它决定了我们要去抓取谁的属性。</em>
<em>它的数据包含：</em></p>
<ul>
<li><em>AttributeToCapture：具体的属性指针（比如攻击力、蓝量）。</em></li>
<li><em>Source / Target：是从施法者身上抓，还是从受击者身上抓。</em></li>
<li><em>bSnapshot：是否快照。如果设为 true，则记录放技能那一刻的属性；如果为 false，则在效果结算那一刻读取实时属性。</em></li>
</ul>
<p><em>2. Coefficient（系数）</em>
<em>数据类型：FScalableFloat</em>
<em>介绍：公式里的乘数。注意，源码里显示它是一个 FScalableFloat。</em>
<em>深度含义：这意味着你的“系数”本身也可以随着 GE 的等级（Level）而变化。</em>
<em>游戏场景：比如“法力加成”。1 级 GE 时，伤害是蓝量的 1.0 倍；到了 5 级 GE，伤害可能变成蓝量的 1.5 倍。这就是靠这个系数的 FScalableFloat 曲线来实现的。</em></p>
<p><em>3. PreMultiplyAdditiveValue（预加值）</em>
<em>数据类型：FScalableFloat</em>
<em>介绍：在乘法执行前，先给捕获到的属性值加上的底数。</em>
<em>逻辑顺序：计算器会先执行 (属性值 + 预加值)。</em>
<em>游戏场景：比如“保底计算”。即便你的蓝量（属性）是 0，你可以设预加值为 10，保证后面乘以系数时不会算出 0。</em></p>
<p><em>4. PostMultiplyAdditiveValue（后加值）</em>
<em>数据类型：FScalableFloat</em>
<em>介绍：在乘法执行完毕后，最后加上的一个固定偏移量。</em>
<em>逻辑顺序：(系数 * 前面的结果) + 这个值。</em>
<em>游戏场景：比如“基于蓝量的额外固伤”。你的一招基础伤害是 100（后加值），然后再额外加上蓝量的 20%。</em></p>
<p><em>5. AttributeCurve（属性曲线表）</em>
<em>数据类型：FCurveTableRowHandle</em>
<em>介绍：这是源码里最精彩的部分。如果这里填了数据，系统就不直接使用属性数值了，而是把属性数值当做 X 轴坐标，去这张表里查对应的 Y 轴结果。</em>
<em>游戏场景：比如“非线性属性收益”。你的力量达到 100 之后，每点力量带来的伤害提升会越来越少（边际递减），这种复杂的数学曲线不需要写代码，直接把这张表填上就行。</em></p>
<p><em>6. AttributeCalculationType（属性计算策略）</em>
<em>数据类型：EAttributeBasedFloatCalculationType</em>
<em>介绍：它决定了计算器怎么看待抓到的那个属性。</em>
<em>常用选项：</em></p>
<ul>
<li><em>AttributeMagnitude：直接拿属性的当前值（算完 Buff 的结果）。</em></li>
<li><em>AttributeBaseValue：只看属性的基础值（不看任何临时 Buff）。</em></li>
<li><em>AttributeEvaluatedUpToChannel：这是一个很深的功能，允许你计算属性时只计算到特定的“层级/通道”，比如无视某些高级别的 Buff。</em></li>
</ul>
<p><em>7. SourceTagFilter / TargetTagFilter（标签过滤器）</em>
<em>数据类型：FGameplayTagContainer</em>
<em>介绍：这是给计算过程加的“前置滤网”。</em>
<em>作用：只有当来源（Source）或目标（Target）拥有这些特定的标签时，这个属性修改才会生效。如果标签不匹配，这一整套公式可能会直接返回 0。</em></p>
<h4 id="ugameplaymodmagnitudecalculation"><em><strong>UGameplayModMagnitudeCalculation</strong></em></h4>
<p><em>该类用于通过蓝图或原生代码（C++）执行自定义的玩法效果（Gameplay Effect）修饰符计算。</em></p>
<p><em>MMC 的核心定位是：为 Gameplay Effect (GE) 里的某一个属性修改提供动态数值。</em></p>
<ul>
<li><em>单一属性修改：如果你只需要算出一个数值（比如“伤害值”或“加血量”），并填入 GE 的某一个 Modifier 里。</em></li>
<li><em>需要客户端预测 (Prediction)：这是最关键的一点。MMC 在客户端和服务器都会运行。如果你希望玩家按下按键，UI 上的数值（如蓝条、体力）立即顺滑减少，必须用 MMC</em>。</li>
<li><em>公式相对独立：公式只涉及基础的数学运算。例如：</em>
<ul>
<li>加血量 = 等级 * 20 + 基础值</li>
<li>技能消耗 = 基础消耗 * (1 - 冷却缩减属性)</li>
</ul>
</li>
<li><em>逻辑简单：它只能返回一个 float，不能直接修改标签（Tags）或执行复杂的逻辑分支。</em></li>
</ul>
<h4 id="ugameplayeffectexecutioncalculation"><em><strong>UGameplayEffectExecutionCalculation</strong></em></h4>
<p><em>重型计算器。用于处理最复杂的伤害公式（涉及多属性对比，如：攻击者的破甲 vs 目标的护甲）。</em></p>
<p><em>ExecCalc 的核心定位是：处理涉及多个属性交互、复杂逻辑的最终结算。</em></p>
<ul>
<li><em>多属性交互（经典伤害公式）：如果你的计算需要同时读取来源（Source）和目标（Target）的大量属性。例如：</em>
<ul>
<li>最终伤害 = (攻击者攻击力 * 暴击倍率 - 目标防御力) * (1 - 目标的免伤率) * 属性克制系数。</li>
</ul>
</li>
<li><em>修改多个属性：ExecCalc 一次执行可以同时修改多个属性。例如：</em>
<ul>
<li><em>一个“吸血”效果：同时减少目标的 Health，增加来源的 Health。</em></li>
<li><em>一个“破甲攻击”：同时扣除目标的 Shield 和 Health。</em></li>
</ul>
</li>
<li><em>复杂逻辑判断：内部可以写 if-else。例如：</em>
<ul>
<li><em>“如果目标生命值低于 20%，则触发斩杀，伤害翻倍”。</em></li>
<li><em>“如果目标有‘护盾’标签，则伤害先扣除护盾”。</em></li>
</ul>
</li>
<li><em>不需要/不建议预测：ExecCalc 通常只在服务器运行。因为伤害结算涉及跨对象的数据交换，客户端预测极易产生“血条回跳”现象。</em></li>
</ul>
<h4 id="ugameplayeffectcomponent"><em><strong>UGameplayEffectComponent</strong></em></h4>
<p><em>UE5.3 引入的模块化设计。将以前杂乱的 GE 设置（如持续时间、几率等）解耦成组件，提高性能。</em></p>
<h3 id="ge-重要函数"><em><strong>GE 重要函数</strong></em></h3>
<ol>
<li>
<p><em>ASC里的函数：创建效果上下文句柄。</em></p>
<p><code>virtual FGameplayEffectContextHandle MakeEffectContext() const;</code></p>
<ul>
<li><em>核心逻辑：这个函数用于生成一个空的、但已经初始化了基础信息的容器。它会自动把当前的 OwnerActor（所有者，如 PlayerState）和 AvatarActor（表现肉体，如 Character）填进去。这个上下文（Context）就像是一张空白的身份证，记录了这一发效果到底是谁发出来的。</em></li>
<li><em>开发提示：这是一个虚函数，你可以重写它来携带更多自定义数据。比如在射击游戏中，你可以在重写的 Context 里加入是否爆头、子弹飞行距离等信息。这个生成的句柄随后会被传入 MakeOutgoingSpec，确保这些背景数据能一路跟随 GE 传递到目标的伤害计算（ExecCalc）逻辑中，让目标知道自己是被谁、从哪、用什么方式打中的。</em></li>
</ul>
</li>
<li>
<p><em>ASC里的函数：创建一个待发送的 GE 规范句柄。</em></p>
<p><code>virtual FGameplayEffectSpecHandle MakeOutgoingSpec(TSubclassOf&lt;UGameplayEffect&gt; GameplayEffectClass, float Level, FGameplayEffectContextHandle Context) const;</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>GameplayEffectClass：你想使用的 GE 类。</em></li>
<li><em>Level：等级。</em></li>
<li><em>Context：施法上下文。</em></li>
</ul>
</li>
<li><em>核心逻辑：这是配合下一个函数使用的前提。它就像是先填好一张“发货单”但还没发货。你会拿到一个 Handle，通过这个 Handle 你可以调用 SetSetByCallerMagnitude 等函数来修改这批货的“重量”或“属性”，改完后再用 Apply 接口发出去。</em></li>
</ul>
</li>
<li>
<p><em>ASC里的函数：应用已经配置好的 GE 规范（Spec）至目标或自身。</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">virtual</span> <span class="n">FActiveGameplayEffectHandle</span> <span class="nf">ApplyGameplayEffectSpecToTarget</span><span class="p">(</span><span class="k">const</span> <span class="n">FGameplayEffectSpec</span><span class="o">&amp;</span> <span class="n">GameplayEffect</span><span class="p">,</span> <span class="n">UAbilitySystemComponent</span> <span class="o">*</span><span class="n">Target</span><span class="p">,</span> <span class="n">FPredictionKey</span> <span class="n">PredictionKey</span><span class="o">=</span><span class="n">FPredictionKey</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">virtual</span> <span class="n">FActiveGameplayEffectHandle</span> <span class="nf">ApplyGameplayEffectSpecToSelf</span><span class="p">(</span><span class="k">const</span> <span class="n">FGameplayEffectSpec</span><span class="o">&amp;</span> <span class="n">GameplayEffect</span><span class="p">,</span> <span class="n">FPredictionKey</span> <span class="n">PredictionKey</span> <span class="o">=</span> <span class="n">FPredictionKey</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><em>入参：</em>
<ul>
<li><em>Spec：这是一个已经填好了所有数据的“全家桶”对象（可以通过 FGameplayEffectSpecHandle 获取）。它里面已经包含了等级、上下文、甚至你手动设置的动态数值（SetByCaller）。</em></li>
<li><em>Target：仅在 ToTarget 中使用，指定效果的接收方。</em></li>
<li><em>PredictionKey：网络预测键，用于消除客户端的操作延迟感。</em></li>
</ul>
</li>
<li><em>核心逻辑：这是 GAS 中最高级的应用方式。与之前直接传 UClass 不同，这种方式允许你在效果真正发出去之前，对它进行最后的修改。</em></li>
</ul>
</li>
<li>
<p><em>ASC里的函数：将状态效果（GE）应用至目标或自身。</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">FActiveGameplayEffectHandle</span> <span class="nf">ApplyGameplayEffectToTarget</span><span class="p">(</span><span class="n">UGameplayEffect</span> <span class="o">*</span><span class="n">GameplayEffect</span><span class="p">,</span> <span class="n">UAbilitySystemComponent</span> <span class="o">*</span><span class="n">Target</span><span class="p">,</span> <span class="kt">float</span> <span class="n">Level</span> <span class="o">=</span> <span class="n">UGameplayEffect</span><span class="o">::</span><span class="n">INVALID_LEVEL</span><span class="p">,</span> <span class="n">FGameplayEffectContextHandle</span> <span class="n">Context</span> <span class="o">=</span> <span class="n">FGameplayEffectContextHandle</span><span class="p">(),</span> <span class="n">FPredictionKey</span> <span class="n">PredictionKey</span> <span class="o">=</span> <span class="n">FPredictionKey</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">FActiveGameplayEffectHandle</span> <span class="nf">ApplyGameplayEffectToSelf</span><span class="p">(</span><span class="k">const</span> <span class="n">UGameplayEffect</span> <span class="o">*</span><span class="n">GameplayEffect</span><span class="p">,</span> <span class="kt">float</span> <span class="n">Level</span><span class="p">,</span> <span class="k">const</span> <span class="n">FGameplayEffectContextHandle</span><span class="o">&amp;</span> <span class="n">EffectContext</span><span class="p">,</span> <span class="n">FPredictionKey</span> <span class="n">PredictionKey</span> <span class="o">=</span> <span class="n">FPredictionKey</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><em>入参（综合介绍）：</em>
<ul>
<li><em>GameplayEffect：想要施加的 GE 类（UClass）。它决定了效果的类型，比如是回血、扣血还是增加防御。</em></li>
<li><em>Target：仅在 ToTarget 中使用。指定谁来接收这个效果。如果是 ToSelf，则默认接收者就是调用者自己。</em></li>
<li><em>Level：效果的等级。用于缩放 GE 内部的数值。比如 1 级技能伤害是 100，2 级可能是 200，就靠这个参数传递。</em></li>
<li><em>Context / EffectContext：上下文句柄。它记录了这次施法的完整背景，比如谁发起的、通过哪个技能发的、命中了哪个点。它是追溯伤害来源（KillCam 或战斗日志）的关键数据。</em></li>
<li><em>PredictionKey：网络预测键。用于处理客户端延迟。它能让玩家在点击技能的瞬间，本地先看到血条变动或 Buff 出现，而不需要等待服务器的往返确认，保证了游戏手感的流畅。</em></li>
</ul>
</li>
<li><em>核心逻辑：这是 GAS 修改属性的终极入口。无论技能逻辑多么复杂，最后一步通常都是通过这两个函数把效果实实在在地挂到角色身上。调用后会返回一个 FActiveGameplayEffectHandle，你可以拿着这个句柄来查询该 Buff 的剩余时间或手动将其移除。</em></li>
</ul>
</li>
</ol>
<h3 id="ge-重要函数里的参数"><em><strong>GE 重要函数里的参数</strong></em></h3>
<h4 id="fgameplayeffectspec"><em><strong>FGameplayEffectSpec</strong></em></h4>
<p><em>这个结构体他告诉了我们</em></p>
<ul>
<li><em>使用了哪个 UGameplayEffect（引用的是不可变的常量数据资产）。</em></li>
<li><em>等级是多少（Level）。</em></li>
<li><em>谁发起的（Instigator）。</em></li>
</ul>
<h4 id="fgameplayeffectspechandle"><em><strong>FGameplayEffectSpecHandle</strong></em></h4>
<p><em>允许蓝图仅生成一次 GameplayEffectSpec，随后通过句柄对其进行引用，从而实现将其多次应用或应用给多个不同的目标。</em></p>
<h4 id="factivegameplayeffect"><em><strong>FActiveGameplayEffect</strong></em></h4>
<p><em>正在运行的“效果快照”。</em></p>
<p><em>存储在 ASC 内部的结构体。它代表了一个正在生效的持续性（Duration）或永久性（Infinite）的 GE。你想知道自己身上有多少层 Buff，看的就是它。</em></p>
<h4 id="factivegameplayeffecthandle"><em><strong>FActiveGameplayEffectHandle</strong></em></h4>
<p><em>效果的“遥控器”。</em></p>
<p><em>一个唯一的 ID。当你应用一个 Buff 后，系统返回这个句柄。你想手动移除某个 Buff（比如驱散效果），必须通过这个句柄来操作。</em></p>
<h4 id="fgameplayeffectcontext"><em><strong>FGameplayEffectContext</strong></em></h4>
<p><em>这是一个用于存储 “发起者”及相关数据（例如位置和目标）的数据结构。</em></p>
<p><em>开发者可以派生（子类化）该结构，以添加特定于游戏的自定义信息。</em></p>
<p><em>由于该结构贯穿于整个效果执行的全过程，因此它是追踪单次执行过程中“瞬态信息（Transient Information）”的绝佳位置。</em></p>
<h4 id="fgameplayeffectcontexthandle"><em><strong>FGameplayEffectContextHandle</strong></em></h4>
<p><em>包装 FGameplayEffectContext 或子类的句柄，以允许其具有多态性并正确复制</em></p>
<h4 id="ugameplayeffectcontextpayloadbase"><em><strong>UGameplayEffectContextPayloadBase</strong></em></h4>
<p><em>它是存储在 FGameplayEffectContext 中的自定义动态数据载体。</em></p>
<p><em>你可以写一个 UHeadshotPayload 继承自这个 Base，里面存一个 <code>float HeadshotMultiplier</code>。在应用 GE 前，把这个 Payload 塞进 Context，后续的伤害计算类（ExecCalc）就能精准地把它取出来。</em></p>
<ul>
<li>
<h2 id="表现层"><em><strong>表现层</strong></em></h2>
<p><em>处理非数值的表现（特效、音效、震动）。</em></p>
<p><em>通过 GameplayTag 触发。不参与服务器的回滚，只在客户端执行。</em></p>
<h3 id="核心路由ugameplaycuemanager"><em><strong>核心路由：UGameplayCueManager</strong></em></h3>
<ul>
<li><strong>分发中心（The Router）：</strong> 它是表现层的“神经中枢”。它在项目启动时扫描指定的路径，建立 <strong>GameplayTag → 表现类（Notify）</strong> 的映射表。</li>
<li><strong>性能优化：</strong> 负责维护对象池（Recycle Pool），避免频繁创建和销毁 Actor 带来的开销。当一个 Tag 触发时，它负责寻找最合适的处理器来展示效果。</li>
</ul>
<h3 id="静态处理器ugameplaycuenotify_static"><em><strong>静态处理器：UGameplayCueNotify_Static</strong></em></h3>
<ul>
<li>*<em>本质： 继承自 UObject 的轻量级单例。</em></li>
<li><em>特性：“火后即焚” (Fire and Forget)。它不在场景中产生持久实体。</em></li>
<li><em>适用场景：处理瞬时状态。如命中时的火花、挥刀的音效、短暂的屏幕震动。</em></li>
<li><em>优势： 极高的性能，不参与复杂的生命周期管理，是处理大量爆发性特效的首选。</em></li>
</ul>
<h3 id="动态载体agameplaycuenotify_actor"><em><strong>动态载体：AGameplayCueNotify_Actor</strong></em></h3>
<ul>
<li><em>本质： 实现了 GC 协议函数的 AActor。</em></li>
<li><em>特性：“状态伴随” (Lifecycle Managed)。它作为一个真实的实体存在于 3D 世界中，支持挂载组件（Niagara、声音、模型）。</em></li>
<li><em>适用场景： 处理持续性状态（WhileActive）。如身上的中毒绿烟、护盾光圈、持续的喷泉特效。</em></li>
<li><em>设计逻辑： 之所以继承自 Actor，是为了利用引擎成熟的 Transform（空间变换）、Component（组件化）以及 Tick（帧更新）系统，从而实现随角色移动或随时间渐变的复杂效果。</em></li>
</ul>
<h3 id="数据包fgameplaycueparameters"><em><strong>数据包：FGameplayCueParameters</strong></em></h3>
<ul>
<li>
<p><em>本质： 表现层的“任务简报” (Payload)。</em></p>
</li>
<li>
<p><em>核心作用： 解决“表现如何根据上下文变化”的问题。</em></p>
</li>
<li>
<p><em>装载信息：</em></p>
<ol>
<li>
<p><em><strong>强度与规模 (Magnitude)</strong></em></p>
<ul>
<li>
<p><em><strong>Normalized Magnitude (归一化强度):</strong></em></p>
<p><em>通常是一个 0.0 到 1.0 之间的值。常用于设置特效的比例（比如蓄力越久，光圈越大）。</em></p>
</li>
</ul>
<ul>
<li>
<p><em><strong>Raw Magnitude (原始强度):</strong></em></p>
<p><em>传递过来的原始数值。比如在伤害 GE 中，这通常是最终计算出的伤害数字。你可以根据这个数字决定播放轻微的出血还是喷涌的出血特效。</em></p>
</li>
</ul>
</li>
<li>
<p><em><strong>标签情报 (Tags)</strong></em></p>
<ul>
<li>
<p><em><strong>Matched Tag Name (匹配标签):</strong></em></p>
<p><em>当前触发这个 Notify 的具体标签。如果你一个 Notify 关联了多个 Tag（如 Abiltiy.Fire.Small 和 Ability.Fire.Big），这个引脚会告诉你到底是哪一个命中了。</em></p>
</li>
<li>
<p><em><strong>Original Tag (原始标签):</strong></em></p>
<p><em>最开始触发 Cue 的那个标签，不受“标签剥离”或“通配符匹配”的影响。</em></p>
</li>
<li>
<p><em><strong>Aggregated Source/Target Tags (来源/目标聚合标签):</strong></em></p>
<p><em>包含了攻击方和受击方在这一瞬间<strong>所有的</strong> Gameplay Tags。这非常强大，例如：你可以根据目标是否有 State.InWater 标签，决定火球术击中时是产生爆炸还是产生水蒸气。</em></p>
</li>
</ul>
</li>
<li>
<p><em><strong>物理与位置 (World Info)</strong></em></p>
<ul>
<li>
<p><strong>Location (位置):</strong></p>
<p><em>特效发生的 3D 坐标。这是爆炸或火花生成的精准点。</em></p>
</li>
<li>
<p><em><strong>Normal (法线):</strong></em></p>
<p><em>碰撞表面的朝向。用于让火花或者弹孔贴图贴在墙面上时角度是正确的。</em></p>
</li>
<li>
<p><em><strong>Physical Material (物理材质):</strong></em></p>
<p><em>打到了什么材质。是金属、木头还是布料？你可以据此切换音效（叮当声 vs 噗噗声）。</em></p>
</li>
</ul>
</li>
<li>
<p><em><strong>角色关系 (Actors)</strong></em></p>
<ul>
<li>
<p><em><strong>Instigator (扇动者/主使人):</strong></em></p>
<p><em>通常是释放技能的那个 <strong>Controller</strong> 或 <strong>Pawn</strong>。用于追踪“谁”干的。</em></p>
</li>
<li>
<p><em><strong>Effect Causer (效果产生物):</strong></em></p>
<p><em>具体的物理媒介。例如：发射出的子弹 Actor 或者手里的那把枪。</em></p>
</li>
<li>
<p><em><strong>SourceObject (源对象):</strong></em></p>
<p><em>通常是一个静态数据对象（如 WeaponData 资产），让你知道这次表现是基于哪种武器配置。</em></p>
</li>
<li>
<p><em><strong>Target Attach Component (目标挂载组件):</strong></em></p>
<p><em>如果特效需要粘在角色身上，这个引脚告诉你应该挂在哪个组件上（通常是 Mesh）。</em></p>
</li>
</ul>
</li>
<li>
<p><em><strong>等级与深度信息 (Levels &amp; Context)</strong></em></p>
<ul>
<li>
<p><em><strong>Gameplay Effect Level (GE 等级):</strong></em></p>
<p><em>触发此特效的 GE 等级。等级越高，特效可以设计得更华丽。</em></p>
</li>
<li>
<p><em><strong>Ability Level (技能等级):</strong></em></p>
<p><em>触发此特效的技能等级。</em></p>
</li>
<li>
<p><em><strong>Effect Context (效果上下文句柄):</strong></em></p>
<p><em>这是最有用的“黑盒子”。它包含了完整的溯源链。在 C++ 或蓝图中，你可以进一步从这里提取出“击中结果（HitResult）”或者自定义的数据（如 Lyra 项目中利用它传递团队 ID）。</em></p>
</li>
</ul>
</li>
<li>
<p><em><strong>技术参数 (Technical)</strong></em></p>
<ul>
<li>
<p><em><strong>bReplicateLocationWhenUsingMinimalRepProxy (最小化同步代理位置同步):</strong></em></p>
<p><em>这是一个底层优化开关。在极简的网络同步模式下，决定是否需要同步具体的地理位置信息，通常开发者不需要手动修改它。</em></p>
</li>
</ul>
</li>
</ol>
<p><em>可以将 FGameplayCueParameters 想象成一份“快递单”。有时候系统会自动帮你填好发件人信息，但有时候（比如具体的撞击坐标）必须由你亲手填上去。</em></p>
</li>
</ul>
<h4 id="哪些参数会被自动传进去"><em><strong>哪些参数会被自动传进去</strong></em></h4>
<ol>
<li>
<p><em>通过 Gameplay Effect (GE) 触发 —— 大部分自动填充</em></p>
<p><em>这是最常用的场景。如果你在 GE 的 GameplayCues 栏位里添加了一个 Tag，那么：</em></p>
<ul>
<li>
<p><em>GAS 自动填充的项目：</em></p>
<ul>
<li><em>Instigator / EffectCauser / SourceObject： 从产生这个 GE 的 EffectContext 中自动提取。</em></li>
<li><em>EffectContext：自动携带触发该 GE 的完整上下文。</em></li>
<li><em>GameplayEffectLevel： 自动填充为 GE 的等级。</em></li>
<li><em>AbilityLevel： 如果 GE 是由技能产生的，自动填充技能等级。</em></li>
<li><em>RawMagnitude： 自动填充为该 GE 的 Modifier 数值（例如：如果你有一个伤害 GE 扣了 50 血，这个 50 会自动塞进 RawMagnitude）。</em></li>
</ul>
</li>
<li>
<p><em>需要你手动处理的项目：</em></p>
<ul>
<li><em>Location / Normal： GE 本身逻辑上并不一定知道“物理撞击点”。如果你需要位置信息，你需要在产生 GE 之前，通过 EffectContext 塞入一个 HitResult。GAS 发现有 HitResult 时，会自动把里面的位置和法线转填到 Cue 参数里。</em></li>
</ul>
</li>
</ul>
</li>
<li>
<p><em>在 Ability (GA) 中通过节点手动触发 —— 全手动填充</em></p>
<p><em>如果你在蓝图里使用 Execute Gameplay Cue with Params 或者 Add Gameplay Cue 节点：</em></p>
<ul>
<li>
<p><em>情况：系统此时只是一张白纸。</em></p>
</li>
<li>
<p><em>你的工作： 你必须自己创建一个 MakeGameplayCueParameters 结构体，并把值连上去。</em></p>
</li>
<li>
<p><em>为什么要手动？ 因为此时系统不知道你触发这个特效的意图。比如你做一个“原地回血”的特效，你可能需要手动把 Location 连成玩家的位置。</em></p>
</li>
</ul>
</li>
<li>
<p><em>“半自动”：通过 EffectContext 传递</em></p>
<p><em>这是高阶开发者最常用的技巧。</em></p>
<ol>
<li>
<p><em>你在 Ability 开始时，使用 MakeEffectContext 创建上下文。</em></p>
</li>
<li>
<p><em>你调用 <strong>AddHitResult</strong> 把射线检测的结果（包含位置、法线、物理材质）塞进去。</em></p>
</li>
<li>
<p><em>魔法发生了： 只要这个 Context 被用来产生 GE 或直接触发 Cue，GAS 就会自动从这个“公文包”里拿出位置、法线、物理材质、Instigator 等信息，填满 FGameplayCueParameters。</em></p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="uattributeset"><em><strong>UAttributeSet</strong></em></h2>
<p><em>属性仓库。存储 Health, Mana, Attack 等浮点数。</em></p>
<h3 id="几个重要的宏"><em><strong>几个重要的宏</strong></em></h3>
<h4 id="attribute_accessors"><em><strong>ATTRIBUTE_ACCESSORS</strong></em></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
</span></span></span><span class="line"><span class="cl"><span class="cp">	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
</span></span></span><span class="line"><span class="cl"><span class="cp">	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
</span></span></span><span class="line"><span class="cl"><span class="cp">	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
</span></span></span><span class="line"><span class="cl"><span class="cp">	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><em>作用：属性访问器自动化宏。</em></li>
<li><em>核心逻辑：这是一个“全家桶”宏，它会自动为你定义的每一个属性（如血量、攻击力）生成四个标准函数。如果没有这个宏，你需要为每一个属性手动写这四个函数，代码量会非常冗余。</em></li>
<li><em>ATTRIBUTE_ACCESSORS 这个是自己手写的 用来整合下面四个宏，下面四个宏才是GAS自带的</em></li>
</ul>
<ol>
<li>
<p><em>生成的四个函数具体是什么（以属性名 Health 为例）</em></p>
<ul>
<li><em>GetHealthAttribute()：获取属性的元数据。这在调用效果、监听属性变化（Delegate）或者在计算逻辑（ExecCalc）中标识属性时非常有用。</em></li>
<li><em>GetHealth()：获取当前血量的具体数值（float）。</em></li>
<li><em>SetHealth(float NewVal)：直接设置血量的当前值。</em></li>
<li><em>InitHealth(float NewVal)：初始化血量的基础值。通常只在角色刚刚出生或等级提升重置属性时使用。</em></li>
</ul>
</li>
<li>
<p><em>为什么必须用这个宏</em></p>
<ul>
<li><em>效率：在 AttributeSet 中，如果你有 20 个属性，手动写就是 80 个函数，而用这个宏只需要在每个属性定义下加一行代码。</em></li>
<li><em>注意这个只能在UAttributeSet中使用</em></li>
</ul>
</li>
<li>
<p><em>老司机的建议</em></p>
<ul>
<li>
<p><em>配合宏定义：这个宏通常不是引擎自带的（虽然有些版本提供了类似的），绝大多数项目都会在项目的头文件里手动定义它。如果你发现代码报错找不到这个宏，记得去把这段定义贴到你的公共头文件（如 ProjectName.h）里。</em></p>
</li>
<li>
<p><em>属性声明范例：</em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadOnly</span><span class="p">,</span> <span class="n">ReplicatedUsing</span> <span class="o">=</span> <span class="n">OnRep_Health</span><span class="p">,</span> <span class="n">Category</span> <span class="o">=</span> <span class="s">&#34;Attributes&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">FGameplayAttributeData</span> <span class="n">Health</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">ATTRIBUTE_ACCESSORS</span><span class="p">(</span><span class="n">UMyAttributeSet</span><span class="p">,</span> <span class="n">Health</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ol>
<h4 id="doreplifetime_condition_notify"><em><strong>DOREPLIFETIME_CONDITION_NOTIFY</strong></em></h4>
<p><code>DOREPLIFETIME_CONDITION_NOTIFY(ULyraHealthSet, Health, COND_None, REPNOTIFY_Always);</code></p>
<ul>
<li><em>作用：带条件和通知规则的生命周期同步注册宏。</em></li>
<li><em>核心逻辑：这个宏写在 GetLifetimeReplicatedProps 函数里。它是虚幻引擎网络底层用来注册变量同步的“最强版本”，比标准的 DOREPLIFETIME 多了两个控制维度。</em></li>
<li><em>参数介绍：</em>
<ul>
<li><em>ULyraHealthSet：类名。</em></li>
<li><em>Health：变量名。</em></li>
<li><em>COND_None：同步条件枚举（下文详细介绍）。</em></li>
<li><em>REPNOTIFY_Always：通知触发规则枚举（下文详细介绍）。</em></li>
</ul>
</li>
</ul>
<p><em>同步条件枚举（ELifetimeCondition）常用值介绍</em></p>
<ul>
<li><em>COND_None：无条件同步。只要变量变了，服务器就会发给所有客户端。这是属性同步最常用的设置。</em></li>
<li><em>COND_OwnerOnly：只同步给拥有者。比如玩家的体力值，其他玩家不需要知道，只需要同步给控制这个角色的玩家即可。</em></li>
<li><em>COND_SkipOwner：同步给除拥有者以外的所有人。常用于某些只在他人表现上存在的特效逻辑。</em></li>
<li><em>COND_SimulatedOnly：只同步给模拟客户端。即不发给服务器，也不发给主控客户端。</em></li>
<li><em>COND_AutonomousOnly：只同步给主控客户端。</em></li>
</ul>
<p><em>通知触发规则枚举（ERepNotifyCondition）常用值介绍</em></p>
<ul>
<li><em>REPNOTIFY_OnChanged：只有当值发生变化时才触发 OnRep 函数。这是虚幻引擎默认的行为。</em></li>
<li><em>REPNOTIFY_Always：无论值是否发生变化，只要服务器发送了同步包，客户端就必须触发一次 OnRep 函数。</em></li>
<li><em>为什么 GAS 喜欢用 Always：因为在 GAS 中，有时候基础值（BaseValue）没变，但内部的计算状态（比如 Buff 叠加）可能需要刷新。使用 Always 可以确保客户端的属性状态始终与服务器保持高度一致，即便数字看起来没变，逻辑也会重新检查一遍。</em></li>
</ul>
<h4 id="gameplayattribute_repnotify"><em><strong>GAMEPLAYATTRIBUTE_REPNOTIFY</strong></em></h4>
<p><em>此宏的作用是确保客户端在收到新数值后，能够正确地通知技能系统组件（ASC）去更新内部的数值状态（包括基础值和当前值），并触发相关的监听回调。</em></p>
<h3 id="fgameplayattribute"><em><strong>FGameplayAttribute</strong></em></h3>
<p><em>属性的“门牌号”。</em></p>
<p><em>它不仅仅是一个名字，而是一个结构体，包装了对 UAttributeSet 中特定字段的反射引用。你在代码中指定“修改生命值”时，传的就是这个。</em></p>
<h3 id="fgameplayattributedata"><em><strong>FGameplayAttributeData</strong></em></h3>
<p><em>属性的“保险箱”。</em></p>
<p><em>这是你在 AttributeSet 中定义的每一个属性的真实数据类型。它不像普通的 float，它内部包含两个核心数值：</em></p>
<ul>
<li>
<p><em>BaseValue（基础值）：你的永久属性。</em></p>
</li>
<li>
<p><em>CurrentValue（当前值）：算上所有临时 Buff/Debuff 后的最终数值。</em></p>
</li>
</ul>
<h3 id="fgameplayattribute-1"><em><strong>FGameplayAttribute</strong></em></h3>
<p><em>属性的“门牌号”。</em></p>
<p><em>它不仅仅是一个名字，而是一个结构体，包装了对 UAttributeSet 中特定字段的反射引用。你在代码中指定“修改生命值”时，传的就是这个。</em></p>
<h3 id="fgameplayattributedata-1"><em><strong>FGameplayAttributeData</strong></em></h3>
<p><em>属性的“保险箱”。</em></p>
<p><em>这是你在 AttributeSet 中定义的每一个属性的真实数据类型。它不像普通的 float，它内部包含两个核心数值：</em></p>
<ul>
<li>
<p><em>BaseValue（基础值）：你的永久属性。</em></p>
</li>
<li>
<p><em>CurrentValue（当前值）：算上所有临时 Buff/Debuff 后的最终数值。</em></p>
</li>
</ul>
<h3 id="重要函数"><em><strong>重要函数</strong></em></h3>
<ol>
<li>
<p><em>GameplayEffect 执行前会触发此函数</em></p>
<p><code>virtual bool PreGameplayEffectExecute(FGameplayEffectModCallbackData&amp; Data) override;</code></p>
<ul>
<li><em>核心逻辑：在一个 GE（状态效果）真正修改属性数值之前触发。</em></li>
<li><em>应用场景：你可以通过返回 false 来取消这次修改。例如，如果你身上有一个“免疫伤害”的标签，你可以在这里拦截所有伤害类的 GE。</em></li>
</ul>
</li>
<li>
<p><em>GameplayEffect 执行后会触发此函数</em></p>
<p><code>virtual void PostGameplayEffectExecute(const FGameplayEffectModCallbackData&amp; Data) override;</code></p>
<ul>
<li><em>核心逻辑：这是 GAS 中最频繁使用的函数。它在 GE 修改完属性后触发，此时你可以拿到修改后的最终数值。</em></li>
<li><em>应用场景：处理核心战斗逻辑。比如：检查血量是否归零并触发死亡、根据受到的伤害数值触发受击动效、将溢出的伤害转化为护盾等。也可以用于数值钳制（Clamping）。</em></li>
</ul>
</li>
<li>
<p><em>属性基础值变更前会触发此函数</em></p>
<p><code>virtual void PreAttributeBaseChange(const FGameplayAttribute&amp; Attribute, float&amp; NewValue) const override;</code></p>
<ul>
<li><em>核心逻辑：当属性的“基础值”（BaseValue，不含 Buff 加成）即将发生永久性改变时触发。</em></li>
<li><em>应用场景：用于数值钳制（Clamping）。例如，确保你的基础血量永远不会设置到 0 以下，或者不会超过基础血量的上限。</em></li>
</ul>
</li>
<li>
<p><em>属性当前值变更前会触发此函数</em></p>
<p><code>virtual void PreAttributeChange(const FGameplayAttribute&amp; Attribute, float&amp; NewValue) override;</code></p>
<ul>
<li><em>核心逻辑：当属性的“当前值”（CurrentValue，包含所有 Buff 修正后的值）即将发生改变时触发。</em></li>
<li><em>应用场景：这是处理数值限制的最常见地方。比如：当你通过一个 Buff 临时增加最大血量时，在这里确保当前血量不会超过新的最大血量。</em></li>
</ul>
</li>
<li>
<p><em>属性变更后会触发此函数</em></p>
<p><code>virtual void PostAttributeChange(const FGameplayAttribute&amp; Attribute, float OldValue, float NewValue) override;</code></p>
<ul>
<li><em>核心逻辑：无论是什么原因导致的属性变化，在变化完成后都会触发。</em></li>
<li><em>应用场景：同步 UI 或者触发简单的被动反应。因为它不提供 GE 的上下文（不知道是谁改的），所以它比 PostGameplayEffectExecute 更纯粹，只关注数字变了这件事。</em></li>
</ul>
</li>
<li>
<p><em>注册属性网络同步</em></p>
<p><code>virtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;</code></p>
<p><em>核心逻辑：如果你在做多人游戏，这个函数是必须重写的。你需要在里面通过 DOREPLIFETIME 宏把每一个属性注册到同步列表里。没有这一步，客户端永远拿不到服务器更新的血量。</em></p>
</li>
<li>
<p><em>ASC里的函数：获取属性的当前最终数值。</em></p>
<p><code>float GetNumericAttribute(const FGameplayAttribute&amp; Attribute) const;</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>Attribute：目标属性，通常通过 AttributeSet 的宏获取。</em></li>
</ul>
</li>
<li><em>核心逻辑：它返回的是经过所有 Buff 修正后的最终数字。比如基础血量 100，身上有加 20 血的 Buff，这里就会返回 120。</em></li>
</ul>
</li>
<li>
<p><em>ASC里的函数：获取属性值变化的监听委托。</em></p>
<p><code>FOnGameplayAttributeValueChange&amp; GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute);</code></p>
<ul>
<li><em>入参：</em>
<ul>
<li><em>Attribute：想要监听的属性。</em></li>
</ul>
</li>
<li><em>核心逻辑：这是做 UI 界面联动最核心的接口。当血量或能量变化时，它会自动广播，让你的 UI 及时更新。</em></li>
</ul>
</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2026-02-26&nbsp;<a class="git-hash" href="https://github.com/dillonzq/LoveIt/commit/800323167fc331a36d5b10953234820cdad8696e" target="_blank" title="commit by vlicecream(vlicecream@163.com) 800323167fc331a36d5b10953234820cdad8696e: Update GAS">
                                    <i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>8003231</a></span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/unreal-gas/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://example.com/unreal-gas/" data-title="Unreal - GAS" data-hashtags="Unreal,GAS"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://example.com/unreal-gas/" data-hashtag="Unreal"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://example.com/unreal-gas/" data-title="Unreal - GAS"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://example.com/unreal-gas/" data-title="Unreal - GAS"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://example.com/unreal-gas/" data-title="Unreal - GAS"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/unreal/">Unreal</a>,&nbsp;<a href="/tags/gas/">GAS</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%A4%8D%E6%95%B0%E5%92%8C%E5%9B%9B%E5%85%83%E6%95%B0/" class="prev" rel="prev" title="复数与四元数"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>复数与四元数</a>
            <a href="/%E6%B8%B2%E6%9F%93-%E6%B0%B4%E4%BD%93%E6%A8%A1%E6%8B%9F/" class="next" rel="next" title="渲染 - 水体模拟">渲染 - 水体模拟<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.127.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2019 - 2026</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Ting</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.5.0/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI","appKey":"WBmoGyJtbqUswvfLh6L8iEBr","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@14.0.0/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-CN","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"serverURLs":"https://leancloud.hugoloveit.com","visitor":true}},"lightgallery":true,"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"PASDMWALPK","algoliaIndex":"index.zh-cn","algoliaSearchKey":"b42948e51daaa93df92381c8e2ac0f93","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
